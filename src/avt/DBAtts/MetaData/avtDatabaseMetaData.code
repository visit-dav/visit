Function: SetNumStates
Declaration: void         SetNumStates(int);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetNumStates
//
//  Arguments:
//      int   the number of states
//
//  Programmer: Jeremy Meredith
//  Creation:   September 12, 2000
//
//  Modifications:
//    Hank Childs, Mon Mar 11 10:00:14 PST 2002
//    Set up boolean vectors dependent on number of states.
//
//    Brad Whitlock, Tue Mar 25 14:32:13 PST 2003
//    I added the time step names.
//
// ****************************************************************************

void
avtDatabaseMetaData::SetNumStates(int n)
{
    numStates = n;
    cyclesAreAccurate.clear();
    timesAreAccurate.clear();
    cycles.clear();
    times.clear();
    timeStepNames.clear();
    for (int i = 0 ; i < numStates ; i++)
    {
        timeStepNames.push_back("");
        cyclesAreAccurate.push_back(0);
        timesAreAccurate.push_back(0);
        cycles.push_back(0);
        times.push_back(0.);
    }
}

Function: SetTemporalExtents
Declaration: void         SetTemporalExtents(double, double);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetTemporalExtents
//
//  Purpose:
//      Sets the minimum and maximum temporal extents.
//
//  Arguments:
//      min    The minimum temporal extents.
//      max    The maximum temporal extents.
//
//  Programmer: Hank Childs
//  Creation:   September 15, 2000
//
//  Modifications:
//
//    Hank Childs, Mon Mar 11 09:57:20 PST 2002
//    Changed type to double.
//
// ****************************************************************************

void
avtDatabaseMetaData::SetTemporalExtents(double min, double max)
{
    hasTemporalExtents = true;
    minTemporalExtents = min;
    maxTemporalExtents = max;
}

Function: SetFormatCanDoDomainDecomposition
Declaration: void         SetFormatCanDoDomainDecomposition(bool can);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetFormatCanDoDomainDecomposition
//
//  Purpose:
//     Sets flag indicating that format can do domain decomposition. This
//     means all meshes should have numBlocks set to 1. Upon each attempt to
//     get data from the database, the format can decide how to decompose
//     the data across processors. This also means that when VisIt
//     "load-balances" blocks (i.e. domains) across processors, it will do so
//     by assigning the one and only block to each and every processor. It
//     is up to the plugin to decide which portion of the whole it will
//     actually return in a request to GetMesh(), GetVar(), ...
//
//  Programmer:  Mark C. Miller
//  Creation:    September 20, 2004
// ****************************************************************************

void
avtDatabaseMetaData::SetFormatCanDoDomainDecomposition(bool can)
{
    if (can)
    {
        // see if there are any meshes with other than a single block
        bool someMeshesHaveOtherThanOneBlock = false;
        for (int i = 0; i < GetNumMeshes(); i++)
        {
            if (GetMeshes(i).numBlocks != 1)
            {
                someMeshesHaveOtherThanOneBlock = true;
                break;
            }
        }

        if (someMeshesHaveOtherThanOneBlock)
        {
            EXCEPTION1(ImproperUseException, "Format cannot do domain "
                "decomposition with meshes having other than a single block");
        }
    }

    formatCanDoDomainDecomposition = can;
}

Function: SetFormatCanDoMultires
Declaration: void         SetFormatCanDoMultires(bool can);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetFormatCanDoMultires
//
//  Purpose:
//     Sets flag indicating that format can provide multiple resolutions
//     of the data. This means all meshes should have numBlocks set to 1.
//     Upon each attempt to get data from the database, the format can decide
//     what resolution of the data to provide and how to decompose the data
//     across processors. This also means that when VisIt "load-balances"
//     blocks (i.e. domains) across processors, it will do so by assigning
//     the one and only block to each and every processor. It is up to the
//     plugin to decide which portion of the whole it will actually return
//     in a request to GetMesh(), GetVar(), ...
//
//  Programmer:  Eric Brugger
//  Creation:    December 20, 2013
// ****************************************************************************

void
avtDatabaseMetaData::SetFormatCanDoMultires(bool can)
{
    if (can)
    {
        // see if there are any meshes with other than a single block
        bool someMeshesHaveOtherThanOneBlock = false;
        for (int i = 0; i < GetNumMeshes(); i++)
        {
            if (GetMeshes(i).numBlocks != 1)
            {
                someMeshesHaveOtherThanOneBlock = true;
                break;
            }
        }

        if (someMeshesHaveOtherThanOneBlock)
        {
            EXCEPTION1(ImproperUseException, "Format cannot provide "
                "multiple resolutions of the data with meshes having other "
                "than a single block");
        }
    }

    formatCanDoMultires = can;
    Select(ID_formatCanDoMultires, (void *)&formatCanDoMultires);
}

Function: SetCycle
Declaration: void         SetCycle(int, int);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetCycle
//
//  Purpose:
//      Sets a cycle for a specific timestep.
//
//  Arguments:
//      ts       The timestep.
//      c        The cycle number.
//
//  Programmer:  Hank Childs
//  Creation:    March 11, 2002
// ****************************************************************************

void
avtDatabaseMetaData::SetCycle(int ts, int c)
{
    if(ts >= 0 && ts < (int)cyclesAreAccurate.size())
    {
        cycles[ts] = c;
        cyclesAreAccurate[ts] = true;
    }
}

Function: SetCycleIsAccurate
Declaration: void         SetCycleIsAccurate(bool, int);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetCycleIsAccurate
//
//  Purpose:
//      Sets a boolean indicating whether a cycle number is accurate.
//
//  Arguments:
//      b       A boolean indicating whether a cycle is accurate.
//      ts      The timestep b corresponds to.
//
//  Programmer: Hank Childs
//  Creation:   March 11, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::SetCycleIsAccurate(bool b, int ts)
{
    if(ts >= 0 && ts < (int)cyclesAreAccurate.size())
        cyclesAreAccurate[ts] = (b ? 1 : 0);
}

Function: SetCyclesAreAccurate
Declaration: void         SetCyclesAreAccurate(bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetCyclesAreAccurate
//
//  Purpose:
//      Sets a boolean indicating whether the cycle numbers are accurate.
//
//  Arguments:
//      b       A boolean indicating whether the cycle std::vector is accurate.
//
//  Programmer: Hank Childs
//  Creation:   March 11, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::SetCyclesAreAccurate(bool b)
{
    for (size_t i = 0 ; i < cyclesAreAccurate.size() ; i++)
    {
        cyclesAreAccurate[i] = (b ? 1 : 0);
    }
}

Function: IsCycleAccurate
Declaration: bool         IsCycleAccurate(int) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::IsCycleAccurate
//
//  Purpose:
//      Gets whether a single cycle is accurate.
//
//  Arguments:
//      ts       A timestep index.
//
//  Returns:     true if the cycle is accurate, false otherwise.
//
//  Programmer:  Hank Childs
//  Creation:    March 11, 2002
//
// ****************************************************************************

bool
avtDatabaseMetaData::IsCycleAccurate(int ts) const
{
    if(ts >= 0 && ts < (int)cyclesAreAccurate.size())
        return (cyclesAreAccurate[ts] != 0 ? true : false);
    return false;
}

Function: AreAllCyclesAccurateAndValid
Declaration: bool         AreAllCyclesAccurateAndValid(int=-1) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AreAllCyclesAccurateAndValid
//
//  Purpose: Convenience method for checking if ALL cycles are accurate and
//  valid (are monotone increasing and there are numStates of them). If the
//  caller doesn't know the expected number of states, it can pass void to
//  use the numStates known in avtDatabaseMetaData
//
//  Programmer:  Mark C. Miller
//  Creation:    March 16, 2005
//
//  Modifications:
//    Mark C. Miller, Tue Mar  6 23:40:10 PST 2007
//    Corrected logic for monotone increasing
//
// ****************************************************************************

bool
avtDatabaseMetaData::AreAllCyclesAccurateAndValid(int expectedNumStates) const
{
    int useNumStates = expectedNumStates == -1 ? numStates : expectedNumStates;

    if ((int)cyclesAreAccurate.size() != useNumStates)
        return false;

    if (cyclesAreAccurate.size() != cycles.size())
        return false;

    for (int i = 0 ; i < useNumStates; i++)
    {
        if (cyclesAreAccurate[i] == 0)
            return false;
        if ((i > 0) && !((cycles[i-1] <= cycles[i])))
            return false;
    }
    return true;
}

Function: SetTime
Declaration: void         SetTime(int, double);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetTime
//
//  Purpose:
//      Sets a time for a specific timestep.
//
//  Arguments:
//      ts       The timestep.
//      t        The time.
//
//  Programmer:  Hank Childs
//  Creation:    March 11, 2002
// ****************************************************************************

void
avtDatabaseMetaData::SetTime(int ts, double t)
{
    if(ts >= 0 && ts < (int)timesAreAccurate.size())
    {
        times[ts] = t;
        timesAreAccurate[ts] = true;
    }
}

Function: SetTimeIsAccurate
Declaration: void         SetTimeIsAccurate(bool, int);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetTimeIsAccurate
//
//  Purpose:
//      Sets a boolean indicating whether a specific timestep is accurate.
//
//  Arguments:
//      b       A boolean indicating whether a time is accurate.
//      ts      The timestep b corresponds to.
//
//  Programmer: Hank Childs
//  Creation:   March 11, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::SetTimeIsAccurate(bool b, int ts)
{
    if(ts >= 0 && ts < (int)timesAreAccurate.size())
        timesAreAccurate[ts] = (b ? 1 : 0);
}

Function: SetTimesAreAccurate
Declaration: void         SetTimesAreAccurate(bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetTimesAreAccurate
//
//  Purpose:
//      Sets a boolean indicating whether the times are accurate.
//
//  Arguments:
//      b       A boolean indicating whether the times std::vector is accurate.
//
//  Programmer: Hank Childs
//  Creation:   March 11, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::SetTimesAreAccurate(bool b)
{
    for (size_t i = 0 ; i < timesAreAccurate.size() ; i++)
    {
        timesAreAccurate[i] = (b ? 1 : 0);
    }
}

Function: IsTimeAccurate
Declaration: bool         IsTimeAccurate(int) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::IsTimeAccurate
//
//  Purpose:
//      Gets whether a single time is accurate.
//
//  Arguments:
//      ts       A timestep index.
//
//  Returns:     true if the time is accurate, false otherwise.
//
//  Programmer:  Hank Childs
//  Creation:    March 11, 2002
//
// ****************************************************************************

bool
avtDatabaseMetaData::IsTimeAccurate(int ts) const
{
    if(ts >= 0 && ts < (int)timesAreAccurate.size())
        return timesAreAccurate[ts] != 0;
    return false;
}

Function: AreAllTimesAccurateAndValid
Declaration: bool         AreAllTimesAccurateAndValid(int=-1) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AreAllTimesAccurateAndValid
//
//  Purpose: Convenience method to check if all times are accurate and
//  monotone increasing. If the caller doesn't know the expected number of
//  states, it can pass void (it will default to -1) and the numStates in
//  avtDatabaseMetaData will be used
//
//  Programmer:  Mark C. Miller
//  Creation:    March 16, 2005
//
//  Modifications:
//    Mark C. Miller, Tue Mar  6 23:40:10 PST 2007
//    Corrected logic for monotone increasing
// ****************************************************************************

bool
avtDatabaseMetaData::AreAllTimesAccurateAndValid(int expectedNumStates) const
{
    int useNumStates = expectedNumStates == -1 ? numStates : expectedNumStates;

    if ((int)timesAreAccurate.size() != useNumStates)
        return false;

    if (timesAreAccurate.size() != times.size())
        return false;

    for (int i = 0 ; i < useNumStates; i++)
    {
        if (timesAreAccurate[i] == 0)
            return false;
        if ((i > 0) && !((times[i-1] <= times[i])))
            return false;
    }
    return true;
}

Function: ReplaceForbiddenCharacters
Declaration: void         ReplaceForbiddenCharacters(void);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::ReplaceForbiddenCharacters
//
//  Purpose:
//      Goes to each of the meta-data objects and replaces characters that
//      are forbidden with a replacement string.
//
//  Programmer: Hank Childs
//  Creation:   February 14, 2005
//
//  Modifications:
//    Brad Whitlock, Fri Apr 1 15:40:29 PST 2005
//    Added labels.
//
//    Hank Childs, Sun Apr 24 10:58:09 PDT 2005
//    Add better support for meshes that are renamed.
//
//    Hank Childs, Tue Jul 19 13:24:19 PDT 2005
//    Added support for arrays.
//
//    Dave Pugmire, Thu Mar  4 10:27:17 EST 2010
//    Added support for curves.
//
//    Brad Whitlock, Tue May 11 14:50:46 PDT 2010
//    Check replacementMask before doing character replacement.
//
//    Mark C. Miller, Thu Sep 15 13:03:15 PDT 2016
//    Moved code setting up forbidden characters and replacement strings from
//    avtGenericDatabase to here. Adjusted interfaces to used C char*'s
//    instead of C++ strings.
// ****************************************************************************

static char const *forbiddenVarNameChars = "\n\t@#:[]<>(){}";

static char const * const replacementVarNameStrs[13] = {
    "_nl_",     // \n
    "_tab_",    // \t
    "_at_",     // @
    "_number_", // #
    "_colon_",  // :
    "_lb_",     // [
    "_rb_",     // ]
    "_la_",     // <
    "_ra_",     // >
    "_lp_",     // (
    "_rp_",     // )
    "_lc_",     // {
    "_rc_"      // }
};

static bool IsForbidden(std::string const &origName, std::string &newName,
                 char const *badChars, char const * const *newStr)
{
    //
    // Note: this is rather unefficiently implemented.  It is expected that
    // this won't be called often.  If it is, then we should re-implement this
    // so "badChars" can be looked up in constant time (presumably using
    // some sort of hash based on the ASCII index of the character).
    //
    bool shouldReplace = false;
    char new_name[1024];
    const char *orig_name = origName.c_str();
    size_t len = strlen(orig_name);
    size_t cur = 0;
    for (size_t i = 0 ; i < len ; i++)
    {
        bool hadBadChar = false;
        for (size_t j = 0 ; j < strlen(badChars) ; j++)
        {
            if (orig_name[i] == badChars[j])
            {
                hadBadChar = true;
                const char *replacement = newStr[j];
                size_t len2 = strlen(replacement);
                for (size_t k = 0 ; k < len2 ; k++)
                {
                    new_name[cur++] = replacement[k];
                }
            }
        }
        if (hadBadChar)
            shouldReplace = true;
        else
            new_name[cur++] = orig_name[i];
    }
    new_name[cur++] = '\0';
    newName = new_name;

    return shouldReplace;
}

void
avtDatabaseMetaData::ReplaceForbiddenCharacters(void)
{
    int  i;

    std::string replacementName;

    if((replacementMask & VAR_CATEGORY_MESH) > 0)
    {
        for (i = 0 ; i < GetNumMeshes() ; i++)
        {
            if (GetMeshes(i).originalName == "")
                GetMeshes(i).originalName = GetMeshes(i).name;
            if (IsForbidden(GetMeshes(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetMeshes(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetMeshes(i).name = replacementName;
            }
        }
    }

    if((replacementMask & VAR_CATEGORY_SCALAR) > 0)
    {
        for (i = 0 ; i < GetNumScalars() ; i++)
        {
            if (GetScalars(i).originalName == "")
                GetScalars(i).originalName = GetScalars(i).name;
            if (IsForbidden(GetScalars(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetScalars(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetScalars(i).name = replacementName;
            }
            if (IsForbidden(GetScalars(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetScalars(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_VECTOR) > 0)
    {
        for (i = 0 ; i < GetNumVectors() ; i++)
        {
            if (GetVectors(i).originalName == "")
                GetVectors(i).originalName = GetVectors(i).name;
            if (IsForbidden(GetVectors(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetVectors(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetVectors(i).name = replacementName;
            }
            if (IsForbidden(GetVectors(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetVectors(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_TENSOR) > 0)
    {
        for (i = 0 ; i < GetNumTensors() ; i++)
        {
            if (GetTensors(i).originalName == "")
                GetTensors(i).originalName = GetTensors(i).name;
            if (IsForbidden(GetTensors(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetTensors(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetTensors(i).name = replacementName;
            }
            if (IsForbidden(GetTensors(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetTensors(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_SYMMETRIC_TENSOR) > 0)
    {
        for (i = 0 ; i < GetNumSymmTensors() ; i++)
        {
            if (GetSymmTensors(i).originalName == "")
                GetSymmTensors(i).originalName = GetSymmTensors(i).name;
            if (IsForbidden(GetSymmTensors(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetSymmTensors(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetSymmTensors(i).name = replacementName;
            }
            if (IsForbidden(GetSymmTensors(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetSymmTensors(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_ARRAY) > 0)
    {
        for (i = 0 ; i < GetNumArrays() ; i++)
        {
            if (GetArrays(i).originalName == "")
                GetArrays(i).originalName = GetArrays(i).name;
            if (IsForbidden(GetArrays(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetArrays(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetArrays(i).name = replacementName;
            }
            if (IsForbidden(GetArrays(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetArrays(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_MATERIAL) > 0)
    {
        for (i = 0 ; i < GetNumMaterials() ; i++)
        {
            if (GetMaterials(i).originalName == "")
                GetMaterials(i).originalName = GetMaterials(i).name;
            if (IsForbidden(GetMaterials(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetMaterials(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetMaterials(i).name = replacementName;
            }
            if (IsForbidden(GetMaterials(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetMaterials(i).meshName = replacementName;
        }
    }

    if((replacementMask & VAR_CATEGORY_CURVE) > 0)
    {
        for (i = 0; i < GetNumCurves(); i++)
        {
            if (GetCurves(i).originalName == "")
                GetCurves(i).originalName = GetCurves(i).name;
            if (IsForbidden(GetCurves(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetCurves(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetCurves(i).name = replacementName;
            }
        }
    }

    if((replacementMask & VAR_CATEGORY_LABEL) > 0)
    {
        for (i = 0 ; i < GetNumLabels() ; i++)
        {
            if (GetLabels(i).originalName == "")
                GetLabels(i).originalName = GetLabels(i).name;
            if (IsForbidden(GetLabels(i).originalName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
            {
                char msg[1024];
                snprintf(msg, 1024, "The database contains an object named \"%s\""
                                 ", which contains characters not supported by "
                                 "VisIt.  VisIt is renaming it to \"%s\"",
                                 GetLabels(i).originalName.c_str(),
                                 replacementName.c_str());
                IssueWarning(msg);
                GetLabels(i).name = replacementName;
            }
            if (IsForbidden(GetLabels(i).meshName, replacementName,
                            forbiddenVarNameChars, replacementVarNameStrs))
                GetLabels(i).meshName = replacementName;
        }
    }
}

Function: Add1
Declaration: void         Add(avtMeshMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      mmd    A mesh meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
//  Modifications:
//
//    Mark C. Miller, Tue Sep 28 19:57:42 PDT 2004
//    Added code to make sure num blocks is 1 if
//    formatCanDoDomainDecomposition is true
//
//    Mark C. Miller, Mon Jul 18 13:41:13 PDT 2005
//    Added code to assure topological dimension is zero if its a point
//    mesh. VisIt has subtle problems with pipeline if it is not.
//
//    Jeremy Meredith, Tue Aug  2 10:45:01 PDT 2005
//    Changed the new m.m.d. for point meshes to avoid using a temporary.
//
//    Brad Whitlock, Tue Nov 27 15:51:36 PST 2007
//    Turn topdim==0 unstructured meshes into point meshes.
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtMeshMetaData *mmd)
{
    if (formatCanDoDomainDecomposition && mmd->numBlocks != 1)
    {
        EXCEPTION1(ImproperUseException, "Cannot deal with meshes having "
            "other than a single block in formats that do their own domain "
            "decomposition.");
    }
    if (mmd->meshType == AVT_POINT_MESH && mmd->topologicalDimension != 0)
    {
        // we shouldn't modify the caller's object, so make a copy
        avtMeshMetaData *tmpmmd = new avtMeshMetaData(*mmd);
        tmpmmd->topologicalDimension = 0;
        meshes.push_back(tmpmmd);
    }
    else if (mmd->meshType == AVT_UNSTRUCTURED_MESH && mmd->topologicalDimension == 0)
    {
        mmd->meshType = AVT_POINT_MESH;
        meshes.push_back(mmd);
    }
    else
    {
        meshes.push_back(mmd);
    }
}

Function: Add2
Declaration: void         Add(avtScalarMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      smd    A scalar meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtScalarMetaData *smd)
{
    scalars.push_back(smd);
}

Function: Add3
Declaration: void         Add(avtVectorMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      vmd    A vector meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtVectorMetaData *vmd)
{
    vectors.push_back(vmd);
}

Function: Add4
Declaration: void         Add(avtTensorMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      tmd    A tensor meta data object.
//
//  Programmer: Hank Childs
//  Creation:   September 20, 2003
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtTensorMetaData *tmd)
{
    tensors.push_back(tmd);
}

Function: Add5
Declaration: void         Add(avtSymmetricTensorMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//     stmd   A symmetric tensor meta data object.
//
//  Programmer: Hank Childs
//  Creation:   September 20, 2003
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtSymmetricTensorMetaData *stmd)
{
    symmTensors.push_back(stmd);
}

Function: Add6
Declaration: void         Add(avtArrayMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      tmd    An array meta data object.
//
//  Programmer: Hank Childs
//  Creation:   July 19, 2005
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtArrayMetaData *tmd)
{
    arrays.push_back(tmd);
}

Function: Add7
Declaration: void         Add(avtMaterialMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      mmd    A material meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtMaterialMetaData *mmd)
{
    materials.push_back(mmd);
}

Function: Add8
Declaration: void         Add(avtSpeciesMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      smd    A species meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtSpeciesMetaData *smd)
{
    species.push_back(smd);
}

Function: Add9
Declaration: void         Add(avtCurveMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      cmd    A curve meta data object.
//
//  Programmer: Hank Childs
//  Creation:   August 1, 2003
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtCurveMetaData *cmd)
{
    curves.push_back(cmd);
}

Function: Add11
Declaration: void         Add(avtLabelMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      smd    A Label meta data object.
//
//  Programmer: Brad Whitlock
//  Creation:   Fri Apr 1 15:26:41 PST 2005
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtLabelMetaData *lmd)
{
    labels.push_back(lmd);
}

Function: Add12
Declaration: void         Add(avtDefaultPlotMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      pmd    A default plot meta data object.
//
//  Programmer: Walter Herrera
//  Creation:   Septemver 04, 2003
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtDefaultPlotMetaData *pmd)
{
    defaultPlots.push_back(pmd);
}

Function: GetMesh1
Declaration: const avtMeshMetaData        *GetMesh(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetMesh
//
// Purpose:
//     This returns the metadata for the nth mesh in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtMeshMetaData *
avtDatabaseMetaData::GetMesh(int n) const
{
    if (n < 0 || n >= GetNumMeshes())
        EXCEPTION2(BadIndexException, n, GetNumMeshes());

    return (const avtMeshMetaData *)meshes[n];
}

Function: GetMesh2
Declaration: const avtMeshMetaData        *GetMesh(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetMesh
//
// Purpose:
//     This returns the metadata for the mesh in the file whose name is n.
//
// Arguments:
//     n  :  the name of the mesh object
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
// *******************************************************************

const avtMeshMetaData *
avtDatabaseMetaData::GetMesh(const std::string &n) const
{
    for (int i=0; i<GetNumMeshes(); i++)
        if (VariableNamesEqual(GetMesh(i)->name, n))
            return GetMesh(i);
    return NULL;
}

Function: GetScalar1
Declaration: const avtScalarMetaData      *GetScalar(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetScalar
//
// Purpose:
//     This returns the metadata for the nth scalar in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtScalarMetaData *
avtDatabaseMetaData::GetScalar(int n) const
{
    if (n < 0 || n >= GetNumScalars())
        EXCEPTION2(BadIndexException, n, GetNumScalars());

    return (const avtScalarMetaData *)scalars[n];
}

Function: GetScalar2
Declaration: const avtScalarMetaData      *GetScalar(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetScalar
//
// Purpose:
//     This returns the metadata for the scalar in the file whose name is n.
//
// Arguments:
//     n  :  the name of the scalar object
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
// *******************************************************************

const avtScalarMetaData *
avtDatabaseMetaData::GetScalar(const std::string &n) const
{
    for (int i=0; i<GetNumScalars(); i++)
        if (VariableNamesEqual(GetScalar(i)->name, n))
            return GetScalar(i);
    return NULL;
}

Function: GetVector1
Declaration: const avtVectorMetaData      *GetVector(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetVector
//
// Purpose:
//     This returns the metadata for the nth vector in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtVectorMetaData *
avtDatabaseMetaData::GetVector(int n) const
{
    if (n < 0 || n >= GetNumVectors())
        EXCEPTION2(BadIndexException, n, GetNumVectors());

    return (const avtVectorMetaData *)vectors[n];
}

Function: GetVector2
Declaration: const avtVectorMetaData      *GetVector(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetVector
//
// Purpose:
//     This returns the metadata for the vector in the file whose name is n.
//
// Arguments:
//     n  :  the name of the vector object
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
// *******************************************************************

const avtVectorMetaData *
avtDatabaseMetaData::GetVector(const std::string &n) const
{
    for (int i=0; i<GetNumVectors(); i++)
        if (VariableNamesEqual(GetVector(i)->name, n))
            return GetVector(i);
    return NULL;
}

Function: GetTensor1
Declaration: const avtTensorMetaData      *GetTensor(int) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetTensor
//
// Purpose:
//     This returns the metadata for the nth tensor in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Hank Childs
// Creation:   September 20, 2003
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// ****************************************************************************

const avtTensorMetaData *
avtDatabaseMetaData::GetTensor(int n) const
{
    if (n < 0 || n >= GetNumTensors())
        EXCEPTION2(BadIndexException, n, GetNumTensors());

    return (const avtTensorMetaData *)tensors[n];
}

Function: GetTensor2
Declaration: const avtTensorMetaData      *GetTensor(const std::string&) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetTensor
//
// Purpose:
//     This returns the metadata for the tensor in the file whose name is n.
//
// Arguments:
//     n  :  the name of the tensor object
//
// Programmer: Hank Childs
// Creation:   September 20, 2003
//
// ****************************************************************************

const avtTensorMetaData *
avtDatabaseMetaData::GetTensor(const std::string &n) const
{
    for (int i=0; i<GetNumTensors(); i++)
        if (VariableNamesEqual(GetTensors(i).name, n))
            return GetTensor(i);
    return NULL;
}

Function: GetSymmTensor1
Declaration: const avtSymmetricTensorMetaData *GetSymmTensor(int) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetSymmTensor
//
// Purpose:
//     This returns the metadata for the nth symmetric tensor in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Hank Childs
// Creation:   September 20, 2003
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// ****************************************************************************

const avtSymmetricTensorMetaData *
avtDatabaseMetaData::GetSymmTensor(int n) const
{
    if (n < 0 || n >= GetNumSymmTensors())
        EXCEPTION2(BadIndexException, n, GetNumSymmTensors());

    return (const avtSymmetricTensorMetaData *)symmTensors[n];
}

Function: GetSymmTensor2
Declaration: const avtSymmetricTensorMetaData *GetSymmTensor(const std::string&) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetSymmTensor
//
// Purpose:
//     This returns the metadata for the symmetric tensor in the file whose
//     name is n.
//
// Arguments:
//     n  :  the name of the tensor object
//
// Programmer: Hank Childs
// Creation:   September 20, 2003
//
// ****************************************************************************

const avtSymmetricTensorMetaData *
avtDatabaseMetaData::GetSymmTensor(const std::string &n) const
{
    for (int i=0; i<GetNumSymmTensors(); i++)
        if (VariableNamesEqual(GetSymmTensors(i).name, n))
            return GetSymmTensor(i);
    return NULL;
}

Function: GetArray1
Declaration: const avtArrayMetaData       *GetArray(int) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetArray
//
// Purpose:
//     This returns the metadata for the nth arrays in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Hank Childs
// Creation:   July 19, 2005
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// ****************************************************************************

const avtArrayMetaData *
avtDatabaseMetaData::GetArray(int n) const
{
    if (n < 0 || n >= GetNumArrays())
        EXCEPTION2(BadIndexException, n, GetNumArrays());

    return (const avtArrayMetaData *)arrays[n];
}

Function: GetArray2
Declaration: const avtArrayMetaData       *GetArray(const std::string&) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::GetArray
//
// Purpose:
//     This returns the metadata for the arrays in the file whose name is n.
//
// Arguments:
//     n  :  the name of the arrays object
//
// Programmer: Hank Childs
// Creation:   July 19, 2005
//
// ****************************************************************************

const avtArrayMetaData *
avtDatabaseMetaData::GetArray(const std::string &n) const
{
    for (int i=0; i<GetNumArrays(); i++)
        if (VariableNamesEqual(GetArrays(i).name, n))
            return GetArray(i);
    return NULL;
}

Function: GetMaterial1
Declaration: const avtMaterialMetaData    *GetMaterial(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetMaterial
//
// Purpose:
//     This returns the metadata for the nth material in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtMaterialMetaData *
avtDatabaseMetaData::GetMaterial(int n) const
{
    if (n < 0 || n >= GetNumMaterials())
        EXCEPTION2(BadIndexException, n, GetNumMaterials());

    return (const avtMaterialMetaData *)materials[n];
}

Function: GetMaterial2
Declaration: const avtMaterialMetaData    *GetMaterial(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetMaterial
//
// Purpose:
//     This returns the metadata for the material in the file whose name is n.
//
// Arguments:
//     n  :  the name of the material object
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//   Kathleen Bonnell, Thu Sep  5 13:53:15 PDT 2002
//   Call ParseCompoundForVar, in case the variable is compound.
// *******************************************************************

const avtMaterialMetaData *
avtDatabaseMetaData::GetMaterial(const std::string &n) const
{
    std::string n2;
    const_cast<avtDatabaseMetaData*>(this)->ParseCompoundForVar(n, n2);
    for (int i=0; i<GetNumMaterials(); i++)
        if (VariableNamesEqual(GetMaterials(i).name, n2))
            return GetMaterial(i);
    return NULL;
}

Function: GetSpecies2
Declaration: const avtSpeciesMetaData     *GetSpecies(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetSpecies
//
// Purpose:
//     This returns the metadata for the species in the file whose name is n.
//
// Arguments:
//     n  :  the name of the species object
//
// Programmer: Jeremy Meredith
// Creation:   September  1, 2000
//
// Modifications:
//
// *******************************************************************

const avtSpeciesMetaData *
avtDatabaseMetaData::GetSpecies(const std::string &n) const
{
    for (int i=0; i<GetNumSpecies(); i++)
        if (VariableNamesEqual(GetSpecies(i).name, n))
            return (const avtSpeciesMetaData *)species[i];
    return NULL;
}

Function: GetCurve1
Declaration: const avtCurveMetaData       *GetCurve(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetCurve
//
// Purpose:
//     This returns the metadata for the nth curve in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Hank Childs
// Creation:   August 1, 2003
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtCurveMetaData *
avtDatabaseMetaData::GetCurve(int n) const
{
    if (n < 0 || n >= GetNumCurves())
        EXCEPTION2(BadIndexException, n, GetNumCurves());

    return (const avtCurveMetaData *)curves[n];
}

Function: GetCurve2
Declaration: const avtCurveMetaData       *GetCurve(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetCurve
//
// Purpose:
//     This returns the metadata for the curve in the file whose name
//     is n.
//
// Arguments:
//     n  :  the name of the curve object
//
// Programmer: Hank Childs
// Creation:   August  1, 2003
//
// Modifications:
//
// *******************************************************************

const avtCurveMetaData *
avtDatabaseMetaData::GetCurve(const std::string &n) const
{
    for (int i=0; i<GetNumCurves(); i++)
        if (VariableNamesEqual(GetCurves(i).name, n))
            return GetCurve(i);
    return NULL;
}

Function: GetLabel1
Declaration: const avtLabelMetaData       *GetLabel(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetLabel
//
// Purpose:
//     This returns the metadata for the nth label in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 1 15:37:40 PST 2005
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtLabelMetaData *
avtDatabaseMetaData::GetLabel(int n) const
{
    if (n < 0 || n >= GetNumLabels())
        EXCEPTION2(BadIndexException, n, GetNumLabels());

    return (const avtLabelMetaData *)labels[n];
}

Function: GetLabel2
Declaration: const avtLabelMetaData       *GetLabel(const std::string&) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetLabel
//
// Purpose:
//     This returns the metadata for the label in the file whose name is n.
//
// Arguments:
//     n  :  the name of the label object
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 1 15:37:59 PST 2005
//
// Modifications:
//
// *******************************************************************

const avtLabelMetaData *
avtDatabaseMetaData::GetLabel(const std::string &n) const
{
    for (int i=0; i<GetNumLabels(); i++)
        if (VariableNamesEqual(GetLabels(i).name, n))
            return GetLabel(i);
    return NULL;
}

Function: GetDefaultPlot
Declaration: const avtDefaultPlotMetaData *GetDefaultPlot(int) const;
Definition:
// *******************************************************************
// Method: avtDatabaseMetaData::GetDefaultPlot
//
// Purpose:
//     This returns the metadata for the nth default plot in the file.
//
// Arguments:
//     n  :  the index into the array
//
// Programmer: Walter Herrera
// Creation:   September 04, 2003
//
// Modifications:
//
//   Hank Childs, Thu Mar 30 12:11:43 PST 2006
//   Add some checking for indices.
//
// *******************************************************************

const avtDefaultPlotMetaData *
avtDatabaseMetaData::GetDefaultPlot(int n) const
{
    if (n < 0 || n >= GetNumDefaultPlots())
        EXCEPTION2(BadIndexException, n, GetNumDefaultPlots());

    return (const avtDefaultPlotMetaData *)defaultPlots[n];
}

Function: SetBlocksForMesh
Declaration: void         SetBlocksForMesh(int index, int nBlocks);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetBlocksForMesh
//
//  Purpose:
//      Resets the number of blocks a mesh can have without violating
//      encapsulation.
//
//  Arguments:
//      index    The index of the mesh in the std::vector "meshes".
//      nBlocks  The number of blocks the mesh actually has.
//
//  Programmer:  Hank Childs
//  Creation:    October 11, 2001
//
// ****************************************************************************

void
avtDatabaseMetaData::SetBlocksForMesh(int index, int nBlocks)
{
    if (index < 0 || index >= GetNumMeshes())
    {
        EXCEPTION2(BadIndexException, index, GetNumMeshes());
    }

    GetMeshes(index).numBlocks = nBlocks;
}

Function: SetContainsGhostZones
Declaration: void         SetContainsGhostZones(std::string name, avtGhostType);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetContainsGhostZones
//
//  Purpose:
//      Sets whether a particular mesh has ghost zones.
//
//  Arguments:
//      name     The name of a mesh.
//      val      True if it has ghost zones, false otherwise.
//
//  Programmer:  Hank Childs
//  Creation:    September 30, 2002
//
//  Modifications:
//
//    Hank Childs, Fri Aug  1 21:58:01 PDT 2003
//    No longer throw an exception.  This is a valid case for curves.
//
// ****************************************************************************

void
avtDatabaseMetaData::SetContainsGhostZones(std::string name, avtGhostType val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).containsGhostZones = val;
            return;
        }
    }
}

Function: GetContainsGhostZones
Declaration: avtGhostType GetContainsGhostZones(std::string name) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetContainsGhostZones
//
//  Purpose:
//      Gets whether a particular mesh has ghost zones.
//
//  Arguments:
//      name     The name of a mesh.
//      val      True if it has ghost zones, false otherwise.
//
//  Programmer:  Mark C. Miller
//  Creation:    August 10, 2004
//
// ****************************************************************************

avtGhostType
avtDatabaseMetaData::GetContainsGhostZones(std::string name) const
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            return GetMeshes(i).containsGhostZones;
        }
    }
    return AVT_MAYBE_GHOSTS;
}

Function: SetContainsOriginalCells
Declaration: void         SetContainsOriginalCells(std::string name, bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetContainsOriginalCells
//
//  Purpose:
//      Sets whether a particular mesh has original cells array.
//
//  Arguments:
//      name     The name of a mesh.
//      val      True if it has original cells, false otherwise.
//
//  Programmer:  Kathleen Bonnell
//  Creation:    March 25, 2003
//
//  Modifications:
//
//    Hank Childs, Fri Aug  1 21:58:01 PDT 2003
//    No longer throw an exception.  This is a valid case for curves.
//
// ****************************************************************************

void
avtDatabaseMetaData::SetContainsOriginalCells(std::string name, bool val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).containsOriginalCells = val;
            return;
        }
    }
}

Function: SetContainsOriginalNodes
Declaration: void         SetContainsOriginalNodes(std::string name, bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetContainsOriginalNodes
//
//  Purpose:
//      Sets whether a particular mesh has original nodes array.
//
//  Arguments:
//      name     The name of a mesh.
//      val      True if it has origina nodes,  false otherwise.
//
//  Programmer:  Kathleen Bonnell
//  Creation:    May 28, 2004
//
//  Modifications:
//
// ****************************************************************************

void
avtDatabaseMetaData::SetContainsOriginalNodes(std::string name, bool val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).containsOriginalNodes = val;
            return;
        }
    }
}

Function: SetContainsGlobalNodeIds
Declaration: void         SetContainsGlobalNodeIds(std::string name, bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetContainsGlobalNodeIds
//
//  Purpose:
//      Sets whether a particular mesh has global node ids array.
//
//  Programmer:  Mark C. Miller
//  Creation:    August 9, 2004
//
// ****************************************************************************

void
avtDatabaseMetaData::SetContainsGlobalNodeIds(std::string name, bool val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).containsGlobalNodeIds = val;
            return;
        }
    }
}

Function: SetContainsGlobalZoneIds
Declaration: void         SetContainsGlobalZoneIds(std::string name, bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetContainsGlobalZoneIds
//
//  Purpose:
//      Sets whether a particular mesh has global zone ids array.
//
//  Programmer:  Mark C. Miller
//  Creation:    August 9, 2004
//
// ****************************************************************************

void
avtDatabaseMetaData::SetContainsGlobalZoneIds(std::string name, bool val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).containsGlobalZoneIds = val;
            return;
        }
    }
}

Function: SetZonesWereSplit
Declaration: void         SetZonesWereSplit(std::string name, bool);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetZonesWereSplit
//
//  Purpose:
//      Sets whether a particular mesh's zones were split
//
//  Programmer:  Kathleen Biagas
//  Creation:    July 23, 2014
//
// ****************************************************************************

void
avtDatabaseMetaData::SetZonesWereSplit(std::string name, bool val)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).zonesWereSplit = val;
            return;
        }
    }
}

Function: AddGroupInformation
Declaration: void         AddGroupInformation(int nGroups, int nBlocks, intVector &blockIds);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AddGroupInformation
//
//  Purpose:
//      Sets the group information for all applicable meshes in this object.
//      They are applicable if they have the correct number of blocks.
//
//  Arguments:
//      nGroups   The total number of groups.
//      nBlocks   The number of blocks in the mesh.
//      groupIds  The group index for each block.
//
//  Programmer:  Hank Childs
//  Creation:    October 11, 2001
//
// ****************************************************************************

void
avtDatabaseMetaData::AddGroupInformation(int nGroups, int nBlocks,
                                         std::vector<int> &groupIds)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).numBlocks == nBlocks)
        {
            GetMeshes(i).numGroups = nGroups;
            GetMeshes(i).groupIds  = groupIds;
        }
    }
}

Function: SetExtents
Declaration: void         SetExtents(std::string, const double *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetExtents
//
//  Purpose:
//      Sets the extents of a variable.
//
//  Arguments:
//      name      The name of the variable to set extents for.
//      extents   The extents for the variable.
//
//  Programmer: Hank Childs
//  Creation:   August 30, 2000
//
//  Modifications:
//    Kathleen Bonnell, Thu Aug 28 13:42:03 PDT 2003
//    Test for 'name' matching 'blockTitle' or 'groupTitle' in MeshMetaData.
//
//    Brad Whitlock, Wed Mar 7 17:36:17 PST 2007
//    Rewrote for new object representation.
//
// ****************************************************************************

void
avtDatabaseMetaData::SetExtents(std::string name, const double *extents)
{
    bool foundVar = false;
    int  i;

    for (i = 0; i < GetNumMeshes(); ++i)
    {
        avtMeshMetaData &m = GetMeshes(i);
        if ((m.name == name) ||
            (m.blockTitle == name) ||
            (m.groupTitle == name))
        {
            m.SetExtents(extents);
            foundVar = true;
        }
    }

    for (i = 0; i < GetNumScalars(); ++i)
    {
        if (GetScalars(i).name == name)
        {
            GetScalars(i).SetExtents(extents);
            foundVar = true;
        }
    }

    for (i = 0; i < GetNumVectors(); ++i)
    {
        if (GetVectors(i).name == name)
        {
            GetVectors(i).SetExtents(extents);
            foundVar = true;
        }
    }

    if (! foundVar)
    {
        EXCEPTION1(InvalidVariableException, name);
    }
}

Function: UnsetExtents
Declaration: void         UnsetExtents();
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::UnsetExtents
//
//  Purpose:
//      Allows all of the extents for all of the meshes, scalar vars, and
//      std::vector vars to be unset at one time.
//
//  Programmer:  Hank Childs
//  Creation:    March 6, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::UnsetExtents(void)
{
    int  i;

    for (i = 0 ; i < GetNumMeshes() ; i++)
    {
        GetMeshes(i).UnsetExtents();
    }
    for (i = 0 ; i < GetNumScalars() ; i++)
    {
        GetScalars(i).UnsetExtents();
    }
    for (i = 0 ; i < GetNumVectors() ; i++)
    {
        GetVectors(i).UnsetExtents();
    }
}

Function: AddExpression
Declaration: void                AddExpression(Expression *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AddExpression
//
//  Purpose:
//      Adds a new expression to the database.
//
//  Programmer: Hank Childs
//  Creation:   September 4, 2002
//
//  Mark C. Miller, Thu Jun 16 18:23:24 PDT 2016
//  Remove leading slash, if any, from expression name.
// ****************************************************************************

void
avtDatabaseMetaData::AddExpression(Expression *_expr)
{
    Expression expr = *_expr;
    std::string exprName = expr.GetName();
    if (exprName[0] == '/')
        expr.SetName(&exprName[1]);
    expr.SetFromDB(true);
    expr.SetDbName(databaseName);
    exprList.AddExpressions(expr);
}

Function: GetExpression
Declaration: const Expression   *GetExpression(int) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetExpression
//
//  Purpose:
//      Get a particular expression.
//
//  Programmer: Hank Childs
//  Creation:   September 4, 2002
//
// ****************************************************************************

const Expression *
avtDatabaseMetaData::GetExpression(int expr) const
{
    return &(exprList[expr]);
}

Function: GetNumberOfExpressions
Declaration: int                 GetNumberOfExpressions(void) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetNumberOfExpressions
//
//  Purpose:
//      Get the number of expressions defined for this database.
//
//  Programmer: Hank Childs
//  Creation:   September 4, 2002
//
// ****************************************************************************

int
avtDatabaseMetaData::GetNumberOfExpressions(void) const
{
    return exprList.GetNumExpressions();
}

Function: ConvertCSGDomainToBlockAndRegion
Declaration: bool         ConvertCSGDomainToBlockAndRegion(const char *const var, int *domain, int *region) const;
Definition:
// ****************************************************************************
//  Function: ConvertCSGDomainId
//
//  Purpose: Handle spoofing of CSG domain ids
//
//  A vtkCSGGrid object served up by a plugin is a bunch of CSG regions, not
//  just one region. It is most intuitive to have each region treated as a
//  VisIt "domain." However, that means that VisIt's notion of domains DOES
//  NOT map 1:1 to vtkCSGGrid objects because a single vtkCSGGrid object
//  represents multiple domains. The problem is further complicated by the
//  "multi-block" case where we have multiple vtkCSGGrid objects knitted together
//  to form a multi-block CSG mesh.
//
//  To deal with this, we adopt the convention to treat each region of a single
//  vtkCSGGrid object as a VisIt domain and multiple vtkCSGGrid objects as
//  "groups" of domains.
//
//  This function maps VisIt's domain ids into a block number (e.g. which of
//  the multiple vtkCSGGrid objects) and a region number within the block
//  (e.g. which region within the vtkCSGGrid object)
//
//  Programmer: Mark C. Miller
//  Creation:   June 28, 2006
//
//  Modifications:
//    Mark C. Miller, Tue Dec  5 18:14:58 PST 2006
//    Fixed possible reference through 0
//
// ****************************************************************************
bool
avtDatabaseMetaData::ConvertCSGDomainToBlockAndRegion(const char *const var,
    int *domain, int *region) const
{
    int domainAsVisItSeesIt = *domain;
    std::string meshname = MeshForVar(var);
    const avtMeshMetaData *mmd = GetMesh(meshname);
    if (mmd && mmd->meshType == AVT_CSG_MESH)
    {
        const intVector& groupIds = mmd->groupIds;
        if (groupIds.size() > (size_t)domainAsVisItSeesIt)
        {
            int i, j = groupIds[domainAsVisItSeesIt];
            for (i = domainAsVisItSeesIt; i >= 0 && groupIds[i] == j; i--)
                ; // no-op
            *domain = j;
            if (region) *region = domainAsVisItSeesIt - i + 1;
        }
        else
        {
            *domain = 0;
            if (region) *region = domainAsVisItSeesIt;
        }
        return true;
    }
    return false;
}

Function: GetNDomains
Declaration: int          GetNDomains(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetNDomains
//
//  Purpose:
//      Gets the number of domains for this variable.
//
//  Arguments:
//      var     A variable name.
//
//  Returns:    The number of domains for var.
//
//  Programmer: Hank Childs
//  Creation:   August 31, 2000
//
//  Modifications:
//
//    Hank Childs, Fri Aug  1 21:50:51 PDT 2003
//    Added support for curves.
//
//    Hank Childs, Fri Sep 12 09:11:26 PDT 2003
//    Re-wrote so this could be designated const.
//
//    Hank Childs, Mon Dec  1 14:06:19 PST 2003
//    Made a more informative error message.
//
// ****************************************************************************

int
avtDatabaseMetaData::GetNDomains(const std::string &var) const
{
    int  i;

    std::string  meshname = MeshForVar(var);

    int nmeshes = GetNumMeshes();
    for (i = 0 ; i < nmeshes ; i++)
        if (VariableNamesEqual(GetMeshes(i).name, meshname))
            return GetMeshes(i).numBlocks;

    int ncurves = GetNumCurves();
    for (i = 0 ; i < ncurves ; i++)
    {
        if (VariableNamesEqual(GetCurves(i).name, meshname))
        {
            return 1;
        }
    }

    debug1 << "Unable to find mesh \"" << meshname.c_str() << "\" associated with "
           << "variable \"" << var.c_str() << "\"." << endl;
    EXCEPTION1(InvalidVariableException, var);
}

Function: DetermineVarType
Declaration: avtVarType   DetermineVarType(std::string, bool = true) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::DetermineVarType
//
//  Purpose:
//      Determines the type of the variable argument.
//
//  Arguments:
//      var_in    A variable name.
//      do_expr   Whether or not to do expressions.
//
//  Returns:    The type of var.
//
//  Programmer: Hank Childs
//  Creation:   August 31, 2000
//
//  Modifications:
//    Kathleen Bonnell, Thu Sep  5 13:53:15 PDT 2002
//    If var is compound, parse it.
//
//    Hank Childs, Fri Aug  1 11:08:21 PDT 2003
//    Add support for curves.
//
//    Sean Ahern, Wed Feb  5 16:30:36 PST 2003
//    Added support for expressions.
//
//    Kathleen Bonnell, Thu Aug 28 13:42:03 PDT 2003
//    Test for 'var' matching 'blockTitle' or 'groupTitle' in MeshMetaData.
//
//    Hank Childs, Fri Sep 12 09:11:26 PDT 2003
//    Made modification so that routine could be 'const'.
//
//    Hank Childs, Sat Sep 20 08:32:38 PDT 2003
//    Add support for tensors.
//
//    Brad Whitlock, Fri Apr 1 15:27:41 PST 2005
//    Added support for labels.
//
//    Hank Childs, Tue Jul 19 13:24:19 PDT 2005
//    Added support for arrays.
//
//    Hank Childs, Sun Feb 19 10:57:47 PST 2006
//    Only get information from expressions based on argument value.
//
//    Hank Childs, Wed May 24 11:00:03 PDT 2006
//    For expression variables, return the type of the expression, not the
//    type of a real variable in that expression.
//
//    Kathleen Bonnell, Fri Sep 28 13:34:13 PDT 2007
//    Use 'VariableNamesEqual' instead of '=='.
//
//    Brad Whitlock, Tue Jan 20 16:01:51 PST 2009
//    Change conversion function.
//
// ****************************************************************************

avtVarType
avtDatabaseMetaData::DetermineVarType(std::string var_in, bool do_expr) const
{
    int  i;

    // If the variable is an expression, we need to find a "real" variable
    // name to work with.
    if (do_expr)
    {
        ParsingExprList *pel = ParsingExprList::Instance();
        Expression const *e = pel->GetExpression(var_in);
        if (e != NULL)
            return ExprType_To_avtVarType(e->GetType());
    }

    std::string var;
    if (!VarIsCompound(var_in))
    {
        var = var_in;
    }
    else
    {
        ParseCompoundForVar(var_in, var);
    }

    int nmeshes = GetNumMeshes();
    for (i = 0 ; i < nmeshes ; i++)
    {
        if ((VariableNamesEqual(GetMeshes(i).name, var)) ||
            (VariableNamesEqual(GetMeshes(i).blockTitle, var)) ||
            (VariableNamesEqual(GetMeshes(i).groupTitle, var)))
        {
            return AVT_MESH;
        }
    }

    int nvectors = GetNumVectors();
    for (i = 0 ; i < nvectors ; i++)
    {
        if (VariableNamesEqual(GetVectors(i).name, var))
        {
            return AVT_VECTOR_VAR;
        }
    }

    int ntensors = GetNumTensors();
    for (i = 0 ; i < ntensors ; i++)
    {
        if (VariableNamesEqual(GetTensors(i).name, var))
        {
            return AVT_TENSOR_VAR;
        }
    }

    int nsymmtensors = GetNumSymmTensors();
    for (i = 0 ; i < nsymmtensors ; i++)
    {
        if (VariableNamesEqual(GetSymmTensors(i).name, var))
        {
            return AVT_SYMMETRIC_TENSOR_VAR;
        }
    }

    int narrays = GetNumArrays();
    for (i = 0 ; i < narrays ; i++)
    {
        if (VariableNamesEqual(GetArrays(i).name, var))
        {
            return AVT_ARRAY_VAR;
        }
    }

    int nscalars = GetNumScalars();
    for (i = 0 ; i < nscalars ; i++)
    {
        if (VariableNamesEqual(GetScalars(i).name, var))
        {
            return AVT_SCALAR_VAR;
        }
    }

    int nmats = GetNumMaterials();
    for (i = 0 ; i < nmats ; i++)
    {
        if (VariableNamesEqual(GetMaterials(i).name, var))
        {
            return AVT_MATERIAL;
        }
    }

    int nspecies = GetNumSpecies();
    for (i = 0 ; i < nspecies ; i++)
    {
        if (VariableNamesEqual(GetSpecies(i).name, var))
        {
            return AVT_MATSPECIES;
        }
    }

    int ncurves = GetNumCurves();
    for (i = 0 ; i < ncurves ; i++)
    {
        if (VariableNamesEqual(GetCurves(i).name, var))
        {
            return AVT_CURVE;
        }
    }

    int nlabels = GetNumLabels();
    for (i = 0 ; i < nlabels ; i++)
    {
        if (VariableNamesEqual(GetLabels(i).name, var))
        {
            return AVT_LABEL_VAR;
        }
    }

    return AVT_UNKNOWN_TYPE;
}

Function: DetermineSubsetType
Declaration: avtSubsetType   DetermineSubsetType(const std::string &) const;
Definition:
// ****************************************************************************
//  Function: avtDatabaseMetaData::DetermineSubsetType
//
//  Purpose:
//    Determines the subset type of the passed  compound variable of the form
//    'CategoryName(MeshName)'.
//
//  Arguments:
//    inVar   The (possibly) compound variable.
//
//  Returns:
//    The subset type (AVT_UNKNOWN_SUBSET) if inVar is not compound.
//
//  Programmer: Kathleen Bonnell
//  Creation:   September 5, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Aug 22 18:02:15 PDT 2003
//    Subset vars are no longer always 'compound', parse accordingly.
//
//    Jeremy Meredith, Wed Aug 23 18:23:16 EDT 2006
//    Find enumerated scalar type subsets.
//
//    Mark C. Miller, Mon Apr 14 15:17:17 PDT 2008
//    Changed interface to enum scalar
//
// ****************************************************************************

avtSubsetType
avtDatabaseMetaData::DetermineSubsetType(const std::string &inVar) const
{
    std::string category, mesh;

    if (VarIsCompound(inVar))
    {
        ParseCompoundForMesh(inVar, mesh);
        ParseCompoundForCategory(inVar, category);
    }
    else
    {
        category = inVar;
        mesh = MeshForVar(inVar);
    }

    //
    // determine which part of the var we want to return
    // HACKISH ... only checking domains, and probably incorrectly at that!
    //
    const avtMeshMetaData *mmd = GetMesh(mesh);
    std::string blockTitle;
    std::string groupTitle;
    if (mmd == NULL)
    {
        blockTitle = "domains";   // Not a lot we can do.
        groupTitle = "blocks";
    }
    else
    {
        blockTitle = mmd->blockTitle;
        groupTitle = mmd->groupTitle;
    }

    //
    // Check Blocks/Domains and Groups first
    //
    if (category == blockTitle)
    {
        return AVT_DOMAIN_SUBSET;
    }
    else if (category == groupTitle)
    {
        return AVT_GROUP_SUBSET;
    }

    //
    // Check material next
    //
    const avtMaterialMetaData *matmd = GetMaterialOnMesh(mesh);

    if (matmd != NULL && matmd->name == category)
        return AVT_MATERIAL_SUBSET;
    //
    // Check enumerated scalars next
    //
    const avtScalarMetaData *smd = GetScalar(category);
    if (smd != NULL && smd->GetEnumerationType() != avtScalarMetaData::None)
        return AVT_ENUMSCALAR_SUBSET;

    //
    // No match on any known subset types
    //
    return AVT_UNKNOWN_SUBSET;
}

Function: MeshForVar
Declaration: std::string  MeshForVar(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::MeshForVar
//
//  Purpose:
//      Determines the mesh that the variable argument is defined on.
//
//  Arguments:
//      var     A variable name.
//
//  Returns:    The mesh that var is defined on.
//
//  Programmer: Hank Childs
//  Creation:   August 31, 2000
//
//  Modifications:
//    Kathleen Bonnell, Thu Sep  5 13:53:15 PDT 2002
//    If var is compound, parse it.
//
//    Hank Childs, Fri Aug  1 21:35:00 PDT 2003
//    Have curve plots return themselves.
//
//    Sean Ahern, Fri Dec 13 11:04:50 PST 2002
//    Added expression support.
//
//    Kathleen Bonnell, Thu Aug 28 13:42:03 PDT 2003
//    Test for 'var' matching 'blockTitle' or 'groupTitle' in MeshMetaData.
//
//    Hank Childs, Fri Sep 12 09:17:33 PDT 2003
//    Re-coded some sections so this routine could be 'const'.
//
//    Hank Childs, Sat Sep 20 08:49:16 PDT 2003
//    Add support for tensors.
//
//    Jeremy Meredith, Tue Dec 14 14:02:35 PST 2004
//    The code to get the real variable name was a duplicate of two
//    other spots in VisIt, but this one was out of date.  I
//    refactored the best one into ParsingExprList::GetRealVariable
//    and made this one point to it.
//
//    Brad Whitlock, Fri Apr 1 15:28:35 PST 2005
//    Added support for labels.
//
//    Hank Childs, Tue Jul 19 13:24:19 PDT 2005
//    Added support for arrays.
//
//    Mark C. Miller, Mon Aug 21 18:47:45 PDT 2006
//    Added test for numBlocks>1 to matching on block/groupTitle
//
//    Brad Whitlock, Wed Mar 7 15:05:09 PST 2007
//    Changed for automatic generation.
//
//    Cyrus Harrison, Wed Aug 25 08:35:22 PDT 2010
//    Support selection of domains, even if we only have
//    a single domain.
//
// ****************************************************************************

std::string
avtDatabaseMetaData::MeshForVar(const std::string &invar) const
{
    int   i;
    std::string var(invar);

    // Check if we even have a variable.
    if (var == "")
    {
        debug1 << "avtDatabaseMetaData::MeshForVar: Null variable passed."
               << endl;
        EXCEPTION1(InvalidVariableException, var);
    }

    // If the variable is an expression, we need to find a "real" variable
    // name to work with.
    var = ParsingExprList::GetRealVariable(var);

    // If the variable is compound, parse out the variable name.
    if (VarIsCompound(var))
    {
        std::string meshName;
        ParseCompoundForMesh(var, meshName);
        return meshName;
    }

    // Look through the meshes.
    int nmeshes = GetNumMeshes();
    for (i = 0 ; i < nmeshes ; i++)
    {
        if (VariableNamesEqual(GetMeshes(i).name, var))
        {
            //
            // The mesh is defined on itself??  A little weird, but this is
            // convenient for some routines.
            //
            return var;
        }
        else if ( VariableNamesEqual(GetMeshes(i).blockTitle, var) ||
                  VariableNamesEqual(GetMeshes(i).groupTitle, var))
        {
            return GetMeshes(i).name;
        }
    }

    // Look through the vectors.
    int nvectors = GetNumVectors();
    for (i = 0 ; i < nvectors ; i++)
    {
        if (VariableNamesEqual(GetVectors(i).name, var))
        {
            return GetVectors(i).meshName;
        }
    }

    // Look through the tensors.
    int ntensors = GetNumTensors();
    for (i = 0 ; i < ntensors ; i++)
    {
        if (VariableNamesEqual(GetTensors(i).name, var))
        {
            return GetTensors(i).meshName;
        }
    }

    // Look through the symmteric tensors.
    int nsymmtensors = GetNumSymmTensors();
    for (i = 0 ; i < nsymmtensors ; i++)
    {
        if (VariableNamesEqual(GetSymmTensors(i).name, var))
        {
            return GetSymmTensors(i).meshName;
        }
    }

    // Look through the arrays.
    int narrays = GetNumArrays();
    for (i = 0 ; i < narrays ; i++)
    {
        if (VariableNamesEqual(GetArrays(i).name, var))
        {
            return GetArrays(i).meshName;
        }
    }

    // Look through the scalars.
    int nscalars = GetNumScalars();
    for (i = 0 ; i < nscalars ; i++)
    {
        if (VariableNamesEqual(GetScalars(i).name, var))
        {
            return GetScalars(i).meshName;
        }
    }

    // Look through the materials.
    int nmats = GetNumMaterials();
    for (i = 0 ; i < nmats ; i++)
    {
        if (VariableNamesEqual(GetMaterials(i).name, var))
        {
            return GetMaterials(i).meshName;
        }
    }

    // Look through the species.
    int nspecies = GetNumSpecies();
    for (i = 0 ; i < nspecies ; i++)
    {
        if (VariableNamesEqual(GetSpecies(i).name, var))
        {
            return GetSpecies(i).meshName;
        }
    }

    // Look through the curves.
    int ncurves = GetNumCurves();
    for (i = 0 ; i < ncurves ; i++)
    {
        if (VariableNamesEqual(GetCurves(i).name, var))
        {
            return var;
        }
    }

    // Look through the labels.
    int nlabels = GetNumLabels();
    for (i = 0 ; i < nlabels ; i++)
    {
        if (VariableNamesEqual(GetLabels(i).name, var))
        {
            return GetLabels(i).meshName;
        }
    }

    EXCEPTION1(InvalidVariableException, var);
}

Function: MaterialOnMesh
Declaration: std::string  MaterialOnMesh(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::MaterialOnMesh
//
//  Purpose:
//      Finds a material for a mesh.
//
//  Arguments:
//      mesh    A mesh name.
//
//  Returns:    The name of a material defined on that mesh.
//
//  Programmer: Hank Childs
//  Creation:   December 13, 2000
//
//  Modifications:
//
//    Hank Childs, Thu Mar  6 14:52:23 PST 2003
//    Issue a warning to the debug files if there are multiple materials on a
//    mesh.
//
//    Hank Childs, Fri Sep 12 09:17:33 PDT 2003
//    Re-coded some sections so this routine could be 'const'.
//
//    Brad Whitlock, Wed Mar 7 15:06:22 PST 2007
//    Changed for automatic generation.
//
//    Cyrus Harrison, Fri Feb 22 09:01:53 PST 2008
//    Provided better exception message if a material was not found.
//
// ****************************************************************************

std::string
avtDatabaseMetaData::MaterialOnMesh(const std::string &mesh) const
{
    std::string rv = "";
    bool foundValue = false;

    int nmats = GetNumMaterials();
    for (int i = 0 ; i < nmats ; i++)
    {
        if (VariableNamesEqual(GetMaterials(i).meshName, mesh))
        {
            if (foundValue)
            {
                debug1 << "WARNING: screwy file.  There are multiple materials"
                       << " (" << rv.c_str() << " and "
                       << GetMaterials(i).name.c_str() << ") defined"
                       << " on the same mesh." << endl;
                debug1 << "There are assumption in the VisIt code that this "
                       << "will never happen." << endl;
            }

            rv = GetMaterials(i).name;
            foundValue = true;
        }
    }

    if (foundValue)
    {
        return rv;
    }

    std::string err_msg = "Cannot find Material Object for mesh =\"";
    err_msg +=  mesh + "\".";
    EXCEPTION1(VisItException,err_msg.c_str());
}

Function: SpeciesOnMesh
Declaration: std::string  SpeciesOnMesh(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SpeciesOnMesh
//
//  Purpose:
//      Finds a species for a mesh.
//
//  Arguments:
//      mesh    A mesh name.
//
//  Returns:    The name of a species defined on that mesh.
//
//  Programmer: Jeremy Meredith
//  Creation:   December 17, 2001
//
//  Modifications:
//
//    Hank Childs, Fri Sep 12 09:17:33 PDT 2003
//    Re-coded some sections so this routine could be 'const'.
//
// ****************************************************************************

std::string
avtDatabaseMetaData::SpeciesOnMesh(const std::string &mesh) const
{
    int nspecies = GetNumSpecies();
    for (int i = 0 ; i < nspecies ; i++)
    {
        if (VariableNamesEqual(GetSpecies(i).meshName, mesh))
        {
            return GetSpecies(i).name;
        }
    }

    EXCEPTION1(InvalidVariableException, mesh);
}

Function: GetMaterialOnMesh
Declaration: const avtMaterialMetaData *GetMaterialOnMesh(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetMaterialOnMesh
//
//  Purpose:
//      Gets a material for a mesh and returns it.
//
//  Arguments:
//      mesh    A mesh name.
//
//  Returns:    The material defined on that mesh.
//
//  Programmer: Hank Childs
//  Creation:   March 12, 2001
//
//  Modifications:
//
//    Hank Childs, Thu Mar  6 14:52:23 PST 2003
//    Issue a warning to the debug files if there are multiple materials on a
//    mesh.
//
//    Hank Childs, Fri Sep 12 09:17:33 PDT 2003
//    Re-coded some sections so this routine could be 'const'.
//
// ****************************************************************************

const avtMaterialMetaData *
avtDatabaseMetaData::GetMaterialOnMesh(const std::string &mesh) const
{
    const avtMaterialMetaData *rv = NULL;

    int nmaterials = GetNumMaterials();
    for (int i = 0 ; i < nmaterials ; i++)
    {
        if (VariableNamesEqual(GetMaterials(i).meshName, mesh))
        {
            if (rv != NULL)
            {
                debug1 << "WARNING: screwy file.  There are multiple materials"
                       << " (" << rv << " and " << GetMaterials(i).name.c_str()
                       << ") defined on the same mesh." << endl;
                debug1 << "There are assumptions in the VisIt code that this "
                       << "will never happen." << endl;
            }
            rv = GetMaterial(i);
        }
    }

    return rv;
}

Function: GetSpeciesOnMesh
Declaration: const avtSpeciesMetaData  *GetSpeciesOnMesh(const std::string &) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetSpeciesOnMesh
//
//  Purpose:
//      Gets a species for a mesh and returns it.
//
//  Arguments:
//      mesh    A mesh name.
//
//  Returns:    The species defined on that mesh.
//
//  Programmer: Jeremy Meredith
//  Creation:   December 14, 2001
//
//  Modifications:
//
//    Hank Childs, Fri Sep 12 09:17:33 PDT 2003
//    Re-coded some sections so this routine could be 'const'.
//
// ****************************************************************************

const avtSpeciesMetaData *
avtDatabaseMetaData::GetSpeciesOnMesh(const std::string &mesh) const
{
    for (int i = 0 ; i < GetNumSpecies() ; i++)
    {
        if (VariableNamesEqual(GetSpecies(i).meshName, mesh))
        {
            return (const avtSpeciesMetaData *)species[i];
        }
    }

    return NULL;
}

Function: GetAllVariableNames
Declaration: const stringVector GetAllVariableNames(const std::string &) const;
Definition:
// ****************************************************************************
//  Function: GetAllVariableNames
//
//  Purpose:
//    Retrieves names of all variables defined on a particular mesh.
//
//  Arguments:
//    activeVar The active variable for the pipeline, used to determine
//              the mesh the vars should be defined on.
//
//  Returns:
//    A list of variable names defined on the same mesh as the active var.
//
//  Programmer: Kathleen Bonnell
//  Creation:   August 24, 2004
//
//  Modifications:
//    Brad Whitlock, Fri Apr 1 22:53:25 PST 2005
//    Added labels.
//
//    Hank Childs, Tue Jul 19 13:24:19 PDT 2005
//    Added support for arrays.
//
// ****************************************************************************

const stringVector
avtDatabaseMetaData::GetAllVariableNames(const std::string &activeVar) const
{
    int i;
    stringVector vars;
    std::string meshName = MeshForVar(activeVar);
    for (i = 0; i < GetNumScalars(); i++)
    {
        if (VariableNamesEqual(GetScalars(i).meshName, meshName))
            vars.push_back(GetScalars(i).name);
    }
    for (i = 0; i < GetNumVectors(); i++)
    {
        if (VariableNamesEqual(GetVectors(i).meshName, meshName))
            vars.push_back(GetVectors(i).name);
    }
    for (i = 0; i < GetNumTensors(); i++)
    {
        if (VariableNamesEqual(GetTensors(i).meshName, meshName))
            vars.push_back(GetTensors(i).name);
    }
    for (i = 0; i < GetNumSymmTensors(); i++)
    {
        if (VariableNamesEqual(GetSymmTensors(i).meshName, meshName))
            vars.push_back(GetSymmTensors(i).name);
    }
    for (i = 0; i < GetNumArrays(); i++)
    {
        if (VariableNamesEqual(GetArrays(i).meshName, meshName))
            vars.push_back(GetArrays(i).name);
    }
    for (i = 0; i < GetNumMaterials(); i++)
    {
        if (VariableNamesEqual(GetMaterials(i).meshName, meshName))
            vars.push_back(GetMaterials(i).name);
    }
    for (i = 0; i < GetNumSpecies(); i++)
    {
        if (VariableNamesEqual(GetSpecies(i).meshName, meshName))
            vars.push_back(GetSpecies(i).name);
    }
    for (i = 0; i < GetNumLabels(); i++)
    {
        if (VariableNamesEqual(GetLabels(i).meshName, meshName))
            vars.push_back(GetLabels(i).name);
    }
    return vars;
}

Function: GetAllMeshNames
Declaration: stringVector GetAllMeshNames(void) const;
Definition:
// ****************************************************************************
//  Function: GetAllMeshNames
//
//  Purpose:
//    Retrieves names of all mesh defined on this database.
//
//  Returns:
//    A list of mesh names.
//
//  Programmer: Kathleen Bonnell
//  Creation:   January 21, 2005
//
//  Modifications:
//
// ****************************************************************************

stringVector
avtDatabaseMetaData::GetAllMeshNames() const
{
    int i;
    stringVector meshNames;
    for (i = 0; i < GetNumMeshes(); i++)
    {
        meshNames.push_back(GetMeshes(i).name);
    }
    return meshNames;
}

Function: Print
Declaration: void         Print(ostream &, int = 0) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Print
//
//  Purpose:
//      Prints out all of the meta-data objects in the database meta-data
//      object.  Meant for debugging only.
//
//  Arguments:
//      out     The stream to print out to.
//      indent  The indentation level for each line.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2000
//
//  Modifications:
//
//    Jeremy Meredith, Tue Sep 12 14:58:42 PDT 2000
//    Added code to print the number of time states.
//
//    Hank Childs, Fri Sep 15 19:07:21 PDT 2000
//    Print out Temporal extents and cycles.
//
//    Brad Whitlock, Tue Aug 20 15:23:59 PST 2002
//    I made it so categories that contain no entries are not printed.
//
//    Hank Childs, Wed Sep  4 11:32:48 PDT 2002
//    Print out information related to expressions.
//
//    Sean Ahern, Fri Dec 13 16:50:58 PST 2002
//    Changed to use the ExprssionList state objects.
//
//    Sean Ahern, Mon Mar 17 23:48:43 America/Los_Angeles 2003
//    Changed the names of expression types.
//
//    Brad Whitlock, Wed Apr 2 12:01:10 PDT 2003
//    I made it print out the timestep names if it is a virtual database.
//
//    Hank Childs, Fri Aug  1 11:08:21 PDT 2003
//    Add support for curves.
//
//    Hank Childs, Sat Sep 20 08:49:16 PDT 2003
//    Add support for tensors.
//
//    Hank Childs, Fri Mar  5 11:21:06 PST 2004
//    Print file format.
//
//    Mark C. Miller, Tue Mar 30 14:36:17 PST 2004
//    Added useCatchAllMesh
//
//    Jeremy Meredith, Wed Jul 21 14:23:12 PDT 2004
//    Removed the exclamation point from unknown.
//
//    Brad Whitlock, Fri Jul 23 12:37:57 PDT 2004
//    Added databaseComment.
//
//    Jeremy Meredith, Thu Aug 12 13:23:25 PDT 2004
//    Added simulation fields.
//
//    Mark C. Miller, Tue Sep 28 19:57:42 PDT 2004
//    Added formatCanDoDomainDecomposition
//
//    Brad Whitlock, Fri Apr 1 15:28:58 PST 2005
//    Added labels.
//
//    Mark C. Miller, Tue May 17 18:48:38 PDT 2005
//    Added code to deal with printing of times and a friendlier format
//    for printing of cycles and times
//
//    Hank Childs, Tue Jul 19 13:25:53 PDT 2005
//    Added arrays.
//
//    Kathleen Bonnell, Thu Aug  3 08:42:33 PDT 2006
//    Added CurveMeshVar.
//
// ****************************************************************************

inline void
Indent(ostream &out, int indent)
{
    for (int i = 0 ; i < indent ; i++)
    {
        out << "\t";
    }
}
void
avtDatabaseMetaData::Print(ostream &out, int indent) const
{
    Indent(out, indent);
    out << "Database: " << databaseName.c_str() << endl;

    Indent(out, indent);
    out << "Simulation: " << (isSimulation ? "Yes" : "No" ) << endl;

    Indent(out, indent);
    out << "Database comment: " << databaseComment.c_str() << endl;

    Indent(out, indent);
    out << "File format: " << fileFormat.c_str() << endl;

    Indent(out, indent);
    out << "Num Time States: " << numStates << endl;

    Indent(out, indent);
    out << "MetaData" << (mustRepopulateOnStateChange ? " IS " : " is NOT ") <<
        "repopulated on state changes" << endl;

    Indent(out, indent);
    out << "useCatchAllMesh: " << useCatchAllMesh << endl;

    Indent(out, indent);
    out << "Format " << (formatCanDoDomainDecomposition ? " can " : " cannot ") <<
        "do its own domain decomposition" << endl;

    Indent(out, indent);
    if (hasTemporalExtents)
    {
        out << "Temporal extents are from "
            << minTemporalExtents << " to " << maxTemporalExtents
            << ",  dt = " << (maxTemporalExtents-minTemporalExtents) << "."
            << endl;
    }
    else
    {
        out << "The temporal extents are not set." << endl;
    }

    Indent(out, indent);
    if (times.size() == 0)
    {
        out << "The times are not set." << endl;
    }
    else
    {
        bool shouldPrintTimes = false;
        for (size_t i = 0; i < times.size(); ++i)
        {
            if (times[i] != (double) cycles[i])
            {
                shouldPrintTimes = true;
                break;
            }
        }

        if (AreAllTimesAccurateAndValid())
            out << "All Times are Accurate" << endl;
        else
            out << "All Times are ***NOT*** Accurate" << endl;
        if (shouldPrintTimes)
        {
            out << "Times: " << endl;
            Indent(out, indent+1);
            for (size_t i = 0; i < times.size(); ++i)
            {
                out << times[i];
                if(i < times.size() - 1)
                    out << ", ";
                if((i+1)%5 == 0)
                {
                    out << endl;
                    Indent(out, indent+1);
                }
            }
        }
        else
        {
            out << "Times: Are identical to cycles";
        }
        out << endl;
    }

    Indent(out, indent);
    if (cycles.size() == 0)
    {
        out << "The cycles are not set." << endl;
    }
    else
    {
        if (AreAllCyclesAccurateAndValid())
            out << "All Cycles are Accurate" << endl;
        else
            out << "All Cycles are ***NOT*** Accurate" << endl;
        out << "Cycles: " << endl;
        Indent(out, indent+1);
        for (size_t i = 0; i < cycles.size(); ++i)
        {
            out << cycles[i];
            if(i < cycles.size() - 1)
                out << ", ";
            if((i+1)%10 == 0)
            {
                out << endl;
                Indent(out, indent+1);
            }
        }
        out << endl;
    }

    if(isVirtualDatabase)
    {
        out << endl;
        out << "Database is virtual" << endl;
        out << "Timesteps are located in " << timeStepPath.c_str() << endl;
        out << "Timesteps:" << endl;
        for(size_t i = 0; i < timeStepNames.size(); ++i)
            out << "\t" << timeStepNames[i].c_str() << endl;
        out << endl;
    }

    int i;
    if(GetNumMeshes() > 0)
    {
        Indent(out, indent);
        out << "Meshes: " << endl;
    }
    for (i = 0; i < GetNumMeshes(); ++i)
    {
        GetMeshes(i).Print(out, indent+1);
        out << endl;
    }
    if (GetNumSubsets() > 0)
    {
        Indent(out, indent);
        out << "Subsets: " << endl;
    }
    for (i = 0; i < GetNumSubsets(); i++)
    {
          GetSubsets(i).Print(out, indent+1);
          out << endl;
    }

    if(GetNumScalars() > 0)
    {
        Indent(out, indent);
        out << "Scalars: " << endl;
    }
    for (i = 0; i < GetNumScalars(); ++i)
    {
        GetScalars(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumVectors() > 0)
    {
        Indent(out, indent);
        out << "Vectors: " << endl;
    }
    for (i = 0; i < GetNumVectors(); ++i)
    {
        GetVectors(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumTensors() > 0)
    {
        Indent(out, indent);
        out << "Tensors: " << endl;
    }
    for (i = 0; i < GetNumTensors(); ++i)
    {
        GetTensors(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumSymmTensors() > 0)
    {
        Indent(out, indent);
        out << "Symmetric Tensors: " << endl;
    }
    for (i = 0; i < GetNumSymmTensors(); ++i)
    {
        GetSymmTensors(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumArrays() > 0)
    {
        Indent(out, indent);
        out << "Arrays: " << endl;
    }
    for (i = 0; i < GetNumArrays(); ++i)
    {
        GetArrays(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumMaterials() > 0)
    {
        Indent(out, indent);
        out << "Materials: " << endl;
    }
    for (i = 0; i < GetNumMaterials(); ++i)
    {
        GetMaterials(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumSpecies() > 0)
    {
        Indent(out, indent);
        out << "Material Species: " << endl;
    }
    for (i = 0; i < GetNumSpecies(); ++i)
    {
        GetSpecies(i).Print(out, indent+1);
        out << endl;
    }

    if(curves.begin() != curves.end())
    {
        Indent(out, indent);
        out << "Curves: " << endl;
    }
    for (i = 0; i < GetNumCurves(); ++i)
    {
        GetCurves(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumLabels() > 0)
    {
        Indent(out, indent);
        out << "Labels: " << endl;
    }
    for (i = 0; i < GetNumLabels(); ++i)
    {
        GetLabels(i).Print(out, indent+1);
        out << endl;
    }

    if(GetNumDefaultPlots() > 0)
    {
        Indent(out, indent);
        out << "Default Plots: " << endl;
    }
    for (i = 0; i < GetNumDefaultPlots(); ++i)
    {
        GetDefaultPlots(i).Print(out, indent+1);
        out << endl;
    }

    if (exprList.GetNumExpressions() > 0)
    {
        Indent(out, indent);
        out << "Expressions:" << endl;
        for (int i = 0 ; i < exprList.GetNumExpressions() ; i++)
        {
            Indent(out, indent+1);
            std::string vartype("unknown var type");
            switch (exprList[i].GetType())
            {
              case Expression::Mesh:
                vartype = "mesh";
                break;
              case Expression::ScalarMeshVar:
                vartype = "scalar";
                break;
              case Expression::VectorMeshVar:
                vartype = "vector";
                break;
              case Expression::TensorMeshVar:
                vartype = "tensor";
                break;
              case Expression::SymmetricTensorMeshVar:
                vartype = "symmetrictensor";
                break;
              case Expression::ArrayMeshVar:
                vartype = "array";
                break;
              case Expression::CurveMeshVar:
                vartype = "curve";
                break;
              case Expression::Material:
                vartype = "material";
                break;
              case Expression::Species:
                vartype = "species";
                break;
              case Expression::Unknown:
                vartype = "unknown";
                break;
            }
            out << exprList[i].GetName().c_str()
                << " (" << vartype.c_str() << "): \t"
                << exprList[i].GetDefinition().c_str() << endl;
        }
    }
}

Function: RegisterWarningCallback
Declaration: void  RegisterWarningCallback(void (*)(const char *));
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::RegisterWarningCallback
//
//  Purpose:
//      Register a warning callback.
//
//  Programmer: Hank Childs
//  Creation:   February 15, 2005
//
// ****************************************************************************

void
avtDatabaseMetaData::RegisterWarningCallback(void (*WC)(const char *))
{
    WarningCallback = WC;
    haveWarningCallback = true;
}

Function: WarnCallbackData1
Declaration: static void (*WarningCallback)(const char *);
Definition:
void    (*avtDatabaseMetaData::WarningCallback)(const char *) = NULL;

Function: WarnCallbackData2
Declaration: static bool haveWarningCallback;
Definition:
bool    avtDatabaseMetaData::haveWarningCallback = false;

Function: IssueWarning
Declaration: void IssueWarning(const char *msg) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::IssueWarning
//
//  Purpose:
//      Issues a warning.
//
//  Programmer: Hank Childs
//  Creation:   February 15, 2005
//
// ****************************************************************************

void
avtDatabaseMetaData::IssueWarning(const char *msg) const
{
    if (haveWarningCallback)
    {
        WarningCallback(msg);
    }
    else
    {
        debug1 << "avtDatabaseMetaData wanted to issue the following warning, "
               << "but could not, because no callback was registered:" << endl;
        debug1 << msg << endl;
    }
}

Function: VarIsCompound
Declaration: bool VarIsCompound(const std::string &inVar) const;
Definition:
// ****************************************************************************
//  Function: avtDatabaseMetaData::VarIsCompound
//
//  Purpose:
//    Determines if a variable is in compound form: 'CategoryName(MeshName)'.
//
//  Arguments:
//    v       The (possibly) compound variable.
//
//  Returns:
//    true if the variable is in compound form, false otherwise.
//
//  Programmer: Kathleen Bonnell
//  Creation:   September 5, 2002
//
// ****************************************************************************

bool
avtDatabaseMetaData::VarIsCompound(const std::string &v) const
{
    // find the mesh name enclosed in parentheses
    size_t beg = v.find('(');
    size_t end = v.find(')');

    if (beg == std::string::npos || end == std::string::npos)
    {
        return false;
    }
    return true;
}

Function: ParseCompoundForVar
Declaration: void ParseCompoundForVar(const std::string &inVar, std::string &outVar) const;
Definition:
// ****************************************************************************
//  Function: avtDatabaseMetaData::ParseCompoundForVar
//
//  Purpose:
//    Parses a compound variable of the form 'CategoryName(MeshName)' for
//    the variable portion.
//
// Notes:
//    The desired variable is one that can be 'typed', which may be either
//    CategoryName or MeshName, depending depending upon the subset.
//    e.g. if the CategoryName matches with blockTile or groupTitle of the
//    corresponding MeshMetaData, then the MeshName is returned, so that the
//    variable can be typed as 'AVT_MESH_VAR'.
//
//    This code pulled from gui. (QvisPlotManagerWidget).
//    If inVar is not in the correct compound form, then outVar set to inVar.
//
//  Arguments:
//    inVar   The (possibly) compound variable to parse.
//    outVar  A place to store the parsed variable name.
//
//  Programmer: Kathleen Bonnell
//  Creation:   September 5, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::ParseCompoundForVar(const std::string &inVar,
    std::string &outVar) const
{
    if (!VarIsCompound(inVar))
    {
        outVar = inVar;
        return;
    }

    avtSubsetType sT = DetermineSubsetType(inVar);

    switch (sT)
    {
        case AVT_DOMAIN_SUBSET : // fall-through
        case AVT_GROUP_SUBSET  :
            ParseCompoundForMesh(inVar, outVar);
            break;
        case AVT_MATERIAL_SUBSET :
            ParseCompoundForCategory(inVar, outVar);
            break;
        default:
            outVar = inVar;
            break;
    }
}

Function: ParseCompoundForMesh
Declaration: void ParseCompoundForMesh(const std::string &inVar, std::string &meshName) const;
Definition:
// ****************************************************************************
//  Function: avtDatabaseMetaData::ParseCompoundForMesh
//
//  Purpose:
//    Parses a compound variable of the form 'CategoryName(MeshName)' for
//    the mesh portion.
//
//  Arguments:
//    inVar   The (possibly) compound variable to parse.
//    outVar  A place to store the parsed mesh name.
//
//  Notes:
//    If inVar is not in the correct compound form, then outVar set to inVar.
//
//  Programmer: Kathleen Bonnell
//  Creation:   September 5, 2002
//
// ****************************************************************************

void
avtDatabaseMetaData::ParseCompoundForMesh(const std::string &inVar,
      std::string &outVar) const
{
    // find the mesh name enclosed in parentheses
    size_t beg = inVar.find('(');
    size_t end = inVar.find(')');

    if (beg == std::string::npos || end == std::string::npos)
    {
        // this is not a parseable variable.
        outVar = inVar;
        return;
    }

    //move past the first paren
    beg += 1;
    outVar = inVar.substr(beg, end - beg);
}

Function: ParseCompoundForCategory
Declaration: void ParseCompoundForCategory(const std::string &inVar, std::string &meshName) const;
Definition:
// ****************************************************************************
//  Function: avtDatabaseMetaData::ParseCompoundForCategory
//
//  Purpose:
//    Parses a compound variable of the form 'CategoryName(MeshName)' for
//    the category portion.
//
//  Arguments:
//    inVar   The (possibly) compound variable to parse.
//    outVar  A place to store the parsed category name.
//
//  Notes:
//    If inVar is not in the correct compound form, then outVar set to inVar.
//
//  Programmer: Kathleen Bonnell
//  Creation:   September 5, 2002
//
// ****************************************************************************


void
avtDatabaseMetaData::ParseCompoundForCategory(const std::string &inVar,
      std::string &outVar) const
{
    // find the mesh name enclosed in parentheses
    size_t beg = inVar.find('(');
    size_t end = inVar.find(')');

    if (beg == std::string::npos || end == std::string::npos)
    {
        // this is not a compound variable.
        outVar = inVar;
        return;
    }
    outVar = inVar.substr(0, beg);
}

Function: VariableNamesEqual
Declaration: bool VariableNamesEqual(const std::string &v1, const std::string &v2) const;
Definition:
// ****************************************************************************
// Method: avtDatabaseMetaData::VariableNamesEqual
//
// Purpose:
//   Compares variable names and allows "/var" to be the same as "var".
//
// Arguments:
//   v1 : variable 1.
//   v2 : variable 2.
//
// Returns:    True if the variables are equal; false otherwise.
//
// Note:
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 29 09:37:17 PDT 2005
//
// Modifications:
//
//    Mark C. Miller, Thu Sep 15 11:01:24 PDT 2016
//    Added logic to compare to original v2 or to munged v2new after forbidden
//    char replacement has occured.
// ****************************************************************************

bool
avtDatabaseMetaData::VariableNamesEqual(const std::string &v1, const std::string &v2) const
{
    bool v1BeginsWithSlash = (v1.size() >= 1) ? v1[0] == '/' : false;
    bool v2BeginsWithSlash = (v2.size() >= 1) ? v2[0] == '/' : false;
    std::string v2new;

    IsForbidden(v2, v2new, forbiddenVarNameChars, replacementVarNameStrs);

    if(v1BeginsWithSlash && v2BeginsWithSlash)
        return v1 == v2 || v1 == v2new;
    else if(!v1BeginsWithSlash && !v2BeginsWithSlash)
        return v1 == v2 || v1 == v2new;
    else if(v1BeginsWithSlash)
        return v1.substr(1) == v2 || v1.substr(1) == v2new;
    else
        return v2.substr(1) == v1 || v2new.substr(1) == v1;
}

Function: CycleFromFilenameRegex
Declaration: static std::string cycleFromFilenameRegex;
Definition:
std::string avtDatabaseMetaData::cycleFromFilenameRegex;

Function: SetCycleFromFilenameRegex
Declaration: static void SetCycleFromFilenameRegex(const char *re);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::SetCycleFromFilenameRegex
//
//  Purpose: Set regular expression for finding cycles in filenames
//
//  The format of string passed here is an opening '<' followed by the actual
//  regular expression string followed by a closing '>', optionally followed
//  by a ' ' (space) and a backslashed reference to the specific substring
//  containing the cycle digits. For example, to extract the cycle digits
//  from strings looking like 'run_23_0010_yana.silo' where '0010' is the cycle
//  digits, the string to pass here would look like...
//
//                                               V--substring reference
//                      "<.*_([0-9]{4})_.*\\..*> \1"
//          opening char-^                     ^--closing char
//                        ^------RE part------^
//
//  Do a 'man 7 regex' to get more information on regular expression syntax
//
//  Programmer: Mark C. Miller
//  Creation:   June 13, 2007
//
// ****************************************************************************

void
avtDatabaseMetaData::SetCycleFromFilenameRegex(const char *re)
{
    cycleFromFilenameRegex = re;
}

Function: GetCycleFromFilenameRegex
Declaration: static std::string GetCycleFromFilenameRegex();
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetCycleFromFilenameRegex
//
//  Purpose: Get regular expression for finding cycles in filenames
//
//  Programmer: Mark C. Miller
//  Creation:   June 13, 2007
//
// ****************************************************************************

std::string
avtDatabaseMetaData::GetCycleFromFilenameRegex()
{
    return cycleFromFilenameRegex;
}

Function: AddDefaultSILRestrictionDescription
Declaration: void AddDefaultSILRestrictionDescription(const std::string&);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AddDefaultSILRestrictionDescription
//
//  Purpose: Add a string to the description of a suggested default SIL
//           restriction. This string should be "!TurnAllOn", "TurnAllOf",
//           "+<SIL set name>" or "-<SIL set name>".
//
//  Programmer: Gunther H. Weber
//  Creation:   February 04, 2008
//
// ****************************************************************************

void
avtDatabaseMetaData::AddDefaultSILRestrictionDescription(const std::string& setName)
{
    suggestedDefaultSILRestriction.push_back(setName);
    Select(ID_suggestedDefaultSILRestriction, (void *)&suggestedDefaultSILRestriction);
}

Function: Add10
Declaration: void         Add(avtSubsetsMetaData *);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Add
//
//  Arguments:
//      smd    A subsets meta data object.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
//
// ****************************************************************************

void
avtDatabaseMetaData::Add(avtSubsetsMetaData *smd)
{
    subsets.push_back(smd);
}

Function: GetRestrictedMatnos
Declaration: const intVector& GetRestrictedMatnos(const std::string&) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetRestrictedMatnos
//
//  Purpose: Given variable name, return materials it may be restricted to.
//
//  Programmer: Mark C. Miller
//  Creation:   August 26, 2010
//
// ****************************************************************************
#define CHECK_VAR_TYPE(VT)                                  \
    int num ## VT = GetNum ## VT();                         \
    for (i = 0 ; i < num ## VT; i++)                        \
        if (VariableNamesEqual(Get ## VT(i).name, varname)) \
            return Get ## VT(i).matRestricted

const intVector& avtDatabaseMetaData::GetRestrictedMatnos(const std::string& varname) const
{
    int i;
    static intVector dummy;
    CHECK_VAR_TYPE(Scalars);
    CHECK_VAR_TYPE(Vectors);
    CHECK_VAR_TYPE(Tensors);
    CHECK_VAR_TYPE(Arrays);
    CHECK_VAR_TYPE(Labels);
    return dummy;
}

Function: Empty
Declaration: bool Empty() const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::Empty
//
//  Purpose: Return whether md object is empty (devoid of any objects)
//
//  Programmer: Mark C. Miller
//  Creation:   28Oct10
//
// ****************************************************************************
bool avtDatabaseMetaData::Empty() const
{
    return (GetNumMeshes() == 0 && GetNumCurves() == 0);
}

Function: GetGhostZoneTypesPresent
Declaration: int GetGhostZoneTypesPresent(std::string name) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetGhostZoneTypesPresent
//
//  Purpose:
//      Gets the type of ghost zones present in a particular mesh.
//
//  Arguments:
//      name     The name of a mesh.
//
//  Programmer:  Cyrus Harrison
//  Creation:    Tue Feb  7 11:15:20 PST 2012
//
// ****************************************************************************

int
avtDatabaseMetaData::GetGhostZoneTypesPresent(std::string name) const
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            return GetMeshes(i).presentGhostZoneTypes;
        }
    }
    return AVT_NO_GHOST_ZONES;
}

Function: ClearGhostTypesPresent
Declaration: void ClearGhostTypesPresent(std::string name);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetGhostZoneTypesPresent
//
//  Purpose:
//      Sets type of ghost zones present to AVT_NO_GHOST_ZONES.
//
//  Arguments:
//      name     The name of a mesh.
//
//  Programmer:  Cyrus Harrison
//  Creation:    Tue Feb  7 11:15:20 PST 2012
//
// ****************************************************************************

void
avtDatabaseMetaData::ClearGhostTypesPresent(std::string name)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).presentGhostZoneTypes = AVT_NO_GHOST_ZONES;
            break;
        }
    }
}

Function: AddGhostZoneTypePresent
Declaration: void AddGhostZoneTypePresent(std::string name, avtGhostsZonesPresent v);
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::AddGhostZoneTypePresent
//
//  Purpose:
//      Adds to the types of ghost zones present in a particular mesh.
//
//  Arguments:
//      name     The name of a mesh.
//      v        Type of ghost zones present.
//
//  Programmer:  Cyrus Harrison
//  Creation:    Tue Feb  7 11:15:20 PST 2012
//
// ****************************************************************************

void
avtDatabaseMetaData::AddGhostZoneTypePresent(std::string name,
                                            avtGhostsZonesPresent v)
{
    for (int i = 0 ; i < GetNumMeshes() ; i++)
    {
        if (GetMeshes(i).name == name)
        {
            GetMeshes(i).presentGhostZoneTypes |= v;
            break;
        }
    }
}

Function: GetTotalVarCount
Declaration: int GetTotalVarCount(void) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetTotalVarCount
//
//  Purpose: Compute the total number of variables this database has
//
//  Programmer: Mark C. Miller, Thu May 25 19:52:38 PDT 2017
//
// ****************************************************************************

int
avtDatabaseMetaData::GetTotalVarCount(void) const
{
    return GetNumMeshes() +
           GetNumSubsets() +
           GetNumScalars() +
           GetNumVectors() +
           GetNumTensors() +
           GetNumSymmTensors() +
           GetNumArrays() +
           GetNumMaterials() +
           GetNumSpecies() +
           GetNumCurves() +
           GetNumLabels() +
           GetNumberOfExpressions();
}

Function: GetSEGEnvVarName
Declaration: char const *GetSEGEnvVarName(void) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetSEGEnvVarName
//
//  Purpose: Return name of environment variable used to force speculative
//      expression generation (SEG).
//
//  Programmer: Mark C. Miller, Thu May 25 19:52:38 PDT 2017
//
// ****************************************************************************

char const *
avtDatabaseMetaData::GetSEGEnvVarName() const
{
    return "VISIT_FORCE_SPECULATIVE_EXPRESSION_GENERATION";
}

Function: GetSEGWarningString
Declaration: char const *GetSEGWarningString(void) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::GetSEGWarningString
//
//  Purpose: Return warning string regarding disablement of SEG.
//
//  Programmer: Mark C. Miller, Thu May 25 19:52:38 PDT 2017
//
// ****************************************************************************

char const *
avtDatabaseMetaData::GetSEGWarningString() const
{
    static char msg[2048];
    snprintf(msg, sizeof(msg),
        "Due to the large number of variables, %d, in this database, VisIt has\n"
        "automatically disabled speculative expression generation of ALL forms\n"
        "(e.g. vector-magnitude, mesh-quality, time-derivative, operator-created)\n"
        "because the large number of expressions bogs down GUI performance.\n"
        "You may override this behavior by exiting VisIt and restarting with the\n"
        "environment variable...\n"
        "    \"%s\"\n"
        "set. Be aware that doing so will likely result in sluggish GUI performance.\n"
        "If you need one or more of the expressions VisIt's speculative expression\n"
        "generation process provides and are unwilling or unable to manually create\n"
        "the expression(s) you need, you have no choice in this version of VisIt\n"
        "except to override this behavior and suffer any GUI performance issues.\n"
        "Unfortunately, if you are running in client-server mode, you will have to\n"
        "take action to set this enviornment variable on both the server and client\n"
        "machines. This will only be necessary in VisIt version 2.12.3. An entirely\n"
        "different mechanism for controlling this behavior will be introduced in 2.13.",
         GetTotalVarCount(), GetSEGEnvVarName());
    return msg;
}

Function: IssueSEGWarningMessage
Declaration: void IssueSEGWarningMessage(void) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::IssueSEGWarningMessage
//
//  Purpose: Use IssueWarning method to issue a warning regarding disablement
//      of SEG.
//
//  Programmer: Mark C. Miller, Thu May 25 19:52:38 PDT 2017
//
// ****************************************************************************

void
avtDatabaseMetaData::IssueSEGWarningMessage() const
{
    IssueWarning(GetSEGWarningString());
}

Function: ShouldDisableSEG
Declaration: bool ShouldDisableSEG(bool envOverride=false) const;
Definition:
// ****************************************************************************
//  Method: avtDatabaseMetaData::ShouldDisableSEG
//
//  Purpose: Determine if SEG should be disabled based on TotalVarCount and
//      on whether or not the enviornment variable required to override it
//      has been set.
//
//  Programmer: Mark C. Miller, Thu May 25 19:52:38 PDT 2017
//
// ****************************************************************************
bool
avtDatabaseMetaData::ShouldDisableSEG(bool envOverride) const
{
    return GetTotalVarCount() > 1000 && !envOverride;
}
