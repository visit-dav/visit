// ************************************************************************* //
//                            avtDuneFileFormat.C                            //
// ************************************************************************* //

#include <avtDuneFileFormat.h>

#include <algorithm>
#include <string>
#include <visitstream.h>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkGenericCell.h>

#include <avtDatabaseMetaData.h>
#include <avtMaterial.h>

#include <Expression.h>

#include <InvalidFilesException.h>
#include <InvalidVariableException.h>

using     std::string;

// Note: particle and fragment are interchangable in comments/descriptions.

// ****************************************************************************
//  Method: avtDune constructor
//
//  Purpose:
//      Basic constructor that opens a Dune file - either a graphics file or a
//      restart/loader file. Counts the number of discrete plots, get the Dune
//      times, cycles, and fragment count for each. Build a density table for
//      each material, and associates each species with a material.
//      
//
//  Arguments:
//      filename (char *) [IN] - File to read.
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
//  Modification history:
//      Fri Sep 16 09:20:59 PDT 2005
//          (DMS) - Use species_list to handle per fragment materials.
//                  Changed string_substr() call to get_tokens() to reflect
//                  parsing mods. All data parsed thru get_tokens().
//                  Combined LOADER and RESTART sections.
//                  Modest cleanups.
//
// ****************************************************************************

avtDuneFileFormat::avtDuneFileFormat(const char *filename)
  : avtMTSDFileFormat(&filename, 1)
{
  // INITIALIZE DATA MEMBERS

  ifile.open(filename);
  if (!ifile)
    EXCEPTION1(InvalidFilesException, filename);

  fname = filename;
  ftype = UNKNOWN;

  const string title = "TITLE =";
  const string domain = "Domain{";
  const string fragments = "Fragments{";
  const string materials = "Materials{";
  const string sinkedFragments = "SinkedFragments{";
  string buffer;

  while (ftype == UNKNOWN && !ifile.eof()) {
    getline(ifile, buffer);
    if (buffer.find(sinkedFragments) != string::npos) {
      ftype = RESTART;
    }
  }
  ifile.clear();
  ifile.seekg((streampos) 0, ios::beg);

  while (ftype == UNKNOWN) {
    getline(ifile, buffer);
    if (buffer.find(title) != string::npos) {
      ftype = TECPLOT;
    }
    if (buffer.find(domain) != string::npos ||
        buffer.find(fragments) != string::npos ||
        buffer.find(materials) != string::npos) {
      ftype = LOADER;
    }
  }

  if (ftype == UNKNOWN) {
    EXCEPTION1(InvalidFilesException, filename);
  }

  const string ztime = "ZONE T=\"";
  const string npart = "I =";
  const string field = "F =";
  int    np = 0;
  const string x = "X(";
  const string timeSink = "TimeSink(";
  const string massD = "MassDensity(";
  const string tag = "Name( \"";
  const string speciestags = "SpeciesTags{";
  const string rbrace = "}";
  const string fragment = "Fragment[";
  const string rbracket = "]";
  const string name = "Name(";
  const string material = "Material(";
  const string a_material = "Material[";
  const string mass_density = "MassDensity(";
  const string species = "Species("; 
  const string timesink = "TimeSink(";

  int max_species = 1;
  int ispecies;
  const double DEFAULT_DENSITY = 1.0;
  const string SPECIES_BASE = "Species_";
  const string MATERIAL_BASE = "Material_";
  const string empty = "";
  vector<string> tokens;

  ntimes = 0;
  buffer.erase();


  // Only looking for number of plot times, the Dune time for each, and the
  // number of particles at each time. Also track the file postion for each
  // discrete time for efficiency when reading the particle data later.

  switch (ftype) {
  case TECPLOT:
    while (getline(ifile, buffer)) {
      if (buffer.find(ztime) != string::npos) {
        cycles.push_back(ntimes);
        ++ntimes;

        fpos.push_back(ifile.tellg());

        // we have a line of the form:
        // ZONE T=" 0.200000000D-1" I =    557 F = "POINT"
        get_tokens(buffer, ztime, tokens);
        times.push_back(fortranDoubleToCDouble(tokens[0]));
        int np = atoi(tokens[3].c_str());
        num_particles.push_back(np);
        for (int i = 0; i < np; i++) {
          getline(ifile, buffer);
          get_tokens(buffer, empty, tokens);
          ispecies = atoi(tokens[0].c_str());
          max_species = MAX(max_species, ispecies);
        }
      }
    }

    // no material/species names in graphics file, we'll roll our own
    // based on the number of materials
    for (int i = 0; i < max_species; i++) {
      ostrstream ss;
      ss << SPECIES_BASE << i+1;
      ostrstream sm;
      sm << MATERIAL_BASE << i+1;
      matnames.push_back(sm.str());
      species_names.push_back(ss.str());
      species_to_matname[ss.str()] = sm.str();
      density[sm.str()] = DEFAULT_DENSITY;
    }
    break;
  case LOADER:
  case RESTART:
    do {
      // SpeciesTags
      if (buffer.find(speciestags) != string::npos) {
        string tmat = "NONE";
        string tname = "NONE";
        do {
          if (buffer.find(fragment) != string::npos) {
            do {
              if (buffer.find(name) != string::npos) {
                get_tokens(buffer, name, tokens);
                tname = tokens[0];
                species_names.push_back(tname);
              }
              if (buffer.find(material) != string::npos) {
                get_tokens(buffer, material,tokens);
                tmat = tokens[0];
                matnames.push_back(tmat);
              }
            } while (getline(ifile, buffer) &&
                     buffer.find(rbracket) == string::npos);
            species_to_matname[tname] = tmat;
          }
        } while (getline(ifile, buffer) && buffer.find(rbrace) == string::npos);
        if (species_names.size() != matnames.size()) {
          EXCEPTION1(InvalidVariableException, "SpeciesTags{}");
        }
      }

      // Materials
      if (buffer.find(materials) != string::npos) {
        string tname = "NONE";
        double tden = -1.0;
        do {
          if (buffer.find(a_material) != string::npos) {
            do {
              if (buffer.find(name) != string::npos) {
                get_tokens(buffer, name, tokens);
                tname = tokens[0];
              }
              if (buffer.find(mass_density) != string::npos) {
                get_tokens(buffer, mass_density, tokens);
                tden = fortranDoubleToCDouble(tokens[0]);
              }
            } while (getline(ifile, buffer) && 
                     buffer.find(rbracket) == string::npos);
            density[tname] = tden;
          }
        } while (getline(ifile, buffer) && buffer.find(rbrace) == string::npos);
      }

      // Fragments
      if ((buffer.find(fragments) != string::npos) &&
          (buffer.find(sinkedFragments) == string::npos)) {
        fpos.push_back(ifile.tellg());
        int nx = 0;
        do {
          if (buffer.find(fragment) != string::npos) {
            ++nx;
          }
        } while (getline(ifile, buffer) && buffer.find(rbrace) == string::npos);
        cycles.push_back(ntimes);
        times.push_back((double)ntimes);
        num_particles.push_back(nx);
        ++ntimes;
      }

      // SinkedFragments
      if (buffer.find(sinkedFragments) != string::npos) {
        fpos.push_back(ifile.tellg());
        int nx = 0;
        double sinked = -1.0;
        do {
          if (buffer.find(timesink) != string::npos) {
            get_tokens(buffer, timesink, tokens);
            sinked = fortranDoubleToCDouble(tokens[0]);
          }
          if (buffer.find(fragment) != string::npos) {
            ++nx;
          }
        } while (getline(ifile, buffer) && buffer.find(rbrace) == string::npos);
        cycles.push_back(ntimes);
        if (sinked != -1.0) {
          times.push_back(sinked);
        }
        else {
          times.push_back((double)ntimes);
        }
        num_particles.push_back(nx);
        ++ntimes;
      }
    } while (getline(ifile, buffer));

    break;
  default:
    EXCEPTION1(InvalidFilesException, filename);
  }

  if (density.size() != species_names.size()) {
    EXCEPTION1(InvalidVariableException, "density/species");
  }

  if (matnames.size() != species_names.size()) {
    EXCEPTION1(InvalidVariableException, "materials/species");
  }

  for (int i = 0; i < matnames.size(); i++) {
    if (density[matnames[i]] <= 0.0) {
      EXCEPTION1(InvalidVariableException, "density - " + matnames[i]);
    }
  }

  ifile.clear();

  lastTimestate = -1;
  nparticles = -1;
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Arguments:
//      none
// 
//  Returns:
//      ntimes (int) - Total number of plot times.
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
// ****************************************************************************

int
avtDuneFileFormat::GetNTimesteps(void)
{
  //return YOU_MUST_DECIDE;
  return ntimes;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetTimes
//
//  Purpose:
//      Populates an STL vector with the times.
//
//      out_timess (vector<double> &) [OUT] - List of plot times.
//
//  Returns:
//      none
//
//  Programmer: Dale Slone
//  Creation:   March 9, 2004
//
// ****************************************************************************

void
avtDuneFileFormat::GetTimes(vector<double> &out_times)
{
  out_times = times;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetCycles
//
//  Purpose:
//      Populates an STL vector with the cycles.
//
//  Arguments:
//      out_cycles (vector<int> &) [OUT] - List of plot cycles.
//
//  Returns:
//      none
//
//  Programmer: Dale Slone
//  Creation:   March 9, 2004
//
// ****************************************************************************

  void
  avtDuneFileFormat::GetCycles(vector<int> &out_cycles)
{
  out_cycles = cycles;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it. This method is the mechanism for doing
//      that.
//
//  Arguments:
//      none
//
//  Returns:
//      none
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
//  Modification history:
//      Fri Sep 16 09:20:59 PDT 2005
//          (DMS) - Added energies.
//
//
// ****************************************************************************

void
avtDuneFileFormat::FreeUpResources(void)
{
  species_list.clear();
  radius.clear();
  impulseTime.clear();
  coordinates.clear();
  velocities.clear();
  impulseVelocities.clear();
  totalVelocities.clear();
  angularVelocities.clear();
  energies.clear();
  mass.clear();

  lastTimestate = -1;
  nparticles = -1;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Arguments:
//      md (avtDatabaseMetaData *) [OUT] - Metadata we need to fill.
//      timestate (int)            [IN]  - The index of the timestate. If 
//                                         GetNTimesteps returned 'N' time
//                                         steps, this is guaranteed to be 
//                                         between 0 and N-1.
//
//  Returns:
//      none
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
//  Modification History:
//      Fri Sep 16 09:20:59 PDT 2005
//          (DMS) - Simplified AddMaterialToMetaData section.
//
//
// ****************************************************************************

void
avtDuneFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  md->SetNumStates(ntimes);
  //
  // CODE TO ADD A MESH
  //
  string meshname = "particles";
  //
  // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
  // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
  avtMeshType mt = AVT_UNSTRUCTURED_MESH;
  //
  int nblocks = 1;         // <-- this must be 1 for MTSD
  int block_origin = 0;
  int spatial_dimension = 3;
  int topological_dimension = 0;
  float *extents = NULL;
  //
  // Here's the call that tells the meta-data object that we have a mesh:
  //
  AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                    spatial_dimension, topological_dimension);
  //

  //
  // CODE TO ADD A SCALAR VARIABLE
  //
  string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  vector<string> svarname;
  svarname.push_back("radius");
  svarname.push_back("mass");
  svarname.push_back("impulse_time");
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  for (int i = 0; i < svarname.size(); i++) {
    AddScalarVarToMetaData(md, svarname[i], mesh_for_this_var, cent);
  }
  //

  //
  // CODE TO ADD A VECTOR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  vector<string> vvarname;
  vvarname.push_back("velocity");
  vvarname.push_back("impulse_velocity");
  vvarname.push_back("angular_velocity");
  vvarname.push_back("total_velocity");

  int vector_dim = 3;
  //
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  for (int i = 0; i < vvarname.size(); i++) {
    AddVectorVarToMetaData(md, vvarname[i], mesh_for_this_var, cent,
                           vector_dim);
  }
  //

  //
  // CODE TO ADD A TENSOR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  // string varname = ...
  // int tensor_dim = 9;
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
  //

  //
  // CODE TO ADD A MATERIAL
  //
  string mesh_for_mat = meshname; // ??? -- could be multiple meshes
  string material_name = "fragments";
  if (matnames.size() == 0) {
    ostrstream ss;
    ss << "material_" << 1;
    matnames.push_back(ss.str());
  }

  //
  // Here's the call that tells the meta-data object that we have a mat:
  //
  AddMaterialToMetaData(md, material_name, mesh_for_mat, matnames.size(),
                        matnames);
  //

  Expression momentum_expr;
  momentum_expr.SetName("momentum");
  momentum_expr.SetDefinition("total_velocity*mass");
  momentum_expr.SetType(Expression::VectorMeshVar);
  md->AddExpression(&momentum_expr);
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file. The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate (int)   [IN] - The index of the timestate. If GetNTimesteps 
//                               returned 'N' time steps, this is guaranteed to
//                               be between 0 and N-1.
//      meshname (char *) [IN] - The name of the mesh of interest.  This can be 
//                               ignored if there is only one mesh.
//
//  Returns:
//      dataset (vtkDataSet *) - The dataset filled with mesh data
// 
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
//  Modification history:
//      Fri Sep 16 09:20:59 PDT 2005
//          (DMS) - Changed InsertNextCell(...) loop to reflect VisIt changes.
//
// ****************************************************************************

vtkDataSet *
avtDuneFileFormat::GetMesh(int timestate, const char *meshname)
{
  //YOU MUST IMPLEMENT THIS
  if (strcmp(meshname, "particles") != 0)
    EXCEPTION1(InvalidVariableException, meshname);

  ReadDuneData(timestate);

  vtkUnstructuredGrid *dataset = vtkUnstructuredGrid::New();
  dataset->Allocate(nparticles);
  vtkPoints *vtkpoints = vtkPoints::New();
  vtkpoints->SetNumberOfPoints(nparticles);
  float *pts = (float *) vtkpoints->GetVoidPointer(0);

  for (int i = 0; i < coordinates.size(); i++) {
    pts[i] = coordinates[i];
  }

  for (int i = 0; i < nparticles; i++) {
    vtkIdType part = i;
    dataset->InsertNextCell(VTK_VERTEX, 1, &part);
  }

  dataset->SetPoints(vtkpoints);
  vtkpoints->Delete();

  return dataset;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file. Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate (int)  [IN] - The index of the timestate. If GetNTimesteps 
//                              returned 'N' time steps, this is guaranteed to
//                              be  between 0 and N-1.
//      varname (char *) [IN] - The name of the variable requested.
//
//  Returns:
//      rv (vtkDataArray *) - Data array filled with appropriate scalar data.
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
// ****************************************************************************

vtkDataArray *
avtDuneFileFormat::GetVar(int timestate, const char *varname)
{
  //YOU MUST IMPLEMENT THIS

  //
  // If you have a file format where variables don't apply (for example a
  // strictly polygonal format like the STL (Stereo Lithography) format,
  // then uncomment the code below.
  //
  // EXCEPTION0(InvalidVariableException, varname);
  //

  ReadDuneData(timestate);
  //
  // If you do have a scalar variable, here is some code that may be helpful.
  //
  int ntuples = nparticles; // this is the number of entries in the variable.
  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfTuples(ntuples);
  if (strcmp(varname, "radius") == 0) {
    for (int i = 0 ; i < ntuples ; i++)
      {
        rv->SetTuple1(i, radius[i]);  // you must determine value for ith entry.
      }
  }
  else if (strcmp(varname, "mass") == 0) {
    for (int i = 0; i < ntuples; i++) {
      rv->SetTuple1(i, mass[i]);
    }
  }
  else if (strcmp(varname, "impulse_time") == 0) {
    for (int i = 0; i < ntuples; i++) {
      rv->SetTuple1(i, impulseTime[i]);
    }
  }
  else {
    EXCEPTION1(InvalidVariableException, varname);
  }

  return rv;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file. Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate (int)  [IN] - The index of the timestate. If GetNTimesteps 
//                              returned 'N' time steps, this is guaranteed to
//                              be between 0 and N-1.
//      varname (char *) [IN] - The name of the requested variable.
//
//  Returns:
//      rv (vtkDataArray *) - Data array filled with appropriate vector data.
//
//  Programmer: dslone -- generated by xml2avt
//  Creation:   Wed Aug 31 17:26:34 PST 2005
//
// ****************************************************************************

vtkDataArray *
avtDuneFileFormat::GetVectorVar(int timestate, const char *varname)
{
  //YOU MUST IMPLEMENT THIS

  ReadDuneData(timestate);

  //
  // If you have a file format where variables don't apply (for example a
  // strictly polygonal format like the STL (Stereo Lithography) format,
  // then uncomment the code below.
  //
  // EXCEPTION0(InvalidVariableException, varname);
  //

  //
  // If you do have a vector variable, here is some code that may be helpful.
  //
  int ncomps = 3;        // This is the rank of the vector - typically 2 or 3.
  int ntuples = nparticles; // this is the number of entries in the variable.
  vtkFloatArray *rv = vtkFloatArray::New();
  int ucomps = (ncomps == 2 ? 3 : ncomps);
  rv->SetNumberOfComponents(ucomps);
  rv->SetNumberOfTuples(ntuples);
  float *one_entry = new float[ucomps];

  vector<double> data;
  if (strcmp(varname, "velocity") == 0) {
    data = velocities;
  }
  else if (strcmp(varname, "impulse_velocity") == 0) {
    data = impulseVelocities;
  }
  else if (strcmp(varname, "angular_velocity") == 0) {
    data = angularVelocities;
  }
  else if (strcmp(varname, "total_velocity") == 0) {
    data = totalVelocities;
  }
  else {
    EXCEPTION1(InvalidVariableException, varname);
  }

  for (int i = 0 ; i < ntuples ; i++)
    {
      for (int j = 0 ; j < ncomps ; j++) {
        one_entry[j] = data[i*VECTOR_SIZE + j];
      }
      for (int j = ncomps ; j < ucomps ; j++) {
        one_entry[j] = 0.;
      }
      rv->SetTuple(i, one_entry);
    }

  delete [] one_entry;
  return rv;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::ReadDuneData
//
//  Purpose:
//      Opens the data file and reads the information for the current timestep,
//      filling the appropriate data members required everywhere through VisIt.
//
//  Arguments:
//      timestate (int) [IN] - Index of the timestate.If GetNTimesteps 
//                             returned 'N' time steps, this is guaranteed to 
//                             be between 0 and N-1.
//
//  Returns:
//      none
//
//  Programmer: dslone --
//  Creation:   Thu Mar 4 11:59:59 PDT 2004
//
//  Modification history:
//      Thu Jun 24 09:14:32 PDT 2004
//          (DMS) - Added impulseTime, impulseVelocity, and totalVelocity vars.
//      Thu Jul 2 09:44:32 PDT 2004
//          (DMS) - Added angularVelocity var.
//                  Redid LOADER, RESTART for new syntax.
//      Fri Sep 16 09:20:59 PDT 2005
//          (DMS) - Use species_list to handle per fragment materials.
//                  Changed string_substr() call to get_tokens() to reflect
//                  parsing mods. All data parsed thru get_tokens().
//                  Combined LOADER and RESTART sections.
//                  Modest cleanups.
//      Thu Oct  6 16:58:57 PDT 2005
//          (HRC) - Qualify find with "std::".  ['6647]
//
// ****************************************************************************

void
avtDuneFileFormat::ReadDuneData(const int timestate) {
  if (timestate == lastTimestate) {
    // current data is still valid, so just return
    return;
  }

  if (ifile.bad()) {
    ifile.open(fname.c_str());
    if (!ifile) {
      EXCEPTION1(InvalidFilesException, fname.c_str());
    }
  }
  else {
    if (ifile.eof()) {
      ifile.clear();
    }
  }

  if (nparticles != num_particles[timestate]) {
    // number of particles has changed for this time step, need to resize arrays
    nparticles = num_particles[timestate];
    species_list.resize(nparticles);
    radius.resize(nparticles);
    impulseTime.resize(nparticles);
    coordinates.resize(VECTOR_SIZE * nparticles);
    velocities.resize(VECTOR_SIZE * nparticles);
    impulseVelocities.resize(VECTOR_SIZE * nparticles);
    angularVelocities.resize(VECTOR_SIZE * nparticles);
    totalVelocities.resize(VECTOR_SIZE * nparticles);
    mass.resize(nparticles);
    energies.resize(TENSOR_SIZE * nparticles);
  }

  // go directly to appropriate section in file
  ifile.seekg(fpos[timestate], ios::beg);

  nparticles = num_particles[timestate];

  int    np = 0;
  string buffer;
  const string x = "X(";
  const string v = "V(";
  const string q = "Q(";
  const string w = "W(";
  const string r = "R(";
  const double pi = M_PI;
  const double volume_factor = 4.0/3.0 * pi;
  const string species = "Species(";
  const string material = "Material(";
  double rho;
  const string time = "Time(";
  const string impulse = "Impulse[";
  const string vi = "DV(";
  const string fragment_block = "Fragment[";
  string fragments = "Fragments{";
  const string rbrace = "}";
  const string rbracket = "]";

  const int fields = 11;                 // 11 fields per line in plot file
  double fragment[fields];
  const string empty = "";
  vector<string> tokens;
  const string lp_delimiters = DEFAULT_DELIMITERS + "(";

  switch (ftype) {
  case TECPLOT:
    for (int i = 0; i < nparticles; i++) {
      getline(ifile, buffer);
      get_tokens(buffer, empty, tokens);
      for (int j = 1; j < tokens.size(); j++) {      // 0th is integer
        fragment[j] = fortranDoubleToCDouble(tokens[j]);
      }
      species_list[i] = atoi(tokens[0].c_str()) - 1;    // 1-based indexing
      double rho = density[matnames[species_list[i]]];
      radius[i] = fragment[1];
      // Dune not currently outputing impulses to plot file
      //impulseTime[i] = atof(fragment[14].c_str());
      impulseTime[i] = 0.0;
      mass[i] = rho * volume_factor * pow(radius[i], 3);
      for (int j = 0; j < VECTOR_SIZE; j++) {
        coordinates[i*VECTOR_SIZE + j] = fragment[2 + j];
        velocities[i*VECTOR_SIZE + j] = fragment[5 + j];
        angularVelocities[i*VECTOR_SIZE + j] = fragment[8 + j];
        impulseVelocities[i*VECTOR_SIZE + j] = 0.0;
      }
      for (int j = 0; j < TENSOR_SIZE; j++) {
        energies[i*TENSOR_SIZE + j] = 0.0;
      }
    }
    break;
  case LOADER:
  case RESTART:
    rho = 1.0;

    while (np < nparticles) {
      getline(ifile, buffer);
      if (ifile.eof()) {
        EXCEPTION1(InvalidFilesException, fname.c_str());
      }

      if (buffer.find(fragment_block) != string::npos) {
        // found Fragment[ block <=> one particle
        bool radius_Found = false;
        bool density_found = false;
        do {
          if (buffer.find(material) != string::npos) {
            // found material, get density
            get_tokens(buffer, material, tokens);
            rho = density[tokens[0]];
            vector<string>::iterator ndx = std::find(matnames.begin(), matnames.end(), tokens[0]);
            if (ndx == matnames.end()) {
              EXCEPTION1(InvalidVariableException, "Material");
            }
            else {
              species_list[np] = ndx - matnames.begin();
            }
            density_found = true;
          }
          else {
            if (buffer.find(species) != string::npos){
              // found species, get density
              get_tokens(buffer, species, tokens);
              rho = density[species_to_matname[tokens[0]]];
              vector<string>::iterator ndx = find(species_names.begin(), species_names.end(), tokens[0]);
              if (ndx == matnames.end()) {
                EXCEPTION1(InvalidVariableException, "Species");
              }
              else {
                species_list[np] = ndx - species_names.begin();
              }
              density_found = true;
            }
          }
          if (buffer.find(r) != string::npos) {
            // found radius
            get_tokens(buffer, r, tokens);
            radius[np] = fortranDoubleToCDouble(tokens[0]);
            radius_Found = true;
            if (timestate == 0) {
              getline(ifile, buffer);
            }
          }
          if (radius_Found && density_found) {
            // radius and density known, compute mass
            mass[np] = rho * volume_factor * pow(radius[np], 3.0);
          }

          if (buffer.find(x) != string::npos) {
            // found X => coordinates for center of fragment
            get_tokens(buffer, x, tokens);
            for (int i = 0; i < VECTOR_SIZE; i++) {
              coordinates[np*VECTOR_SIZE + i] = 
                fortranDoubleToCDouble(tokens[i]);
            }
          }
          if (buffer.find(v) != string::npos &&
              !(buffer.find(vi) != string::npos)) {
            // found V => velocity (not impulse velocity) of fragment
            get_tokens(buffer, v, tokens);
            for (int i = 0; i < VECTOR_SIZE; i++) {
              velocities[np*VECTOR_SIZE + i] = 
                fortranDoubleToCDouble(tokens[i]);
            }
          }
          if (buffer.find(q) != string::npos) {
            // found Q => energy tensor of fragment
            get_tokens(buffer, q, tokens);
            for (int i = 0; i < TENSOR_SIZE; i++) {
              energies[np*TENSOR_SIZE + i] = 
                fortranDoubleToCDouble(tokens[i]);
            }
          }
          if (buffer.find(w) != string::npos) {
            get_tokens(buffer, w, tokens);
            // found W => angular velocity of fragment
            for (int i = 0; i < VECTOR_SIZE; i++) {
              angularVelocities[np*VECTOR_SIZE + i] = 
                fortranDoubleToCDouble(tokens[i]);
            }
          }
          if (buffer.find(impulse) != string::npos) {
            // impulse block
            if (timestate == 0) {
              // loader format has Impuse[ on separate line
              getline(ifile, buffer);
            }
            if (buffer.find(time) != string::npos) {
              get_tokens(buffer, time, tokens);
              impulseTime[np] = fortranDoubleToCDouble(tokens[0]);
            }
            if (timestate == 0) {
              // loader format has Time[ on separate line
              getline(ifile, buffer);
            }
            if (buffer.find(vi) != string::npos) {
              // found DV => impulse velocity of fragment
              get_tokens(buffer, vi, tokens);
              for (int i = 0; i < VECTOR_SIZE; i++) {
                impulseVelocities[np*VECTOR_SIZE + i] = 
                  fortranDoubleToCDouble(tokens[i]);
              }
            }                                              // if vi
          }                                                // if impulse
        } while (getline(ifile, buffer) && 
                 buffer.find(rbracket) == string::npos);   // do ...
        ++np;
      }                                                    // if fragment_block
    }                                                      // while (np)
    break;
  default:
    EXCEPTION1(InvalidFilesException, fname.c_str());
  }


  // compute total velocity for each fragment
  for (int i = 0; i < nparticles; i++) {
    for (int j = 0; j < VECTOR_SIZE; j++) {
      totalVelocities[i*VECTOR_SIZE + j] = velocities[i*VECTOR_SIZE + j] +
        angularVelocities[i*VECTOR_SIZE + j] +
        impulseVelocities[i*VECTOR_SIZE + j];
    }
  }

  lastTimestate = timestate;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::get_tokens
//
//  Purpose:
//      Return all tokens from the input string, beginning after the start
//      substring [an empty start implies tokenize the entire string]. The
//      token is delimiteded using the fourth, optional, argument.
//
//  Arguments:
//      buffer     (string &)            [IN] - Input source string
//      start      (string &)            [IN] - Substring within buffer to
//                                              begin tokenizing
//      tokens     (vector<string> &) [INOUT] - All delimited tokens in string
//      delimiters (string &)            [IN] - List of token delimiters, 
//                                              defaults are ^ ^1"),
//
//  Programmer: dslone --
//  Creation:   Fri Sep 16 09:20:59 PDT 2005
//
// ****************************************************************************

void avtDuneFileFormat::get_tokens(const string& str,
                                   const string& start,
                                   vector<string>& tokens,
                                   const string& delimiters)
{
  // start with a fresh list
  tokens.clear();

  // position for beginning of buffer substring to tokenize
  size_t begPos = (start.length() == 0) ? 0 :
    str.find(start) + start.length();

  // Skip delimiters at beginning.
  size_t lastPos = str.find_first_not_of(delimiters, begPos);
  // Find first "non-delimiter".
  size_t pos     = str.find_first_of(delimiters, lastPos);

  while (string::npos != pos || string::npos != lastPos)
    {
      // Found a token, add it to the vector.
      tokens.push_back(str.substr(lastPos, pos - lastPos));
      // Skip delimiters.  Note the "not_of"
      lastPos = str.find_first_not_of(delimiters, pos);
      // Find next "non-delimiter"
      pos = str.find_first_of(delimiters, lastPos);
    }
}

// ****************************************************************************
//  Method: avtDuneFileFormat::fortranDoubleToCDouble
//
//  Purpose:
//      Convert a Fortran style double var (.123D+01) to a C double (.123e+01).
//      filling the appropriate data members required everywhere through VisIt.
//
//  Arguments:
//      arg (string &) [IN] - string containing Fortran double var.
//
//  Returns:
//      (double) - C double.
//
//  Programmer: dslone --
//  Creation:   Thu Mar 4 11:59:59 PDT 2004
//
// ****************************************************************************

double avtDuneFileFormat::fortranDoubleToCDouble(const string& arg)
{
  string dexp = "D";
  string exp = "e";
  string spart = arg;
  size_t pos = spart.find(dexp);

  if (pos != string::npos) {
    spart.replace(pos, 1, exp);
  }

  return atof(spart.c_str());
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Get the material list data.
//
//  Arguments:
//      var (char *)               [IN] - Variable of interest. Not used.
//      domain (int)               [IN] - Domain of interest. Not used.
//      type (char *)              [IN] - Type of auxiliary data, may not be meaningful.
//      <unnamed> (void *)         [IN] - Not use.
//      df (DestructorFunction &) [OUT] - Pointer to material destructor.
//
//  Returns:
//      rv (void *) - Pointer to material data.
//
//  Programmer: dslone --
//  Creation:   Fri Sep 16 09:20:59 PDT 2005
//
// ****************************************************************************

void *avtDuneFileFormat::GetAuxiliaryData(const char *var, int domain,
                                          const char *type, void *,
                                          DestructorFunction &df)
{
  void *rv = NULL;
  if (strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
    {
      rv = (void *) GetMaterial();
      df = avtMaterial::Destruct;
    }
  return rv;
}


// ****************************************************************************
//  Method: avtDuneFileFormat::GetMaterial
//
//  Purpose:
//      Generate appropriate avtMaterial initialization.
//      Note that Dune has no mixed data.
//
//  Arguments:
//      none
//
//  Returns:
//      mat (void *) - Newly created material.
//
//  Programmer: dslone --
//  Creation:   Fri Sep 16 09:20:59 PDT 2005
//
// ****************************************************************************

void *avtDuneFileFormat::GetMaterial()
{
  int mixed_size = 0;
  vector<int> mix_mat(mixed_size);
  vector<int> mix_next(mixed_size);
  vector<int> mix_zone(mixed_size);
  vector<float> mix_vf(mixed_size);

  avtMaterial *mat = new avtMaterial(matnames.size(), matnames, nparticles,
                                     &(species_list[0]), mixed_size,
                                     &(mix_mat[0]), &(mix_next[0]),
                                     &(mix_zone[0]), &(mix_vf[0]));

  return (void*) mat;    
}


// ****************************************************************************
//  Method: avtDuneFileFormat::MAX
//
//  Purpose:
//      Return maximum of two ints.
//
//  Arguments:
//      a (int) [IN] - First integer.
//      b (int) [IN] - Second integer.
//
//  Returns:
//      <unnamed> (int) - greater of a and b
//
//  Programmer: dslone --
//  Creation:   Fri Sep 16 09:20:59 PDT 2005
//
// ****************************************************************************

int avtDuneFileFormat::MAX(const int a, const int b)
{
  return ((a) > (b) ? a : b);
};
