/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             avtUNICFileFormat.C                           //
// ************************************************************************* //

#include <avtUNICFileFormat.h>

#include <string>

#include <vtkCellArray.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkIdTypeArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidDBTypeException.h>
#include <InvalidVariableException.h>

#include <snprintf.h>
#include <visit-hdf5.h>

using     std::string;


// ****************************************************************************
//  Method: avtUNICFileFormat constructor
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
// ****************************************************************************

avtUNICFileFormat::avtUNICFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
    file_handle = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_handle < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a UNIC data file, since "
                                           "it is not even an HDF5 file.");
    }
    int control = H5Dopen(file_handle, "CONTROL");
    if (control < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a UNIC data file, since "
                                  "it is not contain the dataset \"control\".");    
    }

    H5Fclose(file_handle);
    file_handle = -1;
}


// ****************************************************************************
//  Method: avtUNICFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
// ****************************************************************************

void
avtUNICFileFormat::FreeUpResources(void)
{
    if (file_handle >= 0)
    {
        H5Fclose(file_handle);
        file_handle = -1;
    }
}


// ****************************************************************************
//  Method: avtUNICFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
// ****************************************************************************

void
avtUNICFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    int  i, j;

    // Clean up from the last invocation, in case this method is called multiple times.
    cellvarnames.clear();
    ptvarnames.clear();

    string meshname = "mesh";
    avtMeshType mt = AVT_UNSTRUCTURED_MESH;

    //
    // We know the file is valid and it has "control" from the constructor.
    //
    if (file_handle < 0)
        file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
    int control = H5Dopen(file_handle, "CONTROL");
    int info[5];
    int space_id = H5Dget_space(control);
    H5Dread(control, H5T_NATIVE_INT, H5S_ALL, space_id, H5P_DEFAULT, info);
    H5Dclose(control);

    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = meshname;
    mesh->meshType = AVT_UNSTRUCTURED_MESH;
    mesh->numBlocks = info[0];
    mesh->blockOrigin = 1;
    spatialDim = info[1];
    mesh->spatialDimension = spatialDim;
    mesh->topologicalDimension = spatialDim;
    mesh->blockTitle = "Blocks";
    mesh->blockPieceName = "Block%012d";
    mesh->hasSpatialExtents = false;
    md->Add(mesh);

    int nPtVars   = info[2];
    int nCellVars = info[3];
    int slen      = info[4];
    char *pt_name_buff   = new char[nPtVars*slen+1];
    char *cell_name_buff = new char[nCellVars*slen+1];

    int pt_names = H5Dopen(file_handle, "VERTEX_VECTOR_NAMES");
    if (pt_names < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a UNIC data file, since "
                     "it is not contain the dataset \"VERTEX_VECTOR_NAMES\".");    
    }
    hid_t type_id = H5Dget_type(pt_names);
    H5Dread(pt_names, type_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, pt_name_buff);
    //H5Dclose(pt_names);

    int cell_names = H5Dopen(file_handle, "ELEMENT_VECTOR_NAMES");
    if (cell_names < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a UNIC data file, since "
                     "it is not contain the dataset \"ELEMENT_VECTOR_NAMES\".");
    }
    type_id = H5Dget_type(pt_names);
    H5Dread(cell_names, type_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, cell_name_buff);
    //H5Dclose(cell_names);

    char *fixed_name = new char[slen+1];
    fixed_name[slen] = '\0';
    for (i = 0 ; i < nCellVars ; i++)
    {
        char *name = cell_name_buff + slen*i;
        bool allSpaceSoFar = true;
        for (j = slen-1 ; j >= 0 ; j--)
            if (name[j] == ' ' && allSpaceSoFar)
                fixed_name[j] = '\0';
            else
            {
                fixed_name[j] = name[j];
                allSpaceSoFar = false;
            }

        cellvarnames.push_back(fixed_name);
        AddScalarVarToMetaData(md, fixed_name, meshname, AVT_ZONECENT);
    }

    for (i = 0 ; i < nPtVars ; i++)
    {
        char *name = pt_name_buff + slen*i;
        bool allSpaceSoFar = true;
        for (j = slen-1 ; j >= 0 ; j--)
            if (name[j] == ' ' && allSpaceSoFar)
                fixed_name[j] = '\0';
            else
            {
                fixed_name[j] = name[j];
                allSpaceSoFar = false;
            }

        ptvarnames.push_back(fixed_name);
        AddScalarVarToMetaData(md, fixed_name, meshname, AVT_NODECENT);
    }

    delete [] fixed_name;
    delete [] cell_name_buff;
    delete [] pt_name_buff;
}


// ****************************************************************************
//  Method: avtUNICFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
//  Modifications:
//
//    Hank Childs, Thu Jul 24 17:12:34 PDT 2008
//    Add support for 2D.
//
// ****************************************************************************

vtkDataSet *
avtUNICFileFormat::GetMesh(int domain, const char *meshname)
{
    int  i, j;

    char blockname[1024];
    if (file_handle < 0)
        file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
    SNPRINTF(blockname, 1024, "BLOCK%012d", domain+1);
    hid_t block = H5Gopen(file_handle, blockname);
    if (block < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot locate BLOCK data");
    }

    int control = H5Dopen(block, "INFO");
    int info[3];
    H5Dread(control, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, info);
    H5Dclose(control);

    int numElements = info[0];
    int verticesPerElement = info[1];
    int numVertices = numElements*verticesPerElement;
    int theVtkCellType = info[2];

    float *xyz = new float[3*numVertices];
    int xyz_id = H5Dopen(block, "XYZ");
    H5Dread(xyz_id, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, H5P_DEFAULT, xyz);
    H5Dclose(xyz_id);
    
    vtkPoints *pts = vtkPoints::New();
    pts->SetNumberOfPoints(numVertices);
    for (i = 0 ; i < numElements ; i++)
    {
        int base = spatialDim*verticesPerElement*i;
        for (j = 0 ; j < verticesPerElement ; j++)
        {
            int idx = verticesPerElement*i + j;
            pts->SetPoint(idx, xyz[base+j], xyz[base+verticesPerElement+j], 
                          (spatialDim == 2 ? 0. : xyz[base+2*verticesPerElement+j]));
        }
    }

    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
    ugrid->SetPoints(pts);
    pts->Delete();

    vtkIdTypeArray *nlist = vtkIdTypeArray::New();
    nlist->SetNumberOfValues(numElements*(verticesPerElement+1));
    vtkIdType *nl = nlist->GetPointer(0);

    vtkUnsignedCharArray *cellTypes = vtkUnsignedCharArray::New();
    cellTypes->SetNumberOfValues(numElements);
    unsigned char *ct = cellTypes->GetPointer(0);

    vtkIdTypeArray *cellLocations = vtkIdTypeArray::New();
    cellLocations->SetNumberOfValues(numElements);
    int *cl = cellLocations->GetPointer(0);

    for (i = 0 ; i < numElements ; i++)
    {
        *nl++ = verticesPerElement;
        for (j = 0 ; j < verticesPerElement ; j++)
            *nl++ = i*(verticesPerElement) + j;
        *ct++ = theVtkCellType;
        *cl++ = i*(verticesPerElement+1);
    }

    vtkCellArray *cells = vtkCellArray::New();
    cells->SetCells(numElements, nlist);
    nlist->Delete();

    ugrid->SetCells(cellTypes, cellLocations, cells);
    cellTypes->Delete();
    cellLocations->Delete();
    cells->Delete();

    return ugrid;
}


// ****************************************************************************
//  Method: avtUNICFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
// ****************************************************************************

vtkDataArray *
avtUNICFileFormat::GetVar(int domain, const char *varname)
{
    int i, j;

    bool isPtVar = false;
    int  idx     = -1;

    for (i = 0 ; i < cellvarnames.size() ; i++)
        if (cellvarnames[i] == varname)
            idx = i;
    for (i = 0 ; i < ptvarnames.size() ; i++)
        if (ptvarnames[i] == varname)
        {
            idx = i;
            isPtVar = true;
        }

    if (idx < 0)
    {
        EXCEPTION1(InvalidVariableException, varname);
    }

    char blockname[1024];
    if (file_handle < 0)
        file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
    SNPRINTF(blockname, 1024, "BLOCK%012d", domain+1);
    hid_t block = H5Gopen(file_handle, blockname);
    if (block < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot locate BLOCK data");
    }

    int control = H5Dopen(block, "INFO");
    int info[3];
    H5Dread(control, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, info);
    H5Dclose(control);

    int numElements = info[0];
    int verticesPerElement = info[1];
    int numVertices = numElements*verticesPerElement;

    int ntups = (isPtVar ? numVertices : numElements);
    vtkDoubleArray *rv = vtkDoubleArray::New();
    rv->SetNumberOfTuples(ntups);
    double *vals = (double *) rv->GetVoidPointer(0);

#if HDF5_VERSION_GE(1,6,4)
    hsize_t offsets[2];
    hsize_t counts[2];
#else
    hssize_t offsets[2];
    hssize_t counts[2];
#endif

    int id = -1;
    if (isPtVar)
        id = H5Dopen(block, "VERTEXDATA");
    else
        id = H5Dopen(block, "ELEMENTDATA");

    hid_t dataspace = H5Dget_space(id);
    hid_t rank      = H5Sget_simple_extent_ndims(dataspace);
    hsize_t dims[2];
    int status_n   = H5Sget_simple_extent_dims(dataspace, dims, NULL);
    offsets[0] = idx;
    offsets[1] = 0;
    counts[0]  = 1;
    counts[1]  = ntups;
    H5Sselect_hyperslab(dataspace, H5S_SELECT_SET, offsets, NULL, counts, NULL);

    dims[0] = 1;
    dims[1] = ntups;
    hid_t memdataspace = H5Screate_simple(2, dims, NULL);

    H5Dread(id, H5T_NATIVE_DOUBLE, memdataspace, dataspace, H5P_DEFAULT, vals);

    H5Sclose(memdataspace);
    H5Sclose(dataspace);
    H5Dclose(id);

    return rv;
}


// ****************************************************************************
//  Method: avtUNICFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Wed Jul 9 07:28:15 PDT 2008
//
// ****************************************************************************

vtkDataArray *
avtUNICFileFormat::GetVectorVar(int domain, const char *varname)
{
    EXCEPTION1(InvalidVariableException, varname);
}


