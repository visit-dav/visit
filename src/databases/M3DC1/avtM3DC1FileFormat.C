/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtM3DC1FileFormat.C                           //
// ************************************************************************* //

#include <avtM3DC1FileFormat.h>
#include <avtM3DC1Field.h>

#include <string>

#include <vtkIntArray.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkUnstructuredGrid.h>
#include <vtkTriangle.h>
#include <vtkWedge.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <avtCallback.h>
#include <NonCompliantException.h>
#include <InvalidFilesException.h>
#include <InvalidVariableException.h>
#include <DebugStream.h>


using namespace std;

#define ELEMENT_SIZE_2D 7
#define SCALAR_SIZE_2D 20

#define ELEMENT_SIZE_3D 9
#define SCALAR_SIZE_3D 80


// ****************************************************************************
//  Method: avtM3DC1FileFormat constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

avtM3DC1FileFormat::avtM3DC1FileFormat(const char *filename,
                                       DBOptionsAttributes *readOpts)
  : avtMTSDFileFormat(&filename, 1),
    m_filename(filename),
    m_refinement(2), m_dataLocation(AVT_NODECENT),
    m_perturbationScale(1.5)
{
    if (readOpts != NULL) {
      for (int i=0; i<readOpts->GetNumberOfOptions(); ++i) {
        if (readOpts->GetName(i) == "Mesh refinement")
          m_refinement = readOpts->GetEnum("Mesh refinement");
        else if (readOpts->GetName(i) == "Linear mesh data location") 
        {
          int dataLocation = readOpts->GetEnum("Linear mesh data location");
          
          if( dataLocation == 0 )
            m_dataLocation = AVT_NODECENT;
          else if( dataLocation == 1 )
            m_dataLocation = AVT_ZONECENT;
        }
        else if (readOpts->GetName(i) == "Perturbation scaling")
          m_perturbationScale = readOpts->GetDouble("Perturbation scaling");
      }
    }

    if( m_refinement < 0 )      m_refinement = 0;
    else if( m_refinement > 5 ) m_refinement = 5;

    LoadFile();
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

int
avtM3DC1FileFormat::GetNTimesteps(void)
{
    return m_times.size();
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

void
avtM3DC1FileFormat::FreeUpResources(void)
{
    H5Fclose( m_fileID );
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

void
avtM3DC1FileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md,
                                             int timeState)
{
    avtMeshMetaData *mmd;
    avtMeshType mt = AVT_UNSTRUCTURED_MESH;
    int nblocks = 1;
    int block_origin = 0;
    int cell_origin = 0;
    int group_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension = 3;
    double *extents = NULL;

    char level[4];

    if( m_refinement != 0 )
    {
      sprintf( level, "_%d", m_refinement );
    }
    else
      sprintf( level, "" );


    // Original meshes for the user to see.
    AddMeshToMetaData( md, "equilibrium/mesh",
                       mt, extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension );
    
    AddMeshToMetaData( md,"mesh", mt,
                       extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension );
    
    
    // Populate the scalar field vars that will be interpolate onto a
    // refined mesh.
    for ( int i = 0; i < m_fieldVarNames.size(); ++i )
    {
      string varname = "equilibrium/" + m_fieldVarNames[i];
      string meshname = string("equilibrium/mesh") + string(level);
      AddScalarVarToMetaData( md, varname, meshname, m_dataLocation );

      meshname = string("mesh") + string(level);
      AddScalarVarToMetaData( md, m_fieldVarNames[i], meshname, m_dataLocation );
    }

    // For now the mesh is the same mesh as the original mesh because
    // of needing it for the integration.
    AddVectorVarToMetaData( md, "B_C1_Elements",
                            string("mesh"),
                            AVT_ZONECENT, 3);
    
    // Interpolated on to a mesh for visualization only.
    AddVectorVarToMetaData( md, "B_Interpolated",
                            string("mesh") + string(level),
                            m_dataLocation, 3 );
    
    // Hidden refined meshes for working with the interpolated data
    if( m_refinement )
    {
      int nLevels = m_refinement + 1;

      nblocks = nelms * nLevels * nLevels;

      mmd =
        new avtMeshMetaData(string("equilibrium/mesh") + string(level),
                            nblocks, block_origin,
                            cell_origin, group_origin,
                            spatial_dimension, topological_dimension, mt);
      mmd->hideFromGUI = true;
      md->Add(mmd);


      mmd =
        new avtMeshMetaData(string("mesh") + string(level),
                            nblocks, block_origin,
                            cell_origin, group_origin,
                            spatial_dimension, topological_dimension, mt);
      mmd->hideFromGUI = true;
      md->Add(mmd);
    }

    nblocks = nelms;    

    // Hidden meshes for working with the elements directly
    mmd =
      new avtMeshMetaData("hidden/equilibrium/mesh",
                          nblocks, block_origin, cell_origin, group_origin,
                          spatial_dimension, topological_dimension, mt);
    mmd->hideFromGUI = true;
    md->Add(mmd);

    mmd =
      new avtMeshMetaData("hidden/mesh",
                          nblocks, block_origin, cell_origin, group_origin,
                          spatial_dimension, topological_dimension, mt);
    mmd->hideFromGUI = true;
    md->Add(mmd);


    // Hidden scalar header vars.
    for ( int i = 0; i < m_scalarVarNames.size(); ++i )
    {
      avtScalarMetaData *smd =
        new avtScalarMetaData("hidden/" + m_scalarVarNames[i],
                              "hidden/equilibrium/mesh", AVT_ZONECENT);

      smd->hideFromGUI = true;
      md->Add(smd);
    }

    // Add the elements so we have access to them for the interpolation
    avtVectorMetaData *amd =
      new avtVectorMetaData("hidden/equilibrium/elements",
                           "hidden/equilibrium/mesh",
                           AVT_ZONECENT, element_size);

    amd->hideFromGUI = true;
    md->Add(amd);

    amd = new avtVectorMetaData("hidden/elements", "hidden/mesh",
                               AVT_ZONECENT, element_size);

    amd->hideFromGUI = true;
    md->Add(amd);

    // Hidden array field vars so we have access to them for the interpolation
    for ( int i = 0; i < m_fieldVarNames.size(); ++i )
    {
      string varname = "hidden/equilibrium/" + m_fieldVarNames[i];
      amd = new avtVectorMetaData(varname, "hidden/equilibrium/mesh",
                                 AVT_ZONECENT, scalar_size);

      amd->hideFromGUI = true;
      md->Add(amd);

      varname = "hidden/" + m_fieldVarNames[i];
      amd = new avtVectorMetaData(varname, "hidden/mesh",
                                 AVT_ZONECENT, scalar_size);

      amd->hideFromGUI = true;
      md->Add(amd);
    }

    md->SetCyclesAreAccurate(true);
    md->SetCycles( m_cycles );

    md->SetTimesAreAccurate(true);
    md->SetTimes( m_times );
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetElements
//
//  Purpose:
//      Gets the elements assoicated for the C1 mesh.
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

float *
avtM3DC1FileFormat::GetElements(int timestate, const char *meshname)
{
  char meshStr[64];

  // Parse the mesh naem into the hdf5 group name.
  if( strncmp(meshname, "equilibrium/mesh", 16 ) == 0 )
  {
    sprintf( meshStr, "/equilibrium/mesh" );
  } else if( strncmp(meshname, "mesh", 4 ) == 0 ) {
    sprintf( meshStr, "/time_%03d/mesh", timestate );
  } else
    EXCEPTION2( NonCompliantException, "M3DC1 Element Name Lookup",
                "Element '" + string(meshStr) + "' was not found." );

  // Open the group.
  hid_t meshId = H5Gopen( m_fileID, meshStr, H5P_DEFAULT);
  if ( meshId < 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Group Open",
                "Group '" + string(meshStr) + "' was not found." );
  
  // Read in the mesh information.
  int nElements;
  if ( ! ReadAttribute( meshId, "nelms", &nElements ) )
    EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                "Attribute 'nelms' was not found or was the wrong type." );
  
  if( nElements != nelms )
    EXCEPTION2( NonCompliantException, "M3DC1 Element Check",
                "Time step 'nelms' does not match equilibrium 'nelms'" );
 
  // Open the dataset and space info for the elements.  
  hid_t datasetId = H5Dopen(meshId, "elements", H5P_DEFAULT);
  hid_t spaceId = H5Dget_space(datasetId);
  size_t rank = H5Sget_simple_extent_ndims(spaceId);
  std::vector<hsize_t> sdim(rank);
  H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);

  // Sanity check.  
  if( rank != 2 || sdim[0] != nelms || sdim[1] != element_size )
  {
      EXCEPTION2( NonCompliantException, "M3DC1 Element Check",
                  "The number of elements or the element size does not match" );          
  }

  // Memory for the elements.  
  float *elements = new float[sdim[0]*sdim[1]];
  if( elements == 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Memory Allocation",
                "CAN NOT ALLOCATE MEMORY" );

  // Read in the elements.
  H5Dread( datasetId,
           H5T_NATIVE_FLOAT, H5S_ALL, spaceId, H5P_DEFAULT, elements );

  H5Dclose(spaceId);
  H5Dclose(datasetId);
  H5Gclose( meshId );

  return elements;
}

// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetMeshPoints
//
//  Purpose: Gets the mesh points associated with this file.  The mesh
//      is returned as vtkPoints.
//
//  Arguments:
//      elements        The original C1 elements 
//      refinement      The amount of mesh refinement.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkPoints *
avtM3DC1FileFormat::GetMeshPoints(float *elements,
                                  int refinement)
{
  // Inital number of triangles before refinement.
  int npts = nelms * nvertices;
  int ncoords = nvertices * 3;

  // VTK structure for holding the mesh points. 
  vtkPoints *vtkPts = vtkPoints::New();
  vtkPts->SetNumberOfPoints( npts );
  float *pts = (float *) vtkPts->GetVoidPointer(0);

  float phi = 0;

  // Pointer for fast indexing through the elements.
  float *element = elements;

//   for( int i=0; i<nelms/2; ++i )
//     element += element_size;

  for( int i=0; i<nelms; ++i )
  {
    // The element values from Jardin, JCP 200:133 (2004)
    float a     = element[0];
    float b     = element[1];
    float c     = element[2];
    float theta = element[3];
    float x     = element[4];
    float z     = element[5];

    // The seventh value (call it "e") specifies which edges of the
    // element lie on the domain boundary.  The first edge is the
    // edge between the first and second nodes, the second edge
    // joins nodes 2 and 3, and the third edge joins nodes 3 and 1.
    // If edge n lies on the domain boundary, than the nth bit of e
    // is set.  For example, e=0 means no edges are on the domain
    // boundary, e=5 means the first and third edges are on the
    // domain boundary.
    unsigned int e = element[6];

    if( element_dimension == 3 )
      phi = element[8];

    // The three points in the phi plane that define the triangle mesh element.
    pts[0] = x;
    pts[1] = phi;
    pts[2] = z;

    pts[3] = x + (a+b)*cos(theta);
    pts[4] = phi;
    pts[5] = z + (a+b)*sin(theta);
    
    pts[6] = x + b*cos(theta) - c*sin(theta);
    pts[7] = phi;
    pts[8] = z + b*sin(theta) + c*cos(theta);

    // The three points in the phi+d plane that define the second part of
    // the wedge element.
    if( element_dimension == 3 )
    {
      float d = element[7];

      pts[ 9] = x;
      pts[10] = phi + d;
      pts[11] = z;

      pts[12] = x + (a+b)*cos(theta);
      pts[13] = phi + d;
      pts[14] = z + (a+b)*sin(theta);
    
      pts[15] = x + b*cos(theta) - c*sin(theta);
      pts[16] = phi + d;
      pts[17] = z + b*sin(theta) + c*cos(theta);
    }

    // Increment for fast indexing.
    element += element_size;
    pts += ncoords;
  } 

  // Now do any needed refinement. Currently the flag is 0-4. The user
  // sees 1-5. With 1 being no refinement aka linear.
  if( refinement )
  {
    int nLevels = refinement + 1;

    // Pointer to the current mesh.
    float *pts = (float *) vtkPts->GetVoidPointer(0);

    // VTK structure for holding the refined mesh points. 
    vtkPoints *rf_vtkPts = vtkPoints::New();

    rf_vtkPts->SetNumberOfPoints( npts *
                                  (int) pow( (float) nLevels,
                                             (float) element_dimension) );

    float *rf_pts = (float *) rf_vtkPts->GetVoidPointer(0);

    if( element_dimension == 2 )
    {
      for( int i=0; i<npts; i+=nvertices )
      {
        // Refine the triangle based on barrycentric coordinates.
        float *A = &(pts[0]);
        float *B = &(pts[3]);
        float *C = &(pts[6]);

        for( int j=0; j<nLevels; ++j )
        {
          float a  = (float)  j      / (float) nLevels;
          float a1 = (float) (j + 1) / (float) nLevels;

          for( int k=0; k<nLevels-j; ++k )
          {
            float b   = (float) (nLevels-j-k)   / (float) nLevels;
            float b_1 = (float) (nLevels-j-k-1) / (float) nLevels;

            float c  = (float)  k    / (float) nLevels;
            float c1 = (float) (k+1) / (float) nLevels;

            rf_pts[0] = a * A[0] + b * B[0] + c * C[0];
            rf_pts[1] = a * A[1] + b * B[1] + c * C[1];
            rf_pts[2] = a * A[2] + b * B[2] + c * C[2];

            rf_pts[3] = a * A[0] + b_1 * B[0] + c1 * C[0];
            rf_pts[4] = a * A[1] + b_1 * B[1] + c1 * C[1];
            rf_pts[5] = a * A[2] + b_1 * B[2] + c1 * C[2];

            rf_pts[6] = a1 * A[0] + b_1 * B[0] + c * C[0];
            rf_pts[7] = a1 * A[1] + b_1 * B[1] + c * C[1];
            rf_pts[8] = a1 * A[2] + b_1 * B[2] + c * C[2];

            rf_pts += ncoords;

            if( k )
            {
              float c_1 = (float) (k-1) / (float) nLevels;

              rf_pts[0] = a * A[0] + b * B[0] + c * C[0];
              rf_pts[1] = a * A[1] + b * B[1] + c * C[1];
              rf_pts[2] = a * A[2] + b * B[2] + c * C[2];
            
              rf_pts[3] = a1 * A[0] + b_1 * B[0] + c * C[0];
              rf_pts[4] = a1 * A[1] + b_1 * B[1] + c * C[1];
              rf_pts[5] = a1 * A[2] + b_1 * B[2] + c * C[2];
            
              rf_pts[6] = a1 * A[0] + b * B[0] + c_1 * C[0];
              rf_pts[7] = a1 * A[1] + b * B[1] + c_1 * C[1];
              rf_pts[8] = a1 * A[2] + b * B[2] + c_1 * C[2];
            
              rf_pts += ncoords;
            }
          }
        }

        pts += ncoords;
      }
    }

    else //if( element_dimension == 3 )
    {
      for( int i=0; i<npts; i+=nvertices )
      {
        // Refine the triangle based on barrycentric coordinates.
        float *A = &(pts[0]);
        float *B = &(pts[3]);
        float *C = &(pts[6]);

        float *D = &(pts[9]);
        float *E = &(pts[12]);
        float *F = &(pts[15]);

        for( int j=0; j<nLevels; ++j )
        {
          float a  = (float)  j      / (float) nLevels;
          float a1 = (float) (j + 1) / (float) nLevels;
          
          for( int k=0; k<nLevels-j; ++k )
          {
            float b   = (float) (nLevels-j-k)   / (float) nLevels;
            float b_1 = (float) (nLevels-j-k-1) / (float) nLevels;
            
            float c  = (float)  k    / (float) nLevels;
            float c1 = (float) (k+1) / (float) nLevels;

            double left_pts[9], right_pts[9];

            left_pts[0] = a * A[0] + b * B[0] + c * C[0];
            left_pts[1] = a * A[1] + b * B[1] + c * C[1];
            left_pts[2] = a * A[2] + b * B[2] + c * C[2];

            left_pts[3] = a * A[0] + b_1 * B[0] + c1 * C[0];
            left_pts[4] = a * A[1] + b_1 * B[1] + c1 * C[1];
            left_pts[5] = a * A[2] + b_1 * B[2] + c1 * C[2];

            left_pts[6] = a1 * A[0] + b_1 * B[0] + c * C[0];
            left_pts[7] = a1 * A[1] + b_1 * B[1] + c * C[1];
            left_pts[8] = a1 * A[2] + b_1 * B[2] + c * C[2];


            right_pts[0] = a * D[0] + b * E[0] + c * F[0];
            right_pts[1] = a * D[1] + b * E[1] + c * F[1];
            right_pts[2] = a * D[2] + b * E[2] + c * F[2];

            right_pts[3] = a * D[0] + b_1 * E[0] + c1 * F[0];
            right_pts[4] = a * D[1] + b_1 * E[1] + c1 * F[1];
            right_pts[5] = a * D[2] + b_1 * E[2] + c1 * F[2];

            right_pts[6] = a1 * D[0] + b_1 * E[0] + c * F[0];
            right_pts[7] = a1 * D[1] + b_1 * E[1] + c * F[1];
            right_pts[8] = a1 * D[2] + b_1 * E[2] + c * F[2];

            for( int l=0; l<nLevels; ++l )
            {
              for( int ii=0; ii<9; ++ii )
                rf_pts[ii] = left_pts[ii] + (double) l *
                  (right_pts[ii] - left_pts[ii]) / (double) nLevels;

              rf_pts += ncoords/2;

              for( int ii=0; ii<9; ++ii )
                rf_pts[ii] = left_pts[ii] + (double) (l+1) *
                  (right_pts[ii] - left_pts[ii]) / (double) nLevels;

              rf_pts += ncoords/2;
            }

            if( k )
            {
              float c_1 = (float) (k-1) / (float) nLevels;

              left_pts[0] = a * A[0] + b * B[0] + c * C[0];
              left_pts[1] = a * A[1] + b * B[1] + c * C[1];
              left_pts[2] = a * A[2] + b * B[2] + c * C[2];
              
              left_pts[3] = a1 * A[0] + b_1 * B[0] + c * C[0];
              left_pts[4] = a1 * A[1] + b_1 * B[1] + c * C[1];
              left_pts[5] = a1 * A[2] + b_1 * B[2] + c * C[2];
              
              left_pts[6] = a1 * A[0] + b * B[0] + c_1 * C[0];
              left_pts[7] = a1 * A[1] + b * B[1] + c_1 * C[1];
              left_pts[8] = a1 * A[2] + b * B[2] + c_1 * C[2];
              
              right_pts[0] = a * D[0] + b * E[0] + c * F[0];
              right_pts[1] = a * D[1] + b * E[1] + c * F[1];
              right_pts[2] = a * D[2] + b * E[2] + c * F[2];
              
              right_pts[3] = a1 * D[0] + b_1 * E[0] + c * F[0];
              right_pts[4] = a1 * D[1] + b_1 * E[1] + c * F[1];
              right_pts[5] = a1 * D[2] + b_1 * E[2] + c * F[2];
              
              right_pts[6] = a1 * D[0] + b * E[0] + c_1 * F[0];
              right_pts[7] = a1 * D[1] + b * E[1] + c_1 * F[1];
              right_pts[8] = a1 * D[2] + b * E[2] + c_1 * F[2];

              for( int l=0; l<nLevels; ++l )
              {
                for( int ii=0; ii<9; ++ii )
                  rf_pts[ii] = left_pts[ii] + (double) l *
                    (right_pts[ii] - left_pts[ii]) / (double) nLevels;
                
                rf_pts += ncoords/2;
                
                for( int ii=0; ii<9; ++ii )
                  rf_pts[ii] = left_pts[ii] + (double) (l+1) *
                    (right_pts[ii] - left_pts[ii]) / (double) nLevels;
                
                rf_pts += ncoords/2;
              }
            }
          }
        }

        pts += ncoords;
      }
    }

    // Delete the old points.
    vtkPts->Delete();

    // Update the pointers to the new mesh
    vtkPts = rf_vtkPts;
  }

  return vtkPts;  
}



// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkDataSet *
avtM3DC1FileFormat::GetMesh(int timestate, const char *meshname)
{
  const char *meshnamePtr = meshname;  
  char meshStr[64];

  // If hidden only one poloidal plane as the mesh will be used for
  // interpolation. There should also be no refinement.
  if( strncmp(meshname, "hidden/", 7 ) == 0 )
  {
    meshnamePtr = &(meshname[7]);
  }
  else
  {
    meshnamePtr = meshname;
  }
  
  // Parse the mesh variable name to get the true mesh name.
  if( strncmp(meshnamePtr, "equilibrium/mesh", 16 ) == 0 )
  {
    meshnamePtr = &(meshnamePtr[16]);
    sprintf( meshStr, "equilibrium/mesh" );    
  }
  else if( strncmp(meshnamePtr, "mesh", 4 ) == 0 ) {
    meshnamePtr = &(meshnamePtr[4]);
    sprintf( meshStr, "mesh" );    
  }
  else
    EXCEPTION2( NonCompliantException, "M3DC1 Mesh Name",
                "Can not find '" + string(meshnamePtr) );

  // Parse the mesh variable name to get the refinement level.
  int refinement;

  if( strlen(meshnamePtr) && atoi(&(meshnamePtr[1])) == m_refinement )
      refinement = m_refinement;
  else
    refinement = 0;

  // Get the C1 elements.
  float* elements = GetElements(timestate, meshStr);

  // Create a VTK grid for the mesh.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();

  // Now get the points on the mesh based on the refinement level.
  vtkPoints *vtkPts = GetMeshPoints( elements, refinement);

  // Add the points to the VTK grid.
  int npts = vtkPts->GetNumberOfPoints();
  grid->SetPoints( vtkPts );

  delete [] elements;

  // Add in the VTK cells. The connectivity is the same for all
  // triangles because each triangle is defined by three points that
  // are not unique. 

  grid->Allocate(npts/nvertices);
    
  if( element_dimension == 2 )
  {
    vtkTriangle *tri = vtkTriangle::New();
    for( int i=0; i<npts; i+=nvertices )
    {
      tri->GetPointIds()->SetId( 0, i   );
      tri->GetPointIds()->SetId( 1, i+1 );
      tri->GetPointIds()->SetId( 2, i+2 );
      
      grid->InsertNextCell( tri->GetCellType(), tri->GetPointIds() );
    }
    
    tri->Delete();
  }
  else //if( element_dimension == 3 )
  {
    vtkWedge *wedge = vtkWedge::New();
    for( int i=0; i<npts; i+=nvertices )
    {
      wedge->GetPointIds()->SetId( 0, i   );
      wedge->GetPointIds()->SetId( 1, i+1 );
      wedge->GetPointIds()->SetId( 2, i+2 );
      wedge->GetPointIds()->SetId( 3, i+3 );
      wedge->GetPointIds()->SetId( 4, i+4 );
      wedge->GetPointIds()->SetId( 5, i+5 );
      
      grid->InsertNextCell( wedge->GetCellType(), wedge->GetPointIds() );
    }
    
    wedge->Delete();
  }

  return grid;
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetHeaderVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkDataArray *
avtM3DC1FileFormat::GetHeaderVar(int timestate, const char *varname)
{
  // Get the header variable

  // Header variables are at the top level group.
  hid_t rootID = H5Gopen( m_fileID, "/", H5P_DEFAULT);
  if ( rootID < 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Group Open",
                "The root group '/' was not found" );

  // Everything is converted to floats by visit so might as well do it
  // here and save the copying time and memory.
  string variable(&(varname[7]));
  float value;

  // Read in 3D flag and nplanes an an int
  if( variable == "nplanes" )
  {
    int intVal;
    // 2D or 3D elements?
    if ( ReadAttribute( rootID, "3d", &intVal ) && intVal == 1 )
    {
      // Read in nplanes
      if ( ! ReadAttribute( rootID, "nplanes", &intVal ) )
      {
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nplanes' was not found or was the wrong type." );
      }
      else
        value = intVal;
    }  
    else
    {
      value = 1;
    }  
  }

  // Read in linear flag and ntor an an int
  else if( variable == "linear" || variable == "ntor"   )
  {
      int intVal;
      if ( ! ReadAttribute( rootID, variable.c_str(), &intVal ) )
      {
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute '" + variable + "' was not found or was the wrong type." );
      }
      else
        value = intVal;
  }
    
  // Read in bzero and rzero as a double
  else if( variable == "bzero" || variable == "rzero" )
  {
      double dblVal;
      if ( ! ReadAttribute( rootID, variable.c_str(), &dblVal ) )
      {
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute '" + variable + "' was not found or was the wrong type." );
      }
      else
        value = dblVal;
  }

  vtkFloatArray *var = vtkFloatArray::New();

  // Set the number of components before setting the number of tuples
  // for proper memory allocation.
  var->SetNumberOfComponents( 1 );
  var->SetNumberOfTuples( nelms );
    
  float* varPtr = (float *) var->GetVoidPointer(0);
    
  for( int i=0; i<nelms; ++i)
    *varPtr++ = value;
    
  H5Gclose( rootID );
    
  return var;
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetFieldVar
//
//  Purpose:
//      Gets a field variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkDataArray *
avtM3DC1FileFormat::GetFieldVar(int timestate, const char *varname)
{
  char groupStr[64];
  char varStr[64];

  int nComponents;

  // Parse the field variable name to get the HDF5 group and dataset
  // name.
  if( strncmp(varname, "equilibrium", 11 ) == 0 )
  {
    if( strcmp(&(varname[11]), "elements" ) == 0 ) {
      nComponents = element_size;;
      sprintf( groupStr, "/equilibrium/mesh" );
    } else {
      nComponents = scalar_size;;
      sprintf( groupStr, "/equilibrium/fields" );
    }

    strcpy( varStr, &(varname[12]) );

  } else {
    if( strcmp(varname, "elements" ) == 0 ) {
      nComponents = element_size;;
      sprintf( groupStr, "/time_%03d/mesh", timestate );
    } else {
      nComponents = scalar_size;;
      sprintf( groupStr, "/time_%03d/fields", timestate );
    }

    strcpy( varStr, varname );
  }

  // Open the group.
  hid_t groupID = H5Gopen( m_fileID, groupStr, H5P_DEFAULT);
  if ( groupID < 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Group Open",
                "Group '" + string(groupStr) + "' was not found" );

  // Open the field dataset
  hid_t datasetId = H5Dopen(groupID, varStr, H5P_DEFAULT);
  if ( datasetId < 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Dataset Open",
                "Dataset '" + string(varStr) + "' was not found" );
  
  // Read in the dataset information.
  hid_t spaceId = H5Dget_space(datasetId);
  size_t rank = H5Sget_simple_extent_ndims(spaceId);
  std::vector<hsize_t> sdim(rank);
  H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);
  
  if( rank != 2 || sdim[0] != nelms || sdim[1] != nComponents )
    EXCEPTION2( NonCompliantException, "M3DC1 Element Check",
                "Dataset '" +
                string(groupStr) + string("/") + string(varStr) +
                "' the number of elements or the component size does not match" );

  // Normally an array would be created but instead use the VTK memory
  // directly - this usage works because the vtk and hdf5 memory
  // layout are the same.

//   float *vals = new float[sdim[0]*sdim[1]];
//   if( H5Dread( datasetId,
//             H5T_NATIVE_FLOAT, H5S_ALL, spaceId, H5P_DEFAULT, vals ) < 0 )
//     EXCEPTION2( UnexpectedValueException,
//                 groupStr + string("/") + varStr, "Can not read the data" );

  // Create the VTK structure to hole the field variable.
  vtkFloatArray *var = vtkFloatArray::New();

  // Set the number of components before setting the number of tuples
  // for proper memory allocation.
  var->SetNumberOfComponents( sdim[1] );
  var->SetNumberOfTuples( sdim[0] );

  // Pointer to the vtk memory.
  float* values = (float*) var->GetVoidPointer(0);
  
  // Read the data directly into the vtk memory - this call assume
  // that the hdfd5 and vtk memory layout are the same.
  if( H5Dread( datasetId,
               H5T_NATIVE_FLOAT, H5S_ALL, spaceId, H5P_DEFAULT, values ) < 0 )
    EXCEPTION2( NonCompliantException, "M3DC1 Dataset Read",
                "Dataset '" + string(groupStr) + string("/") + string(varStr) +
                "' can not be read" );
  
  H5Dclose(spaceId);
  H5Dclose(datasetId);
  H5Gclose( groupID );

//  delete [] vals;
  
  return var;
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkDataArray *
avtM3DC1FileFormat::GetVar(int timestate, const char *varname)
{
  // Hidden scalar variables are read from the header and put on the
  // C1 mesh.
  if( strncmp(varname, "hidden/", 7) == 0 )
  {
    char varStr[64];
    strcpy( varStr, &(varname[7]) );

    if( strncmp(varStr, "header", 6) == 0 )
      return GetHeaderVar( timestate, varStr);
    else
      return 0;
  }
    
  // First get the elements for this variable so that the variable can
  // be interpolated onto the linear mesh.
  float* elements;
  if( strncmp(varname, "equilibrium", 11 ) == 0 )
    elements = GetElements(timestate, "equilibrium/mesh");
  else
    elements = GetElements(timestate, "mesh");

  // Create a temporary mesh for getting the correct field variable
  // values on the linear mesh.
  vtkPoints *vtkPts = GetMeshPoints( elements, m_refinement );
  float* pts = (float *) vtkPts->GetVoidPointer(0);
  int npts = vtkPts->GetNumberOfPoints();

  // Get the M3D C1 field so the variables can be interpolated on the
  // linear mesh.
  avtM3DC1Field m3dField(elements, nelms, element_dimension, nplanes);

  // Get the field variable to be interpolated on the linear mesh.
  vtkDataArray* vtkVar = GetFieldVar( timestate, varname );
  float* values = (float*) vtkVar->GetVoidPointer(0);

  // Get the value at the node of each element on the linear mesh.
  int nvalues;

  if( m_dataLocation == AVT_NODECENT)
    nvalues = npts;
  // Get the value at the center of each element on the linear mesh.
  else if( m_dataLocation == AVT_ZONECENT)
    nvalues = npts / nvertices;
    
  // VTK structure for the field variable on the linear mesh.
  vtkFloatArray *var = vtkFloatArray::New();

  // Set the number of components before setting the number of tuples
  // for proper memory allocation.
  var->SetNumberOfComponents( 1 );
  var->SetNumberOfTuples( nvalues );

  // Pointer to the field variable on the linear mesh.
  float* varPtr = (float *) var->GetVoidPointer(0);

  int element;
  double *xieta = new double[element_dimension];

  double pt[3], centroid[3];

  if( m_dataLocation == AVT_NODECENT)
  {
    for( int i=0; i<npts; ++i )
    {
      // Find the element containing the point; get local coords
      // xi,eta. We only want the index so that we know which element
      // the nodes are part of. Do this once so that it is
      // faster. Also it ensures that the correct element is found
      // because the points lie in the element.
      // 
      if( i % nvertices == 0 )
      {
        if( element_dimension == 2 )
        {
          centroid[0] = (pts[0] + pts[3] + pts[6] ) / nvertices;
          centroid[1] = (pts[1] + pts[4] + pts[7] ) / nvertices;
          centroid[2] = (pts[2] + pts[5] + pts[8] ) / nvertices;
        }
        else //if( element_dimension == 3 )
        {
          centroid[0] = (pts[0] + pts[3] + pts[6] +
                         pts[9] + pts[12] + pts[15] ) / nvertices;
          centroid[1] = (pts[1] + pts[4] + pts[7] +
                         pts[10] + pts[13] + pts[16] ) / nvertices;
          centroid[2] = (pts[2] + pts[5] + pts[8] +
                         pts[11] + pts[14] + pts[17] ) / nvertices;
        }

        if( (element = m3dField.get_tri_coords2D(centroid, xieta)) < 0 )
        {
          char buf[1024];

          sprintf( buf, "avtM3DC1FileFormat::GetVar - Get Triangle Coords 2d can not find element for centroid %10.6f %10.6f %10.6f",
                   centroid[0], centroid[1], centroid[2] );

          avtCallback::IssueWarning( buf );
        }
      }

      pt[0] = pts[0];  pt[1] = pts[1];   pt[2] = pts[2];

      /* Find the element containing the point; get local coords xi,eta */
      if ((element = m3dField.get_tri_coords2D(pt, element, xieta)) >= 0)
      {
        *varPtr++ = m3dField.interp(values, element, xieta);
      }
      else
      {
        char buf[1024];

        sprintf( buf, "avtM3DC1FileFormat::GetVar - Get Triangle Coords 2d can not find element for point %10.6f %10.6f %10.6f", 
                 pt[0], pt[1], pt[2] );

        avtCallback::IssueWarning( buf );

        *varPtr++ = 0;
      }

      pts += 3;
    }
  }
  
  else if( m_dataLocation == AVT_ZONECENT)
  {
    for( int i=0; i<npts; i+=nvertices )
    {
      if( element_dimension == 2 )
      {
        centroid[0] = (pts[0] + pts[3] + pts[6] ) / nvertices;
        centroid[1] = (pts[1] + pts[4] + pts[7] ) / nvertices;
        centroid[2] = (pts[2] + pts[5] + pts[8] ) / nvertices;
      }
      else //if( element_dimension == 3 )
      {
        centroid[0] = (pts[0] + pts[3] + pts[6] +
                       pts[9] + pts[12] + pts[15] ) / nvertices;
        centroid[1] = (pts[1] + pts[4] + pts[7] +
                       pts[10] + pts[13] + pts[16] ) / nvertices;
        centroid[2] = (pts[2] + pts[5] + pts[8] +
                       pts[11] + pts[14] + pts[17] ) / nvertices;
      }

      /* Find the element containing the point; get local coords xi,eta */
      if ((element = m3dField.get_tri_coords2D(centroid, xieta)) >= 0)
      {
        *varPtr++ = m3dField.interp(values, element, xieta);
      }
      else
      {
        char buf[1024];

        sprintf( buf, "avtM3DC1FileFormat::GetVar - Get Triangle Coords 2d can not find element for centroid %10.6f %10.6f %10.6f", 
                 centroid[0], centroid[1], centroid[2] );
        
        avtCallback::IssueWarning( buf );
        
        *varPtr++ = 0;
      }
      
      pts += nvertices * 3;
    }
  }

  vtkPts->Delete();
  vtkVar->Delete();
  delete [] xieta; 
  return var;
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Dec 4 15:04:15 PST 2009
//
// ****************************************************************************

vtkDataArray *
avtM3DC1FileFormat::GetVectorVar(int timestate, const char *varname)
{
  // Hidden variables are read directly set down stream.
  if( strncmp(varname, "hidden/", 7) == 0 )
  {
    char varStr[64];

    strcpy( varStr, &(varname[7]) );
    
    if( m_perturbationScale == 1.0 ||
        (strcmp(varname, "hidden/f" ) &&
         strcmp(varname, "hidden/f_i" ) &&
         strcmp(varname, "hidden/psi" ) &&
         strcmp(varname, "hidden/psi_i" ) ) )
    {
      return GetFieldVar( timestate, varStr );
    }

    // The user can scale the perturbed variables by a scaling factor
    // set when the file is openned.
    else
    {
      debug1 << "avtM3DC1FileFormat::GetVectorVar - Scaling "
             << varname << " by " << m_perturbationScale << endl;

      vtkDataArray* vtkVar = GetFieldVar( timestate, varStr );

      float* values = (float*) vtkVar->GetVoidPointer(0);
      
      unsigned int nvals =
        vtkVar->GetNumberOfTuples() * vtkVar->GetNumberOfComponents();
      
      for( unsigned int i=0; i<nvals; ++i )
        *values++ *= m_perturbationScale;

      return vtkVar;
    } 
  }
  else if( strcmp(varname, "B_C1_Elements") == 0 ||
           strcmp(varname, "B_Interpolated") == 0 )
  {
    avtCentering dataLocation = m_dataLocation;

    // When using by part the location is center based.
    if( strcmp(varname, "B_C1_Elements") == 0 )
      m_dataLocation = AVT_ZONECENT;
    
    // First get the elements for this variable so that the variable can
    // be interpolated onto the linear mesh.
    float* elements = GetElements(timestate, "mesh");

    // Create a temporary mesh for getting the correct field variable
    // values on the linear mesh.

    // For now the mesh is the same mesh as the original mesh because
    // of needing it for the integration.
    vtkPoints *vtkPts;

    if( strcmp(varname, "B_C1_Elements") == 0 )
      vtkPts = GetMeshPoints( elements, 0 );
    else if( strcmp(varname, "B_Interpolated") == 0 )
      vtkPts = GetMeshPoints( elements, m_refinement );

    float* pts = (float *) vtkPts->GetVoidPointer(0);
    int npts = vtkPts->GetNumberOfPoints();

    // Get the M3D C1 field so the variables can be interpolated on the
    // linear mesh.
    avtM3DC1Field m3dField(elements, nelms, element_dimension, nplanes);

    // Header variables are at the top level group.
    hid_t rootID = H5Gopen( m_fileID, "/", H5P_DEFAULT);
    if ( rootID < 0 )
      EXCEPTION2( NonCompliantException, "M3DC1 Group Open",
                  "The root group '/' was not found" );

    vtkDataArray* vtkVarF0;
    vtkDataArray* vtkVarPsi0;
    
    vtkDataArray* vtkVarF;
    vtkDataArray* vtkVarF_i;
    vtkDataArray* vtkVarPsi;
    vtkDataArray* vtkVarPsi_i;

    vtkDataArray* vtkVarI;
    vtkDataArray* vtkVarPhi;

    if( element_dimension == 2 )
    {
      // Get the field variable to be interpolated on the linear mesh.
      if ( ! ReadAttribute( rootID, "linear", &(m3dField.linflag) ) )
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute 'linear' was not found or was the wrong type." );
      
      if ( ! ReadAttribute( rootID, "ntor", &(m3dField.tmode) ) )
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute 'ntor' was not found or was the wrong type." );
      
      if ( ! ReadAttribute( rootID, "bzero", &(m3dField.bzero) ) )
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute 'bzero' was not found or was the wrong type." );
      
      if ( ! ReadAttribute( rootID, "rzero", &(m3dField.rzero) ) )
        EXCEPTION2( NonCompliantException, "M3DC1 Attribute Reader",
                    "Attribute 'rzero' was not found or was the wrong type." );

      m3dField.F0 = -m3dField.bzero * m3dField.rzero;
      
      H5Gclose( rootID );
    
      // Variables on the mesh - N elements x 20
      vtkVarF0 = GetFieldVar( timestate, "equilibrium/f");  
      m3dField.f0 = (float*) vtkVarF0->GetVoidPointer(0);

      vtkVarPsi0 = GetFieldVar( timestate, "equilibrium/psi");
      m3dField.psi0 = (float*) vtkVarPsi0->GetVoidPointer(0);
    
      vtkVarF = GetFieldVar( timestate, "f");
      m3dField.fnr = (float*) vtkVarF->GetVoidPointer(0);

      vtkVarF_i = GetFieldVar( timestate, "f_i");
      m3dField.fni = (float*) vtkVarF_i->GetVoidPointer(0);

      vtkVarPsi = GetFieldVar( timestate, "psi");
      m3dField.psinr = (float*) vtkVarPsi->GetVoidPointer(0);

      vtkVarPsi_i = GetFieldVar( timestate, "psi_i");
      m3dField.psini = (float*) vtkVarPsi_i->GetVoidPointer(0);
    }
    else //if( element_dimension == 3 )
    {
      vtkVarF = GetFieldVar( timestate, "f");
      m3dField.f = (float*) vtkVarF->GetVoidPointer(0);

      vtkVarPsi = GetFieldVar( timestate, "psi");
      m3dField.psi = (float*) vtkVarPsi->GetVoidPointer(0);

      vtkVarPhi = GetFieldVar( timestate, "phi");
      m3dField.phi = (float*) vtkVarPhi->GetVoidPointer(0);

      vtkVarI = GetFieldVar( timestate, "I");
      m3dField.I = (float*) vtkVarI->GetVoidPointer(0);
    }

    // Get the value at the node of each element on the linear mesh.
    int nvalues;

    if( m_dataLocation == AVT_NODECENT)
      nvalues = npts;
    // Get the value at the center of each element on the linear mesh.
    else if( m_dataLocation == AVT_ZONECENT)
      nvalues = npts / nvertices;
    
    // VTK structure for the field variable on the linear mesh.
    vtkFloatArray *var = vtkFloatArray::New();

    // Set the number of components before setting the number of tuples
    // for proper memory allocation.
    var->SetNumberOfComponents( 3 );
    var->SetNumberOfTuples( nvalues );

    // Pointer to the field variable on the linear mesh.
    float* varPtr = (float *) var->GetVoidPointer(0);

    int element;
    float B[3];
    double pt[3], centroid[3], *xieta = new double[element_dimension];

    if( m_dataLocation == AVT_NODECENT)
    {
      for( int i=0; i<npts; ++i )
      {
        // Find the element containing the point; get local coords
        // xi,eta. We only want the index so that we know which element
        // the nodes are part of. Do this once so that it is
        // faster. Also it ensures that the correct element is found
        // because the points lie on the element.
        // 
        if( i % nvertices == 0 )
        {
          if( element_dimension == 2 )
          {
            centroid[0] = (pts[0] + pts[3] + pts[6] ) / nvertices;
            centroid[1] = (pts[1] + pts[4] + pts[7] ) / nvertices;
            centroid[2] = (pts[2] + pts[5] + pts[8] ) / nvertices;
          }
          else //if( element_dimension == 3 )
          {
            centroid[0] = (pts[0] + pts[3] + pts[6] +
                           pts[9] + pts[12] + pts[15] ) / nvertices;
            centroid[1] = (pts[1] + pts[4] + pts[7] +
                           pts[10] + pts[13] + pts[16] ) / nvertices;
            centroid[2] = (pts[2] + pts[5] + pts[8] +
                           pts[11] + pts[14] + pts[17] ) / nvertices;
          }

          element = m3dField.get_tri_coords2D(centroid, xieta);
        }
        
        pt[0] = pts[0];  pt[1] = pts[1];   pt[2] = pts[2];

        /* Find the element containing the point; get local coords xi,eta */
        if ((element = m3dField.get_tri_coords2D(pt, element, xieta)) >= 0) 
        {
          m3dField.interpBcomps(B, pt, element, xieta);

          *varPtr++ = B[0]; *varPtr++ = B[1]; *varPtr++ = B[2];
        }
        else 
        {
          char buf[1024];

          sprintf( buf, "avtM3DC1FileFormat::GetVar - Get Triangle Coords 2d can not find element for point %10.6f %10.6f %10.6f", 
                   pt[0], pt[1], pt[2] );

          avtCallback::IssueWarning( buf );

          *varPtr++ = 0; *varPtr++ = 0; *varPtr++ = 0;
        }
        
        pts += 3;
      }
    }
  
    else if( m_dataLocation == AVT_ZONECENT)
    {
      for( int i=0; i<npts; i+=nvertices )
      {
        if( element_dimension == 2 )
        {
          centroid[0] = (pts[0] + pts[3] + pts[6] ) / nvertices;
          centroid[1] = (pts[1] + pts[4] + pts[7] ) / nvertices;
          centroid[2] = (pts[2] + pts[5] + pts[8] ) / nvertices;
        }
        else //if( element_dimension == 3 )
        {
          centroid[0] = (pts[0] + pts[3] + pts[6] +
                         pts[9] + pts[12] + pts[15] ) / nvertices;
          centroid[1] = (pts[1] + pts[4] + pts[7] +
                         pts[10] + pts[13] + pts[16] ) / nvertices;
          centroid[2] = (pts[2] + pts[5] + pts[8] +
                         pts[11] + pts[14] + pts[17] ) / nvertices;
        }

        /* Find the element containing the point; get local coords xi,eta */
        if ((element = m3dField.get_tri_coords2D(centroid, xieta)) >= 0) 
        {
          m3dField.interpBcomps(B, centroid, element, xieta);

          *varPtr++ = B[0];  *varPtr++ = B[1];  *varPtr++ = B[2];
        }
        else 
        {
          char buf[1024];

          sprintf( buf, "avtM3DC1FileFormat::GetVar - Get Triangle Coords 2d can not find element for centroid %10.6f %10.6f %10.6f",
                   centroid[0], centroid[1], centroid[2] );

          avtCallback::IssueWarning( buf );

          *varPtr++ = 0; *varPtr++ = 0; *varPtr++ = 0;
        }

        pts += nvertices * 3;
      }
    }

    delete [] xieta;

    // Set the pointers to null as the VTK delete operation will take
    // of deleting the data. Normally the M3DCIField thinks it needs
    // to delete the data.
    if( element_dimension == 2 )
    {
      m3dField.f0 = 0;
      m3dField.psi0 = 0;    
      m3dField.fnr = 0;
      m3dField.fni = 0;
      m3dField.psinr = 0;
      m3dField.psini = 0;

      vtkVarF0->Delete();
      vtkVarPsi0->Delete();
   
      vtkVarF->Delete();
      vtkVarF_i->Delete();
      vtkVarPsi->Delete();
      vtkVarPsi_i->Delete();
    }
    else //if( element_dimension == 3 )
    {
      vtkVarF->Delete();
      vtkVarPsi->Delete();
      vtkVarPhi->Delete();
      vtkVarI->Delete();

      m3dField.f   = 0;
      m3dField.psi = 0;    
      m3dField.phi = 0;    
      m3dField.I   = 0;
    }

    vtkPts->Delete();

    // Make the original data location is used.
    m_dataLocation = dataLocation;
  
    return var;
  }

  else
    return 0;
}



// ****************************************************************************
//  Method: avtM3DFileFormat::NormalizeH5Type
//
//  Purpose:
//     Convert HDF5 types to visit types if necessary.
//
//  Arguments:
//      type       Input type from file.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Tue Sep 25 08:49:28 PDT 2007
//
// ****************************************************************************
hid_t
avtM3DC1FileFormat::NormalizeH5Type( hid_t type )
{
    H5T_class_t tclass = H5Tget_class( type );
    int size = H5Tget_size( type );

    switch ( tclass )
    {
    case H5T_INTEGER:
        if ( size == 8 )
            return H5T_NATIVE_INT64;
        else if ( size == 4 )
            return H5T_NATIVE_INT32;
        else if ( size == 1 )
            return H5T_NATIVE_CHAR;
        break;
    case H5T_FLOAT:
        if ( size == 8 )
            return H5T_NATIVE_DOUBLE;
        else if ( size == 4 )
            return H5T_NATIVE_FLOAT;
    default:
        break;
    }
    return -1;
}

// ****************************************************************************
//  Method: avtM3DFileFormat::ReadStringAttribute
//
//  Purpose:
//      Read a string attribute from an HDF5 file.
//
//  Arguments:
//      parentID   The id of the parent.
//      attr       Name of the attribute to be read.
//      value      The attribute value that was read.
//
//  Programmer: allen
//  Creation:   Tue Sep 25 08:49:28 PDT 2007
//
// ****************************************************************************
bool
avtM3DC1FileFormat::ReadStringAttribute( hid_t parentID,
                                         const char *attr,
                                         string *value )
{
    hid_t attrID = H5Aopen_name( parentID, attr );
    if ( attrID <= 0 )
        return false;

    hid_t typeID = H5Aget_type( attrID );
    if ( typeID < 0 )
        return false;
    hsize_t nelem = H5Tget_size( typeID );
    if ( nelem <= 0 )
        return false;
    char *str = new char[nelem];
    H5Aread( attrID, typeID, str );
    *value = str;
    delete [] str;

    H5Tclose( typeID );
    H5Aclose( attrID );
    return true;
}

// ****************************************************************************
//  Method: avtM3DFileFormat::ReadAttribute
//
//  Purpose:
//      Read an attribute from an HDF5 file.
//
//  Arguments:
//      parentID   The id of the parent.
//      attr       Name of the attribute to be read.
//      value      The attribute value that was read.
//
//  Programmer: allen
//  Creation:   Tue Sep 25 08:49:28 PDT 2007
//
// ****************************************************************************
bool
avtM3DC1FileFormat::ReadAttribute( hid_t parentID,
                                   const char *attr,
                                   void *value )
{
    hid_t attrID = H5Aopen_name( parentID, attr );
    if ( attrID <= 0 )
        return false;

    hid_t attrType = H5Aget_type( attrID );
    if ( attrType < 0 )
        return false;

    hid_t spaceID = H5Aget_space( attrID );
    if ( spaceID < 0 )
        return false;

    hsize_t nelem = H5Sget_simple_extent_npoints( spaceID );
    if ( nelem < 0 )
        return false;

    hid_t typeID = NormalizeH5Type( attrType );
    if ( typeID < 0 )
        return false;

    if ( H5Aread ( attrID, typeID, value ) < 0 )
        return false;

    H5Sclose( spaceID );
    H5Tclose( attrType );
    H5Aclose( attrID );

    return true;
}

// ****************************************************************************
//  Method: avtM3DFileFormat::groupIterator
//
//  Purpose:
//      Iterate through all of the grops in an HDF5 file.
//
//  Arguments:
//      parentID   The id of the parent.
//      attr       Name of the group.
//      value      Optional data - in this case the avtM3DC1FileFormat.
//
//  Programmer: allen
//  Creation:   Tue Sep 25 08:49:28 PDT 2007
//
// ****************************************************************************
herr_t groupIterator(hid_t locId, const char* name, void* opdata) {

  avtM3DC1FileFormat* M3DC1FF = static_cast< avtM3DC1FileFormat* >(opdata);

  H5G_stat_t statbuf;
  H5Gget_objinfo (locId, name, false, &statbuf);

  switch (statbuf.type) {

    case H5G_DATASET: {
      hid_t datasetId = H5Dopen(locId, name, H5P_DEFAULT);
      hid_t spaceId = H5Dget_space(datasetId);
      size_t rank = H5Sget_simple_extent_ndims(spaceId);
      std::vector<hsize_t> sdim(rank);
      H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);

      H5Dclose(spaceId);
      H5Dclose(datasetId);

      if( rank != 2 ||
          sdim[0] != M3DC1FF->nelms ||
          sdim[1] != M3DC1FF->scalar_size )
      {
        EXCEPTION2( NonCompliantException, "M3DC1 Element Check",
                    "Dataset '" + string(name) +
                    "' is of the wrong rank or dimensions" );

        return -1;
      }
      else
      {
        M3DC1FF->m_fieldVarNames.push_back( std::string( name ) );

        return 0;
      }
    }
  }
}


// ****************************************************************************
//  Method: avtM3DFileFormat::LoadFile
//
//  Purpose:
//      Open an m3d file and read in it's structure.
//
//  Arguments:
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Tue Sep 25 08:49:28 PDT 2007
//
//  Modifications:
//    Jeremy Meredith, Thu Jan  7 15:36:19 EST 2010
//    Close all open ids when returning an exception.
// ****************************************************************************
void
avtM3DC1FileFormat::LoadFile()
{
    debug1 << "Attempting to open M3D C1 file " << m_filename << endl;

    // Init HDF5 and turn off error message printing.
    H5open();
    H5Eset_auto( NULL, NULL, NULL );

    // Check for a valid M3D C1 file
    if( H5Fis_hdf5( m_filename.c_str() ) < 0 )
        EXCEPTION1( InvalidFilesException, m_filename.c_str() );

    if ( (m_fileID =
          H5Fopen( m_filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT)) < 0)
      EXCEPTION1( InvalidFilesException, m_filename.c_str() );

    // Root group
    hid_t rootID = H5Gopen( m_fileID, "/", H5P_DEFAULT);
    if ( rootID < 0 )
    {
        H5Fclose(m_fileID);        
        EXCEPTION1( InvalidVariableException,
                    "M3DC1 Group Open - The root group '/' was not found" );
    }

    // HEADER

    // Read in step and time information.
    int ntime;
    if ( ! ReadAttribute( rootID, "ntime", &ntime ) )
    {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'ntime' was not found or was the wrong type." );
    }

    // 2D or 3D elements?
    if ( ReadAttribute( rootID, "3d", &element_dimension ) )
      element_dimension += 2;
    else
      element_dimension = 2;

    if( element_dimension == 2 )
    {
      nvertices = 3;

      element_size = ELEMENT_SIZE_2D;
      scalar_size = SCALAR_SIZE_2D;

      nplanes = 1;
    }  
    else //if( element_dimension == 3 )
    {
      nvertices = 6;

      element_size = ELEMENT_SIZE_3D;
      scalar_size = SCALAR_SIZE_3D;

      // Read in nplanes
      if ( ! ReadAttribute( rootID, "nplanes", &nplanes ) )
      {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nplanes' was not found or was the wrong type." );
      }
    }

    m_scalarVarNames.push_back("header/nplanes");

    // Read in linear flag and ntor
    int linear;
    if ( ! ReadAttribute( rootID, "linear", &linear ) )
    {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'linear' was not found or was the wrong type." );
    }
    
    m_scalarVarNames.push_back("header/linear");

    int ntor;
    if ( ! ReadAttribute( rootID, "ntor", &ntor ) )
    {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'ntor' was not found or was the wrong type." );
    }
    
    m_scalarVarNames.push_back("header/ntor");

    // Read in bzero and rzero
    double bzero, rzero;
    if ( ! ReadAttribute( rootID, "bzero", &bzero ) )
    {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'bzero' was not found or was the wrong type." );
    }

    m_scalarVarNames.push_back("header/bzero");

    if ( ! ReadAttribute( rootID, "rzero", &rzero ) )
    {
        H5Gclose(rootID);
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'rzero' was not found or was the wrong type." );
    }

    m_scalarVarNames.push_back("header/rzero");

    H5Gclose( rootID );

    // EQUILIBRIUM

    // Read in equilibrium mesh element information.
    hid_t groupId = H5Gopen( m_fileID, "/equilibrium/mesh", H5P_DEFAULT);
    if ( groupId < 0 )
    {
        H5Fclose(m_fileID);
        EXCEPTION1( InvalidVariableException, "M3DC1 Group Open - '/equilibrium/mesh' was not found" );
    }

    if ( ! ReadAttribute( groupId, "nelms", &nelms ) )
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nelms' was not found or was the wrong type." );

    hid_t datasetId = H5Dopen(groupId, "elements", H5P_DEFAULT);
    hid_t spaceId = H5Dget_space(datasetId);
    size_t rank = H5Sget_simple_extent_ndims(spaceId);
    std::vector<hsize_t> sdim(rank);
    H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);
    
    H5Dclose(spaceId);
    H5Dclose(datasetId);
    
    if( rank != 2 ||
        sdim[0] != nelms ||
        sdim[1] != element_size )
    {
      EXCEPTION1( InvalidVariableException, "M3DC1 Element Check - number of elements or the element size does not match" );
    }

    H5Gclose( groupId );


    // Read in equilibrium field information.
    groupId = H5Gopen( m_fileID, "/equilibrium/fields", H5P_DEFAULT);
    if ( groupId < 0 )
        EXCEPTION1( InvalidVariableException, "M3DC1 Group Open - '/equilibrium/fields' was not found" );

    int nfields;
    
    if ( ! ReadAttribute( groupId, "nfields", &nfields ) )
        EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nfields' was not found or was the wrong type." );

    // Go through the field group and collect all of the field datasets
    H5Giterate(groupId, ".", NULL, groupIterator, this);

    H5Gclose( groupId );

    if( nfields != m_fieldVarNames.size() )
        EXCEPTION1( InvalidVariableException, "M3DC1 number of fields check - of fields does not match the number of datasets founds." );

    // TIME STEPS

    //Load basic info on variables for each time step.
    for ( int t=0; t<ntime; ++t )
    {
        char timeStep[64];
        sprintf( timeStep, "/time_%03d", t );

        hid_t groupID = H5Gopen( m_fileID, timeStep, H5P_DEFAULT);
        if ( groupID < 0 )
          EXCEPTION1( InvalidVariableException, "M3DC1 Group Open - 'timeStep' was not found" );

        // Read the time value
        double time;
        if ( ! ReadAttribute( groupID, "time", &time ) )
          EXCEPTION1( InvalidVariableException, "M3DC1 Group Open - 'time' was not found" );

        m_times.push_back( time );
        m_cycles.push_back( t );

        // Read in the field information.
        hid_t fieldID = H5Gopen( groupID, "fields", H5P_DEFAULT);
        if ( fieldID < 0 )
          EXCEPTION1( InvalidVariableException, "M3DC1 Group Open - 'fields' was not found" );

        if ( ! ReadAttribute( fieldID, "nfields", &nfields ) )
          EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nfields' was not found" );

        if( nfields != m_fieldVarNames.size() )
          EXCEPTION1( InvalidVariableException, "M3DC1 Time Step Check - time step nfields does not match the equilibrium nfields" );
             
        for ( int i=0; i<m_fieldVarNames.size(); ++i )
        {
            hid_t datasetId =
              H5Dopen(fieldID, m_fieldVarNames[i].c_str(), H5P_DEFAULT);
            if ( datasetId < 0 )
              EXCEPTION1( InvalidVariableException, "M3DC1 Dataset Open - '" + string(timeStep) + string("/fields/") +
                          m_fieldVarNames[i] + "' was not found" );


            hid_t spaceId = H5Dget_space(datasetId);
            size_t rank = H5Sget_simple_extent_ndims(spaceId);
            std::vector<hsize_t> sdim(rank);
            H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);
            
            H5Dclose(spaceId);
            H5Dclose(datasetId);

            if( rank != 2 ||
                sdim[0] != nelms ||
                sdim[1] != scalar_size )
              {
                EXCEPTION1( InvalidVariableException, "M3DC1 Element Check - Dataset '" +
                            string(timeStep) + string("/fields/") + m_fieldVarNames[i] +
                            "' the number of elements or the element size does not match" );
              }
        }
            
        H5Gclose( fieldID );

        // Read in the mesh information.
        hid_t meshId = H5Gopen( groupID, "mesh", H5P_DEFAULT);

        int nElements;
        if ( ! ReadAttribute( meshId, "nelms", &nElements ) )
          EXCEPTION1( InvalidVariableException, "M3DC1 Attribute Reader - 'nelms' was not found" );

        if( nElements != nelms )
          EXCEPTION1( InvalidVariableException, "M3DC1 Element Check - Time step 'nelms' does not match equilibrium 'nelms'" );

        hid_t datasetId = H5Dopen(meshId, "elements", H5P_DEFAULT);
        hid_t spaceId = H5Dget_space(datasetId);
        size_t rank = H5Sget_simple_extent_ndims(spaceId);
        std::vector<hsize_t> sdim(rank);
        H5Sget_simple_extent_dims(spaceId, &sdim[0], NULL);
    
        H5Dclose(spaceId);
        H5Dclose(datasetId);
    
        if( rank != 2 ||
            sdim[0] != nelms ||
            sdim[1] != element_size )
        {
          EXCEPTION1( InvalidVariableException, "M3DC1 Element Check - The number of elements or the element size does not match" );
        }
        
        H5Gclose( meshId );
    }

    debug1 << "SUCCESS in opening M3D C1 file " << m_filename << endl;
}


// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetCycles
//
//  Purpose:
//      Returns the cycles
//
//  Arguments:
//      c          the cycles
//
//  Programmer: allen
//  Creation:   
//
// ****************************************************************************


void avtM3DC1FileFormat::GetCycles(std::vector<int> &cycles)
{
    cycles = m_cycles;
}



// ****************************************************************************
//  Method: avtM3DC1FileFormat::GetTimes
//
//  Purpose:
//      Returns the times
//
//  Arguments:
//      t          the times
//
//  Programmer: allen
//  Creation:   
//
// ****************************************************************************

void avtM3DC1FileFormat::GetTimes(std::vector<double> &times)
{
    times = m_times;
}
