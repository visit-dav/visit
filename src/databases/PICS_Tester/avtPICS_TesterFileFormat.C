/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                         avtPICS_TesterFileFormat.C                        //
// ************************************************************************* //

#include <avtPICS_TesterFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkPoints.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <DebugStream.h>
#include <InvalidVariableException.h>


using     std::string;


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

avtPICS_TesterFileFormat::avtPICS_TesterFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    isRectilinear = true;
    is3D = true;
    ReadHeader(filename);
}

void
avtPICS_TesterFileFormat::ReadHeader(const char *filename)
{
    char line[1024];
    ifstream ifile(filename);
    while (! ifile.eof())
    {
        ifile.getline(line, 1024);
        if (line[0] == '#')
            continue;
        if (strcmp(line, "3D") == 0)
        {
            is3D = true;
            continue;
        }
        if (strcmp(line, "2D") == 0)
        {
            is3D = false;
            continue;
        }
        if (strcmp(line, "rectilinear") == 0)
        {
            isRectilinear = true;
            continue;
        }
        if (strcmp(line, "unstructured") == 0)
        {
            isRectilinear = false;
            continue;
        }
        float time;
        int nb;
        int nc;
        float velx, vely, velz;
        float magnitude;
        bool validScan = false;
        if (is3D)
        {
            validScan = (sscanf(line, "%f %d %d %f %f %f %f", &time, &nb, &nc,
                               &velx, &vely, &velz, &magnitude) == 7);
        }
        else
        {
            validScan = (sscanf(line, "%f %d %d %f %f %f", &time, &nb, &nc,
                               &velx, &vely, &magnitude) == 6);
            velz = 0.;
        }
        if (validScan)
        {
            times.push_back(time);
            numBlocks.push_back(nb);
            numCells.push_back(nc);
            vels.push_back(velx);
            vels.push_back(vely);
            vels.push_back(velz);
            magnitudes.push_back(magnitude);
        }
    }
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

int
avtPICS_TesterFileFormat::GetNTimesteps(void)
{
    return times.size();
}


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

void
avtPICS_TesterFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

void
avtPICS_TesterFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    string meshname = "mesh";
    avtMeshType mt = AVT_RECTILINEAR_MESH;
    if (! isRectilinear)
        mt = AVT_UNSTRUCTURED_MESH;

    int nblocks = numBlocks[timeState]*numBlocks[timeState];
    if (is3D)
        nblocks *= numBlocks[timeState];

    int block_origin = 0;
    int spatial_dimension = is3D ? 3 : 2;
    int topological_dimension = is3D ? 3 : 2;
    AddMeshToMetaData(md, meshname, mt, NULL, nblocks, block_origin,
                      spatial_dimension, topological_dimension);

    string varname = "velocity";
    int vector_dim = spatial_dimension;
    avtCentering cent = AVT_NODECENT;
    AddVectorVarToMetaData(md, varname, meshname, cent,vector_dim);

    md->SetTimes(times);
    md->SetTimesAreAccurate(true);
}


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

void
RotatePoint(const float *pt3, float *pt2)
{
    double mid[3] = { 0.5, 0.5, 0.5 };

    float pt[3];
    pt[0] = pt3[0] - mid[0];
    pt[1] = pt3[1] - mid[1];
    pt[2] = pt3[2] - mid[2];

    pt2[0] = pt[0]*0.707-pt[1]*0.707; // x*cos\theta-y*sin\theta, theta=45
    pt2[1] = pt[0]*0.707+pt[1]*0.707; // x*sin\theta+y*cos\theta, theta=45
    pt2[2] = pt[2];

    pt2[0] += mid[0];
    pt2[1] += mid[1];
    pt2[2] += mid[2];
}

vtkDataSet *
avtPICS_TesterFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    int nblocks = numBlocks[timestate]*numBlocks[timestate];
    if (is3D)
        nblocks *= numBlocks[timestate];
    if (domain >= nblocks)
    {
        EXCEPTION1(VisItException, "Invalid mesh requested!");
    }

    double sizePerBlock = 1.0/numBlocks[timestate];
    int xOff = domain % numBlocks[timestate];
    int yOff = (domain/numBlocks[timestate]) % numBlocks[timestate];
    int zOff = domain/(numBlocks[timestate]*numBlocks[timestate]);

    int dims[3] = { numCells[timestate]+1, numCells[timestate]+1, numCells[timestate]+1 };
    if (! is3D)
        dims[2] = 1;

    if (isRectilinear)
    {
        vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
    
        rgrid->SetDimensions(dims);
    
        vtkFloatArray *x = vtkFloatArray::New();
        x->SetNumberOfTuples(numCells[timestate]+1);
        for (int i = 0 ; i < numCells[timestate]+1 ; i++)
            x->SetTuple1(i, sizePerBlock*xOff + i*sizePerBlock/numCells[timestate]);
        rgrid->SetXCoordinates(x);
        x->Delete();
    
        vtkFloatArray *y = vtkFloatArray::New();
        y->SetNumberOfTuples(numCells[timestate]+1);
        for (int i = 0 ; i < numCells[timestate]+1 ; i++)
            y->SetTuple1(i, sizePerBlock*yOff + i*sizePerBlock/numCells[timestate]);
        rgrid->SetYCoordinates(y);
        y->Delete();
    
        if (is3D)
        {
            vtkFloatArray *z = vtkFloatArray::New();
            z->SetNumberOfTuples(numCells[timestate]+1);
            for (int i = 0 ; i < numCells[timestate]+1 ; i++)
                z->SetTuple1(i, sizePerBlock*zOff + i*sizePerBlock/numCells[timestate]);
            rgrid->SetZCoordinates(z);
            z->Delete();
        }
        else
        {
            vtkFloatArray *z = vtkFloatArray::New();
            z->SetNumberOfTuples(1);
            z->SetTuple1(0, 0.0);
            rgrid->SetZCoordinates(z);
            z->Delete();
        }
    
        return rgrid;
    }
    else
    {
        vtkPoints *pts = vtkPoints::New();
        //pts->SetNumberOfComponents(3);
        int npts = dims[0]*dims[1]*dims[2];
        pts->SetNumberOfPoints(npts);

        int idx = 0;
        for (int i = 0 ; i < dims[0] ; i++)
            for (int j = 0 ; j < dims[1] ; j++)
                for (int k = 0 ; k < dims[2] ; k++)
                {
                    float pt[3];
                    pt[0] = sizePerBlock*xOff + i*sizePerBlock/numCells[timestate];
                    pt[1] = sizePerBlock*yOff + j*sizePerBlock/numCells[timestate];
                    pt[2] = sizePerBlock*zOff + k*sizePerBlock/numCells[timestate];
  
                    float pt2[3];
                    RotatePoint(pt, pt2);
                    pts->SetPoint(idx++, pt2);
                }


        vtkStructuredGrid *sgrid = vtkStructuredGrid::New();
        sgrid->SetDimensions(dims);
        sgrid->SetPoints(pts);
        pts->Delete();

        return sgrid;
    }
}


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

vtkDataArray *
avtPICS_TesterFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    return NULL;
}


// ****************************************************************************
//  Method: avtPICS_TesterFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Tue Mar 6 07:45:19 PDT 2012
//
// ****************************************************************************

vtkDataArray *
avtPICS_TesterFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    int dims[3] = { numCells[timestate]+1, numCells[timestate]+1, numCells[timestate]+1 };
    if (! is3D)
        dims[2] = 1;

    int ntuples = dims[0]*dims[1]*dims[2];
    vtkFloatArray *rv = vtkFloatArray::New();
    rv->SetNumberOfComponents(3);
    rv->SetNumberOfTuples(ntuples);
    srand((timestate+1)*(domain+1));
    for (int i = 0 ; i < ntuples ; i++)
    {
        double vec[3];
        for (int j = 0 ; j < 3 ; j++)
        {
            if (j == 2 && ! is3D)
            {
                vec[2] = 0.;
                continue;
            }
            double r = (rand()%1000)/1000.0;
            vec[j] = vels[3*timestate+j]+magnitudes[timestate]*r;
        }
        rv->SetTuple(i, vec);
    }

    return rv;
}

void *
avtPICS_TesterFileFormat::GetAuxiliaryData(const char *var, int ts, int dom,
                                      const char * type, void *,
                                      DestructorFunction &df)
{
    if (strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0)
    {
        int nblocks = numBlocks[ts]*numBlocks[ts];
        if (is3D)
            nblocks *= numBlocks[ts];

        int dimension = (is3D ? 3 : 2);
        avtIntervalTree *itree = new avtIntervalTree(nblocks, dimension);

        double sizePerBlock = 1.0/numBlocks[ts];

        for (int domain = 0 ; domain < nblocks ; domain++)
        {
            int xOff = domain % numBlocks[ts];
            int yOff = (domain/numBlocks[ts]) % numBlocks[ts];
            int zOff = domain/(numBlocks[ts]*numBlocks[ts]);

            double bounds[6];
            bounds[0] = xOff*sizePerBlock;
            bounds[1] = (xOff+1)*sizePerBlock;
            bounds[2] = yOff*sizePerBlock;
            bounds[3] = (yOff+1)*sizePerBlock;
            if (is3D)
            {
                bounds[4] = zOff*sizePerBlock;
                bounds[5] = (zOff+1)*sizePerBlock;
            }
            else
            {
                bounds[4] = 0.0;
                bounds[5] = 0.0;
            }
            if (! isRectilinear)
            {
                int i;
                double b[6] = { 10, -10, 10, -10, 10, -10 };
                if (! is3D)
                   b[4] = b[5] = 0.0;

                for (i = 0 ; i < 8 ; i++)
                {
                    float pt[3];
                    pt[0] = (i%2 ? bounds[0] : bounds[1]);
                    pt[1] = (((i/2)%2) ? bounds[2] : bounds[3]);
                    pt[2] = (i/2 ? bounds[4] : bounds[5]);
                    float pt2[3];
                    RotatePoint(pt, pt2);
                    b[0] = (b[0] < pt2[0] ? b[0] : pt2[0]);
                    b[1] = (b[1] > pt2[0] ? b[1] : pt2[0]);
                    b[2] = (b[2] < pt2[1] ? b[2] : pt2[1]);
                    b[3] = (b[3] > pt2[1] ? b[3] : pt2[1]);
                    b[4] = (b[4] < pt2[2] ? b[4] : pt2[2]);
                    b[5] = (b[5] > pt2[2] ? b[5] : pt2[2]);
                }
                for (i = 0 ; i < 6 ; i++)
                    bounds[i] = b[i];
            }
            itree->AddElement(domain, bounds);
        }
        itree->Calculate(true);

        df = avtIntervalTree::Destruct;

        return ((void *) itree);
    }

    return NULL;
}

