/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtXDMFFileFormat.C                            //
// ************************************************************************* //

#include <avtXDMFFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtCallback.h>
#include <avtDatabaseMetaData.h>

#include <Expression.h>

#include <DebugStream.h>
#include <InvalidVariableException.h>

#include <XDMFParser.h>

#include <hdf5.h>

using     std::string;

// ****************************************************************************
//  Method: avtXDMFFileFormat constructor
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

avtXDMFFileFormat::avtXDMFFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
    fname = filename;
    fileRead = false;

    //
    // Turn off HDF5 error message to the terminal.
    //
    H5Eset_auto(NULL, NULL);
}


// ****************************************************************************
//  Method: avtXDMFFileFormat destructor
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

avtXDMFFileFormat::~avtXDMFFileFormat()
{
    FreeUpResources();
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::DetermineFileAndDataset
//
//  Purpose:
//      Split a filename:dataset location into the file name and dataset name.
//      The filename and datasetname buffers must be 1024 characters long
//      including the terminating NULL.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

int
avtXDMFFileFormat::DetermineFileAndDataset(const char *input,
    char *filename, char *datasetname) const
{
    //
    // Determine the start of the filename;
    //
    const char *ptr = input;
    while (isspace(*ptr))
        ptr++;
    
    //
    // Find the ':' in the string.
    //
    char *ptr2 = strstr(ptr, ":");
    if (ptr2 == NULL)
    {
        avtCallback::IssueWarning("Dataset specifier missing a colon.");
        return 1;
    }

    //
    // Find the end of the dataset name.
    //
    char *ptr3 = ptr2 + 1;
    while (!isspace(*ptr3))
        ptr3++;

    //
    // Copy the filename and dataset names.
    //
    if (ptr2 - ptr == 0)
    {
        avtCallback::IssueWarning("Dataset specifier missing a filename.");
        return 2;
    }
    if (ptr2 - ptr > 1023)
    {
        avtCallback::IssueWarning("Dataset specifier filename over 1023 characters.");
        return 3;
    }
    char *ptr4 = filename;
    while (ptr != ptr2)
        *ptr4++ = *ptr++;
    *ptr4 = '\0';

    ptr2++;
    if (ptr3 - ptr2 == 0)
    {
        avtCallback::IssueWarning("Dataset specifier missing a dataset name.");
        return 4;
    }
    if (ptr3 - ptr2 > 1023)
    {
        avtCallback::IssueWarning("Dataset specifier dataset name over 1023 characters.");
        return 5;
    }
    ptr4 = datasetname;
    while (ptr2 != ptr3)
        *ptr4++ = *ptr2++;
    *ptr4 = '\0';

    return 0;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ReadHDFDataItem
//
//  Purpose:
//      Read a data item in HDF5 format.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

int
avtXDMFFileFormat::ReadHDFDataItem(DataItem *dataItem, void *buf,
    int lbuf)
{
    hid_t     file_id, dataset_id, dataspace_id;

    //
    // If cdata is NULL, then read it from the file.
    //
    if (dataItem->cdata == NULL)
    {
        FILE *file = fopen(fname.c_str(), "r");
        fseek(file, dataItem->cdataOffset, SEEK_SET);
        dataItem->cdata = new char[dataItem->cdataLength+1];
        fread(dataItem->cdata, 1, dataItem->cdataLength, file);
        dataItem->cdata[dataItem->cdataLength] = '\0';
        fclose(file);
    }

    //
    // Split the path into the file and dataset parts.
    //
    if (DetermineFileAndDataset(dataItem->cdata, filename, datasetname) != 0)
    {
        avtCallback::IssueWarning("Dataset specification invalid.");
        return 0;
    }

    //
    // Open the data file.
    //
    if ((file_id = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT)) < 0)
    {
        avtCallback::IssueWarning("Unable to open file.");
        return 0;
    }

    //
    // Open the data set.
    //
    if ((dataset_id = H5Dopen(file_id, datasetname)) < 0)
    {
        avtCallback::IssueWarning("Unable to open dataset.");
        H5Fclose(file_id);
        return 0;
    }

    //
    // Determine the size of the dataset.
    //
    if ((dataspace_id = H5Dget_space(dataset_id)) < 0)
    {
        avtCallback::IssueWarning("Unable to get the dataspace id.");
        H5Dclose(dataset_id);
        H5Fclose(file_id);
        return 0;
    }
    hssize_t ldataset = H5Sget_simple_extent_npoints(dataspace_id);
    if (H5Sclose(dataspace_id) < 0)
    {
        avtCallback::IssueWarning("Unable to close the dataspace.");
    }

    //
    // Check that the size of the dataset and the dimensions match.
    //
    int ldataItem = 1;
    for (int i = 0; i < dataItem->nDims; i++)
        ldataItem *= dataItem->dims[i];
    if (ldataItem != ldataset)
    {
        avtCallback::IssueWarning("Dimensions don't match dataset size.");
        H5Dclose(dataset_id);
        H5Fclose(file_id);
        return 0;
    }

    //
    // Check that the size of the dataset and the buffer match.
    //
    if (ldataset != lbuf)
    {
        avtCallback::IssueWarning("Buffer size doesn't match dataset size.");
        H5Dclose(dataset_id);
        H5Fclose(file_id);
        return 0;
    }

    //
    // Read the data set.
    //
    if (H5Dread(dataset_id, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, buf) < 0)
    {
        avtCallback::IssueWarning("Unable to read the dataset.");
        H5Dclose(dataset_id);
        H5Fclose(file_id);
        return 0;
    }

    //
    // Close the dataset.
    //
    if (H5Dclose(dataset_id) < 0)
    {
        avtCallback::IssueWarning("Unable to close the dataset.");
    }

    //
    // Close the file.
    //
    if (H5Fclose(file_id) < 0)
    {
        avtCallback::IssueWarning("Unable to close the file.");
    }

    return 1;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::AddVarInfo
//
//  Purpose:
//      Add a VarInfo entry to the file variable list.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::AddVarInfo(bool topGrid, int iBlock, VarInfo *varInfo)
{
    //
    // Check if the varInfo already exists in the file list.
    //
    unsigned int iVar = 0;
    while (iVar < fileVarList.size() &&
           (fileVarList[iVar]->iDomain != varInfo->iDomain || 
            fileVarList[iVar]->iGrid != varInfo->iGrid || 
            fileVarList[iVar]->name != varInfo->name))
    {
        iVar++;
    }

    if (iVar == fileVarList.size())
    {
        //
        // The entry is not in the list. If this is a top level grid add
        // it straight to the list, otherwise add it as block under a new
        // top level entry.  We are adding NULL blocks to fill any gapps
        // in the block list.
        //
        if (topGrid)
        {
            fileVarList.push_back(varInfo);
        }
        else
        {
            VarInfo *varInfo2 = new VarInfo;
            varInfo2->name         = varInfo->name;
            varInfo2->meshName     = varInfo->meshName;
            varInfo2->variableType = varInfo->variableType;
            varInfo2->centering    = varInfo->centering;
            varInfo2->varDimension = varInfo->varDimension;
            varInfo2->iDomain      = varInfo->iDomain;
            varInfo2->iGrid        = varInfo->iGrid;

            varInfo2->nBlocks = iBlock + 1;
            for (int i = fileVarList.size(); i < iBlock; i++)
            {
                varInfo2->blockList.push_back(NULL);
            } 
            varInfo2->blockList.push_back(varInfo);

            fileVarList.push_back(varInfo2);
        }
    }
    else
    {
        //
        // The entry is in the list. If this is a top level grid then it
        // is a duplicate and we will ignore it, otherwise it will normally
        // be added as a new block under an existing top level entry. If the
        // block is already in the list then it is a duplicate and we will
        // ignore it. We are adding NULL blocks to fill any gapps in the
        // block list.
        //
        if (topGrid)
        {
            debug1 << "Duplicate variable name, ignoring second instance." << endl;
        }
        else
        {
            if (fileVarList[iVar]->nBlocks == iBlock + 1)
            {
                debug1 << "Duplicate variable name, ignoring second instance." << endl;
                return;
            }

            fileVarList[iVar]->nBlocks = iBlock + 1;
            for (int i = fileVarList[iVar]->blockList.size(); i < iBlock; i++)
            {
                fileVarList[iVar]->blockList.push_back(NULL);
            } 
            fileVarList[iVar]->blockList.push_back(varInfo);
        }
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseDataItem
//
//  Purpose:
//      Parse a DataItem node in the DOM tree, returning a pointer to a
//      DataItem.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

DataItem *
avtXDMFFileFormat::ParseDataItem()
{
    string    dimensions;
    string    numberType;
    string    precision;
    string    format;
    char     *cdata=NULL;
    int       cdataOffset=0;
    int       cdataLength=0;

    //
    // Process the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute())
    {
        if (strcmp(xdmfParser.GetAttributeName(), "Dimensions") == 0)
        {
            dimensions = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
                 strcmp(xdmfParser.GetAttributeName(), "NumberType") == 0)
        {
            numberType = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Precision") == 0)
        {
            precision = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Format") == 0)
        {
            format = string(xdmfParser.GetAttributeValue());
        }
    }

    //
    // Process the rest of the information.
    //
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            xdmfParser.SkipToEndTag();
        }
        else if (elementType == XDMFParser::TYPE_CDATA)
        {
            cdataOffset = xdmfParser.GetCDataOffset();
            cdataLength = xdmfParser.GetCDataLength();
            if (cdataLength <= 1023)
            {
                cdata = new char[cdataLength+1];
                memcpy(cdata, xdmfParser.GetCDataValue(), cdataLength+1);
            }
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }

    DataItem *dataItem = new DataItem;

    //
    // Store the CData. We do this first so that it will get freed
    // as part of the DataItem destructor.
    //
    if (cdataLength == 0)
    {
        debug1 << "Invalid DataItem: CData missing." << endl;
        delete dataItem;
        return NULL;
    }
    dataItem->cdata = cdata;
    dataItem->cdataOffset = cdataOffset;
    dataItem->cdataLength = cdataLength;
    
    //
    // Determine the format (HDF or XML).
    //
    if (format == "HDF")
        dataItem->format = DataItem::DATA_FORMAT_HDF; 
    else if (format == "" || format == "XML")
        dataItem->format = DataItem::DATA_FORMAT_XML; 
    else
    {
        debug1 << "Invalid DataItem: Format must be XML or HDF." << endl;
        delete dataItem;
        return NULL;
    }

    //
    // Determine the number type.
    //
    if (numberType == "" || numberType == "Float")
        dataItem->type = DataItem::DATA_TYPE_FLOAT;
    else if (numberType == "Int")
        dataItem->type = DataItem::DATA_TYPE_INT;
    else if (numberType == "UInt")
        dataItem->type = DataItem::DATA_TYPE_UINT;
    else if (numberType == "Char")
        dataItem->type = DataItem::DATA_TYPE_CHAR;
    else if (numberType == "UChar")
        dataItem->type = DataItem::DATA_TYPE_UCHAR;
    else
    {
        debug1 << "Invalid DataItem: NumberType must be Float, Int, UInt, Char, or UChar." << endl;
        delete dataItem;
        return NULL;
    }

    //
    // Determine the precision.
    //
    if (precision == "" || precision == "4")
        dataItem->precision = 4;
    else if (precision == "8")
        dataItem->precision = 8;
    else if (precision == "1")
        dataItem->precision = 1;
    else
    {
        debug1 << "Invalid DataItem: Precision must be 1, 4, or 8." << endl;
        delete dataItem;
        return NULL;
    }

    //
    // Determine the dimensions.
    //
    if (dimensions == "")
    {
        debug1 << "Invalid DataItem: Dimensions missing." << endl;
        delete dataItem;
        return NULL;
    }
    dataItem->nDims = sscanf(dimensions.c_str(), "%d %d %d %d",
           &dataItem->dims[0],
           &dataItem->dims[1],
           &dataItem->dims[2],
           &dataItem->dims[3]);
    if (dataItem->nDims < 1)
    {
        debug1 << "Invalid DataItem: Dimensions must have at least 1 value." << endl;
        delete dataItem;
        return NULL;
    }

    return dataItem;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseTopology
//
//  Purpose:
//      Parse a Topology node in the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseTopology(string &topologyType,
    string &numberOfElements)
{
    //
    // Process the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute())
    {
        if (strcmp(xdmfParser.GetAttributeName(), "NumberOfElements") == 0)
        {
            numberOfElements = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
                 strcmp(xdmfParser.GetAttributeName(), "TopologyType") == 0)
        {
            topologyType = string(xdmfParser.GetAttributeValue());
        }
    }

    //
    // Process the rest of the information.
    //
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            xdmfParser.SkipToEndTag();
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseGeometry
//
//  Purpose:
//      Parse a Geometry node in the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseGeometry(string &geometryType, int &nDataItem,
    struct DataItem **geometryData)
{
    //
    // Process the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute())
    {
        if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
            strcmp(xdmfParser.GetAttributeName(), "GeometryType") == 0)
        {
            geometryType = string(xdmfParser.GetAttributeValue());
        }
    }

    //
    // Process the rest of the information.
    //
    nDataItem = 0;
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "DataItem") == 0)
            {
                if (nDataItem < 3)
                {
                    geometryData[nDataItem] = ParseDataItem();
                    nDataItem++;
                }
                else
                {
                    xdmfParser.SkipToEndTag();
                }
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseAttribute
//
//  Purpose:
//      Parse an Attribute node in the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

VarInfo *
avtXDMFFileFormat::ParseAttribute(int iDomain, int iGrid,
    const string &gridName)
{
    string    attributeName;
    string    attributeType;
    string    center;
    DataItem *varData=NULL;
    
    //
    // Process the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute())
    {
        if (strcmp(xdmfParser.GetAttributeName(), "Name") == 0)
        {
            attributeName = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
                 strcmp(xdmfParser.GetAttributeName(), "AttributeType") == 0)
        {
            attributeType = string(xdmfParser.GetAttributeValue());
        }
        else if (strcmp(xdmfParser.GetAttributeName(), "Center") == 0)
        {
            center = string(xdmfParser.GetAttributeValue());
        }
    }

    //
    // Process the rest of the information.
    //
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "DataItem") == 0)
            {
                varData = ParseDataItem();
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }

    //
    // Do some error checking.
    //
    if (attributeName == "")
    {
        debug1 << "Invalid Attribute: Name missing." << endl;
        return NULL;
    }

    if (varData == NULL)
    {
        debug1 << "Invalid Attribute: Data missing." << endl;
        return NULL;
    }

    VarInfo *varInfo = new VarInfo;

    //
    // Store the DataItem. We do this first so that it will get freed
    // as part of the VarInfo destructor.
    //
    varInfo->varData = varData;

    //
    // Set some identifying information for the variable.
    //
    varInfo->name = attributeName;
    varInfo->meshName = gridName;
    varInfo->iDomain = iDomain;
    varInfo->iGrid = iGrid;

    //
    // Determine the attribute type and dimension.
    //
    if (attributeType == "" || attributeType == "Scalar")
    {
        varInfo->variableType = VarInfo::TYPE_SCALAR;
        varInfo->varDimension = 1;
    }
    else if (attributeType == "Vector")
    {
        varInfo->variableType = VarInfo::TYPE_VECTOR;
        varInfo->varDimension = varData->dims[varData->nDims-1];
    }
    else if (attributeType == "Tensor")
    {
        varInfo->variableType = VarInfo::TYPE_TENSOR;
        varInfo->varDimension = 9;
    }
    else if (attributeType == "Tensor6")
    {
        varInfo->variableType = VarInfo::TYPE_TENSOR;
        varInfo->varDimension = 6;
    }
    else if (attributeType == "Matrix")
    {
        debug1 << "Invalid Attribute: Unsupported AttributeType - Matrix." << endl;
        delete varInfo;
        return NULL;
    }
    else
    {
        debug1 << "Invalid Attribute: Invalid AttributeType." << endl;
        delete varInfo;
        return NULL;
    }

    //
    // Determine the centering.
    //
    if (center == "" || center == "Node")
    {
        varInfo->centering = AVT_NODECENT;
    }
    else if (center == "Cell")
    {
        varInfo->centering = AVT_ZONECENT;
    }
    else if (center == "Face" || center == "Edge" || center == "Grid")
    {
        debug1 << "Invalid Attribute: Unsupported Center." << endl;
        delete varInfo;
        return NULL;
    }
    else
    {
        debug1 << "Invalid Attribute: Invalid Center." << endl;
        delete varInfo;
        return NULL;
    }

    varInfo->nBlocks = 1;
    varInfo->extents = NULL;

    return varInfo;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseUniformGrid
//
//  Purpose:
//      Parse a uniform grid node of the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseUniformGrid(vector<MeshInfo*> &meshList,
    int iDomain, int iGrid, bool topGrid,
    const string &gridName)
{
    string    topologyType;
    string    numberOfElements;
    string    geometryType;
    int       nMeshData;
    DataItem *meshData[3];
    VarInfo  *varInfo = NULL;
    vector<VarInfo*> varList;

    //
    // Process the elements of the grid.
    //
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "Topology") == 0)
            {
                ParseTopology(topologyType, numberOfElements);
            }
            else if (strcmp(xdmfParser.GetElementName(), "Geometry") == 0)
            {
                ParseGeometry(geometryType, nMeshData, meshData);
            }
            else if (strcmp(xdmfParser.GetElementName(), "Attribute") == 0)
            {
                if ((varInfo = ParseAttribute(iDomain, iGrid, gridName)) != NULL)
                    varList.push_back(varInfo);
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }

    //
    // Do some error checking.
    //
    if (topologyType == "")
    {
        debug1 << gridName << ": Invalid Grid elmement - "
               << "Topology type missing." << endl;
        for (unsigned int i = 0; i < varList.size(); i++)
            delete varList[i];
        return;
    }

    if (numberOfElements == "")
    {
        debug1 << gridName << ": Invalid Grid elmement - "
               << "Topology doesn't contain the number of elements." << endl;
        for (unsigned int i = 0; i < varList.size(); i++)
            delete varList[i];
        return;
    }

    MeshInfo *meshInfo = new MeshInfo;

    if (topGrid)
    {
        meshInfo->name = gridName;
        meshInfo->iDomain = iDomain;
    }

    meshInfo->nBlocks = 1;
    meshInfo->extents = NULL;

    if (geometryType == "" || geometryType == "XYZ")
        meshInfo->geometryType = MeshInfo::TYPE_XYZ;
    else if (geometryType == "XY")
        meshInfo->geometryType = MeshInfo::TYPE_XY;
    else if (geometryType == "X_Y_Z")
        meshInfo->geometryType = MeshInfo::TYPE_X_Y_Z;
    else if (geometryType == "VXVYVZ")
        meshInfo->geometryType = MeshInfo::TYPE_VXVYVZ;
    else if (geometryType == "ORIGIN_DXDYDZ")
        meshInfo->geometryType = MeshInfo::TYPE_ORIGIN_DXDYDZ;
    else
    {
        debug1 << gridName << ": Invalid Grid elmement - "
               << "Illegal GeometryType." << endl;
        delete meshInfo;
        for (unsigned int i = 0; i < varList.size(); i++)
            delete varList[i];
        return;
    }

    if (topologyType == "2DRectMesh" || topologyType == "2DCoRectMesh")
    {
        meshInfo->topologicalDimension = 2;
        meshInfo->spatialDimension = 2;
        meshInfo->type = AVT_RECTILINEAR_MESH;
    }
    else if (topologyType == "2DSMesh")
    {
        meshInfo->topologicalDimension = 2;
        meshInfo->spatialDimension = 2;
        meshInfo->type = AVT_CURVILINEAR_MESH;
    }
    else if (topologyType == "3DRectMesh" || topologyType == "3DCoRectMesh")
    {
        meshInfo->topologicalDimension = 3;
        meshInfo->spatialDimension = 3;
        meshInfo->type = AVT_RECTILINEAR_MESH;
    }
    else if (topologyType == "3DSMesh")
    {
        meshInfo->topologicalDimension = 3;
        meshInfo->spatialDimension = 3;
        meshInfo->type = AVT_CURVILINEAR_MESH;
    }
    else
    {
        if (meshInfo->geometryType == MeshInfo::TYPE_XY)
        {
            meshInfo->topologicalDimension = 2;
            meshInfo->spatialDimension = 2;
        }
        else if (meshInfo->geometryType = MeshInfo::TYPE_VXVYVZ)
        {
            meshInfo->topologicalDimension = nMeshData;
            meshInfo->spatialDimension = nMeshData;
        }
        else
        {
            meshInfo->topologicalDimension = 3;
            meshInfo->spatialDimension = 3;
        }
        meshInfo->type = AVT_UNSTRUCTURED_MESH;
    }

    meshInfo->dimensions[0] = 1;
    meshInfo->dimensions[1] = 1;
    meshInfo->dimensions[2] = 1;
    if (meshInfo->topologicalDimension == 2)
    {
        sscanf(numberOfElements.c_str(), "%d %d",
               &meshInfo->dimensions[1], &meshInfo->dimensions[0]);
    }
    else
    {
        sscanf(numberOfElements.c_str(), "%d %d %d", &meshInfo->dimensions[2],
               &meshInfo->dimensions[1], &meshInfo->dimensions[0]);
    }

    for (int i = 0; i < nMeshData; i++)
        meshInfo->meshData[i] = meshData[i];

    meshList.push_back(meshInfo);

    for (unsigned int i = 0; i < varList.size(); i++)
        AddVarInfo(topGrid, meshList.size()-1, varList[i]);
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseGrid
//
//  Purpose:
//      Parse a grid node of the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseGrid(vector<MeshInfo*> &meshList,
    int iDomain, int iGrid, string &gridName, bool topGrid)
{
    string    gridType;

    //
    // If this is the top grid then we want both the name and grid type
    // from the attribute list, if it isn't then we want to use the grid
    // passed in and get the grid type from the attribute list. It is
    // done this way because we want to use the top grid name for all the
    // sub grids.
    //
    if (topGrid)
    {
        //
        // Process the attributes in the start tag.
        //
        while (xdmfParser.GetNextAttribute())
        {
            if (strcmp(xdmfParser.GetAttributeName(), "Name") == 0)
            {
                gridName = string(xdmfParser.GetAttributeValue());
            }
            else if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
                     strcmp(xdmfParser.GetAttributeName(), "GridType") == 0)
            {
                gridType = string(xdmfParser.GetAttributeValue());
            }
        }

        //
        // If no name was given, create a default one.
        //
        if (gridName == "")
        {
            char str[16];
            sprintf(str, "Grid%04d", iGrid);
            gridName = str;
        }

        //
        // Check that the grid name is unique and skip it if it isn't.
        //
        for (unsigned int i = 0; i < meshList.size(); i++)
        {
            if (meshList[i]->iDomain == iDomain &&
                meshList[i]->name == gridName)
            {
                debug1 << "Duplicate mesh name, ignoring second instance." << endl;
                xdmfParser.SkipToEndTag();
                return;
            }
        }
    }
    else
    {
        //
        // Process the attributes in the start tag.
        //
        while (xdmfParser.GetNextAttribute())
        {
            if (strcmp(xdmfParser.GetAttributeName(), "Type") == 0 ||
                strcmp(xdmfParser.GetAttributeName(), "GridType") == 0)
            {
                gridType = string(xdmfParser.GetAttributeValue());
            }
        }
    }

    if (gridType == "" || gridType == "Uniform")
    {
        ParseUniformGrid(meshList, iDomain, iGrid,
            topGrid, gridName);
    }
    else if (gridType == "Collection" || gridType == "Tree")
    {
        if (topGrid)
        {
            topGrid = false;
            MeshInfo *meshInfo = new MeshInfo;

            XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
            while (elementType != XDMFParser::TYPE_EOF)
            {
                if (elementType == XDMFParser::TYPE_START_TAG)
                {
                    if (strcmp(xdmfParser.GetElementName(), "Grid") == 0)
                    {
                        ParseGrid(meshInfo->blockList, iDomain, iGrid,
                                  gridName, topGrid);
                    }
                    else
                    {
                        xdmfParser.SkipToEndTag();
                    }
                }
                else if (elementType == XDMFParser::TYPE_END_TAG)
                {
                    break;
                }
                elementType = xdmfParser.GetNextElement();
            }

            if (meshInfo->blockList.size() == 0)
            {
                debug1 << gridName << ": Invalid Tree/Collection - no valid blocks"
                       << endl;
                delete meshInfo;
                return;
            }

            meshInfo->name = gridName;
            meshInfo->nBlocks = meshInfo->blockList.size();
            meshInfo->extents = NULL;

            meshInfo->topologicalDimension = meshInfo->blockList[0]->topologicalDimension;
            meshInfo->spatialDimension = meshInfo->blockList[0]->spatialDimension;
            meshInfo->type = meshInfo->blockList[0]->type;

            meshList.push_back(meshInfo);
        }
        else
        {
            XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
            while (elementType != XDMFParser::TYPE_EOF)
            {
                if (elementType == XDMFParser::TYPE_START_TAG)
                {
                    if (strcmp(xdmfParser.GetElementName(), "Grid") == 0)
                    {
                        ParseGrid(meshList, iDomain, iGrid, gridName,
                                  topGrid);
                    }
                    else
                    {
                        xdmfParser.SkipToEndTag();
                    }
                }
                else if (elementType == XDMFParser::TYPE_END_TAG)
                {
                    break;
                }
                elementType = xdmfParser.GetNextElement();
            }
        }
    }
    else if (gridType == "Subset")
    {
        debug1 << gridName << ": Unsupported Grid type - Subset" << endl;
        return;
    }
    else
    {
        debug1 << gridName << ": Invalid Grid type" << endl;
        return;
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseDomain
//
//  Purpose:
//      Parse a domain node of the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseDomain(int iDomain)
{
    string    domainName;

    //
    // Process the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute())
    {
        if (strcmp(xdmfParser.GetAttributeName(), "Name") == 0)
        {
            domainName = string(xdmfParser.GetAttributeValue());
        }
    }

    //
    // If no name was given, create a default one.
    //
    if (domainName == "")
    {
        char str[16];
        sprintf(str, "Domain%04d", iDomain);
        domainName = str;
    }

    DomainInfo *domainInfo = new DomainInfo;

    domainInfo->name = domainName;
    fileDomainList.push_back(domainInfo);

    //
    // Process the rest of the information.
    //
    int iGrid = 0;
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "Grid") == 0)
            {
                string gridName;

                ParseGrid(fileMeshList, iDomain, iGrid, gridName, true);

                iGrid++;
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        else if (elementType == XDMFParser::TYPE_END_TAG)
        {
            break;
        }
        elementType = xdmfParser.GetNextElement();
    }
    fileDomainList[iDomain]->nGrids = iGrid;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseXdmf
//
//  Purpose:
//      Parse a xdmf node of the DOM tree.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseXdmf()
{
    //
    // Skip the attributes in the start tag.
    //
    while (xdmfParser.GetNextAttribute()) /* do nothing */;

    //
    // Process the rest of the information.
    //
    int nDomains = 0;
    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "Domain") == 0)
            {
                ParseDomain(nDomains);

                nDomains++;
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        elementType = xdmfParser.GetNextElement();
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ParseXMLFile
//
//  Purpose:
//      Parse the XML file, storing its contents in internal data structures
//      for efficient reading of data.  It gets the DOM for the XML file
//      to parse the file and then frees the DOM at the end.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 16 13:08:36 PST 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ParseXMLFile(void)
{
    xdmfParser.SetInputFileName(fname.c_str());

    XDMFParser::ElementType elementType = xdmfParser.GetNextElement();
    while (elementType != XDMFParser::TYPE_EOF)
    {
        if (elementType == XDMFParser::TYPE_START_TAG)
        {
            if (strcmp(xdmfParser.GetElementName(), "Xdmf") == 0)
            {
                ParseXdmf();
            }
            else
            {
                xdmfParser.SkipToEndTag();
            }
        }
        elementType = xdmfParser.GetNextElement();
    }
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::FreeUpResources(void)
{
    for (unsigned int i = 0; i < fileMeshList.size(); i++)
        delete fileMeshList[i];
    fileMeshList.clear();
    for (unsigned int i = 0; i < fileVarList.size(); i++)
        delete fileVarList[i];
    fileVarList.clear();
    for (unsigned int i = 0; i < fileDomainList.size(); i++)
        delete fileDomainList[i];
    fileDomainList.clear();

    fileRead = false;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::ActivateTimestep
//
//  Purpose: Provides a guarenteed collective entry point for operations
//    that may involve collective parallel communication.
//
//  Programmer: brugger
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::ActivateTimestep(void)
{
    //
    // Return if the data has been read.
    //
    if (fileRead)
        return;

    //
    // Read the XML file.
    //
    ParseXMLFile();

    //
    // Patch up the variable and mesh names to prepend the domain name
    // and mesh name if necessary to ensure unique names.
    //
    if (fileDomainList.size() == 1)
    {
        for (unsigned int i = 0; i < fileVarList.size(); i++)
        {
            VarInfo *varInfo = fileVarList[i];

            if (fileDomainList[varInfo->iDomain]->nGrids > 1)
            {
                varInfo->name = varInfo->meshName + "/" + varInfo->name;
            }
        }
    }
    else
    {
        for (unsigned int i = 0; i < fileMeshList.size(); i++)
        {
            MeshInfo *meshInfo = fileMeshList[i];

            meshInfo->name = fileDomainList[meshInfo->iDomain]->name + "/" +
                             meshInfo->name;
        }

        for (unsigned int i = 0; i < fileVarList.size(); i++)
        {
            VarInfo *varInfo = fileVarList[i];

            if (fileDomainList[varInfo->iDomain]->nGrids == 1)
            {
                varInfo->name = fileDomainList[varInfo->iDomain]->name + "/" +
                                varInfo->name;
            }
            else
            {
                varInfo->name = fileDomainList[varInfo->iDomain]->name + "/" +
                                varInfo->meshName + "/" + varInfo->name;
            }
            varInfo->meshName = fileDomainList[varInfo->iDomain]->name + "/" +
                                varInfo->meshName;
        }
    }

    fileRead = true;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

void
avtXDMFFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    //
    // Set the mesh information.
    //
    for (unsigned int i = 0; i < fileMeshList.size(); i++)
    {
        MeshInfo *meshInfo = fileMeshList[i];

        AddMeshToMetaData(md, meshInfo->name, meshInfo->type,
            meshInfo->extents, meshInfo->nBlocks, 0,
            meshInfo->spatialDimension, meshInfo->topologicalDimension);
    }   

    //
    // Set the variable information.  Handle scalars, vectors and tensors
    // all at the same time.
    //
    for (unsigned int i = 0; i < fileVarList.size(); i++)
    {
        VarInfo *varInfo = fileVarList[i];

        switch (varInfo->variableType)
        {
          case VarInfo::TYPE_SCALAR:
            AddScalarVarToMetaData(md, varInfo->name, varInfo->meshName,
                varInfo->centering);
            break;

          case VarInfo::TYPE_VECTOR:
            AddVectorVarToMetaData(md, varInfo->name, varInfo->meshName,
                varInfo->centering, varInfo->varDimension);
            break;

          default:
            AddTensorVarToMetaData(md, varInfo->name, varInfo->meshName,
                varInfo->centering, varInfo->varDimension);
            break;
        }
    }   
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::GetCurvilinearMesh
//
//  Purpose:
//      Gets the curvilinear mesh associated with this mesh info.  The mesh
//      is returned as a vtkStructuredGrid.
//
//  Arguments:
//      meshInfo    The MeshInfo structure describing the mesh.
//
//  Programmer: Eric Brugger
//  Creation:   Fri Nov 30 13:10:08 PST 2007
//
// ****************************************************************************

vtkDataSet *
avtXDMFFileFormat::GetCurvilinearMesh(MeshInfo *meshInfo)
{
    //
    // Create the VTK objects and connect them up.
    //
    vtkStructuredGrid    *sgrid   = vtkStructuredGrid::New();
    vtkPoints            *points  = vtkPoints::New();
    sgrid->SetPoints(points);
    points->Delete();

    //
    // Tell the grid what its dimensions are and populate the points array.
    //
    sgrid->SetDimensions(meshInfo->dimensions);

    //
    // Populate the coordinates.  Put in 3D points with z=0 if the
    // mesh is 2D.
    //
    int nnodes = meshInfo->dimensions[0] * meshInfo->dimensions[1] *
                 meshInfo->dimensions[2];

    points->SetNumberOfPoints(nnodes);
    float *pts = (float *) points->GetVoidPointer(0);

    switch (meshInfo->geometryType)
    {
      case MeshInfo::TYPE_XYZ:
        if (!ReadHDFDataItem(meshInfo->meshData[0], pts, 3 * nnodes))
        {
            sgrid->Delete();
            return NULL;
        }
        break;

      case MeshInfo::TYPE_XY:
        {
            float *coords = new float[2*nnodes];
            if (!ReadHDFDataItem(meshInfo->meshData[0], coords, 2 * nnodes))
            {
                delete [] coords;
                sgrid->Delete();
                return NULL;
            }
            for (int i = 0; i < nnodes; i++)
            {
                *pts++ = *coords++;
                *pts++ = *coords++;
                *pts++ = 0.;
            }
            delete [] coords;
        }
        break;

      case MeshInfo::TYPE_VXVYVZ:
        {
            float *xcoords = new float[nnodes];
            float *ycoords = new float[nnodes];
            float *zcoords = new float[nnodes];
            if (!ReadHDFDataItem(meshInfo->meshData[0], xcoords, nnodes))
            {
                delete [] xcoords; delete [] ycoords; delete [] zcoords;
                sgrid->Delete();
                return NULL;
            }
            if (!ReadHDFDataItem(meshInfo->meshData[1], ycoords, nnodes))
            {
                delete [] xcoords; delete [] ycoords; delete [] zcoords;
                sgrid->Delete();
                return NULL;
            }
            if (!ReadHDFDataItem(meshInfo->meshData[2], zcoords, nnodes))
            {
                for (int i = 0; i < nnodes; i++)
                {
                    *pts++ = *xcoords++;
                    *pts++ = *ycoords++;
                    *pts++ = 0.;
                }
            }
            else
            {
                for (int i = 0; i < nnodes; i++)
                {
                    *pts++ = *xcoords++;
                    *pts++ = *ycoords++;
                    *pts++ = *zcoords++;
                }
            }
            delete [] xcoords;
            delete [] ycoords;
            delete [] zcoords;
        }
        break;

      default:
        avtCallback::IssueWarning("GetMesh: Invalid GeometryType.");
        break;
    }

    return sgrid;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

vtkDataSet *
avtXDMFFileFormat::GetMesh(int domain, const char *meshname)
{
    debug2 << "avtXDMFFileFormat::GetMesh: domain = " << domain
           << ",meshname = " << meshname << endl;

    //
    // Determine the mesh to return.
    //
    MeshInfo *meshInfo = NULL;
    for (unsigned int i = 0; i < fileMeshList.size(); i++)
    {
        if (strcmp(fileMeshList[i]->name.c_str(), meshname) == 0)
        {
            meshInfo = fileMeshList[i];
            break;
        }
    }
    if (meshInfo != NULL && meshInfo->blockList.size() > 0)
    {
        if (domain >= meshInfo->blockList.size())
        {
            debug1 << "GetMesh: Invalid domain number." << endl;
            return NULL;
        }
        else
        {
            meshInfo = meshInfo->blockList[domain];
        }
    }
    if (meshInfo == NULL)
    {
        debug1 << "GetMesh: Invalid mesh name." << endl;
        return NULL;
    }

    //
    // Get the dataset.
    //
    vtkDataSet *ds = NULL;
    switch (meshInfo->type)
    {
      case AVT_RECTILINEAR_MESH:
        break;
      case AVT_CURVILINEAR_MESH:
        ds = GetCurvilinearMesh(meshInfo);
        break;
      default:
        break;
    }
    
    return ds;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

vtkDataArray *
avtXDMFFileFormat::GetVar(int domain, const char *varname)
{
    debug2 << "avtXDMFFileFormat::GetVar: domain = " << domain
           << ",varname = " << varname << endl;

    //
    // Determine the variable to return.
    //
    VarInfo *varInfo = NULL;
    for (unsigned int i = 0; i < fileVarList.size(); i++)
    {
        if (strcmp(fileVarList[i]->name.c_str(), varname) == 0)
        {
            varInfo = fileVarList[i];
            break;
        }
    }
    if (varInfo == NULL)
    {
        avtCallback::IssueWarning("GetVar: Invalid variable name.");
        return NULL;
    }
    if (varInfo->blockList.size() > 0)
    {
        if (domain >= varInfo->blockList.size())
        {
            return NULL;
        }
        else
        {
            varInfo = varInfo->blockList[domain];
            if (varInfo == NULL)
            {
                return NULL;
            }
        }
    }

    //
    // Determine the size of the data.
    //
    int ntuples = 1;
    for (int i = 0; i < varInfo->varData->nDims; i++)
        ntuples *= varInfo->varData->dims[i];

    //
    // Create the data array.
    //
    vtkFloatArray *rv = vtkFloatArray::New();
    rv->SetNumberOfTuples(ntuples);

    //
    // Read the data.
    //
    void *buf = rv->GetVoidPointer(0);
    if (!ReadHDFDataItem(varInfo->varData, buf, ntuples))
    {
        rv->Delete();
        rv = NULL;
    }

    return rv;
}


// ****************************************************************************
//  Method: avtXDMFFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Nov 14 11:28:35 PDT 2007
//
// ****************************************************************************

vtkDataArray *
avtXDMFFileFormat::GetVectorVar(int domain, const char *varname)
{
    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
    return NULL;
}
