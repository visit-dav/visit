// ************************************************************************* //
//                            avtH5PartFileFormat.C                           //
// ************************************************************************* //

#define H5_USE_16_API
#include <hdf5.h>

#include <avtH5PartFileFormat.h>

#include <string>
#include <vector>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>
#include <DBOptionsAttributes.h>

#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidFilesException.h>
#include <InvalidDBTypeException.h>
#include <BadIndexException.h>
#include <vtkCellType.h>
#include <vtkPolyData.h>


//H5Part specific
#include <stdio.h>
#include <stdlib.h>

#include <fstream>
#include <iomanip>
#include <iostream>

#include <DebugStream.h>

#ifdef PARALLEL
#include <avtParallel.h>
#endif

using namespace std;

// ****************************************************************************
//  Method: avtH5Part constructor
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
//  Modifications:
//    Kathleen Bonnell, Wed Jul 2 8:49:52 PDT 2008
//    Removed unreferenced variables.
//
//    Gunther H. Weber, Fri Apr 17 12:42:38 PDT 2009
//    Added option allowing to ignore files with FastBit index so that
//    they get passed on to the HDF_UC file format.
//
//    Gunther H. Weber, Fri Apr 17 14:24:33 PDT 2009
//    Fixed handling of FastBit option in case there is a config file without
//    the option saved.
//
// ****************************************************************************

avtH5PartFileFormat::avtH5PartFileFormat(const char *filename,
        DBOptionsAttributes *atts) : avtMTMDFileFormat(filename)
{
    // Depending on options reject file if it has a FastBit index
    bool ignoreFilesWithFastBitIndex = true;
    if (atts != NULL)
        for (int i = 0; i < atts->GetNumberOfOptions(); ++i)
            if (atts->GetName(i) == "Ignore files with FastBit index")
                ignoreFilesWithFastBitIndex =
                    atts->GetBool("Ignore files with FastBit index");
 
    if (ignoreFilesWithFastBitIndex)
    {
        bool hasIndex = false;
        hid_t filehandle = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
        if (filehandle > 0)
        {
            //
            // Get current automatic stack traversal function to re-enable it later and
            // disable HDF5's automatic error printing
            //
            H5E_auto_t h5e_autofunc;
            void* h5e_clientdata;
            H5Eget_auto(&h5e_autofunc, &h5e_clientdata);
            H5Eset_auto(0, 0);

            hid_t indexGroup = H5Gopen(filehandle, "__H5PartIndex__");
            if (indexGroup > 0)
            {
                hasIndex = true;
                H5Gclose(indexGroup);
            }

            //
            // Re-enable HDF5's automatic diagnostic output
            //
            H5Eset_auto(h5e_autofunc, h5e_clientdata);

            H5Fclose(filehandle);
        }
        else
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a H5Part file, since "
                                "it is not even an HDF5 file.");
        }
        
        if (hasIndex)
        {
            EXCEPTION1(InvalidDBTypeException, "May be an H5Part file, but has an "
                    "FastBit index. Rejecting file so that HDF_UC plugin can take "
                    "a turn. If you want to open this file with the H5Part plugin "
                    " disable the file reader option \"Ignore files with FastBit "
                    " index\".");
        }
    }

    // INITIALIZE DATA MEMBERS
    H5PartFile *file;
    fname = filename;

    file = H5PartOpenFile(filename,H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, filename);


    int npoints, npointvars;
    int nspace = 3;

    H5PartSetStep(file,0);
    //points
    npoints= (int) H5PartGetNumParticles(file);
    if (npoints ==  0)
        EXCEPTION1(VisItException, "npoints is zero");
    points.resize(npoints*nspace);
    debug5 << "constructor: npoints: " << npoints << "\n";

    //point vars
    npointvars= (int) H5PartGetNumDatasets(file); /* get number of datasets in timestep 0 */
    pointvars.resize(npointvars);
    pointvarnames.resize(npointvars);
    debug5 << "constructor: nvariables: " << npointvars << "\n";

    char name[128];
    h5part_int64_t status;
    for (int j=0; j < npointvars; j++)
    {
        status = H5PartGetDatasetName(file,j, name,128);
        if (status != H5PART_SUCCESS)
        {
            EXCEPTION1(VisItException, "could not read a variable name");
        }
        pointvarnames[j] = name;
    }


    // H5Block data
    h5part_int64_t nFields = H5BlockGetNumFields(file);
    h5part_int64_t gridRank;
    h5part_int64_t gridDims[3];
    h5part_int64_t fieldDims;

    // store global field information
    for (h5part_int64_t idx=0; idx < nFields; idx++)
    {
        const h5part_int64_t lenName = 64;
        char name[lenName];

        status = H5BlockGetFieldInfo (file, idx, name, lenName,
                &gridRank, gridDims, &fieldDims);
        if ( status != H5PART_SUCCESS ) 
            EXCEPTION1(VisItException, "Could not read field information.");

        fieldNames.push_back(name);
        fieldExtents.push_back((int)fieldDims);
    }

    H5PartCloseFile(file);
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
// ****************************************************************************

int
avtH5PartFileFormat::GetNTimesteps(void)
{
    h5part_int64_t nt;
    H5PartFile *file;
    file = H5PartOpenFile(fname.c_str(),H5PART_READ);
    H5PartSetStep(file,0);
    nt=H5PartGetNumSteps(file); /* get number of steps in file */
    H5PartCloseFile(file);
    return (int) nt;
}


// ****************************************************************************
//  Method: avtH5PartFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
// ****************************************************************************

void
avtH5PartFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtH5PartFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
//  Modifications:
//    Kurt Stockinger, Tue Aug 28 17:35:50 PDT 2007
//    Added support for field data
//
// ****************************************************************************

void
avtH5PartFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    int size = 1;
#ifdef PARALLEL
    size = PAR_Size();
#endif

    // H5Part
    if (!points.size())
    {
        EXCEPTION1(InvalidFilesException, "Number of points is zero");
    }

    debug5 << "Populate: size, : " << size << "\n";

    avtMeshMetaData *pmesh = new avtMeshMetaData;

    int dimension = 3;
    pmesh->name = "particles";
    pmesh->originalName = "particles";
    pmesh->meshType = AVT_POINT_MESH;
    pmesh->topologicalDimension = 0;
    pmesh->spatialDimension = dimension;
    debug5 << "Spatial dimension: " << pmesh->spatialDimension << endl;
    pmesh->numBlocks = size;
    pmesh->blockTitle = "subset";
    pmesh->blockPieceName = "subset";
    pmesh->hasSpatialExtents = false; 

    md->Add(pmesh);

    int i;
    for (i=0; i < pointvarnames.size(); i++)
    {
        AddScalarVarToMetaData(md, pointvarnames[i], "particles", AVT_NODECENT);
    }

    // H5Block
    string meshName = "fields"; 
    avtMeshType mt = AVT_RECTILINEAR_MESH;

    int nblocks = size;
    int blockOrigin = 0;
    int spatialDimension = 3;
    int topologicalDimension = 3;
    int vectorDim = 3;
    double *extents = NULL;

    AddMeshToMetaData(md, meshName, mt, extents, nblocks, blockOrigin,
            spatialDimension, topologicalDimension);
    avtCentering cent = AVT_NODECENT;

    // add scalar and vector fields
    for (unsigned int i =0; i < fieldNames.size(); i++)
    {
        if (fieldExtents[i] == 1)
        {
            AddScalarVarToMetaData(md, fieldNames[i], meshName, cent);
        }
        else
        {
            AddVectorVarToMetaData(md, fieldNames[i], meshName, cent, vectorDim);
        }
    }
}


// ****************************************************************************
//  Method: avtH5PartFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
//  Modifications:
//    Kurt Stockinger, Tue Aug 28 17:35:50 PDT 2007
//    Added support for field data
//
//    Kathleen Bonnell, Wed Jul 2 08:50:02 PDT 2008 
//    Removed unreferenced variables.
//
// ****************************************************************************

vtkDataSet *
avtH5PartFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    debug5 << "GetMesh domain: " << domain << "\n";


    if (strcmp(meshname, "fields") == 0)
    {
        return GetMeshBlock(timestate, domain);
    }
    else if (strcmp(meshname, "particles") != 0)
    {
        EXCEPTION1(InvalidVariableException, meshname);
        return 0;
    }

    debug5 << "GetMesh Particles..." << endl;

    H5PartFile *file;
    file = H5PartOpenFile(fname.c_str(),H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, fname.c_str());

    long int tnpoints, npoints;
    int nspace = 3;
    int nprocs = 1;
#ifdef PARALLEL
    nprocs = PAR_Size();	
#endif

    H5PartSetStep(file,timestate);

    //points
    tnpoints= (int) H5PartGetNumParticles(file);
    h5part_int64_t idStart = (( h5part_int64_t)(tnpoints/nprocs))*domain;
    h5part_int64_t idEnd;	
    if (domain < nprocs-1) 
        idEnd   = ((h5part_int64_t)(tnpoints/nprocs))*(domain+1);
    else if (domain == nprocs - 1)
        idEnd   = tnpoints;


    H5PartSetView(file,idStart,idEnd);

    //points
    npoints= (long int) H5PartGetNumParticles(file);
    debug5 << "GetMesh: npoints for domain " << domain << ": " << npoints << "\n";

    if (npoints ==  0)
        EXCEPTION1(VisItException, "npoints is zero");

    points.resize(npoints*nspace);
    h5part_float64_t *x, *y, *z;
    x = (h5part_float64_t *) malloc(sizeof(h5part_float64_t)*npoints);
    y = (h5part_float64_t *) malloc(sizeof(h5part_float64_t)*npoints);
    z = (h5part_float64_t *) malloc(sizeof(h5part_float64_t)*npoints);


    h5part_int64_t status = H5PART_SUCCESS; 
    status = H5PartReadDataFloat64(file, "x", x);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read x coordinates");
    status = H5PartReadDataFloat64(file, "y", y);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read y coordinates");
    status = H5PartReadDataFloat64(file, "z", z);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read z coordinates");
    for (long int i = 0; i < npoints; i++)
    {
        points[nspace*i] = (float) x[i];
        points[nspace*i+1] = (float) y[i];
        points[nspace*i+2] = (float) z[i];
        //debug5 << i << ": " << x[i] << " " << y[i] << " " << z[i] << endl;
    }
    free(x);
    free(y);
    free(z);

    H5PartSetView(file,-1, -1);

    vtkPolyData *dataset = vtkPolyData::New();
    vtkPoints *vtkpoints = vtkPoints::New();
    vtkpoints->SetNumberOfPoints((vtkIdType) npoints);

    float *pts = (float *) vtkpoints->GetVoidPointer(0);

    for (long int i=0; i < npoints*nspace; i++)
    {
        pts[i] = points[i];
    }

    dataset->Allocate(npoints*nspace);
    for (long int i=0; i < npoints; i++)
    {
        vtkIdType onevertex = (vtkIdType) i;
        dataset->InsertNextCell(VTK_VERTEX, 1, &onevertex);
    }
    dataset->SetPoints(vtkpoints);
    vtkpoints->Delete();


    H5PartCloseFile(file);
    debug5 << "Proc [" << domain << "]: done" << std::endl;

    return dataset;
}

// ****************************************************************************
//  Method: avtH5PartFileFormat::GetMeshBlock
//
//  Purpose:
//      Gets the mesh associated with fields of this file
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//
//  Programmer: kurts
//  Creation:   Tue Aug 28 17:35:50 PDT 2007
//
//  Modifications:
//    Gunther H. Weber, Fri Apr 17 13:55:07 PDT 2009
//    Read block origin from file.
//
// ****************************************************************************

vtkDataSet *
avtH5PartFileFormat::GetMeshBlock(int timestate, int domain)
{
    debug5 << "GetMeshBlock..." << endl;

    int nprocs = 1;
    h5part_int64_t status = H5PART_SUCCESS; 
    const h5part_int64_t lenFieldName = 64;
    char fieldName[lenFieldName];
    h5part_int64_t gridRank;
    h5part_int64_t gridDims[3];
    h5part_int64_t fieldDims;
    vtkFloatArray *coords[3] = {0, 0, 0};

    H5PartFile *file;
    file = H5PartOpenFile(fname.c_str(),H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, fname.c_str());

#ifdef PARALLEL
    nprocs = PAR_Size();	
#endif

    H5PartSetStep (file, timestate);

    // assume all fields have the same dimensions
    // get information from first field
    status = H5BlockGetFieldInfo (file, 0, fieldName, lenFieldName,
            &gridRank, gridDims, &fieldDims);


    h5part_int64_t subBlockDims[6];
    GetSubBlock(domain, gridDims, subBlockDims);

    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read field information");

    double xOrigin = 0;
    double yOrigin = 0;
    double zOrigin = 0;
    status = H5Block3dGetFieldOrigin(file, fieldName, &xOrigin, &yOrigin, &zOrigin);
    if (status != H5PART_SUCCESS)
    {
        EXCEPTION1(VisItException, "Could not read field origin.");
    }

    double xSpacing = 0;
    double ySpacing = 0;
    double zSpacing = 0;

    status = H5Block3dGetFieldSpacing (file, fieldName, &xSpacing, &ySpacing, &zSpacing);
    if (status != H5PART_SUCCESS)
    {
        EXCEPTION1(VisItException, "Could not read field spacing.");
    }

    debug5 << "xSpacing: " << xSpacing << "\n";
    debug5 << "ySpacing: " << ySpacing << "\n";
    debug5 << "zSpacing: " << zSpacing << "\n";

    // set x coordinates
    coords[0] = vtkFloatArray::New();
    coords[0]->SetNumberOfTuples(subBlockDims[1] - subBlockDims[0] + 1);
    float *xarray = (float *) coords[0]->GetVoidPointer(0);
    for (int i=subBlockDims[0]; i <= subBlockDims[1]; i++)
    {
        xarray[i-subBlockDims[0]] = xOrigin + i * xSpacing;
    }

    // set y coordinates
    coords[1] = vtkFloatArray::New();
    coords[1]->SetNumberOfTuples(subBlockDims[3] - subBlockDims[2] + 1);
    float *yarray = (float *) coords[1]->GetVoidPointer(0);
    for (int i=subBlockDims[2]; i <= subBlockDims[3]; i++) {
        yarray[i-subBlockDims[2]] = yOrigin + i * ySpacing;
    }

    // set z coordinates
    coords[2] = vtkFloatArray::New();
    coords[2]->SetNumberOfTuples(subBlockDims[5] - subBlockDims[4] + 1);
    float *zarray = (float *) coords[2]->GetVoidPointer(0);
    for (int i=subBlockDims[4]; i <= subBlockDims[5]; i++) {
        zarray[i-subBlockDims[4]] = zOrigin + i * zSpacing;
    }

    // create vtkRectilinearGrid objects + set dims and coords
    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
    rgrid->SetDimensions(coords[0]->GetNumberOfTuples(), coords[1]->GetNumberOfTuples(), coords[2]->GetNumberOfTuples());
    rgrid->SetXCoordinates(coords[0]);
    coords[0]->Delete();
    rgrid->SetYCoordinates(coords[1]);
    coords[1]->Delete();
    rgrid->SetZCoordinates(coords[2]);
    coords[2]->Delete();

    H5PartCloseFile(file);

    return rgrid;

}

// ****************************************************************************
//  Method: avtH5PartFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: cristina -- generated by xml2avt
//              extended by Kurt Stockiger
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
//  Modifications:
//    Kurt Stockinger, Tue Aug 28 17:35:50 PDT 2007
//    Added support for field data
//
//    Kathleen Bonnell, Wed Jul 2 8:49:52 PDT 2008
//    Removed unreferenced variables.
//
// ****************************************************************************

vtkDataArray *
avtH5PartFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    // check if varname is a scalar field (H5Block)

    for (unsigned int i =0; i < fieldNames.size(); i++) {
        if ((strcmp(varname, fieldNames[i].c_str()) == 0) && (fieldExtents[i] == 1)) {
            return GetVarBlock(timestate, domain, varname);
        }
    }

    H5PartFile *file;

    file = H5PartOpenFile(fname.c_str(),H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, fname.c_str());

    h5part_int64_t status;
    h5part_int64_t tnpoints, npoints;
    int nspace = 3;
    int nprocs = 1;
#ifdef PARALLEL
    nprocs = PAR_Size(); 
#endif

    H5PartSetStep(file,timestate);
    //points
    tnpoints= H5PartGetNumParticles(file);
    //point vars

    char name[64];
    h5part_int64_t *idvar;
    double *data;
    h5part_int64_t idStart = ((h5part_int64_t)(tnpoints/nprocs))*domain;
    h5part_int64_t idEnd; 
    if (domain < nprocs-1) 
        idEnd   = ((h5part_int64_t)(tnpoints/nprocs))*(domain+1);
    else if (domain == nprocs - 1)
        idEnd   = (h5part_int64_t)tnpoints;

    H5PartSetView(file,idStart,idEnd);
    npoints= H5PartGetNumParticles(file);
    debug5 << "GetVar: npoints for domain " << domain << ": " << npoints << "\n"; 

    for (size_t j=0; j < (size_t)(pointvarnames.size()); j++)
    {
        status = H5PartGetDatasetName(file,j, name,64);
        if (pointvarnames[j] == name)
        {
            if (strstr(name, "id") != NULL)
            {
                idvar = (h5part_int64_t *) malloc(sizeof(h5part_int64_t)*npoints);
                status = H5PartReadDataInt64(file, name, idvar);
                if (status != H5PART_SUCCESS)
                    EXCEPTION1(VisItException, "Could not read dataset");
                pointvars[j].resize(npoints);
                for (size_t i=0; i < (size_t) npoints; i++)
                {
                    pointvars[j][i] = (float) idvar[i];
                }
                if (idvar != NULL)
                    free(idvar);
            }
            else
            {
                data = (h5part_float64_t *) malloc(sizeof(h5part_float64_t)*npoints);
                status = H5PartReadDataFloat64(file, name, data);
                if (status != H5PART_SUCCESS)
                    EXCEPTION1(VisItException, "Could not read dataset");
                pointvars[j].resize(npoints);
                for (size_t i=0; i < (size_t)(npoints); i++)
                {
                    pointvars[j][i] = (float) data[i];
                }
                if (data != NULL)
                    free(data);
            }
        }
    }
    H5PartSetView(file,-1, -1);

    for (int i=0; i < pointvarnames.size(); i++)
    {
        if (pointvarnames[i] == string(varname))
        {
            vtkFloatArray *scalars = vtkFloatArray::New();
            scalars->SetNumberOfTuples(npoints);
            float *ptr = (float*) scalars->GetVoidPointer(0);
            memcpy(ptr, &pointvars[i][0], sizeof(float)*npoints);
            return scalars;
        }
    }
    H5PartCloseFile(file);
    EXCEPTION1(InvalidVariableException, varname);
}

// ****************************************************************************
//  Method: avtH5PartFileFormat::GetVarBlock
//
//  Purpose:
//      Get a scalar variable associated with the field mesh of this file
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: kurts
//  Creation:   Tue Aug 28 17:35:50 PDT 2007
//
// ****************************************************************************


vtkDataArray *
avtH5PartFileFormat::GetVarBlock(int timestate, int domain, const char* varname)
{
    const h5part_int64_t lenFieldName = 64;
    char fieldName[lenFieldName];
    h5part_int64_t gridRank;
    h5part_int64_t gridDims[3];
    h5part_int64_t fieldDims;
    h5part_int64_t status = H5PART_SUCCESS; 

    debug5 << "GetVarBlock... \n"; 
    H5PartFile *file;
    file = H5PartOpenFile(fname.c_str(),H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, fname.c_str());

    H5PartSetStep (file, timestate);
    status = H5BlockGetFieldInfo (file, 0, fieldName, lenFieldName,
            &gridRank, gridDims, &fieldDims);

    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read field information.");


    h5part_int64_t subBlockDims[6];
    GetSubBlock(domain, gridDims, subBlockDims);

    // set field layout
    status = H5BlockDefine3DFieldLayout (file, 
            subBlockDims[0], subBlockDims[1], 
            subBlockDims[2], subBlockDims[3], 
            subBlockDims[4], subBlockDims[5]);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not set field layout");

    // read data
    int nValues = (subBlockDims[1] - subBlockDims[0] + 1) * (subBlockDims[3] - subBlockDims[2] + 1) * (subBlockDims[5] - subBlockDims[4] + 1);
    h5part_float64_t *data;
    data = (h5part_float64_t*) malloc (nValues * sizeof ( h5part_float64_t) );

    status = H5Block3dReadScalarField ( file, varname, data );
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read scalar field.");
    debug5 << "GetVarBlock::H5Block3dReadScalarField - END \n";

    // store data in VTK object
    vtkFloatArray *array = vtkFloatArray::New();
    array->SetNumberOfTuples(nValues);
    float *vtkData = (float *) array->GetVoidPointer(0);
    for (int i = 0; i < nValues; i++)
    {
        vtkData[i] = (float) data[i];
    }

    free(data);
    H5PartCloseFile(file);

    return array;
}

// ****************************************************************************
//  Method: avtH5PartFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: cristina -- generated by xml2avt
//  Creation:   Mon Feb 27 13:47:07 PST 2006
//
//  Modifications:
//    Kurt Stockinger, Tue Aug 28 17:35:50 PDT 2007
//    Added support for field data
//
// ****************************************************************************

vtkDataArray *
avtH5PartFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    int nprocs = 1;
    const h5part_int64_t lenFieldName = 64;
    char fieldName[lenFieldName];
    h5part_int64_t gridRank;
    h5part_int64_t gridDims[3];
    h5part_int64_t fieldDims;
    h5part_int64_t status = H5PART_SUCCESS; 


    debug5 << "GetVectorVar... \n"; 
    H5PartFile *file;
    file = H5PartOpenFile(fname.c_str(),H5PART_READ);

    if (!file)
        EXCEPTION1(InvalidFilesException, fname.c_str());

#ifdef PARALLEL
    nprocs = PAR_Size();	
#endif

    H5PartSetStep (file, timestate);
    status = H5BlockGetFieldInfo (file, 0, fieldName, lenFieldName,
            &gridRank, gridDims, &fieldDims);

    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read field information.");

    h5part_int64_t subBlockDims[6];
    GetSubBlock(domain, gridDims, subBlockDims);

    // set field layout
    status = H5BlockDefine3DFieldLayout (file, 
            subBlockDims[0], subBlockDims[1], 
            subBlockDims[2], subBlockDims[3], 
            subBlockDims[4], subBlockDims[5]);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not set field layout");

    // read data
    int nValues = (subBlockDims[1] - subBlockDims[0] + 1) * (subBlockDims[3] - subBlockDims[2] + 1) * (subBlockDims[5] - subBlockDims[4] + 1);
    h5part_float64_t *xval;
    h5part_float64_t *yval;
    h5part_float64_t *zval;

    xval = (h5part_float64_t*) malloc (nValues * sizeof ( h5part_float64_t) );
    yval = (h5part_float64_t*) malloc (nValues * sizeof ( h5part_float64_t) );
    zval = (h5part_float64_t*) malloc (nValues * sizeof ( h5part_float64_t) );

    status = H5Block3dRead3dVectorField(file, varname, xval, yval, zval);
    if (status != H5PART_SUCCESS)
        EXCEPTION1(VisItException, "Could not read vector field.");

    // store data in VTK object
    vtkFloatArray *array = vtkFloatArray::New();
    array->SetNumberOfComponents(3);
    array->SetNumberOfTuples(nValues);
    float *vtkData = (float *) array->GetVoidPointer(0);
    for (int i = 0; i < nValues; i++)
    {
        *vtkData++ = (float) xval[i];
        *vtkData++ = (float) yval[i];
        *vtkData++ = (float) zval[i];
    }

    free(xval);
    free(yval);
    free(zval);

    H5PartCloseFile(file);

    return array;

}

// ****************************************************************************
//  Method: avtH5PartFileFormat::GetSubBlock
//
//  Purpose:
//      Compute extents of a sub bliock for a given processor id
//
//  Arguments:
//      blockno       The index of the block/processor
//      gridDims      Number of nodes in x-/y-/z-direction
//
//  Output:
//      subBlockDims  Range of samples that this processor should read. Order
//                    i_min, i_max, j_min, j_max, k_min, k_max. Indices are
//                    inclusive, i.e., processor should also read samples i_min
//                    and i_max as well as all samples with indices in between.
//
//  Programmer: kurts and ghweber
//  Creation:   Tue Aug 28 17:35:50 PDT 2007
//
// ****************************************************************************


void avtH5PartFileFormat::GetSubBlock(int blockNo, h5part_int64_t gridDims[3], h5part_int64_t subBlockDims[6])
{
#ifdef PARALLEL
    int partitionAxis =0;
    int axis1 = 1;
    int axis2 = 2;

    if (gridDims[1] > gridDims[0] && gridDims[1] > gridDims[2])
    {
        partitionAxis = 1;
        axis1 = 0;
        axis2 = 2;
    }
    else if (gridDims[2] > gridDims[0] && gridDims[2] > gridDims[1])
    {
        axis1 = 0;
        axis2 = 1;
        partitionAxis = 2;
    }
    debug1 << "Grid dims are "
        << gridDims[0] << " " << gridDims[1] << " " << gridDims[2]
        << " partition axis is " << partitionAxis
        << " other axes are " << axis1 << " " << axis2 << std::endl;

    subBlockDims[2*axis1+0] = 0;
    subBlockDims[2*axis1+1] = gridDims[axis1] - 1;

    subBlockDims[2*axis2+0] = 0;
    subBlockDims[2*axis2+1] = gridDims[axis2] - 1;

    int numPartsForPartition = std::min(h5part_int64_t(PAR_Size()), gridDims[partitionAxis]);
    float slicesPerProcessor = float(gridDims[partitionAxis]) / float(numPartsForPartition);
    debug1 << "Slices per processor: " << slicesPerProcessor << std::endl;

    subBlockDims[2*partitionAxis+0] = int(blockNo*slicesPerProcessor);
    subBlockDims[2*partitionAxis+1] = int((blockNo+1)*slicesPerProcessor);
    if (blockNo == numPartsForPartition - 1)
    {
        // Make sure that we include the final slice and do not include anything beyond
        subBlockDims[2*partitionAxis+1] = gridDims[partitionAxis] - 1; 
    }
    debug1 << "Processor " << blockNo << " has block "
        << subBlockDims[0] << " " << subBlockDims[1] << " "
        << subBlockDims[2] << " " << subBlockDims[3] << " "
        << subBlockDims[4] << " " << subBlockDims[5] << std::endl;

#else
    subBlockDims[2*0+0] = 0;
    subBlockDims[2*0+1] = gridDims[0] - 1;

    subBlockDims[2*1+0] = 0;
    subBlockDims[2*1+1] = gridDims[1] - 1;

    subBlockDims[2*2+0] = 0;
    subBlockDims[2*2+1] = gridDims[2] - 1;
#endif
}
