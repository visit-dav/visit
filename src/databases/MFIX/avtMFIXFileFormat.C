// ************************************************************************* //
//                            avtMFIXFileFormat.C                           //
// ************************************************************************* //

#include <avtMFIXFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <Expression.h>

#include <InvalidVariableException.h>

using namespace std;

// ****************************************************************************
//  Method: avtMFIX constructor
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

avtMFIXFileFormat::avtMFIXFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{

  this->DimensionIc = 5;
  this->DimensionBc = 5;
  this->DimensionC = 5;
  this->DimensionIs = 5;
  this->NumberOfSPXFilesUsed = 9;

  strcpy(this->RestartFileName, filename);
  ReadRestartFile(filename);
  CreateVariableNames(filename);
  GetTimeSteps(filename);
  this->MaxTimeStep = GetMaxTimeStep();
  MakeTimeStepTable();
  GetNumberOfVariablesInSPXFiles();
  MakeSPXTimeStepIndexTable();

  Points = vtkPoints::New();
  FluidMesh = vtkUnstructuredGrid::New();
  InletMesh = vtkUnstructuredGrid::New();
  OutletMesh = vtkUnstructuredGrid::New();
  ObstructionMesh = vtkUnstructuredGrid::New();
  AHexahedron = vtkHexahedron::New();
  AWedge = vtkWedge::New();
  AQuad = vtkQuad::New();

  MakeMeshes();

}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

int
avtMFIXFileFormat::GetNTimesteps(void)
{
    return this->MaxTimeStep;
}


// ****************************************************************************
//  Method: avtMFIXFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

void
avtMFIXFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtMFIXFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

void
avtMFIXFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  avtMeshMetaData *mesh = new avtMeshMetaData;
  mesh->name = "Mesh";
  mesh->meshType = AVT_UNSTRUCTURED_MESH;
  mesh->topologicalDimension = 3;
  mesh->spatialDimension = 3;
  mesh->numBlocks = 4;
  mesh->blockNames.push_back("Fluid");
  mesh->blockNames.push_back("Inlet");
  mesh->blockNames.push_back("Outlet");
  mesh->blockNames.push_back("Walls");
  mesh->hasSpatialExtents = false;
  md->Add(mesh);

  int i;
  for (i=0; i < VariableNames.size(); i++)
    {
    if (VariableComponents[i] == 1)
      {
      AddScalarVarToMetaData(md, VariableNames[i], "Mesh", AVT_ZONECENT);
      }
    else
      {
      AddVectorVarToMetaData(md, VariableNames[i], "Mesh", AVT_ZONECENT);
      }
    }

}


// ****************************************************************************
//  Method: avtMFIXFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

vtkDataSet *
avtMFIXFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
  vtkUnstructuredGrid *dataset = vtkUnstructuredGrid::New();

  if (domain == 0)
    {
    dataset->DeepCopy(this->FluidMesh);
    }
  else if (domain == 1)
    {
    dataset->DeepCopy(this->InletMesh);
    }
  else if (domain == 2)
    {
    dataset->DeepCopy(this->OutletMesh);
    }
  else
    {
    dataset->DeepCopy(this->ObstructionMesh);
    }

  return dataset;
}


// ****************************************************************************
//  Method: avtMFIXFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

vtkDataArray *
avtMFIXFileFormat::GetVar(int timestate, int domain, const char *varname)
{

  int vari = 0;
  for ( int i = 0; i < VariableNames.size(); i++)
    {
    if ( !strcmp(VariableNames[i].c_str(), varname))
      {
      vari = i;
      }
    }

  vtkFloatArray *v = vtkFloatArray::New();

  if (domain == 0)
    {
    GetVariableAtTimestep(vari , timestate, v, this->RestartFileName);
    }
  else if (domain == 1)
    {
    for (int i = 0; i<this->InletMesh->GetNumberOfCells(); i++)
      {
      v->InsertValue(i, 0);
      }
    }
  else if (domain == 2)
    {
    for (int i = 0; i<this->OutletMesh->GetNumberOfCells(); i++)
      {
      v->InsertValue(i, 0);
      }
    }
  else
    {
    for (int i = 0; i<this->ObstructionMesh->GetNumberOfCells(); i++)
      {
      v->InsertValue(i, 0);
      }
    }
  return v;
}


// ****************************************************************************
//  Method: avtMFIXFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: bdotson -- generated by xml2avt
//  Creation:   Fri May 26 08:59:22 PDT 2006
//
// ****************************************************************************

vtkDataArray *
avtMFIXFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{

  int vari = 0;
  for ( int i = 0; i < VariableNames.size(); i++)
    {

    if ( !strcmp(VariableNames[i].c_str(), varname))
      {
      vari = i;
      }
    }

  vtkFloatArray *v = vtkFloatArray::New();
  v->SetNumberOfComponents(3);
  vtkFloatArray *x = vtkFloatArray::New();
  vtkFloatArray *y = vtkFloatArray::New();
  vtkFloatArray *z = vtkFloatArray::New();

  if (domain == 0)
    {
    GetVariableAtTimestep(vari-3 , timestate, x, this->RestartFileName);
    GetVariableAtTimestep(vari-2 , timestate, y, this->RestartFileName);
    GetVariableAtTimestep(vari-1 , timestate, z, this->RestartFileName);

    for ( int i = 0; i <= x->GetMaxId(); i++)
      {
      v->InsertComponent(i, 0, x->GetValue(i));
      v->InsertComponent(i, 1, y->GetValue(i));
      v->InsertComponent(i, 2, z->GetValue(i));
      }

    x->Delete();
    y->Delete();
    z->Delete();
    }
  else if (domain == 1)
    {
    for (int i = 0; i<this->InletMesh->GetNumberOfCells(); i++)
      {
      v->InsertComponent(i, 0, 0);
      v->InsertComponent(i, 1, 0);
      v->InsertComponent(i, 2, 0);
      }
    }
  else if (domain == 2)
    {
    for (int i = 0; i<this->OutletMesh->GetNumberOfCells(); i++)
      {
      v->InsertComponent(i, 0, 0);
      v->InsertComponent(i, 1, 0);
      v->InsertComponent(i, 2, 0);
      }
    }
  else
    {
    for (int i = 0; i<this->ObstructionMesh->GetNumberOfCells(); i++)
      {
      v->InsertComponent(i, 0, 0);
      v->InsertComponent(i, 1, 0);
      v->InsertComponent(i, 2, 0);
      }
    }

  return v;
}

//----------------------------------------------------------------------------
void avtMFIXFileFormat::ReadRestartFile(const char *filename)
{
  int dimensionUsr = 5;
  ifstream in(filename,ios::binary);
  if (!in)
    {
    cout << "could not open file" << endl;
    return;
    }

  this->DataBuffer[512] = '\0';

  // version : record 1
  memset(this->DataBuffer,0,513);
  in.read(this->DataBuffer,512);
  RestartVersionNumber(this->DataBuffer);

  // skip 2 linesline : records 2 and 3
  in.read(this->DataBuffer,512);
  in.read(this->DataBuffer,512);

  // IMinimum1 etc : record 4
  memset(this->DataBuffer,0,513);

  if (Version == "RES = 01.00")
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);

    // 15 ints ... 4 doubles = 92 bytes
    this->SkipBytes(in,420);
    }
  else if (Version == "RES = 01.01" || Version == "RES = 01.02")
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetInt(in,this->DimensionIc);
    this->GetInt(in,this->DimensionBc);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);

    // 17 ints ... 4 doubles = 100 bytes
    this->SkipBytes(in,412);
    }
  else if(Version == "RES = 01.03")
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetInt(in,this->DimensionIc);
    this->GetInt(in,this->DimensionBc);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XMinimum);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);

    // 17 ints ... 5 doubles = 108 bytes
    this->SkipBytes(in,404);
    }
  else if(Version == "RES = 01.04")
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetInt(in,this->DimensionIc);
    this->GetInt(in,this->DimensionBc);
    this->GetInt(in,this->DimensionC);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XMinimum);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);

    // 18 ints ... 5 doubles = 112 bytes
    this->SkipBytes(in,400);
    }
  else if(Version == "RES = 01.05")
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetInt(in,this->DimensionIc);
    this->GetInt(in,this->DimensionBc);
    this->GetInt(in,this->DimensionC);
    this->GetInt(in,this->DimensionIs);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XMinimum);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);

    // 19 ints ... 5 doubles = 116 bytes
    this->SkipBytes(in,396);
    }
  else
    {
    this->GetInt(in,this->IMinimum1);
    this->GetInt(in,this->JMinimum1);
    this->GetInt(in,this->KMinimum1);
    this->GetInt(in,this->IMaximum);
    this->GetInt(in,this->JMaximum);
    this->GetInt(in,this->KMaximum);
    this->GetInt(in,this->IMaximum1);
    this->GetInt(in,this->JMaximum1);
    this->GetInt(in,this->KMaximum1);
    this->GetInt(in,this->IMaximum2);
    this->GetInt(in,this->JMaximum2);
    this->GetInt(in,this->KMaximum2);
    this->GetInt(in,this->IJMaximum2);
    this->GetInt(in,this->IJKMaximum2);
    this->GetInt(in,this->MMAX);
    this->GetInt(in,this->DimensionIc);
    this->GetInt(in,this->DimensionBc);
    this->GetInt(in,this->DimensionC);
    this->GetInt(in,this->DimensionIs);
    this->GetDouble(in,this->DeltaTime);
    this->GetDouble(in,this->XMinimum);
    this->GetDouble(in,this->XLength);
    this->GetDouble(in,this->YLength);
    this->GetDouble(in,this->ZLength);
    this->GetDouble(in,this->Ce);
    this->GetDouble(in,this->Cf);
    this->GetDouble(in,this->Phi);
    this->GetDouble(in,this->PhiW);

    // 19 ints ... 9 doubles = 148 bytes
    this->SkipBytes(in,364);
    }

  this->numberOfFloatsInBlock = 512/sizeof(float);

  if ( this->IJKMaximum2%this->numberOfFloatsInBlock == 0)
    {
    this->SPXRecordsPerTimestep = this->IJKMaximum2/this->numberOfFloatsInBlock;
    }
  else
    {
    this->SPXRecordsPerTimestep = 1 + this->IJKMaximum2/this->numberOfFloatsInBlock;
    }
  // C , C_name and nmax

  this->NMax.resize(this->MMAX+1);
  for (int lc=0; lc<this->MMAX+1; ++lc)
    {
    this->NMax[lc] =  1;
    }

  this->C.resize(this->DimensionC);

  if (this->VersionNumber > 1.04)
    {
    this->GetBlockOfDoubles (in, this->C, this->DimensionC);

    for (int lc=0; lc<DimensionC; ++lc) 
      {
      in.read(this->DataBuffer,512);  // c_name[]
      }

    if (this->VersionNumber < 1.12)
      {
      this->GetBlockOfInts(in, this->NMax,this->MMAX+1);
      }
    else
      {
      // what is the diff between this and above ??? 
      for (int lc=0; lc<this->MMAX+1; ++lc) 
        {
        int temp;
        this->GetInt(in,temp);
        this->NMax[lc] = temp;
        }
      this->SkipBytes(in,512-(this->MMAX+1)*sizeof(int));
      }
    }

  this->Dx.resize(this->IMaximum2);
  this->Dy.resize(this->JMaximum2);
  this->Dz.resize(this->KMaximum2);

  this->GetBlockOfDoubles(in, this->Dx,this->IMaximum2);
  this->GetBlockOfDoubles(in, this->Dy,this->JMaximum2);
  this->GetBlockOfDoubles(in, this->Dz,this->KMaximum2);

  // RunName etc.

  memset(this->Units,0,17);
  memset(this->CoordinateSystem,0,17);

  in.read(this->DataBuffer,120);      // run_name , description
  in.read(this->Units,16);        // Units
  in.read(this->DataBuffer,16);       // run_type
  in.read(this->CoordinateSystem,16);  // CoordinateSystem 

  this->SkipBytes(in,512-168);

  char tempCharArray[17];

  memset(tempCharArray,0,17);

  int ic = 0;
  for (int i=0; i<17; ++i)
    {
    if (this->Units[i] != ' ') 
      {
      tempCharArray[ic++] = this->Units[i];
      }
    }

  memset(tempCharArray,0,17);

  ic = 0;
  for (int i=0; i<17; ++i)
    {
    if (this->CoordinateSystem[i] != ' ')
      {
      tempCharArray[ic++] = this->CoordinateSystem[i];
      }
    }
  strcpy(this->CoordinateSystem,tempCharArray);

  if (this->VersionNumber >= 1.04)
    {
    this->TempD.resize(this->NMax[0]);
    this->GetBlockOfDoubles(in, this->TempD, this->NMax[0]); // MW_g
    for (int i=0; i<this->MMAX; ++i)
      {
      in.read(this->DataBuffer,512);  // MW_s
      }
    }

  in.read(this->DataBuffer,512);  // D_p etc.

  // read in the "DimensionIc" variables (and ignore ... not used by ani_mfix)
  this->TempI.resize(this->DimensionIc);
  this->TempD.resize(this->DimensionIc);

  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_x_w
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_x_e
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_y_s
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_y_n
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_z_b
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_z_t

  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_i_w
  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_i_e
  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_j_s
  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_j_n
  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_k_b
  this->GetBlockOfInts(in, this->TempI,this->DimensionIc);  // ic_k_t

  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_ep_g
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_p_g
  this->GetBlockOfDoubles(in, this->TempD,this->DimensionIc);  // ic_t_g

  if (this->VersionNumber < 1.15)
    {
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc);  // ic_t_s(1,1)
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc);  // ic_t_s(1,2)
                                                                // or ic_tmp 
    }

  if (this->VersionNumber >= 1.04)
    {
    for (int i=0; i<this->NMax[0]; ++i)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_x_g
      }
    }

  this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_u_g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_v_g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_w_g

  for (int lc=0; lc<this->MMAX; ++lc)
    {
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_rop_s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_u_s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_v_s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_w_s

    if (this->VersionNumber >= 1.15)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_t_s
      }

    if (this->VersionNumber >= 1.04)
      {
      for (int n=0; n<this->NMax[lc+1]; ++n)
        {
        this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_x_s
        }
      }
    }

  // read in the "DimensionBc" variables (and ignore ... not used by ani_mfix)
  this->TempI.resize(this->DimensionBc);
  this->TempD.resize(this->DimensionBc);

  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_x_w
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_x_e
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc y s
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc y n
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc z b
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc);  // bc z t
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc);  // bc i w
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc); // bc i e
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc); // bc j s
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc); // bc j n
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc); // bc k b
  this->GetBlockOfInts(in,this->TempI,this->DimensionBc); // bc k t
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc ep g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc p g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc t g

  if (VersionNumber < 1.15)
    {
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_t_s(1,1)
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_t_s(1,1)
                                                               // or bc_tmp
    }

  if (VersionNumber >= 1.04)
    {
    for (int i=0; i<this->NMax[0]; ++i)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_x_g
      }
    }

  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc u g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc v g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc w g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc ro g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_rop_g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc volflow g
  this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc massflow g

  for (int lc=0; lc<this->MMAX; ++lc)
    {
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc rop s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc u s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc v s

    if (this->VersionNumber >= 1.04)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc w s

      if (this->VersionNumber >= 1.15)
        {
        this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc t s
        }
      for (int n=0; n<this->NMax[lc+1]; ++n)
        {
        this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc x s
        }
      }
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc volflow s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc massflow s
    }

  if (this->Version == "RES = 01.00")
    {
    for (int lc=0; lc<10; ++lc)
      {
      in.read(this->DataBuffer,512); // BC TYPE
      }
    }
  else
    {
    for (int lc=0; lc<this->DimensionBc; ++lc)
      {
      in.read(this->DataBuffer,512); // BC TYPE
      }
    }

  this->Flag.resize(this->IJKMaximum2);
  this->GetBlockOfInts(in, this->Flag,this->IJKMaximum2);

  // DimensionIs varibles (not needed by ani_mfix)
  this->TempI.resize(this->DimensionIs);
  this->TempD.resize(this->DimensionIs);

  if (this->VersionNumber >= 1.04)
    {
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is x w
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is x e
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is y s
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is y n
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is z b
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs); // is z t
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is i w
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is i e
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is j s
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is j n
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is k b
    this->GetBlockOfInts(in,this->TempI,this->DimensionIs); // is k t
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs);  // is_pc(1,1)
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs);  // is_pc(1,2)

    if (this->VersionNumber >= 1.07)
      {
      for (int i=0; i<this->MMAX; ++i) 
        {
        this->GetBlockOfDoubles(in,this->TempD,this->DimensionIs);//is_vel_s
        }
      }

    for (int lc=0; lc<this->DimensionIs; ++lc)
      {
      in.read(this->DataBuffer,512); // is_type
      }
    }

  if (this->VersionNumber >= 1.08)
    {
    in.read(this->DataBuffer,512);
    }

  if (this->VersionNumber >= 1.09)
    {
    in.read(this->DataBuffer,512);

    if (this->VersionNumber >= 1.5)
      {
      this->GetInt(in,this->NumberOfSPXFilesUsed);
      this->SkipBytes(in,508);
      }

    for (int lc=0; lc< this->NumberOfSPXFilesUsed; ++lc)
      {
      in.read(this->DataBuffer,512); // spx_dt
      }

    for (int lc=0; lc<this->MMAX+1; ++lc)
      {
      in.read(this->DataBuffer,512);    // species_eq
      }

    this->TempD.resize(dimensionUsr);

    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr_dt
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr x w
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr x e
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr y s
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr y n
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr z b
    this->GetBlockOfDoubles(in,this->TempD,dimensionUsr); // usr z t

    for (int lc=0; lc<dimensionUsr; ++lc)
      {
      in.read(this->DataBuffer,512);    // usr_ext etc.
      }

    this->TempD.resize(this->DimensionIc);
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_p_star
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_l_scale
    for (int lc=0; lc<this->DimensionIc; ++lc)
      {
      in.read(this->DataBuffer,512);    // ic_type
      }

    this->TempD.resize(DimensionBc);
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_dt_0
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_jet_g0
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_dt_h
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_jet_gh
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_dt_l
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_jet_gl
    }

  if (this->VersionNumber >= 1.1)
    {
    in.read(this->DataBuffer,512);  // mu_gmax
    }

  if (this->VersionNumber >= 1.11)
    {
    in.read(this->DataBuffer,512);  // x_ex , model_b
    }

  if (this->VersionNumber >= 1.12)
    {
    in.read(this->DataBuffer,512);   // p_ref , etc.
    in.read(this->DataBuffer,512);   // leq_it , leq_method

    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_hw_g
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_uw_g
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_vw_g
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_ww_g

    for (int lc=0; lc<this->MMAX; ++lc)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_hw_s
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_uw_s
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_vw_s
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionBc); // bc_ww_s
      }
    }

  if (this->VersionNumber >= 1.13)
    {
    in.read(this->DataBuffer,512);    // momentum_x_eq , etc.
    }

  if (this->VersionNumber >= 1.14)
    {
    in.read(this->DataBuffer,512);    // detect_small
    }

  if (this->VersionNumber >= 1.15)
    {
    in.read(this->DataBuffer,512);    // k_g0 , etc.

    this->TempD.resize(this->DimensionIc);

    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_gama_rg
    this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_t_rg

    for (int lc=0; lc<this->MMAX; ++lc)
      {
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_gama_rs
      this->GetBlockOfDoubles(in,this->TempD,this->DimensionIc); // ic_t_rs
      }
    }

  if (this->VersionNumber >= 1.2)
    {
    in.read(this->DataBuffer,512); // norm_g , norm_s
    }

  if (this->VersionNumber >= 1.3)
    {
    this->GetInt(in,this->NumberOfScalars);
    this->SkipBytes(in,sizeof(double)); // tol_resid_scalar

    this->GetInt(in,this->DIM_tmp);
    this->SkipBytes(in,512-sizeof(double)-2*sizeof(int));


    this->TempI.resize(this->DIM_tmp);
    this->GetBlockOfInts(in,this->TempI,this->DIM_tmp);  // Phase4Scalar;
    }

  if (this->VersionNumber >= 1.5)
    {
    this->GetInt(in,this->NumberOfReactionRates);
    this->SkipBytes(in,508);
    }

  if (this->VersionNumber >= 1.5999)
    {
    int tmp;
    this->GetInt(in,tmp);
    this->SkipBytes(in,508);

    if (tmp != 0)
      {
      this->BkEpsilon = true;
      }
    }
in.close();
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetInt(istream& in, int &val)
{
  in.read( (char*)&val,sizeof(int));
  this->SwapInt(val);
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetDouble(istream& in, double& val)
{
  in.read( (char*)&val,sizeof(double));
  this->SwapDouble(val);
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::SkipBytes(istream& in, int n)
{
  in.read(this->DataBuffer,n); // maybe seekg instead
}
//----------------------------------------------------------------------------
// ****************************************************************************
// Method: avtMFIXFileFormat::GetBlockOfDoubles
//
// Programmer: MFIX team
// Creation:   Tue Jun 20 09:37:27 PDT 2006
//
// Modifications:
//   Brad Whitlock, Tue Jun 20 09:37:45 PDT 2006
//   Fixed a bug that could clobber the stack.
//
// ****************************************************************************

void avtMFIXFileFormat::GetBlockOfDoubles(istream& in, std::vector<double> &v, int n)
{
  const int numberOfDoublesInBlock = 512/sizeof(double);
  double tempArray[numberOfDoublesInBlock];
  int numberOfRecords;

  if ( n%numberOfDoublesInBlock == 0)
    {
    numberOfRecords = n/numberOfDoublesInBlock;
    }
  else
    {
    numberOfRecords = 1 + n/numberOfDoublesInBlock;
    }

  int c = 0;
  for (int i=0; i<numberOfRecords; ++i)
    {
    in.read( (char*)tempArray , 512 );
    for (int j=0; j<numberOfDoublesInBlock; ++j)
      {
      if (c < n) 
        {
        double temp = tempArray[j];
        this->SwapDouble(temp);
        v[c] = temp;
        ++c;
        }
      }
    }
}
//----------------------------------------------------------------------------
// ****************************************************************************
// Method: avtMFIXFileFormat::GetBlockOfInts
//
// Programmer: MFIX team
// Creation:   Tue Jun 20 09:37:27 PDT 2006
//
// Modifications:
//   Brad Whitlock, Tue Jun 20 09:37:45 PDT 2006
//   Fixed a bug that could clobber the stack.
//
// ****************************************************************************
void avtMFIXFileFormat::GetBlockOfInts(istream& in, std::vector<int> &v, int n)
{
  const int numberOfIntsInBlock = 512/sizeof(int);
  int tempArray[numberOfIntsInBlock];
  int numberOfRecords;

  if ( n%numberOfIntsInBlock == 0)
    {
    numberOfRecords = n/numberOfIntsInBlock;
    }
  else
    {
    numberOfRecords = 1 + n/numberOfIntsInBlock;
    }

  int c = 0;
  for (int i = 0; i < numberOfRecords; ++i)
    {
    in.read( (char*)tempArray , 512 );
    for (int j=0; j<numberOfIntsInBlock; ++j)
      {
      if (c < n)
        {
        int temp = tempArray[j];
        this->SwapInt(temp);
        v[c] = temp;
        //cout << " C = " << c << ", v[c] = " << v[c] << endl;
        ++c;
        }
      }
    }
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::RestartVersionNumber(char* buffer)
{
  char s1[120];
  char s2[120];
  sscanf(buffer,"%s %s %f", s1, s2, &this->VersionNumber);
  strncpy(this->Version, buffer, 100);
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::SwapInt(int &value)
{
  static char Swapped[4];
  int * Addr = &value;
  Swapped[0]=*((char*)Addr+3);
  Swapped[1]=*((char*)Addr+2);
  Swapped[2]=*((char*)Addr+1);
  Swapped[3]=*((char*)Addr  );
  value = *(reinterpret_cast<int*>(Swapped));
}

//----------------------------------------------------------------------------
void avtMFIXFileFormat::SwapDouble(double &value)
{
  static char Swapped[8];
  double * Addr = &value;

  Swapped[0]=*((char*)Addr+7);
  Swapped[1]=*((char*)Addr+6);
  Swapped[2]=*((char*)Addr+5);
  Swapped[3]=*((char*)Addr+4);
  Swapped[4]=*((char*)Addr+3);
  Swapped[5]=*((char*)Addr+2);
  Swapped[6]=*((char*)Addr+1);
  Swapped[7]=*((char*)Addr  );
  value = *(reinterpret_cast<double*>(Swapped));
}

//----------------------------------------------------------------------------
void avtMFIXFileFormat::CreateVariableNames(const char *filename)
{
  char fileName[256];
  int cnt = 0;
  char uString[120];
  char vString[120];
  char wString[120];
  char svString[120];
  char tempString[120];
  char ropString[120];
  char temperatureString[120];
  char variableString[120];

  this->SpxFileExists.resize(12);
  for (int i = 0; i < this->SpxFileExists.size(); i++)
    {
    this->SpxFileExists[i] = 0;
    }

  for (int i=0; i<11; ++i)
    {
    for(int k = 0; k < (int)sizeof(fileName); k++)
      {
      fileName[k]=0;
      }
    strncpy(fileName, filename, strlen(filename)-4);

    if (i==0)
      {
      strcat(fileName, ".SP1");
      }
    else if (i==1)
      {
      strcat(fileName, ".SP2");
      }
    else if (i==2)
      {
      strcat(fileName, ".SP3");
      }
    else if (i==3)
      {
      strcat(fileName, ".SP4");
      }
    else if (i==4)
      {
      strcat(fileName, ".SP5");
      }
    else if (i==5)
      {
      strcat(fileName, ".SP6");
      }
    else if (i==6)
      {
      strcat(fileName, ".SP7");
      }
    else if (i==7)
      {
      strcat(fileName, ".SP8");
      }
    else if (i==8)
      {
      strcat(fileName, ".SP9");
      }
    else if (i==9)
      {
      strcat(fileName, ".SPA");
      }
    else
      {
      strcat(fileName, ".SPB");
      }

    ifstream in(fileName,ios::binary);
    if (in) // file exists
      {
      this->SpxFileExists[i] = 1;

      switch (i+1)
        {

        case 1:
          this->VariableNames.push_back("EP_g");
          this->VariableIndexToSPX.push_back(1);
          this->VariableComponents.push_back(1);
          break;

        case 2:
          this->VariableNames.push_back("P_g");
          this->VariableIndexToSPX.push_back(2);
          this->VariableComponents.push_back(1);
          this->VariableNames.push_back("P_star");
          this->VariableIndexToSPX.push_back(2);
          this->VariableComponents.push_back(1);
          break;

        case 3:
          this->VariableNames.push_back("U_g");
          this->VariableIndexToSPX.push_back(3);
          this->VariableComponents.push_back(1);
          this->VariableNames.push_back("V_g");
          this->VariableIndexToSPX.push_back(3);
          this->VariableComponents.push_back(1);
          this->VariableNames.push_back("W_g");
          this->VariableIndexToSPX.push_back(3);
          this->VariableComponents.push_back(1);
          this->VariableNames.push_back("Gas Velocity");
          this->VariableIndexToSPX.push_back(3);
          this->VariableComponents.push_back(3);
          break;

        case 4:
          for (int j=0; j<this->MMAX; ++j)
            {
            for(int k=0;k<(int)sizeof(uString);k++)
              {
              uString[k]=0;
              }
            for(int k=0;k<(int)sizeof(vString);k++)
              {
              vString[k]=0;
              }
            for(int k=0;k<(int)sizeof(wString);k++)
              {
              wString[k]=0;
              }
            for(int k=0;k<(int)sizeof(svString);k++)
              {
              svString[k]=0;
              }
            strcpy(uString, "U_s_");
            strcpy(vString, "V_s_");
            strcpy(wString, "W_s_");
            strcpy(svString, "Solids_Velocity_");
            sprintf(tempString, "%d", j+1);
            strcat(uString, tempString);
            strcat(vString, tempString);
            strcat(wString, tempString);
            strcat(svString, tempString);
            this->VariableNames.push_back(uString);
            this->VariableIndexToSPX.push_back(4);
            this->VariableComponents.push_back(1);

            this->VariableNames.push_back(vString);
            this->VariableIndexToSPX.push_back(4);
            this->VariableComponents.push_back(1);

            this->VariableNames.push_back(wString);
            this->VariableIndexToSPX.push_back(4);
            this->VariableComponents.push_back(1);

            this->VariableNames.push_back(svString);
            this->VariableIndexToSPX.push_back(4);
            this->VariableComponents.push_back(3);
            }
          break;

        case 5:
          for (int j=0; j<this->MMAX; ++j)
            {
            for(int k=0;k<(int)sizeof(ropString);k++)
              {
              ropString[k]=0;
              }
            strcpy(ropString, "ROP_s_");
            sprintf(tempString, "%d", j+1);
            strcat(ropString, tempString);
            this->VariableNames.push_back(ropString);
            this->VariableIndexToSPX.push_back(5);
            this->VariableComponents.push_back(1);
            }
          break;

        case 6:
          this->VariableNames.push_back("T_g");
          this->VariableIndexToSPX.push_back(6);
          this->VariableComponents.push_back(1);

          if (this->VersionNumber <= 1.15)
            {
            this->VariableNames.push_back("T_s_1");
            this->VariableIndexToSPX.push_back(6);
            this->VariableComponents.push_back(1);

            if (this->MMAX > 1)
              {
              this->VariableNames.push_back("T_s_2");
              this->VariableIndexToSPX.push_back(6);
              this->VariableComponents.push_back(1);
              }
            else
              {
              this->VariableNames.push_back("T_s_2_not_used");
              this->VariableIndexToSPX.push_back(6);
              this->VariableComponents.push_back(1);
              }
            }
          else
            {
            for (int j=0; j<this->MMAX; ++j)
              {
              for(int k=0;k<(int)sizeof(temperatureString);k++)
                {
                temperatureString[k]=0;
                }
              strcpy(temperatureString, "T_s_");
              sprintf(tempString, "%d", j+1);
              strcat(temperatureString, tempString);
              this->VariableNames.push_back(temperatureString);
              this->VariableIndexToSPX.push_back(6);
              this->VariableComponents.push_back(1);
              }
            }
          break;

        case 7:
          for (int j=0; j<this->NMax[0]; ++j)
            {
            for (int k=0;k<(int)sizeof(variableString);k++)
              {
              variableString[k]=0;
              }
            strcpy(variableString, "X_g_");
            sprintf(tempString, "%d", j+1);
            strcat(variableString, tempString);
            this->VariableNames.push_back(variableString);
            this->VariableIndexToSPX.push_back(7);
            this->VariableComponents.push_back(1);
            }

          for (int m=1; m<=this->MMAX; ++m)
            {
            for (int j=0; j<this->NMax[m]; ++j)
              {
              char tempString1[120];
              char tempString2[120];
              for (int k=0;k<(int)sizeof(variableString);k++)
                {
                variableString[k]=0;
                }
              strcpy(variableString, "X_s_");
              sprintf(tempString1, "%d", m);
              sprintf(tempString2, "%d", j+1);
              strcat(variableString, tempString1);
              strcat(variableString, "_");
              strcat(variableString, tempString2);
              this->VariableNames.push_back(variableString);
              this->VariableIndexToSPX.push_back(7);
              this->VariableComponents.push_back(1);
              }
            }
          break;

        case 8:
          for (int j=0; j<MMAX; ++j)
            {
            for (int k=0;k<(int)sizeof(variableString);k++)
              {
              variableString[k]=0;
              }
            strcpy(variableString, "Theta_m_");
            sprintf(tempString, "%d", j+1);
            strcat(variableString, tempString);
            this->VariableNames.push_back(variableString);
            this->VariableIndexToSPX.push_back(8);
            this->VariableComponents.push_back(1);
            }
          break;

        case 9:
          for (int j=0; j<this->NumberOfScalars; ++j)
            {
            for(int k=0;k<(int)sizeof(variableString);k++)
              {
              variableString[k]=0;
              }
            strcpy(variableString, "Scalar_");
            sprintf(tempString, "%d", j+1);
            strcat(variableString, tempString);
            this->VariableNames.push_back(variableString);
            this->VariableIndexToSPX.push_back(9);
            this->VariableComponents.push_back(1);
            }
          break;

        case 10:
          for (int j=0; j<this->NumberOfReactionRates; ++j)
            {
            for (int k=0;k<(int)sizeof(variableString);k++)
              {
              variableString[k]=0;
              }
            strcpy(variableString, "RRates_");
            sprintf(tempString, "%d", j+1);
            strcat(variableString, tempString);
            this->VariableNames.push_back(variableString);
            this->VariableIndexToSPX.push_back(10);
            this->VariableComponents.push_back(1);
            }
          break;

        case 11:
          if (BkEpsilon)
            {
            this->VariableNames.push_back("k_turb_g");
            this->VariableIndexToSPX.push_back(11);
            this->VariableComponents.push_back(1);
            this->VariableNames.push_back("e_turb_g");
            this->VariableIndexToSPX.push_back(11);
            this->VariableComponents.push_back(1);
            }
          break;
        default:
          cout << "unknown SPx file : " << i << "\n";
          break;
        }
      }
    else 
      {
      this->SpxFileExists[i] = 0;
      }
    in.close();
    }
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetTimeSteps(const char *filename)
{
  int nextRecord, numberOfRecords;
  char fileName[256];
  int cnt = 0;

  for (int i=0; i<11; ++i)
    {
    for (int k=0;k<(int)sizeof(fileName);k++)
      {
      fileName[k]=0;
      }
    strncpy(fileName, filename, strlen(filename)-4);
    if (i==0)
      {
      strcat(fileName, ".SP1");
      }
    else if (i==1)
      {
      strcat(fileName, ".SP2");
      }
    else if (i==2)
      {
      strcat(fileName, ".SP3");
      }
    else if (i==3)
      {
      strcat(fileName, ".SP4");
      }
    else if (i==4)
      {
      strcat(fileName, ".SP5");
      }
    else if (i==5)
      {
      strcat(fileName, ".SP6");
      }
    else if (i==6)
      {
      strcat(fileName, ".SP7");
      }
    else if (i==7)
      {
      strcat(fileName, ".SP8");
      }
    else if (i==8)
      {
      strcat(fileName, ".SP9");
      }
    else if (i==9)
      {
      strcat(fileName, ".SPA");
      }
    else
      {
      strcat(fileName, ".SPB");
      }

    ifstream in(fileName , ios::binary);

    int numberOfVariables=0;
    if (in) // file exists
      {
      in.clear();
      in.seekg( 1024, ios::beg ); 
      in.read( (char*)&nextRecord,sizeof(int) );
      this->SwapInt(nextRecord);
      in.read( (char*)&numberOfRecords,sizeof(int) );
      this->SwapInt(numberOfRecords);

      switch (i+1)
        {
        case 1: 
          {
          numberOfVariables = 1;
          break;
          }
        case 2:
          {
          numberOfVariables = 2;
          break;
          }
        case 3:
          {
          numberOfVariables = 4;
          break;
          }
        case 4:
          {
          numberOfVariables = 4*this->MMAX;
          break;
          }
        case 5:
          {
          numberOfVariables = this->MMAX;
          break;
          }
        case 6:
          {
          if (this->VersionNumber <= 1.15)
            {
            numberOfVariables = 3;
            }
          else
            {
            numberOfVariables = this->MMAX + 1;
            }
          break;
          }
        case 7:
          {
          numberOfVariables = this->NMax[0];
          for (int m=0; m<this->MMAX; ++m)
            {
            numberOfVariables += this->NMax[m];
            }
          break;
          }
        case 8:
          {
          numberOfVariables = this->MMAX;
          break;
          }
        case 9:
          {
          numberOfVariables = this->NumberOfScalars;
          break;
          }
        case 10:
          {
          numberOfVariables = this->NumberOfReactionRates;
          break;
          }
        case 11:
          {
          if (this->BkEpsilon)
            {
            numberOfVariables = 2;
            }
          break;
          }
        }

      for(int j=0; j<numberOfVariables; j++)
        {
        this->VariableTimesteps.push_back((nextRecord-4)/numberOfRecords);
        }
      }
      in.close();
    }
}
//----------------------------------------------------------------------------
int avtMFIXFileFormat::GetMaxTimeStep()
{
  int max = 0;
  for ( int i=0; i < this->VariableNames.size(); i++ )
    {
    if (this->VariableTimesteps[i] > max)
      {
      max = this->VariableTimesteps[i];
      }
    }
  return max;
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::MakeTimeStepTable()
{
  //this->VariableTimestepTable->SetNumberOfComponents(numberOfVariables);
  VariableTimestepTable.resize(VariableNames.size());
  for (int i = 0; i < VariableNames.size(); i++)
    {
    VariableTimestepTable[i].resize(this->MaxTimeStep);
    }

  for(int i=0; i<VariableNames.size(); i++)
    {
    int timestepIncrement = this->MaxTimeStep/this->VariableTimesteps[i];
    int timestep = 1;
    for (int j=0; j<this->MaxTimeStep; j++)
      {
      this->VariableTimestepTable[i][j] = timestep;
      timestepIncrement--;
      if (timestepIncrement <= 0)
        {
        timestepIncrement = this->MaxTimeStep/this->VariableTimesteps[i];
        timestep++;
        }
      if (timestep > this->VariableTimesteps[i]) 
        {
        timestep = this->VariableTimesteps[i];
        }
      }
    }
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetNumberOfVariablesInSPXFiles()
{
  this->SPXToNVarTable.resize(11);
  this->VariableToSkipTable.resize(this->VariableNames.size());

  int NumberOfVariablesInSPX = 0;
  int skip = 0;
  for (int j=1; j<11; j++)
    {
    for(int i=0;i<this->VariableNames.size();i++)
      {
      if ((this->VariableIndexToSPX[i]== j) 
        && (this->VariableComponents[i]== 1))
        {
        NumberOfVariablesInSPX++;
        this->VariableToSkipTable[i] = skip;
        skip++;
        }
      }
    this->SPXToNVarTable[j] = NumberOfVariablesInSPX;
    NumberOfVariablesInSPX = 0;
    skip = 0;
    }
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::MakeSPXTimeStepIndexTable()
{
  SPXTimestepIndexTable.resize(VariableNames.size());
  for (int i = 0; i < VariableNames.size(); i++)
    {
    SPXTimestepIndexTable[i].resize(this->MaxTimeStep);
    }

  int timestep;
  int spx;
  int NumberOfVariablesInSPX;
  int skip;
  int index;

  for (int i=0; i<VariableNames.size(); i++)
    {
    for (int j=0; j<this->MaxTimeStep; j++)
      {
      timestep = this->VariableTimestepTable[i][j];
      spx = this->VariableIndexToSPX[i];

      NumberOfVariablesInSPX = this->SPXToNVarTable[spx];

      skip = this->VariableToSkipTable[i];

      index = (3*512) + (timestep-1) * 
        ((NumberOfVariablesInSPX*this->SPXRecordsPerTimestep*512)+512) + 
        512 + (skip*this->SPXRecordsPerTimestep*512);

      //int ind = (i*this->MaximumTimestep) + j;
      SPXTimestepIndexTable[i][j] = index;
      }
    }
}
void avtMFIXFileFormat::MakeMeshes()
{
    Points->SetNumberOfPoints((this->IMaximum2+1)
      *(this->JMaximum2+1)*(this->KMaximum2+1));

    //
    //  3D Cartesian type mesh
    //
    if (  !strcmp(this->CoordinateSystem,"CARTESIAN") && (this->KMaximum2 != 1))
      {
      double pointX = 0.0;
      double pointY = 0.0;
      double pointZ = 0.0;
      int cnt = 0;
      for (int k = 0; k <= this->KMaximum2; k++)
        {
        for (int j = 0; j <= this->JMaximum2; j++)
          {
          for (int i = 0; i <= this->IMaximum2; i++)
            {
            this->Points->InsertPoint(cnt, pointX, pointY, pointZ );
            cnt++;
            if ( i == this->IMaximum2 )
              {
              pointX = pointX + this->Dx[i-1];
              }
            else
              {
              pointX = pointX + this->Dx[i];
              }
            }
          pointX = 0.0;
          if ( j == this->JMaximum2)
            {
            pointY = pointY + this->Dy[j-1];
            }
          else
            {
            pointY = pointY + this->Dy[j];
            }
          }
        pointY = 0.0;
        if ( k == this->KMaximum2)
          {
          pointZ = pointZ + this->Dz[k-1];
          }
        else
          {
          pointZ = pointZ + this->Dz[k];
          }
        }
      }
    //
    //  2D Cartesian type mesh
    //
    else if ( !strcmp(this->CoordinateSystem,"CARTESIAN") && (this->KMaximum2 == 1))
      {
      double pointX = 0.0;
      double pointY = 0.0;
      double pointZ = 0.0;
      int cnt = 0;
        for (int j = 0; j <= this->JMaximum2; j++)
          {
          for (int i = 0; i <= this->IMaximum2; i++)
            {
            this->Points->InsertPoint(cnt, pointX, pointY, pointZ );
            cnt++;
            if ( i == this->IMaximum2 )
              {
              pointX = pointX + this->Dx[i-1];
              }
            else
              {
              pointX = pointX + this->Dx[i];
              }
            }
          pointX = 0.0;
          if ( j == this->JMaximum2)
            {
            pointY = pointY + this->Dy[j-1];
            }
          else
            {
            pointY = pointY + this->Dy[j];
            }
          }
      }
    //
    //  2D Cylindrical type mesh
    //
    else if (!strcmp(this->CoordinateSystem,"CYLINDRICAL") && (this->KMaximum2 == 1))
      {
      double pointX = 0.0;
      double pointY = 0.0;
      double pointZ = 0.0;
      int cnt = 0;
        for (int j = 0; j <= this->JMaximum2; j++)
          {
          for (int i = 0; i <= this->IMaximum2; i++)
            {
            this->Points->InsertPoint(cnt, pointX, pointY, pointZ );
            cnt++;
            if ( i == this->IMaximum2 )
              {
              pointX = pointX + this->Dx[i-1];
              }
            else
              {
              pointX = pointX + this->Dx[i];
              }
            }
          pointX = 0.0;
          if ( j == this->JMaximum2)
            {
            pointY = pointY + this->Dy[j-1];
            }
          else
            {
            pointY = pointY + this->Dy[j];
            }
          }
      }
    //
    //  3D Cylindrical type mesh
    //
    else
      {
      double pointX = 0.0;
      double pointY = 0.0;
      double pointZ = 0.0;
      double radialX = 0.0;
      double radialY = 0.0;
      double radialZ = 0.0;
      int cnt = 0;
      for (int k = 0; k <= this->KMaximum2; k++)
        {
        for (int j = 0; j <= this->JMaximum2; j++)
          {
          for (int i = 0; i <= this->IMaximum2; i++)
            {
            this->Points->InsertPoint(cnt, radialX, radialY, radialZ );
            cnt++;
            if ( i == this->IMaximum2 )
              {
              pointX = pointX + this->Dx[i-1];
              }
            else if ( i == 0 )
              {
              pointX = 0;
              }
            else
              {
              pointX = pointX + this->Dx[i];
              }
            radialX = pointX * cos(pointZ);
            radialZ = pointX * sin(pointZ) * -1;
            }
          pointX = 0.0;
          radialX = 0.0;
          radialZ = 0.0;
          if ( j == this->JMaximum2)
            {
            pointY = pointY + this->Dy[j-1];
            }
          else
            {
            pointY = pointY + this->Dy[j];
            }
          radialY = pointY;
          }
        pointY = 0.0;
        radialY = 0.0;
        if ( k == this->KMaximum2)
          {
          pointZ = pointZ + this->Dz[k-1];
          }
        else
          {
          pointZ = pointZ + this->Dz[k];
          }
        }
      }

    //
    //  Let's put the points in a mesh
    //
    this->FluidMesh->SetPoints(this->Points);
    this->InletMesh->SetPoints(this->Points);
    this->OutletMesh->SetPoints(this->Points);
    this->ObstructionMesh->SetPoints(this->Points);

    int point0 = 0;
    int count = 0;
    int fmcnt = 0;

    // 2D cylindrical
    if ( !strcmp(this->CoordinateSystem,"CYLINDRICAL") && (this->KMaximum2 == 1))
      {
      for (int j = 0; j < this->JMaximum2; j++)
        {
        for (int i = 0; i < this->IMaximum2; i++)
          {
          this->AQuad->GetPointIds()->SetId( 0, point0);
          this->AQuad->GetPointIds()->SetId( 1, point0+1);
          this->AQuad->GetPointIds()->
            SetId( 2, point0+2+this->IMaximum2);
          this->AQuad->GetPointIds()->
            SetId( 3, point0+1+this->IMaximum2);

          if ( this->Flag[count] < 10 )
            {
            this->FluidMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
              fmcnt++;
            }
          else if ( (this->Flag[count] == 10) || 
            (this->Flag[count] == 20))
            {
            this->InletMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          else if ( (this->Flag[count] == 11) || 
            (this->Flag[count] == 21) ||
            (this->Flag[count] == 31))
            {
            this->OutletMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          else if ( (this->Flag[count] >= 100))
            {
            this->ObstructionMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          point0++;
          count++;
          }
        point0++;
        }
      }
    // 3D cylindrical 
    else if (!strcmp(this->CoordinateSystem,"CYLINDRICAL") && (this->KMaximum2 != 1))
      {
      for (int k = 0; k < this->KMaximum2; k++)
        {
        for (int j = 0; j < this->JMaximum2; j++)
          {
          for (int i = 0; i < this->IMaximum2; i++)
            {
            if (( k == (this->KMaximum2-2)) && (i != 1))
              {
              this->AHexahedron->GetPointIds()->SetId( 0, point0);
              this->AHexahedron->GetPointIds()->SetId( 1, point0+1);
              this->AHexahedron->GetPointIds()->SetId( 2,
                (point0+1+((this->IMaximum2+1)*(this->JMaximum2+1)))-
                ((this->IMaximum2+1)*(this->JMaximum2+1)
                *(this->KMaximum2-2)));
              this->AHexahedron->GetPointIds()->SetId( 3,
                (point0+((this->IMaximum2+1)*(this->JMaximum2+1)))-
                ((this->IMaximum2+1)*(this->JMaximum2+1)
                *(this->KMaximum2-2)));
              this->AHexahedron->GetPointIds()->
                SetId( 4, point0+1+this->IMaximum2);
              this->AHexahedron->GetPointIds()->
                SetId( 5, point0+2+this->IMaximum2);
              this->AHexahedron->GetPointIds()->
                SetId( 6, (point0+2+this->IMaximum2 +
                ((this->IMaximum2+1)*(this->JMaximum2+1))) -
                ((this->IMaximum2+1)*(this->JMaximum2+1) 
                * (this->KMaximum2-2)));
              this->AHexahedron->GetPointIds()->
                SetId( 7, (point0+1+this->IMaximum2 +
                ((this->IMaximum2+1)*(this->JMaximum2+1)))- 
                ((this->IMaximum2+1)*(this->JMaximum2+1)
                *(this->KMaximum2-2)));
              if ( this->Flag[count] < 10 )
                {
                this->FluidMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                  fmcnt++;
                }
              else if (  (this->Flag[count] == 10) || 
                (this->Flag[count] == 20))
                {
                this->InletMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }
              else if ( (this->Flag[count] == 11) || 
                (this->Flag[count] == 21) ||
                (this->Flag[count] == 31))
                {
                this->OutletMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }
              else if ( (this->Flag[count] >= 100))
                {
                this->ObstructionMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }
              }
            else if ((k != (this->KMaximum2-2)) && (i != 1))
              {
              this->AHexahedron->GetPointIds()->SetId( 0, point0);
              this->AHexahedron->GetPointIds()->SetId( 1, point0+1);
              this->AHexahedron->GetPointIds()->SetId( 2, 
                point0+1+((this->IMaximum2+1)*(this->JMaximum2+1)));
              this->AHexahedron->GetPointIds()->SetId( 3, 
                point0+((this->IMaximum2+1)*(this->JMaximum2+1)));
              this->AHexahedron->GetPointIds()->
                SetId( 4, point0+1+this->IMaximum2);
              this->AHexahedron->GetPointIds()->
                SetId( 5, point0+2+this->IMaximum2);
              this->AHexahedron->GetPointIds()->
                SetId( 6, point0+2+this->IMaximum2+
                ((this->IMaximum2+1)*(this->JMaximum2+1)));
              this->AHexahedron->GetPointIds()->
                SetId( 7, point0+1+this->IMaximum2+
                ((this->IMaximum2+1)*(this->JMaximum2+1)));

              if ( this->Flag[count] < 10 )
                {
                this->FluidMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                  fmcnt++;
                }
              else if ( (this->Flag[count] == 10) || 
                (this->Flag[count] == 20))
                {
                this->InletMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }
              else if ( (this->Flag[count] == 11) || 
                (this->Flag[count] == 21) ||
                (this->Flag[count] == 31))
                {
                this->OutletMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }
              else if ( (this->Flag[count] >= 100))
                {
                this->ObstructionMesh->InsertNextCell(
                  this->AHexahedron->GetCellType(), 
                  this->AHexahedron->GetPointIds());
                }

              }
            else if ( (k != (this->KMaximum2-2)) && (i == 1))
              {
              this->AWedge->GetPointIds()->SetId( 0, j*(this->IMaximum2+1));
              this->AWedge->GetPointIds()->SetId( 1, point0+1);
              this->AWedge->GetPointIds()->
                SetId( 2, point0+1+((this->IMaximum2+1)
                *(this->JMaximum2+1)));
              this->AWedge->GetPointIds()->
                SetId( 3, (j+1)*(this->IMaximum2+1));
              this->AWedge->GetPointIds()->
                SetId( 4, point0+2+this->IMaximum2);
              this->AWedge->GetPointIds()->
                SetId( 5, point0+2+this->IMaximum2+
                ((this->IMaximum2+1)*(this->JMaximum2+1)));

              if ( this->Flag[count] < 10 )
                {
                this->FluidMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                  fmcnt++;
                }
              else if (  (this->Flag[count] == 10) || 
                (this->Flag[count] == 20))
                {
                this->InletMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              else if ( (this->Flag[count] == 11) || 
                (this->Flag[count] == 21) ||
                (this->Flag[count] == 31))
                {
                this->OutletMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              else if ( (this->Flag[count] >= 100))
                {
                this->ObstructionMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              }
            else if (( k == (this->KMaximum2-2)) && (i == 1))
              {
              this->AWedge->GetPointIds()->SetId( 0, j*(this->IMaximum2+1));
              this->AWedge->GetPointIds()->SetId( 1, point0+1);
              this->AWedge->GetPointIds()->SetId( 2,
               (point0+1+((this->IMaximum2+1)
               *(this->JMaximum2+1)))-((this->IMaximum2+1)
               *(this->JMaximum2+1)*(this->KMaximum2-2)));
              this->AWedge->GetPointIds()->
                SetId( 3, (j+1)*(this->IMaximum2+1));
              this->AWedge->GetPointIds()->
                SetId( 4, point0+2+this->IMaximum2);
              this->AWedge->GetPointIds()->
                SetId( 5, (point0+2+this->IMaximum2 +
                ((this->IMaximum2+1)*(this->JMaximum2+1))) 
                -((this->IMaximum2+1)
                *(this->JMaximum2+1)*(this->KMaximum2-2)));

              if ( this->Flag[count] < 10 )
                {
                this->FluidMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                  fmcnt++;
                }
              else if ( (this->Flag[count] == 10) || 
                (this->Flag[count] == 20))
                {
                this->InletMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              else if ( (this->Flag[count] == 11) || 
                (this->Flag[count] == 21) ||
                (this->Flag[count] == 31))
                {
                this->OutletMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              else if ( (this->Flag[count] >= 100))
                {
                this->ObstructionMesh->InsertNextCell(
                  this->AWedge->GetCellType(), 
                  this->AWedge->GetPointIds());
                }
              }
            point0++;
            count++;
            }
          point0++;
          }
        point0 = point0 + this->IMaximum2+1;
        }
      }
    // 2D cartesian
    else if (!strcmp(this->CoordinateSystem,"CARTESIAN") && (this->KMaximum2 == 1))
      {
      for (int j = 0; j < this->JMaximum2; j++)
        {
        for (int i = 0; i < this->IMaximum2; i++)
          {
          this->AQuad->GetPointIds()->SetId( 0, point0);
          this->AQuad->GetPointIds()->SetId( 1, point0+1);
          this->AQuad->GetPointIds()->
            SetId( 2, point0+2+this->IMaximum2);
          this->AQuad->GetPointIds()->
            SetId( 3, point0+1+this->IMaximum2);

          if ( this->Flag[count] < 10 )
            {
            this->FluidMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
              fmcnt++;
            }
          else if ( (this->Flag[count] == 10) || 
            (this->Flag[count] == 20))
            {
            this->InletMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          else if ( (this->Flag[count] == 11) || 
            (this->Flag[count] == 21) ||
            (this->Flag[count] == 31))
            {
            this->OutletMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          else if ( (this->Flag[count] >= 100))
            {
            this->ObstructionMesh->InsertNextCell(
              this->AQuad->GetCellType(), 
              this->AQuad->GetPointIds());
            }
          point0++;
          count++;
          }
        point0++;
        }
      }
    else
      {
      for (int k = 0; k < this->KMaximum2; k++)
        {
        for (int j = 0; j < this->JMaximum2; j++)
          {
          for (int i = 0; i < this->IMaximum2; i++)
            {
            this->AHexahedron->GetPointIds()->SetId( 0, point0);
            this->AHexahedron->GetPointIds()->SetId( 1, point0+1);
            this->AHexahedron->GetPointIds()->
              SetId( 2, point0+1+((this->IMaximum2+1)
              *(this->JMaximum2+1)));
            this->AHexahedron->GetPointIds()->
              SetId( 3, point0+((this->IMaximum2+1)
              *(this->JMaximum2+1)));
            this->AHexahedron->GetPointIds()->
              SetId( 4, point0+1+this->IMaximum2);
            this->AHexahedron->GetPointIds()->
              SetId( 5, point0+2+this->IMaximum2);
            this->AHexahedron->GetPointIds()->
              SetId( 6, point0+2+this->IMaximum2 +
              ((this->IMaximum2+1)*(this->JMaximum2+1)));
            this->AHexahedron->GetPointIds()->
              SetId( 7, point0+1+this->IMaximum2 + 
              ((this->IMaximum2+1)*(this->JMaximum2+1)));

            if ( this->Flag[count] < 10 )
              {
              this->FluidMesh->InsertNextCell(
                this->AHexahedron->GetCellType(), 
                this->AHexahedron->GetPointIds());
                fmcnt++;
              }
            else if ( (this->Flag[count] == 10) || 
              (this->Flag[count] == 20))
              {
              this->InletMesh->InsertNextCell(
                this->AHexahedron->GetCellType(), 
                this->AHexahedron->GetPointIds());
              }
            else if ( (this->Flag[count] == 11) || 
              (this->Flag[count] == 21) ||
              (this->Flag[count] == 31))
              {
              this->OutletMesh->InsertNextCell(
                this->AHexahedron->GetCellType(), 
                this->AHexahedron->GetPointIds());
              }
            else if ( (this->Flag[count] >= 100))
              {
              this->ObstructionMesh->InsertNextCell(
                this->AHexahedron->GetCellType(), 
                this->AHexahedron->GetPointIds());
              }
            point0++;
            count++;
            }
          point0++;
          }
        point0 = point0 + this->IMaximum2+1;
        }
      }
}

//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetVariableAtTimestep(int vari , int tstep, 
  vtkFloatArray *v, const char *filename)
{
  // This routine opens and closes the file for each request.
  // Maybe keep all SPX files open, and just perform relative
  // moves to get to the correct location in the file
  // get filename that vaiable # vari is located in
  // assumptions : there are <10 solid phases,
  // <10 scalars and <10 ReactionRates (need to change this)

  char variableName[256];
  strcpy(variableName, this->VariableNames[vari].c_str());
  int spx = this->VariableIndexToSPX[vari];
  char fileName[256];

  for(int k=0;k<(int)sizeof(fileName);k++)
    {
    fileName[k]=0;
    }

  strncpy(fileName, filename, strlen(filename)-4);

  if (spx==1)
    {
    strcat(fileName, ".SP1");
    }
  else if (spx==2)
    {
    strcat(fileName, ".SP2");
    }
  else if (spx==3)
    {
    strcat(fileName, ".SP3");
    }
  else if (spx==4)
    {
    strcat(fileName, ".SP4");
    }
  else if (spx==5)
    {
    strcat(fileName, ".SP5");
    }
  else if (spx==6)
    {
    strcat(fileName, ".SP6");
    }
  else if (spx==7)
    {
    strcat(fileName, ".SP7");
    }
  else if (spx==8)
    {
    strcat(fileName, ".SP8");
    }
  else if (spx==9)
    {
    strcat(fileName, ".SP9");
    }
  else if (spx==10)
    {
    strcat(fileName, ".SPA");
    }
  else
    {
    strcat(fileName, ".SPB");
    }

  //int index = (vari*this->MaxTimeStep) + tstep;
  int nBytesSkip = this->SPXTimestepIndexTable[vari][tstep];
  ifstream in(fileName,ios::binary);
  in.seekg(nBytesSkip,ios::beg);
  //cout << "ijkmax2 = " << this->IJKMaximum2 << endl;
  this->GetBlockOfFloats (in, v, this->IJKMaximum2);
  in.close();
}

//----------------------------------------------------------------------------
// ****************************************************************************
// Method: avtMFIXFileFormat::GetBlockOfFloats
//
// Purpose: 
//   Gets a block of floats from the MFIX file.
//
// Programmer: MFIX team
// Creation:   Tue Jun 20 09:32:55 PDT 2006
//
// Modifications:
//   Brad Whitlock, Tue Jun 20 09:33:27 PDT 2006
//   I changed (char*)&tempArray to (char*)tempArray so the reader would
//   no longer overwrite the stack and kill VisIt.
//
// ****************************************************************************

void avtMFIXFileFormat::GetBlockOfFloats(istream& in, vtkFloatArray *v, int n)
{
  float *tempArray = new float[this->numberOfFloatsInBlock];
  int numberOfRecords;

  if ( n%this->numberOfFloatsInBlock == 0)
    {
    numberOfRecords = n/this->numberOfFloatsInBlock;
    }
  else
    {
    numberOfRecords = 1 + n/this->numberOfFloatsInBlock;
    }

  int c = 0;
  int cnt = 0;
  for (int i=0; i<numberOfRecords; ++i)
    {
    in.read( (char*)tempArray , 512 );
    for (int j=0; j<this->numberOfFloatsInBlock; ++j)
      {
      if (c < n) 
        {
        float temp = tempArray[j];
        this->SwapFloat(temp);
        if ( this->Flag[c] < 10) 
          {
          //cout << temp << endl;
          v->InsertValue(cnt, temp);
          cnt++;
          }
        ++c;
        }
      }
    }

   delete [] tempArray;
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::SwapFloat(float &value)
{
  static char Swapped[4];
  float * Addr = &value;

  Swapped[0]=*((char*)Addr+3);
  Swapped[1]=*((char*)Addr+2);
  Swapped[2]=*((char*)Addr+1);
  Swapped[3]=*((char*)Addr  );
  value = *(reinterpret_cast<float*>(Swapped));
}
//----------------------------------------------------------------------------
void avtMFIXFileFormat::GetTimes(vector<double> &times) 
{
  int max = 0;
  int maxVar = 0;

  for(int j=0; j<this->VariableNames.size(); j++)
    {
    int n = this->VariableTimesteps[j];
    if (n > max)
      {
      max = n;
      maxVar = j;
      }
    }

  char fileName[256];

  for(int k=0;k<(int)sizeof(fileName);k++)
    {
    fileName[k]=0;
    }
  strncpy(fileName, this->RestartFileName, strlen(this->RestartFileName)-4);

  if (maxVar==0)
    {
    strcat(fileName, ".SP1");
    }
  else if (maxVar==1)
    {
    strcat(fileName, ".SP2");
    }
  else if (maxVar==2)
    {
    strcat(fileName, ".SP3");
    }
  else if (maxVar==3)
    {
    strcat(fileName, ".SP4");
    }
  else if (maxVar==4)
    {
    strcat(fileName, ".SP5");
    }
  else if (maxVar==5)
    {
    strcat(fileName, ".SP6");
    }
  else if (maxVar==6)
    {
    strcat(fileName, ".SP7");
    }
  else if (maxVar==7)
    {
    strcat(fileName, ".SP8");
    }
  else if (maxVar==8)
    {
    strcat(fileName, ".SP9");
    }
  else if (maxVar==9)
    {
    strcat(fileName, ".SPA");
    }
  else
    {
    strcat(fileName, ".SPB");
    }

  ifstream tfile(fileName , ios::binary);

  int numberOfVariablesInSPX =this->SPXToNVarTable[this->VariableIndexToSPX[maxVar]];

  int offset = 512-(int)sizeof(float) + 
    512*(numberOfVariablesInSPX*SPXRecordsPerTimestep);

  tfile.clear();
  tfile.seekg( 3*512, ios::beg ); // first time
  float time;

  for (int i = 0; i < this->MaxTimeStep; i++)
    {
    tfile.read( (char*)&time,sizeof(float) );
    SwapFloat(time);
    times.push_back((double)time);
    tfile.seekg(offset,ios::cur);
    }
  tfile.close();
}


