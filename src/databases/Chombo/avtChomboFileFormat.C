// ************************************************************************* //
//                           avtChomboFileFormat.C                           //
// ************************************************************************* //

#include <avtChomboFileFormat.h>

#include <snprintf.h>
#include <string>

#include <vtkFieldData.h>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>
#include <avtVariableCache.h>

#include <Expression.h>

#include <BadDomainException.h>
#include <DebugStream.h>
#include <InvalidDBTypeException.h>
#include <InvalidFilesException.h>
#include <InvalidVariableException.h>


using     std::string;


// ****************************************************************************
//  Method: avtChomboFileFormat constructor
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

avtChomboFileFormat::avtChomboFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
    initializedReader = false;
    file_handle = -1;
}


// ****************************************************************************
//  Method: avtChomboFileFormat destructor
//
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

avtChomboFileFormat::~avtChomboFileFormat()
{
    FreeUpResources();
}


// ****************************************************************************
//  Method: avtChomboFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

void
avtChomboFileFormat::FreeUpResources(void)
{
    initializedReader = false;
    if (file_handle != -1)
    {
        H5Fclose(file_handle);
        file_handle = -1;
    }
    varnames.clear();
    patchesPerLevel.clear();
    refinement_ratio.clear();
    dx.clear();
    lowI.clear();
    hiI.clear();
    lowJ.clear();
    hiJ.clear();
    lowK.clear();
    hiK.clear();
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetCycleFromFilename
//
//  Purpose:
//      Gets the cycle from the file name.  A custom implementation is needed,
//      because they have file names like "...plt0080.2d.hdf5".  We want the
//      "80".
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

int
avtChomboFileFormat::GetCycleFromFilename(const char *fname) const
{
    const char *tmp = strstr(fname, "plt");
    if (tmp == NULL)
        return avtSTMDFileFormat::GetCycleFromFilename(fname);
    return atoi(tmp + strlen("plt"));
}


// ****************************************************************************
//  Method: avtChomboFileFormat::ActivateTimestep
//
//  Purpose:
//      Tells the reader it can now do some initialization work.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::ActivateTimestep(void)
{
    InitializeReader();
}


// ****************************************************************************
//  Method: avtChomboFileFormat::InitializeReader
//
//  Purpose:
//      Walks through the HDF5 file and reads in some non-problem size data.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::InitializeReader(void)
{
    int   i, j;

    if (initializedReader)
        return;

    file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_handle < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, since "
                                           "it is not even an HDF5 file.");
    }

    //
    // Most of the global info is stored in the "/" group.
    //
    hid_t slash = H5Gopen(file_handle, "/");
    if (slash < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                           "have the \"/\" group.");
    }

    bool hasTime = false;
    bool hasIterations = false;

    int numAttrs = H5Aget_num_attrs(slash);
    char buf[1024];
    for (i = 0 ; i < numAttrs ; i++)
    {
        hid_t idx = H5Aopen_idx(slash, i);
        H5Aget_name(idx, 1024, buf);
        if (strcmp(buf, "time") == 0)
            hasTime = true;
        if (strcmp(buf, "iteration") == 0)
            hasIterations = true;
        H5Aclose(idx);
    }

    //
    // Get the time.
    //
    if (hasTime)
    {
        hid_t time_id = H5Aopen_name(slash, "time");
        if (time_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                               "have time in \"/\" group.");
        }
        H5Aread(time_id, H5T_NATIVE_DOUBLE, &dtime);
        H5Aclose(time_id);
    }
    else
        dtime = 0.;

    //
    // Get the cycle.
    //
    if (hasIterations)
    {
        hid_t cycle_id = H5Aopen_name(slash, "iteration");
        if (cycle_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                             "have iteration in \"/\" group.");
        }
        H5Aread(cycle_id, H5T_NATIVE_INT, &cycle);
        H5Aclose(cycle_id);
    }
    else
        cycle = 0;

    //
    // Note: max_level, per conversation with John Shalf, is for the code
    // to say what the maximum level could be.  We don't need this...
    //
    /*
    int max_level;
    hid_t ml_id = H5Aopen_name(slash, "max_level");
    H5Aread(ml_id, H5T_NATIVE_INT, &max_level);
    H5Aclose(ml_id);
    */

    //
    // Determine how many refinement levels there are.
    //
    hid_t nl_id = H5Aopen_name(slash, "num_levels");
    if (nl_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                           "have num_levels in \"/\" group.");
    }
    H5Aread(nl_id, H5T_NATIVE_INT, &num_levels);
    if (num_levels <= 0)
    {
        debug1 << "ERROR: Number of levels (" << num_levels 
               << ") must be at least 1" << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(nl_id);

    //
    // Determine how many variables there are.
    //
    int num_vars;
    hid_t nv_id = H5Aopen_name(slash, "num_components");
    if (nv_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                        "have num_components in \"/\" group.");
    }
    H5Aread(nv_id, H5T_NATIVE_INT, &num_vars);
    if (num_vars < 0)
    {
        debug1 << "ERROR: Number of variables less than 0" << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(nv_id);

    //
    // Read out each variable name and store it in vector "varnames".
    //
    for (i = 0 ; i < num_vars ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "component_%d", i);
        hid_t vname = H5Aopen_name(slash, name);
        if (vname < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                               "not have all component names");
        }
        char name2[1024] = { '\0' };
        hid_t atype = H5Aget_type(vname);
        H5Aread(vname, atype, name2);
        varnames.push_back(name2);
        H5Aclose(vname);
    }

    //
    // We're done reading everything from "slash".
    //
    H5Gclose(slash);

    //
    // Now open up "Chombo_global".
    //
    hid_t global = H5Gopen(file_handle, "Chombo_global");
    if (global < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                           "not have Chombo_global");
    }
    hid_t dim_id = H5Aopen_name(global, "SpaceDim");
    if (dim_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                         "not have SpaceDim in Chombo_global");
    }
    H5Aread(dim_id, H5T_NATIVE_INT, &dimension);
    if (dimension != 2 && dimension != 3)
    {
        debug1 << "ERROR: Reader only supports 2D and 3D data sets." << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(dim_id);
    H5Gclose(global);

    //
    // Now iterate over each refinement level and determine how many patches
    // there are at that refinement level, what the refinement ratio is, and
    // what "dx" is ... "dx" is the distance between consecutive points.
    //
    int totalPatches = 0;
    patchesPerLevel.resize(num_levels);
    refinement_ratio.resize(num_levels);
    dx.resize(num_levels);
    for (i = 0 ; i < num_levels ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "level_%d", i);
        hid_t level = H5Gopen(file_handle, name);
        if (level < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain all "
                                               "refinement levels.");
        }
        hid_t boxes = H5Dopen(level, "boxes");
        if (boxes < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain \"boxes\".");
        }
        hid_t boxspace = H5Dget_space(boxes);
        hsize_t dims[1], maxdims[1];
        H5Sget_simple_extent_dims(boxspace, dims, maxdims);
        hid_t memdataspace = H5Screate_simple(1, dims, NULL);
        patchesPerLevel[i] = dims[0];
        totalPatches += patchesPerLevel[i];

        hid_t dx_id = H5Aopen_name(level, "dx");
        if (dx_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain \"dx\".");
        }
        double dx_tmp;
        H5Aread(dx_id, H5T_NATIVE_DOUBLE, &dx_tmp);
        H5Aclose(dx_id);
        dx[i] = dx_tmp;

        hid_t rr_id = H5Aopen_name(level, "ref_ratio");
        if (rr_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException,
                                            "Does not contain \"ref_ratio\".");
        }
        int rr;
        H5Aread(rr_id, H5T_NATIVE_INT, &rr);
        H5Aclose(rr_id);
        refinement_ratio[i] = rr;

        H5Sclose(memdataspace);
        H5Sclose(boxspace);
        H5Dclose(boxes);
        H5Gclose(level);
    }

    // 
    // Now that we know how many total patches there are, create our data
    // structures to hold the extents of each patch.
    //
    lowI.resize(totalPatches);
    hiI.resize(totalPatches);
    lowJ.resize(totalPatches);
    hiJ.resize(totalPatches);
    if (dimension == 3)
    {
        lowK.resize(totalPatches);
        hiK.resize(totalPatches);
    }
    
    //
    // Now iterate over the patches again, storing their extents in our
    // internal data structure.
    //
    hid_t box2d_id = H5Tcreate (H5T_COMPOUND, sizeof(box));
    H5Tinsert (box2d_id, "lo_i", HOFFSET(box2d, lo.i), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "lo_j", HOFFSET(box2d, lo.j), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "hi_i", HOFFSET(box2d, hi.i), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "hi_j", HOFFSET(box2d, hi.j), H5T_NATIVE_INT);

    hid_t box3d_id = H5Tcreate (H5T_COMPOUND, sizeof(box));
    H5Tinsert (box3d_id, "lo_i", HOFFSET(box3d, lo.i), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "lo_j", HOFFSET(box3d, lo.j), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "lo_k", HOFFSET(box3d, lo.k), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_i", HOFFSET(box3d, hi.i), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_j", HOFFSET(box3d, hi.j), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_k", HOFFSET(box3d, hi.k), H5T_NATIVE_INT);

    int patchId = 0;
    for (i = 0 ; i < num_levels ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "level_%d", i);

        hid_t level = H5Gopen(file_handle, name);
        hid_t boxes = H5Dopen(level, "boxes");
        hid_t boxspace = H5Dget_space(boxes);
        hsize_t dims[1], maxdims[1];
        H5Sget_simple_extent_dims(boxspace, dims, maxdims);
        hid_t memdataspace = H5Screate_simple(1, dims, NULL);

        box *boxes_buff = new box[dims[0]];
        H5Dread(boxes, (dimension == 2 ? box2d_id : box3d_id), memdataspace, 
                boxspace, H5P_DEFAULT, boxes_buff);

        for (j = 0 ; j < patchesPerLevel[i] ; j++)
        {
            if (dimension == 2)
            {
                lowI[patchId] = boxes_buff[j].b2.lo.i;
                lowJ[patchId] = boxes_buff[j].b2.lo.j;
                hiI[patchId] = boxes_buff[j].b2.hi.i+1;
                hiJ[patchId] = boxes_buff[j].b2.hi.j+1;
            }
            else
            {
                lowI[patchId] = boxes_buff[j].b3.lo.i;
                lowJ[patchId] = boxes_buff[j].b3.lo.j;
                lowK[patchId] = boxes_buff[j].b3.lo.k;
                hiI[patchId] = boxes_buff[j].b3.hi.i+1;
                hiJ[patchId] = boxes_buff[j].b3.hi.j+1;
                hiK[patchId] = boxes_buff[j].b3.hi.k+1;
            }
            patchId++;
        }

        H5Sclose(memdataspace);
        H5Sclose(boxspace);
        H5Dclose(boxes);
        H5Gclose(level);
    }

    H5Tclose(box2d_id);
    H5Tclose(box3d_id);

    //
    // The domain nesting takes a while to calculate.  We don't need the
    // data structure if we are on the mdserver.  But we do if we're on the
    // engine.  So only calculate it conditionally.
    //
    if (!avtDatabase::OnlyServeUpMetaData())
    {
        CalculateDomainNesting();
    }

    initializedReader = true;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::CalculateDomainNesting
//
//  Purpose:
//      Calculates two important data structures.  One is the structure domain
//      nesting, which tells VisIt how the AMR patches are nested, which allows
//      VisIt to ghost out coarse zones that are refined by smaller zones.
//      The other structure is the rectilinear domain boundaries, which tells
//      VisIt which patches are next to each other, allowing VisIt to create
//      a layer of ghost zones around each patch.  Note that this only works
//      within a refinement level, not across refinement levels.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::CalculateDomainNesting(void)
{
    int i, j;
    int level;

    //
    // Calculate some info we will need in the rest of the routine.
    //
    int totalPatches = 0;
    vector<int> levelStart;
    vector<int> levelEnd;
    for (level = 0 ; level < num_levels ; level++)
    {

        levelStart.push_back(totalPatches);
        totalPatches += patchesPerLevel[level];
        levelEnd.push_back(totalPatches);
    }

    //
    // Now that we know the total number of patches, we can allocate the
    // data structure for the patch nesting.
    //
    avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(
                                          totalPatches, num_levels);

    //
    // Calculate what the refinement ratio is from one level to the next.
    //
    vector<int> rr(dimension);
    for (level = 0 ; level < num_levels ; level++)
    {
        if (level == 0)
        {
            for (j = 0 ; j < dimension ; j++)
                rr[j] = 1;
        }
        else
        {
            for (j = 0 ; j < dimension ; j++)
                rr[j] = refinement_ratio[level-1];
        }
        dn->SetLevelRefinementRatios(level, rr);
    }

    //
    // This multiplier will be needed to find out if patches are nested.
    //
    vector<int> multiplier(num_levels);
    multiplier[num_levels-1] = 1;
    for (level = num_levels-2 ; level >= 0 ; level--)
    {
        multiplier[level] = multiplier[level+1]*refinement_ratio[level];
    }

    //
    // Now set up the data structure for patch boundaries.  The data 
    // does all the work ... it just needs to know the extents of each patch.
    //
    avtRectilinearDomainBoundaries *rdb 
                                    = new avtRectilinearDomainBoundaries(true);
    rdb->SetNumDomains(totalPatches);
    for (int patch = 0 ; patch < totalPatches ; patch++)
    {
        int my_level, local_patch;
        GetLevelAndLocalPatchNumber(patch, my_level, local_patch);

        int e[6];
        e[0] = lowI[patch];
        e[1] = hiI[patch];
        e[2] = lowJ[patch];
        e[3] = hiJ[patch];
        e[4] = (dimension == 2 ? 0 : lowK[patch]);
        e[5] = (dimension == 2 ? 0 : hiK[patch]);

        rdb->SetIndicesForAMRPatch(patch, my_level, e);
    }
    rdb->CalculateBoundaries();
    void_ref_ptr vrdb = void_ref_ptr(rdb,
                                   avtStructuredDomainBoundaries::Destruct);
    cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
                        timestep, -1, vrdb);

    //
    // Calculating the child patches really needs some better sorting than
    // what I am doing here.  This is likely to become a bottleneck in extreme
    // cases.  Although this routine has performed well for a previous 55K
    // patch run.
    //
    vector< vector<int> > childPatches(totalPatches);
    for (level = num_levels-1 ; level > 0 ; level--)
    {
        int prev_level = level-1;
        int search_start  = levelStart[prev_level];
        int search_end    = levelEnd[prev_level];
        int mC = multiplier[prev_level];
        int patches_start = levelStart[level];
        int patches_end   = levelEnd[level];
        int mP = multiplier[level];
        for (int patch = patches_start ; patch < patches_end ; patch++)
        {
            for (int candidate = search_start ; candidate < search_end ;
                 candidate++)
            {
                if (hiI[patch]*mP < lowI[candidate]*mC)
                    continue;
                if (lowI[patch]*mP >= hiI[candidate]*mC)
                    continue;
                if (hiJ[patch]*mP < lowJ[candidate]*mC)
                    continue;
                if (lowJ[patch]*mP >= hiJ[candidate]*mC)
                    continue;
                if (dimension == 3)
                {
                    if (hiK[patch]*mP < lowK[candidate]*mC)
                        continue;
                    if (lowK[patch]*mP >= hiK[candidate]*mC)
                        continue;
                }
                childPatches[candidate].push_back(patch);
           }
        }
    }

    //
    // Now that we know the extents for each patch and what its children are,
    // tell the structured domain boundary that information.
    //
    for (int i = 0 ; i < totalPatches ; i++)
    {
        int my_level, local_patch;
        GetLevelAndLocalPatchNumber(i, my_level, local_patch);

        vector<int> logExts(6);
        logExts[0] = lowI[i];
        logExts[3] = hiI[i]-1;
        logExts[1] = lowJ[i];
        logExts[4] = hiJ[i]-1;
        logExts[2] = 0;
        logExts[5] = 0;
        if (dimension == 3)
        {
            logExts[2] = lowK[i];
            logExts[5] = hiK[i]-1;
        }

        dn->SetNestingForDomain(i, my_level, childPatches[i], logExts);
    }

    //
    // Register this structure with the generic database so that it knows
    // to ghost out the right cells.
    //
    dn->SetNumDimensions(dimension);
    void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
    cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                        timestep, -1, vr);
}


// ****************************************************************************
//  Method: avtChomboFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

void
avtChomboFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    int   i, j;

    if (!initializedReader)
        InitializeReader();

    int totalPatches = 0;
    int level;
    for (level = 0 ; level < num_levels ; level++)
    {
        totalPatches += patchesPerLevel[level];
    }

    // Prevent VisIt from sorting the variables.
    md->SetMustAlphabetizeVariables(false);

    //
    // Set up the mesh.  Use the groups construct to represent refinement
    // levels.  Also take care to name each patch in an appropriate way.
    char mesh_name[32] = "Mesh";
    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = mesh_name;
    mesh->meshType = AVT_AMR_MESH;
    mesh->numBlocks = totalPatches;
    mesh->blockOrigin = 0;
    mesh->spatialDimension = dimension;
    mesh->topologicalDimension = dimension;
    mesh->hasSpatialExtents = false;
    mesh->blockTitle = "patches";
    mesh->blockPieceName = "patch";
    mesh->numGroups = num_levels;
    mesh->groupTitle = "levels";
    mesh->groupPieceName = "level";
    std::vector<int> groupIds(totalPatches);
    std::vector<string> blockPieceNames(totalPatches);
    for (i = 0 ; i < totalPatches ; i++)
    {
        char tmpName[128];
        int level, local_patch;
        GetLevelAndLocalPatchNumber(i, level, local_patch);
        groupIds[i] = level;
        sprintf(tmpName, "level%d,patch%d", level, local_patch);
        blockPieceNames[i] = tmpName;
    }
    mesh->blockNames = blockPieceNames;
    md->Add(mesh);
    md->AddGroupInformation(num_levels, totalPatches, groupIds);

    //
    // Add each scalar variable.
    //
    int nVars = varnames.size();
    for (i = 0; i < nVars; i++)
    {
        AddScalarVarToMetaData(md, varnames[i], mesh_name, AVT_ZONECENT);
    }

    //
    // Chombo has no vector variables.  But it clearly has some scalar
    // variables that should be combined into vectors.  Identify these and
    // make expressions for the vectors.
    //
    for (i = 0; i < nVars; i++)
    {
        int id2 = -1;
        bool startsWithFirst = false;
        bool foundVector = false;
        if (varnames[i][0] == 'x')
        {
            char yName[1024];
            SNPRINTF(yName, 1024, "y%s", varnames[i].c_str()+1);
            int matchY = -1;
            for (j = 0 ; j < nVars ; j++)
            {
                if (varnames[j] == yName)
                {
                    matchY = j;
                    break;
                }
            }
            if (matchY < 0)
                continue;
            if (dimension == 2)
            {
                Expression vec;
                const char *str = varnames[i].c_str()+1;
                while (*str != '\0' && !isalpha(*str))
                    str++;
                vec.SetName(str);
                char defn[1024];
                SNPRINTF(defn, 1024, "{<%s>, <%s>}", varnames[i].c_str(), yName);
                vec.SetDefinition(defn);
                vec.SetType(Expression::VectorMeshVar);
                md->AddExpression(&vec);
            }
            else
            {
                char zName[1024];
                SNPRINTF(yName, 1024, "z%s", varnames[i].c_str()+1);
                int matchZ = -1;
                for (j = 0 ; j < nVars ; j++)
                {
                    if (varnames[j] == zName)
                    {
                        matchZ = j;
                        break;
                    }
                }
                if (matchZ < 0)
                    continue;
                Expression vec;
                const char *str = varnames[i].c_str()+1;
                while (*str != '\0' && !isalpha(*str))
                    str++;
                vec.SetName(str);
                char defn[1024];
                SNPRINTF(defn, 1024, "{<%s>, <%s>, <%s>}", varnames[i].c_str(), 
                                                     yName,zName);
                vec.SetDefinition(defn);
                vec.SetType(Expression::VectorMeshVar);
                md->AddExpression(&vec);
            }
        }
    }

    md->SetTime(timestep, dtime);
    md->SetCycle(timestep, cycle);
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetLevelAndLocalPatchNumber
//
//  Purpose:
//      Translates our global patch identifier to a refinement level and patch
//      number local to that refinement level.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::GetLevelAndLocalPatchNumber(int global_patch,
                                            int &level, int &local_patch) const
{
    int tmp = global_patch;
    level = 0;
    while (1 && level < num_levels)
    {
        if (tmp < patchesPerLevel[level])
        {
            break;
        }
        tmp -= patchesPerLevel[level];
        level++;
    }
    local_patch = tmp;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

vtkDataSet *
avtChomboFileFormat::GetMesh(int patch, const char *meshname)
{
    int   i;

    if (strcmp(meshname, "Mesh") != 0)
        EXCEPTION1(InvalidVariableException, meshname);

    if (!initializedReader)
        InitializeReader();

    int level, local_patch;
    GetLevelAndLocalPatchNumber(patch, level, local_patch);

    if (level >= num_levels)
    {
        EXCEPTION1(InvalidVariableException, meshname);
    }

    if (local_patch >= patchesPerLevel[level])
    {
        EXCEPTION2(BadDomainException, local_patch, patchesPerLevel[level]);
    }

    int dims[3];
    dims[0] = hiI[patch]-lowI[patch]+1;
    dims[1] = hiJ[patch]-lowJ[patch]+1;
    dims[2] = (dimension == 3 ? hiK[patch]-lowK[patch]+1 : 1);

    vtkRectilinearGrid *rg = vtkRectilinearGrid::New();
    rg->SetDimensions(dims);

    vtkFloatArray  *xcoord = vtkFloatArray::New();
    vtkFloatArray  *ycoord = vtkFloatArray::New();
    vtkFloatArray  *zcoord = vtkFloatArray::New();

    xcoord->SetNumberOfTuples(dims[0]);
    ycoord->SetNumberOfTuples(dims[1]);
    zcoord->SetNumberOfTuples(dims[2]);

    float *ptr = xcoord->GetPointer(0);
    ptr[0] = lowI[patch]*dx[level];
    for (i = 1; i < dims[0]; i++)
        ptr[i] = ptr[i-1] + dx[level];

    ptr = ycoord->GetPointer(0);
    ptr[0] = lowJ[patch]*dx[level];
    for (i = 1; i < dims[1]; i++)
        ptr[i] = ptr[i-1] + dx[level];

    if (dimension == 3)
    {
        ptr = zcoord->GetPointer(0);
        ptr[0] = lowK[patch]*dx[level];
        for (i = 1; i < dims[2]; i++)
            ptr[i] = ptr[i-1] + dx[level];
    }
    else
       zcoord->SetTuple1(0, 0.);

    rg->SetXCoordinates(xcoord);
    rg->SetYCoordinates(ycoord);
    rg->SetZCoordinates(zcoord);

    xcoord->Delete();
    ycoord->Delete();
    zcoord->Delete();

    //
    // Determine the indices of the mesh within its group.  Add that to the
    // VTK dataset as field data.
    //
    vtkIntArray *arr = vtkIntArray::New();
    arr->SetNumberOfTuples(3);
    arr->SetValue(0, lowI[patch]);
    arr->SetValue(1, lowJ[patch]);
    arr->SetValue(2, (dimension == 3 ? lowK[patch] : 0));
    arr->SetName("base_index");
    rg->GetFieldData()->AddArray(arr);
    arr->Delete();

    return rg;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

vtkDataArray *
avtChomboFileFormat::GetVar(int patch, const char *varname)
{
    int   i;

    if (!initializedReader)
        InitializeReader();

    int varIdx = -1;
    int nVars = varnames.size();
    for (i = 0 ; i < nVars ; i++)
    {
        if (varnames[i] == varname)
        {
            varIdx = i;
            break;
        }
    }
    if (varIdx < 0)
        EXCEPTION1(InvalidVariableException, varname);

    int level, local_patch;
    GetLevelAndLocalPatchNumber(patch, level, local_patch);

    if (level >= num_levels)
    {
        EXCEPTION1(InvalidVariableException, varname);
    }

    if (local_patch >= patchesPerLevel[level])
    {
        EXCEPTION2(BadDomainException, local_patch, patchesPerLevel[level]);
    }

    //
    // Figure out how much data to read and what it's offset is into the
    // bigger array.  This will be needed so we can read a hyperslab from
    // the HDF file.
    //
    int patchStart = patch-local_patch;
    int nvals = 0;
    for (i = patchStart ; i < patch ; i++)
    {
        int numZones = (hiI[i]-lowI[i])*(hiJ[i]-lowJ[i]);
        if (dimension == 3)
            numZones *= (hiK[i]-lowK[i]);
        nvals += numZones*nVars;
    }
    int start = nvals;
    int amt = (hiI[patch]-lowI[patch])*(hiJ[patch]-lowJ[patch]);
    if (dimension == 3)
        amt *= (hiK[patch]-lowK[patch]);
    start += amt*varIdx;

    vtkFloatArray *farr = vtkFloatArray::New();
    farr->SetNumberOfComponents(1);
    farr->SetNumberOfTuples(amt);
    float *ptr = farr->GetPointer(0);

    // 
    // Now do the HDF magic.  Disclosure: this code was cobbled together
    // from examples I found on the internet.  If you think that there is a
    // more efficient way to do this (in lines of code or in performance), you
    // are probably right...
    //
    char name[1024];
    SNPRINTF(name, 1024, "level_%d", level);
    hid_t level_id = H5Gopen(file_handle, name);
    hid_t data = H5Dopen(level_id, "data:datatype=0");

    hid_t space_id = H5Dget_space(data);
    hid_t rank     = H5Sget_simple_extent_ndims(space_id);
    hsize_t dims[1];
    int status_n   = H5Sget_simple_extent_dims(space_id, dims, NULL);
    hssize_t offset[1] = { start };
    hsize_t count[1]  = { amt };
    H5Sselect_hyperslab(space_id, H5S_SELECT_SET, offset, NULL, count, NULL);
    
    hsize_t mem_size[1] = { amt };
    hid_t memdataspace = H5Screate_simple(1, mem_size, NULL);
    
    H5Dread(data, H5T_NATIVE_FLOAT, memdataspace, space_id, H5P_DEFAULT, ptr);

    H5Sclose(space_id);
    H5Sclose(memdataspace);
    H5Dclose(data);
    H5Gclose(level_id);

    return farr;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

vtkDataArray *
avtChomboFileFormat::GetVectorVar(int domain, const char *varname)
{
    return NULL;
}


// ****************************************************************************
//  Method: avtBoxlib2DFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Gets the auxiliary data specified.
//
//  Arguments:
//      var        The variable of interest.
//      dom        The domain of interest.
//      type       The type of auxiliary data.
//      <unnamed>  The arguments for that type -- not used.
//      df         Destructor function.
//
//  Returns:    The auxiliary data.
//
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void *
avtChomboFileFormat::GetAuxiliaryData(const char *var, int dom,
                                      const char * type, void *,
                                      DestructorFunction &df)
{
    if (strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0)
    {
        int totalPatches = 0;
        for (int level = 0 ; level < num_levels ; level++)
            totalPatches += patchesPerLevel[level];
    
        avtIntervalTree *itree = new avtIntervalTree(totalPatches, dimension);
    
        for (int patch = 0 ; patch < totalPatches ; patch++)
        {
            double bounds[6];
            int level, local_patch;

            GetLevelAndLocalPatchNumber(patch, level, local_patch);

            bounds[0] = lowI[patch]*dx[level];
            bounds[1] = bounds[0] + (hiI[patch]-lowI[patch])*dx[level];
            bounds[2] = lowJ[patch]*dx[level];
            bounds[3] = bounds[2] + (hiJ[patch]-lowJ[patch])*dx[level];
            bounds[4] = 0;
            bounds[5] = 0;
            if (dimension == 3)
            {
                bounds[4] = lowK[patch]*dx[level];
                bounds[5] = bounds[4] + (hiK[patch]-lowK[patch])*dx[level];
            }
            itree->AddDomain(patch, bounds);
        }
        itree->Calculate(true);

        df = avtIntervalTree::Destruct;

        return ((void *) itree);
    }

    return NULL;
}


