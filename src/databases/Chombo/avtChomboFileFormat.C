/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                           avtChomboFileFormat.C                           //
// ************************************************************************* //

#include <avtChomboFileFormat.h>

#include <snprintf.h>
#include <string>
#include <cstring>
#include <limits>

#include <vtkFieldData.h>
#include <vtkCellData.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkIntArray.h>
#include <vtkUnsignedCharArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkUnstructuredGrid.h>

#include <DBOptionsAttributes.h>

#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtStructuredDomainNesting.h>
#include <avtVariableCache.h>
#include <avtMaterial.h>

#include <Expression.h>

#include <Utility.h>

#include <BadDomainException.h>
#include <DebugStream.h>
#include <InvalidDBTypeException.h>
#include <InvalidFilesException.h>
#include <InvalidVariableException.h>
#include <TimingsManager.h>

// Define this symbol BEFORE including hdf5.h to indicate the HDF5 code
// in this file uses version 1.6 of the HDF5 API. This is harmless for
// versions of HDF5 before 1.8 and ensures correct compilation with
// version 1.8 and thereafter. When, and if, the HDF5 code in this file
// is explicitly upgraded to the 1.8 API, this symbol should be removed.
#define H5_USE_16_API
#include <hdf5.h>
#include <visit-hdf5.h>

using     std::string;


// ****************************************************************************
//  Method: avtChomboFileFormat constructor
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
//  Modifications:
//    Brad Whitlock, Mon Sep 25 13:59:20 PST 2006
//    Initialize the cycle and time.
//
//    Hank Childs, Mon Oct  8 17:17:24 PDT 2007
//    Initialized atts.
//
//    Gunther H. Weber, Tue Apr 15 17:43:30 PDT 2008
//    Add support to automatically import a coordinate mapping file via conn_cmfe
//
//    Gunther H. Weber, Thu Apr 17 14:29:25 PDT 2008
//    Check if an option exists before querying its value
//
//    Hank Childs, Sun Jan 25 15:39:08 PST 2009
//    Improve support for ghost data.
//
// ****************************************************************************

avtChomboFileFormat::avtChomboFileFormat(const char *filename, 
                                         DBOptionsAttributes *atts)
    : avtSTMDFileFormat(&filename, 1)
{
    initializedReader = false;
    allowedToUseGhosts = true;
    fileContainsGhosts = false;
    enableOnlyRootLevel = false;
    enableOnlyExplicitMaterials = false;
    checkForMappingFile = true;
    if (atts != NULL)
    {
        for (int i = 0; i < atts->GetNumberOfOptions(); ++i)
        {
            if (atts->GetName(i) == "Use ghost data (if present)")
                allowedToUseGhosts = atts->GetBool("Use ghost data (if present)");
            else if (atts->GetName(i) == "Enable only root level by default")
                enableOnlyRootLevel = atts->GetBool("Enable only root level by default");
            else if (atts->GetName(i) == "Enable only explicitly defined materials by default")
                enableOnlyExplicitMaterials = atts->GetBool("Enable only explicitly defined materials by default");
            else if (atts->GetName(i) == "Check for mapping file and import coordinates if available")
                checkForMappingFile = atts->GetBool("Check for mapping file and import coordinates if available");
            else
                debug1 << "Ignoring unknown option " << atts->GetName(i) << endl;
        }
    }

    file_handle = -1;
    dtime = 0.;
    cycle = 0;
}


// ****************************************************************************
//  Method: avtChomboFileFormat destructor
//
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

avtChomboFileFormat::~avtChomboFileFormat()
{
    FreeUpResources();
}


// ****************************************************************************
//  Method: avtChomboFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
//  Modifications:
//
//    Hank Childs, Mon Jun 19 16:56:26 PDT 2006
//    Add support for ghosts.
//
//    Gunther H. Weber, Thu Oct 11 16:00:16 PDT 2007
//    Clean up expressions from file
//
// ****************************************************************************

void
avtChomboFileFormat::FreeUpResources(void)
{
    initializedReader = false;
    if (file_handle != -1)
    {
        H5Fclose(file_handle);
        file_handle = -1;
    }
    varnames.clear();
    patchesPerLevel.clear();
    refinement_ratio.clear();
    dx.clear();
    lowI.clear();
    hiI.clear();
    lowJ.clear();
    hiJ.clear();
    lowK.clear();
    hiK.clear();
    numGhosts.clear();
    for (std::list<Expression*>::iterator it = expressions.begin(); it != expressions.end(); ++it)
        delete *it;
    expressions.clear();
}

// ****************************************************************************
// Method: avtChomboFileFormat::GetCycle
//
// Purpose: 
//   Get the cycle.
//
// Note:       We have to initialize the reader before returning a cycle
//             so we can accurately read the cycle from the file.
//
// Programmer: Brad Whitlock
// Creation:   Mon Sep 25 13:58:05 PST 2006
//
// Modifications:
//   
// ****************************************************************************

int
avtChomboFileFormat::GetCycle(void)
{
    InitializeReader();
    return cycle; 
}

// ****************************************************************************
// Method: avtChomboFileFormat::GetTime
//
// Purpose: 
//   Get the cycle.
//
// Note:       We have to initialize the reader before returning a time
//             so we can accurately read the time from the file.
//
// Programmer: Brad Whitlock
// Creation:   Mon Sep 25 13:58:05 PST 2006
//
// Modifications:
//   
// ****************************************************************************

double
avtChomboFileFormat::GetTime(void)
{
    InitializeReader();
    return dtime;
}

// ****************************************************************************
//  Method: avtChomboFileFormat::GetCycleFromFilename
//
//  Purpose:
//      Gets the cycle from the file name.  A custom implementation is needed,
//      because they have file names like "...plt0080.2d.hdf5".  We want the
//      "80".
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
//  Modifications:
//    Brad Whitlock, Mon Sep 25 13:57:02 PST 2006
//    Added code to support names like plot0.0080.2d.hdf5 where we want the 80.
//
//    Mark C. Miller, Thu Jun 14 10:26:37 PDT 2007
//    Modified to use regular expression based guess 
//
//    Mark C. Miller, Wed Sep 24 11:43:38 PDT 2008
//    Modified regular expression to meet specifications in ticket 8737
// ****************************************************************************

int
avtChomboFileFormat::GetCycleFromFilename(const char *fname) const
{
    int ret = avtFileFormat::INVALID_CYCLE;

    if (fname == 0 || fname[0] == '\0')
        return ret;

    return GuessCycle(fname, "<^([a-zA-Z_]*)([0-9]*\\.)?([0-9]*)\\.(2|3)d\\.hdf5$> \\3");
}


// ****************************************************************************
//  Method: avtChomboFileFormat::ActivateTimestep
//
//  Purpose:
//      Tells the reader it can now do some initialization work.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::ActivateTimestep(void)
{
    InitializeReader();
}


// ****************************************************************************
//  Method: avtChomboFileFormat::InitializeReader
//
//  Purpose:
//      Walks through the HDF5 file and reads in some non-problem size data.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
//  Modifications:
//
//    Hank Childs, Mon Jun 19 14:51:26 PDT 2006
//    Add support for when "time" is placed at "level_0".
//
//    Hank Childs, Mon Jun 19 16:44:06 PDT 2006
//    Added support for ghost zones.
//
//    Brad Whitlock, Mon Sep 25 15:22:38 PST 2006
//    I made it revert to cycles from the filename in the event that cycles
//    are not in the file.
//
//    Gunther H. Weber, Tue Aug  7 15:58:03 PDT 2007
//    Added check for variables specifying material fractions (variable name
//    fraction-<i>)
//
//    Gunther H. Weber, Thu Oct 11 15:49:41 PDT 2007
//    Read expressions from Chombo files.
//
//    Gunther H. Weber, Fri Oct 19 16:47:45 PDT 2007
//    Disable  HDF5 diagnostic output while attempting to read information
//    that may not be contained in the data set. Read problem domain from
//    file (used to figure out, which ghost cells are external to the problem).
//
//    Gunther H. Weber, Mon Oct 22 11:22:35 PDT 2007
//    Read information about problem domain [low|hi]Prob[I|J|K] needed
//    to figure out whether a ghost zone is external to the problem.
//
//    Gunther H. Weber, Mon Nov 19 14:02:59 PST 2007
//    Added missing H5Tclose in expression reading code.
//
//    Gunther H. Weber, Mon Mar 24 20:46:04 PDT 2008
//    Added support for node centered Chombo data.
//
//    Dave Pugmire, Fri Aug 22 10:27:39 EDT 2008
//    boxes_buff was leaking.
//
//    Hank Childs, Sun Jan 25 15:43:03 PST 2009
//    Set proper Boolean if we find evidence of ghost data.
//
//    Gunther H. Weber, Wed Mar 25 13:31:56 PDT 2009
//    Close file to prevent file handle depletion
//
// ****************************************************************************

void
avtChomboFileFormat::InitializeReader(void)
{
    int   i, j;

    if (initializedReader)
        return;

    debug5 << "avtChomboFileFormat: Initializing reader." << std::endl;

    //
    // Get current automatic stack traversal function to re-enable it later and
    // disable HDF5's automatic error printing
    //
    H5E_auto_t h5e_autofunc;
    void* h5e_clientdata;
    H5Eget_auto(&h5e_autofunc, &h5e_clientdata);
    H5Eset_auto(0, 0);

    //
    // Open file
    //
    file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file_handle < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, since "
                                           "it is not even an HDF5 file.");
    }

    //
    // Most of the global info is stored in the "/" group.
    //
    hid_t slash = H5Gopen(file_handle, "/");
    if (slash < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                           "have the \"/\" group.");
    }

    bool hasTime = false;
    bool hasIterations = false;
    bool hasCentering = false;

    int numAttrs = H5Aget_num_attrs(slash);
    char buf[1024];
    for (i = 0 ; i < numAttrs ; i++)
    {
        hid_t idx = H5Aopen_idx(slash, i);
        H5Aget_name(idx, 1024, buf);
        if (strcmp(buf, "time") == 0)
            hasTime = true;
        if (strcmp(buf, "iteration") == 0)
            hasIterations = true;
        if (strcmp(buf,"data_centering") == 0)
            hasCentering = true;
        H5Aclose(idx);
    }

    //
    // Get the time.
    //
    if (hasTime)
    {
        hid_t time_id = H5Aopen_name(slash, "time");
        if (time_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                               "have time in \"/\" group.");
        }
        H5Aread(time_id, H5T_NATIVE_DOUBLE, &dtime);
        H5Aclose(time_id);
    }
    else
        dtime = 0.;

    //
    // Get the cycle.
    //
    if (hasIterations)
    {
        hid_t cycle_id = H5Aopen_name(slash, "iteration");
        if (cycle_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                             "have iteration in \"/\" group.");
        }
        H5Aread(cycle_id, H5T_NATIVE_INT, &cycle);
        H5Aclose(cycle_id);
    }
    else
        cycle = GetCycleFromFilename(filenames[0]);

    //
    // Get the centering.
    //
    nodeCentered = false;
    if (hasCentering)
    {
        debug1 << "Chombo file has centering information." << std::endl;
        hid_t time_id = H5Aopen_name(slash, "data_centering");
        if (time_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                               "have data_centering in \"/\" group.");
        }
        int centeringVal;
        H5Aread(time_id, H5T_NATIVE_INT, &centeringVal);
        H5Aclose(time_id);
        if (centeringVal == 7)
        {
            debug1 << "Node centered data." << std::endl;
            nodeCentered = true;
        }
        else
        {
            debug1 << "Cell centered data." << std::endl;
        }
    }

    //
    // Note: max_level, per conversation with John Shalf, is for the code
    // to say what the maximum level could be.  We don't need this...
    //
    /*
    int max_level;
    hid_t ml_id = H5Aopen_name(slash, "max_level");
    H5Aread(ml_id, H5T_NATIVE_INT, &max_level);
    H5Aclose(ml_id);
    */

    //
    // Determine how many refinement levels there are.
    //
    hid_t nl_id = H5Aopen_name(slash, "num_levels");
    if (nl_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                           "have num_levels in \"/\" group.");
    }
    H5Aread(nl_id, H5T_NATIVE_INT, &num_levels);
    if (num_levels <= 0)
    {
        debug1 << "ERROR: Number of levels (" << num_levels 
               << ") must be at least 1" << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(nl_id);

    //
    // Determine how many variables there are.
    //
    int num_vars;
    hid_t nv_id = H5Aopen_name(slash, "num_components");
    if (nv_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, must "
                                        "have num_components in \"/\" group.");
    }
    H5Aread(nv_id, H5T_NATIVE_INT, &num_vars);
    if (num_vars < 0)
    {
        debug1 << "ERROR: Number of variables less than 0" << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(nv_id);

    //
    // Read out each variable name and store it in vector "varnames".
    //
    for (i = 0 ; i < num_vars ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "component_%d", i);
        hid_t vname = H5Aopen_name(slash, name);
        if (vname < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                               "not have all component names");
        }
        char name2[1024] = { '\0' };
        hid_t atype = H5Aget_type(vname);
        H5Aread(vname, atype, name2);
        varnames.push_back(name2);
        H5Aclose(vname);
    }

    //
    // We're done reading everything from "slash".
    //
    H5Gclose(slash);

    //
    // Now open up "Chombo_global".
    //
    hid_t global = H5Gopen(file_handle, "Chombo_global");
    if (global < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                           "not have Chombo_global");
    }
    hid_t dim_id = H5Aopen_name(global, "SpaceDim");
    if (dim_id < 0)
    {
        EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, does "
                                         "not have SpaceDim in Chombo_global");
    }
    H5Aread(dim_id, H5T_NATIVE_INT, &dimension);
    if (dimension != 2 && dimension != 3)
    {
        debug1 << "ERROR: Reader only supports 2D and 3D data sets." << endl;
        EXCEPTION1(InvalidFilesException, filenames[0]);
    }
    H5Aclose(dim_id);
    H5Gclose(global);

    //
    // Look for epxressions
    //
    hid_t expressionsGroup = H5Gopen(file_handle, "/Expressions");
    if (expressionsGroup > 0)
    {
        for (unsigned int i=0; i<H5Aget_num_attrs(expressionsGroup); ++i)
        {
            // Open expression
            hid_t currExpression = H5Aopen_idx(expressionsGroup, i);

            // Get name, which has form <return type> <name>
            const size_t buffSize = 1024;
            char buffer[buffSize];
            H5Aget_name(currExpression, buffSize, buffer);

            // Split into type and name
            char *separatorPos = std::strchr(buffer, ' ');
            *separatorPos = '\0';
            char *exprTypeStr = buffer;
            char *exprName = separatorPos + 1;

            // Parse type
            Expression::ExprType exprType = Expression::Unknown;
            if (strcmp("vector", exprTypeStr) == 0)
                exprType = Expression::VectorMeshVar;
            else if (strcmp("scalar", exprTypeStr) == 0)
                exprType = Expression::ScalarMeshVar;
            else 
                debug1 << "Unknown expression type " << exprType << " in file." << std::endl;

            if (exprType != Expression::Unknown) 
            {
                hid_t strType = H5Aget_type(currExpression);
                hsize_t strLen;
                if (strType >= 0 && H5Tget_class(strType) == H5T_STRING &&
                    (strLen = H5Tget_size(strType)) < buffSize - 1)
                {
                    Expression *newExpression = new Expression;
                    newExpression->SetName(exprName);
                    newExpression->SetType(exprType);
                    newExpression->SetHidden(false);

                    // Read definition
                    H5Aread(currExpression, strType, buffer);
                    buffer[strLen]  = '\0';
                    newExpression->SetDefinition(buffer);
                    expressions.push_back(newExpression);
                }
                H5Tclose(strType);
            }
            H5Aclose(currExpression);
        }
        H5Gclose(expressionsGroup);
    }

    //
    // Now iterate over each refinement level and determine how many patches
    // there are at that refinement level, what the refinement ratio is, and
    // what "dx" is ... "dx" is the distance between consecutive points.
    //
    int totalPatches = 0;
    patchesPerLevel.resize(num_levels);
    refinement_ratio.resize(num_levels);
    dx.resize(num_levels);
    for (i = 0 ; i < num_levels ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "level_%d", i);
        hid_t level = H5Gopen(file_handle, name);
        if (level < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain all "
                                               "refinement levels.");
        }

        hid_t boxes = H5Dopen(level, "boxes");
        if (boxes < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain \"boxes\".");
        }
        hid_t boxspace = H5Dget_space(boxes);
        hsize_t dims[1], maxdims[1];
        H5Sget_simple_extent_dims(boxspace, dims, maxdims);
        hid_t memdataspace = H5Screate_simple(1, dims, NULL);
        patchesPerLevel[i] = dims[0];
        totalPatches += patchesPerLevel[i];

        hid_t dx_id = H5Aopen_name(level, "dx");
        if (dx_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Does not contain \"dx\".");
        }
        double dx_tmp;
        H5Aread(dx_id, H5T_NATIVE_DOUBLE, &dx_tmp);
        H5Aclose(dx_id);
        dx[i] = dx_tmp;

        hid_t rr_id = H5Aopen_name(level, "ref_ratio");
        if (rr_id < 0)
        {
            EXCEPTION1(InvalidDBTypeException,
                                            "Does not contain \"ref_ratio\".");
        }
        int rr;
        H5Aread(rr_id, H5T_NATIVE_INT, &rr);
        H5Aclose(rr_id);
        refinement_ratio[i] = rr;

        if (!hasTime && i == 0)
        {
            // Some Chombo files put time at level_0 instead of in the "/"
            // directory.  Look for it here.
            hid_t time_id = H5Aopen_name(level, "time");
            if (time_id >= 0)
            {
                H5Aread(time_id, H5T_NATIVE_DOUBLE, &dtime);
                H5Aclose(time_id);
            }
        }

        H5Sclose(memdataspace);
        H5Sclose(boxspace);
        H5Dclose(boxes);
        H5Gclose(level);
    }

    // 
    // Now that we know how many total patches there are, create our data
    // structures to hold the extents of each patch.
    //
    lowI.resize(totalPatches);
    hiI.resize(totalPatches);
    lowJ.resize(totalPatches);
    hiJ.resize(totalPatches);
    if (dimension == 3)
    {
        lowK.resize(totalPatches);
        hiK.resize(totalPatches);
    }

    //
    // Also, create space for the problem domain extent for each level
    //
    lowProbI.resize(num_levels);
    hiProbI.resize(num_levels);
    lowProbJ.resize(num_levels);
    hiProbJ.resize(num_levels);
    if (dimension == 3)
    {
        lowProbK.resize(num_levels);
        hiProbK.resize(num_levels);
    }
    
    //
    // Now iterate over the patches again, storing their extents in our
    // internal data structure.
    //
    hid_t box2d_id = H5Tcreate (H5T_COMPOUND, sizeof(box));
    H5Tinsert (box2d_id, "lo_i", HOFFSET(box2d, lo.i), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "lo_j", HOFFSET(box2d, lo.j), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "hi_i", HOFFSET(box2d, hi.i), H5T_NATIVE_INT);
    H5Tinsert (box2d_id, "hi_j", HOFFSET(box2d, hi.j), H5T_NATIVE_INT);

    hid_t box3d_id = H5Tcreate (H5T_COMPOUND, sizeof(box));
    H5Tinsert (box3d_id, "lo_i", HOFFSET(box3d, lo.i), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "lo_j", HOFFSET(box3d, lo.j), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "lo_k", HOFFSET(box3d, lo.k), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_i", HOFFSET(box3d, hi.i), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_j", HOFFSET(box3d, hi.j), H5T_NATIVE_INT);
    H5Tinsert (box3d_id, "hi_k", HOFFSET(box3d, hi.k), H5T_NATIVE_INT);

    hid_t intvect2d_id = H5Tcreate (H5T_COMPOUND, sizeof(intvect2d));
    H5Tinsert (intvect2d_id, "intvecti", HOFFSET(intvect2d, i), H5T_NATIVE_INT);
    H5Tinsert (intvect2d_id, "intvectj", HOFFSET(intvect2d, j), H5T_NATIVE_INT);

    hid_t intvect3d_id = H5Tcreate (H5T_COMPOUND, sizeof(intvect3d));
    H5Tinsert (intvect3d_id, "intvecti", HOFFSET(intvect3d, i), H5T_NATIVE_INT);
    H5Tinsert (intvect3d_id, "intvectj", HOFFSET(intvect3d, j), H5T_NATIVE_INT);
    H5Tinsert (intvect3d_id, "intvectk", HOFFSET(intvect3d, k), H5T_NATIVE_INT);

    int patchId = 0;
    for (i = 0 ; i < num_levels ; i++)
    {
        char name[1024];
        SNPRINTF(name, 1024, "level_%d", i);

        hid_t level = H5Gopen(file_handle, name);
        hid_t boxes = H5Dopen(level, "boxes");
        hid_t boxspace = H5Dget_space(boxes);
        hsize_t dims[1], maxdims[1];
        H5Sget_simple_extent_dims(boxspace, dims, maxdims);
        hid_t memdataspace = H5Screate_simple(1, dims, NULL);

        //
        // Level 0 contains information about the problem domain
        // 
        if (i == 0)
        {
            hid_t probDomain = H5Aopen_name(level, "prob_domain");
            if (probDomain < 0)
            {
                EXCEPTION1(InvalidDBTypeException, "Does not contain \"prob_domain\".");
            }
            box *probDomain_buff = new box;
            if (H5Aread(probDomain, (dimension == 2 ? box2d_id : box3d_id), probDomain_buff) < 0)
            {
                EXCEPTION1(InvalidDBTypeException, "Cannot read \"prob_domain\".");
            }
            if (dimension == 2)
            {
                lowProbI[0] = probDomain_buff->b2.lo.i;
                hiProbI[0] = probDomain_buff->b2.hi.i;
                lowProbJ[0] = probDomain_buff->b2.lo.j;
                hiProbJ[0] = probDomain_buff->b2.hi.j;
            }
            else
            {
                lowProbI[0] = probDomain_buff->b3.lo.i;
                hiProbI[0] = probDomain_buff->b3.hi.i;
                lowProbJ[0] = probDomain_buff->b3.lo.j;
                hiProbJ[0] = probDomain_buff->b3.hi.j;
                lowProbK[0] = probDomain_buff->b3.lo.k;
                hiProbK[0] = probDomain_buff->b3.hi.k;
            }
            delete probDomain_buff;
            H5Aclose(probDomain);
        }
        else
        {
            // In higher levels, calculate the information using
            // the previous level and refinement ratio
            lowProbI[i] = refinement_ratio[i-1] * lowProbI[i-1];
            hiProbI[i] = refinement_ratio[i-1] * hiProbI[i-1];
            lowProbJ[i] = refinement_ratio[i-1] * lowProbJ[i-1];
            hiProbJ[i] = refinement_ratio[i-1] * hiProbJ[i-1];
            if (dimension == 3)
            {
                lowProbK[i] = refinement_ratio[i-1] * lowProbK[i-1];
                hiProbK[i] = refinement_ratio[i-1] * hiProbK[i-1];
            }
        }

        //
        // Read box information
        //
        box *boxes_buff = new box[dims[0]];
        H5Dread(boxes, (dimension == 2 ? box2d_id : box3d_id), memdataspace, 
                boxspace, H5P_DEFAULT, boxes_buff);

        for (j = 0 ; j < patchesPerLevel[i] ; j++)
        {
            if (dimension == 2)
            {
                lowI[patchId] = boxes_buff[j].b2.lo.i;
                lowJ[patchId] = boxes_buff[j].b2.lo.j;
                hiI[patchId] = boxes_buff[j].b2.hi.i+1;
                hiJ[patchId] = boxes_buff[j].b2.hi.j+1;
            }
            else
            {
                lowI[patchId] = boxes_buff[j].b3.lo.i;
                lowJ[patchId] = boxes_buff[j].b3.lo.j;
                lowK[patchId] = boxes_buff[j].b3.lo.k;
                hiI[patchId] = boxes_buff[j].b3.hi.i+1;
                hiJ[patchId] = boxes_buff[j].b3.hi.j+1;
                hiK[patchId] = boxes_buff[j].b3.hi.k+1;
            }
            patchId++;
        }

        delete [] boxes_buff;

        hid_t data_atts = H5Gopen(level, "data_attributes");
        if (data_atts >= 0)
        {
            hid_t ghost_id = H5Aopen_name(data_atts, "outputGhost");
            if (ghost_id < 0)
            {
                numGhosts.push_back(0);
                numGhosts.push_back(0);
                numGhosts.push_back(0);
            }
            else
            {
                int g[3] = { 0, 0, 0 };
                if (dimension == 2)
                {
                    intvect2d g;
                    H5Aread(ghost_id, intvect2d_id, &g);
                    numGhosts.push_back(g.i);
                    numGhosts.push_back(g.j);
                    if (g.i > 0 || g.j > 0)
                        fileContainsGhosts = true;
                    numGhosts.push_back(0);
                }
                else
                {
                    intvect3d g;
                    H5Aread(ghost_id, intvect3d_id, &g);
                    if (g.i > 0 || g.j > 0 || g.k)
                        fileContainsGhosts = true;
                    numGhosts.push_back(g.i);
                    numGhosts.push_back(g.j);
                    numGhosts.push_back(g.k);
                }
                H5Aclose(ghost_id);
            }
            H5Gclose(data_atts);
        }
        else
        {
            numGhosts.push_back(0);
            numGhosts.push_back(0);
            numGhosts.push_back(0);
        }
           
        H5Sclose(memdataspace);
        H5Sclose(boxspace);
        H5Dclose(boxes);
        H5Gclose(level);
    }

    H5Tclose(box2d_id);
    H5Tclose(box3d_id);

    //
    // Re-enable HDF5's automatic diagnostic output
    //
    H5Eset_auto(h5e_autofunc, h5e_clientdata);

    //
    // The domain nesting takes a while to calculate.  We don't need the
    // data structure if we are on the mdserver.  But we do if we're on the
    // engine.  So only calculate it conditionally.
    //
    if (!avtDatabase::OnlyServeUpMetaData())
    {
        int t0 = visitTimer->StartTimer();
        CalculateDomainNesting();
        visitTimer->StopTimer(t0, "Chombo calculating domain nesting");
    }

    H5Fclose(file_handle);
    file_handle = -1;
    initializedReader = true;

    //
    // Find any materials
    //
    nMaterials = 0;
    for (i = 0; i < varnames.size(); ++i)
    {
        int val = 0;
        if (varnames[i].find("fraction-") == 0)
        {
            int val = atoi(varnames[i].c_str()+9) + 1;

            if (val > nMaterials)
                nMaterials = val;
        }
    }

    if (nMaterials != 0)
    {
	++nMaterials; // There is always one extra material
    }
}


// ****************************************************************************
//  Method: avtChomboFileFormat::CalculateDomainNesting
//
//  Purpose:
//      Calculates two important data structures.  One is the structure domain
//      nesting, which tells VisIt how the AMR patches are nested, which allows
//      VisIt to ghost out coarse zones that are refined by smaller zones.
//      The other structure is the rectilinear domain boundaries, which tells
//      VisIt which patches are next to each other, allowing VisIt to create
//      a layer of ghost zones around each patch.  Note that this only works
//      within a refinement level, not across refinement levels.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
//  Modifications:
//
//    Hank Childs, Fri Nov 14 09:11:33 PST 2008
//    Only create the domain boundaries object if we are not using ghost data.
//
//    Hank Childs, Sun Jan 25 15:54:52 PST 2009
//    Improve the test for whether or not to create the domain boundaries
//    object.
//
// ****************************************************************************

void
avtChomboFileFormat::CalculateDomainNesting(void)
{
    int j;
    int level;

    //
    // Calculate some info we will need in the rest of the routine.
    //
    int t0 = visitTimer->StartTimer();
    int totalPatches = 0;
    vector<int> levelStart;
    vector<int> levelEnd;
    for (level = 0 ; level < num_levels ; level++)
    {

        levelStart.push_back(totalPatches);
        totalPatches += patchesPerLevel[level];
        levelEnd.push_back(totalPatches);
    }
    visitTimer->StopTimer(t0, "Pre-work for domain nesting");

    //
    // Now that we know the total number of patches, we can allocate the
    // data structure for the patch nesting.
    //
    int t1 = visitTimer->StartTimer();
    avtStructuredDomainNesting *dn = new avtStructuredDomainNesting(
                                          totalPatches, num_levels);

    //
    // Calculate what the refinement ratio is from one level to the next.
    //
    vector<int> rr(dimension);
    for (level = 0 ; level < num_levels ; level++)
    {
        if (level == 0)
        {
            for (j = 0 ; j < dimension ; j++)
                rr[j] = 1;
        }
        else
        {
            for (j = 0 ; j < dimension ; j++)
                rr[j] = refinement_ratio[level-1];
        }
        dn->SetLevelRefinementRatios(level, rr);
    }

    //
    // This multiplier will be needed to find out if patches are nested.
    //
    vector<int> multiplier(num_levels);
    multiplier[num_levels-1] = 1;
    for (level = num_levels-2 ; level >= 0 ; level--)
    {
        multiplier[level] = multiplier[level+1]*refinement_ratio[level];
    }
    visitTimer->StopTimer(t1, "Setting up domain nesting: part 1");

    //
    // Now set up the data structure for patch boundaries.  The data 
    // does all the work ... it just needs to know the extents of each patch.
    //
    if (!allowedToUseGhosts || !fileContainsGhosts)
    {
        int t2 = visitTimer->StartTimer();
        avtRectilinearDomainBoundaries *rdb 
                                    = new avtRectilinearDomainBoundaries(true);
        rdb->SetNumDomains(totalPatches);
        for (int patch = 0 ; patch < totalPatches ; patch++)
        {
            int my_level, local_patch;
            GetLevelAndLocalPatchNumber(patch, my_level, local_patch);
    
            int e[6];
            e[0] = lowI[patch];
            e[1] = hiI[patch];
            e[2] = lowJ[patch];
            e[3] = hiJ[patch];
            e[4] = (dimension == 2 ? 0 : lowK[patch]);
            e[5] = (dimension == 2 ? 0 : hiK[patch]);
    
            rdb->SetIndicesForAMRPatch(patch, my_level, e);
        }
        rdb->CalculateBoundaries();
        void_ref_ptr vrdb = void_ref_ptr(rdb,
                                       avtStructuredDomainBoundaries::Destruct);
        cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION,
                            timestep, -1, vrdb);
        visitTimer->StopTimer(t2, "Chombo reader doing rect domain boundaries");
    }

    //
    // Calculate the child patches.
    //
    int t3 = visitTimer->StartTimer();
    vector< vector<int> > childPatches(totalPatches);
    for (level = num_levels-1 ; level > 0 ; level--)
    {
        int prev_level = level-1;
        int coarse_start  = levelStart[prev_level];
        int coarse_end    = levelEnd[prev_level];
        int num_coarse    = coarse_end - coarse_start;
        int mc            = multiplier[prev_level];
        avtIntervalTree coarse_levels(num_coarse, dimension, false);
        double exts[6] = { 0, 0, 0, 0, 0, 0 };
        for (int i = 0 ; i < num_coarse ; i++)
        {
            exts[0] = mc*lowI[coarse_start+i];
            exts[1] = mc*hiI[coarse_start+i];
            exts[2] = mc*lowJ[coarse_start+i];
            exts[3] = mc*hiJ[coarse_start+i];
            if (dimension == 3)
            {
                exts[4] = mc*lowK[coarse_start+i];
                exts[5] = mc*hiK[coarse_start+i];
            }
            coarse_levels.AddElement(i, exts);
        }
        coarse_levels.Calculate(true);
        
        int patches_start = levelStart[level];
        int patches_end   = levelEnd[level];
        int mp = multiplier[level];
        for (int patch = patches_start ; patch < patches_end ; patch++)
        {
            double min[3];
            double max[3];
            min[0] = mp*lowI[patch];
            max[0] = mp*hiI[patch];
            min[1] = mp*lowJ[patch];
            max[1] = mp*hiJ[patch];
            if (dimension == 3)
            {
                min[2] = mp*lowK[patch];
                max[2] = mp*hiK[patch];
            }
            vector<int> list;
            coarse_levels.GetElementsListFromRange(min, max, list);
            for (int i = 0 ; i < list.size() ; i++)
            {
                int candidate = coarse_start + list[i];
                if (hiI[patch]*mp < lowI[candidate]*mc)
                    continue;
                if (lowI[patch]*mp >= hiI[candidate]*mc)
                    continue;
                if (hiJ[patch]*mp < lowJ[candidate]*mc)
                    continue;
                if (lowJ[patch]*mp >= hiJ[candidate]*mc)
                    continue;
                if (dimension == 3)
                {
                    if (hiK[patch]*mp < lowK[candidate]*mc)
                        continue;
                    if (lowK[patch]*mp >= hiK[candidate]*mc)
                        continue;
                }
                childPatches[candidate].push_back(patch);
           }
        }
    }
    visitTimer->StopTimer(t3, "Slow part of Chombo nesting.");

    //
    // Now that we know the extents for each patch and what its children are,
    // tell the structured domain boundary that information.
    //
    int t4 = visitTimer->StartTimer();
    for (int i = 0 ; i < totalPatches ; i++)
    {
        int my_level, local_patch;
        GetLevelAndLocalPatchNumber(i, my_level, local_patch);

        vector<int> logExts(6);
        logExts[0] = lowI[i];
        logExts[3] = hiI[i]-1;
        logExts[1] = lowJ[i];
        logExts[4] = hiJ[i]-1;
        logExts[2] = 0;
        logExts[5] = 0;
        if (dimension == 3)
        {
            logExts[2] = lowK[i];
            logExts[5] = hiK[i]-1;
        }

        dn->SetNestingForDomain(i, my_level, childPatches[i], logExts);
    }

    //
    // Register this structure with the generic database so that it knows
    // to ghost out the right cells.
    //
    dn->SetNumDimensions(dimension);
    void_ref_ptr vr = void_ref_ptr(dn, avtStructuredDomainNesting::Destruct);
    cache->CacheVoidRef("any_mesh", AUXILIARY_DATA_DOMAIN_NESTING_INFORMATION,
                        timestep, -1, vr);
    visitTimer->StopTimer(t4, "Final step of Chombo nesting");
}


// ****************************************************************************
//  Method: avtChomboFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
//  Modifications:
//
//    Hank Childs, Mon Jun 19 14:30:12 PDT 2006
//    Fix problem with grouping vectors in 3D.  Also add support for U,V,W
//    vectors.
//
//    Gunther H. Weber, Tue Aug  7 16:00:22 PDT 2007
//    If material information was found in the file, add corresponding
//    meta data
//
//    Gunther H. Weber, Thu Oct 11 15:49:41 PDT 2007
//    Add expressions from Chombo files.
//
//    Hank Childs, Sun Oct 28 09:42:50 PST 2007
//    Set meta-data saying whether or not we have ghosts on the exterior
//    boundary.
//
//    Gunther H. Weber, Mon Mar 24 20:46:04 PDT 2008
//    Added support for node centered Chombo data.
//
//    Gunther H. Weber, Mon Mar 24 21:14:59 PDT 2008
//    Fixed bug for files containing only one level when "default to only root
//    level was selected" (for these files an empty selection was the result).
//
//    Gunther H. Weber, Tue Apr 15 17:43:30 PDT 2008
//    Add support to automatically import a coordinate mapping file via
//    conn_cmfe.
//
//    Gunther H. Weber, Thu Apr 17 14:47:44 PDT 2008
//    Do not use a unique but unreadable name for displacement expression
//    since database-defined expressions are local to database.
//
//    Gunther H. Weber, Thu May  8 19:41:52 PDT 2008
//    Set spatial extents.
//
//    Hank Childs, Sun Jan 25 15:55:17 PST 2009
//    Change test for whether or not we are using ghost data.
//
// ****************************************************************************

void
avtChomboFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    int   i, j;

    if (!initializedReader)
        InitializeReader();

    int totalPatches = 0;
    int level;
    for (level = 0 ; level < num_levels ; level++)
    {
        totalPatches += patchesPerLevel[level];
    }

    // Prevent VisIt from sorting the variables.
    md->SetMustAlphabetizeVariables(false);

    //
    // Set up the mesh.  Use the groups construct to represent refinement
    // levels.  Also take care to name each patch in an appropriate way.
    char mesh_name[32] = "Mesh";
    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = mesh_name;
    mesh->meshType = AVT_AMR_MESH;
    mesh->numBlocks = totalPatches;
    mesh->blockOrigin = 0;
    mesh->spatialDimension = dimension;
    mesh->topologicalDimension = dimension;
    mesh->hasSpatialExtents = true;
    mesh->minSpatialExtents[0] = lowProbI[0] * dx[0];
    mesh->maxSpatialExtents[0] = (hiProbI[0] + 1) * dx[0];
    mesh->minSpatialExtents[1] = lowProbJ[0] * dx[0];
    mesh->maxSpatialExtents[1] = (hiProbJ[0] + 1) * dx[0];
    if (dimension == 3)
    {
        mesh->minSpatialExtents[2] = lowProbK[0] * dx[0];
        mesh->maxSpatialExtents[2] = (hiProbK[0] + 1) * dx[0];
    }
    mesh->blockTitle = "patches";
    mesh->blockPieceName = "patch";
    mesh->numGroups = num_levels;
    mesh->groupTitle = "levels";
    mesh->groupPieceName = "level";
    mesh->containsExteriorBoundaryGhosts = allowedToUseGhosts && fileContainsGhosts;
    std::vector<int> groupIds(totalPatches);
    std::vector<string> blockPieceNames(totalPatches);
    for (i = 0 ; i < totalPatches ; i++)
    {
        char tmpName[128];
        int level, local_patch;
        GetLevelAndLocalPatchNumber(i, level, local_patch);
        groupIds[i] = level;
        sprintf(tmpName, "level%d,patch%d", level, local_patch);
        blockPieceNames[i] = tmpName;
    }
    mesh->blockNames = blockPieceNames;
    md->Add(mesh);
    md->AddGroupInformation(num_levels, totalPatches, groupIds);

    //
    // Add each scalar variable.
    //
    int nVars = varnames.size();
    for (i = 0; i < nVars; i++)
    {
        AddScalarVarToMetaData(md, varnames[i], mesh_name, nodeCentered ? AVT_NODECENT : AVT_ZONECENT);
    }

    //
    // Chombo has no vector variables.  But it clearly has some scalar
    // variables that should be combined into vectors.  Identify these and
    // make expressions for the vectors.
    //
    for (i = 0; i < nVars; i++)
    {
        int id2 = -1;
        bool startsWithFirst = false;
        bool foundVector = false;
        if (varnames[i][0] == 'x' || varnames[i][0] == 'X' || 
            varnames[i][0] == 'u' || varnames[i][0] == 'U')
        {
            char yChar = '\0', zChar = '\0';
            if (varnames[i][0] == 'x')
            {
                yChar = 'y';
                zChar = 'z';
            }
            else if (varnames[i][0] == 'X')
            {
                yChar = 'Y';
                zChar = 'Z';
            }
            else if (varnames[i][0] == 'u')
            {
                yChar = 'v';
                zChar = 'w';
            }
            else if (varnames[i][0] == 'U')
            {
                yChar = 'V';
                zChar = 'W';
            }

            char yName[1024];
            SNPRINTF(yName, 1024, "%c%s", yChar, varnames[i].c_str()+1);
            int matchY = -1;
            for (j = 0 ; j < nVars ; j++)
            {
                if (varnames[j] == yName)
                {
                    matchY = j;
                    break;
                }
            }
            if (matchY < 0)
                continue;
            if (dimension == 2)
            {
                Expression vec;
                const char *str = varnames[i].c_str()+1;
                while (*str != '\0' && !isalpha(*str))
                    str++;
                vec.SetName(str);
                char defn[1024];
                SNPRINTF(defn, 1024, "{<%s>, <%s>}", varnames[i].c_str(), yName);
                vec.SetDefinition(defn);
                vec.SetType(Expression::VectorMeshVar);
                md->AddExpression(&vec);
            }
            else
            {
                char zName[1024];
                SNPRINTF(zName, 1024, "%c%s", zChar, varnames[i].c_str()+1);
                int matchZ = -1;
                for (j = 0 ; j < nVars ; j++)
                {
                    if (varnames[j] == zName)
                    {
                        matchZ = j;
                        break;
                    }
                }
                if (matchZ < 0)
                    continue;
                Expression vec;
                const char *str = varnames[i].c_str()+1;
                while (*str != '\0' && !isalpha(*str))
                    str++;
                vec.SetName(str);
                char defn[1024];
                SNPRINTF(defn, 1024, "{<%s>, <%s>, <%s>}", varnames[i].c_str(), 
                                                     yName,zName);
                vec.SetDefinition(defn);
                vec.SetType(Expression::VectorMeshVar);
                md->AddExpression(&vec);
            }
        }
    }

    //
    // If any materials were found, add them here
    // 
    if (nMaterials)
    {
        vector<string> mnames(nMaterials);

        string matname;
        matname = "materials";
        
        char str[32];
        for (int m = 0; m < nMaterials; ++m)
        {
            sprintf(str, "mat%d", m+1);
            mnames[m] = str;
        }
        AddMaterialToMetaData(md, matname, mesh_name, nMaterials, mnames);
    }

    //
    // If any expressions where found, add them here
    //
    for (std::list<Expression*>::iterator it = expressions.begin(); it != expressions.end(); ++it)
    {
        md->AddExpression(*it);
    }

    //
    // Check for existence of mapping file
    //
    if (checkForMappingFile)
    {
        std::string mappingFilename(filenames[0]);
        size_t extPos = mappingFilename.find(".hdf5");
        if  (extPos == std::string::npos)
        {
            extPos = mappingFilename.find(".h5");
        }

        if (extPos != std::string::npos)
        {
            mappingFilename.insert(extPos, ".map");

            VisItStat_t fs;
            if (VisItStat(mappingFilename.c_str(), &fs) == 0)
            {
                debug5 << "Found mapping file " << mappingFilename << ". ";
                debug5 << "Adding cmfe expression!" << std::endl;

#ifdef _WIN32
                // Escape ":" and "\" in Windows filenames
                int numCharactersToEscape = 0;
                for (std::string::iterator it = mappingFilename.begin();
                        it != mappingFilename.end(); ++it)
                    if (*it == ':' || *it == '\\')
                        ++numCharactersToEscape;

                if (numCharactersToEscape)
                {
                    std::string escapedFilename;
                    for (std::string::iterator it = mappingFilename.begin();
                            it != mappingFilename.end(); ++it)
                    {
                        if (*it == ':' || *it == '\\')
                            escapedFilename.push_back('\\');
                        escapedFilename.push_back(*it);
                    }
                    mappingFilename = escapedFilename; 
                }
#endif

                Expression *mappingExpression = new Expression;
                //mappingExpression->SetName("_"+mappingVarPrefix+"_disp");
                mappingExpression->SetName("_mapping_displacement");
                mappingExpression->SetType(Expression::VectorMeshVar);
                mappingExpression->SetHidden(false);

                if (dimension == 2)
                    mappingExpression->SetDefinition(
                            "{conn_cmfe(<"+mappingFilename+":x>,Mesh)-coords(Mesh)[0]," +
                            "conn_cmfe(<"+mappingFilename+":y>,Mesh)-coords(Mesh)[1]}");
                else
                    mappingExpression->SetDefinition(
                            "{conn_cmfe(<"+mappingFilename+":x>,Mesh)-coords(Mesh)[0]," +
                            "conn_cmfe(<"+mappingFilename+":y>,Mesh)-coords(Mesh)[1]," +
                            "conn_cmfe(<"+mappingFilename+":z>,Mesh)-coords(Mesh)[2]}");

                md->AddExpression(mappingExpression);
            }
            else
            {
                debug5 << "No mapping file " << mappingFilename << " exists. ";
                debug5 << "No need to add cmfe expressions." << std::endl;
            }
        }
        else
        {
            debug1 << "Warning: Chombo file does not have .h5 or .hdf5 extension. ";
            debug1 << "Cannot figure out possible filename for coordinate mapping file. ";
            debug1 << "Ignoring any mapping files." << endl;
        }
    }


    //
    // Add information about SIL restrictions
    //
    if (enableOnlyRootLevel || enableOnlyExplicitMaterials)
    {
        if (enableOnlyRootLevel && num_levels > 1)
        {
            md->AddDefaultSILRestrictionDescription(std::string("!TurnOffAll"));
            md->AddDefaultSILRestrictionDescription(std::string("+level0"));
        }
        else
        {
            md->AddDefaultSILRestrictionDescription(std::string("!TurnOnAll"));
        }
        if (enableOnlyExplicitMaterials && nMaterials > 1)
        {
            char str[32];
            sprintf(str, "-mat%d", nMaterials);
            md->AddDefaultSILRestrictionDescription(std::string(str));
        }
    }

    md->SetTime(timestep, dtime);
    md->SetCycle(timestep, cycle);
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetLevelAndLocalPatchNumber
//
//  Purpose:
//      Translates our global patch identifier to a refinement level and patch
//      number local to that refinement level.
//  
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
// ****************************************************************************

void
avtChomboFileFormat::GetLevelAndLocalPatchNumber(int global_patch,
                                            int &level, int &local_patch) const
{
    int tmp = global_patch;
    level = 0;
    while (1 && level < num_levels)
    {
        if (tmp < patchesPerLevel[level])
        {
            break;
        }
        tmp -= patchesPerLevel[level];
        level++;
    }
    local_patch = tmp;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
//  Modifications:
//
//    Hank Childs, Thu Sep 27 17:14:58 PDT 2007
//    Avoid floating point accumulation errors.
//
//    Gunther H. Wever, Wed Oct  3 17:34:56 PDT 2007
//    Do not strip ghost zones from file and instead add appropriate
//    ghost zone field data.
//
//    Hank Childs, Mon Oct  8 17:22:26 PDT 2007
//    Make Gunther's code go live using DB options.  Also correct bug with
//    setting coordinate positions with ghost zones.
//
//    Gunther H. Weber, Mon Oct 22 11:50:41 PDT 2007
//    Distinguish between ghost zones internal and exterior to problem.
//
//    Hank Childs, Sun Oct 28 13:36:43 PST 2007
//    Fix bug with avtRealDims.
//
//    Hank Childs, Sun Jan 25 15:55:31 PST 2009
//    Change test for whether or not we are allowed to use ghost data.
//
// ****************************************************************************

vtkDataSet *
avtChomboFileFormat::GetMesh(int patch, const char *meshname)
{
    int   i;

    if (strcmp(meshname, "Mesh") != 0)
        EXCEPTION1(InvalidVariableException, meshname);

    if (!initializedReader)
        InitializeReader();

    int level, local_patch;
    GetLevelAndLocalPatchNumber(patch, level, local_patch);

    if (level >= num_levels)
    {
        EXCEPTION1(InvalidVariableException, meshname);
    }

    if (local_patch >= patchesPerLevel[level])
    {
        EXCEPTION2(BadDomainException, local_patch, patchesPerLevel[level]);
    }

    int dims[3];
    int numGhostI = 0, numGhostJ = 0, numGhostK = 0;
    if (!allowedToUseGhosts)
    {
        dims[0] = hiI[patch]-lowI[patch]+1;
        dims[1] = hiJ[patch]-lowJ[patch]+1;
        dims[2] = (dimension == 3 ? hiK[patch]-lowK[patch]+1 : 1);
    }
    else
    {
        numGhostI = numGhosts[3*level];
        numGhostJ = numGhosts[3*level+1];
        numGhostK = numGhosts[3*level+2];
     
        dims[0] = hiI[patch]-lowI[patch]+1+2*numGhostI;
        dims[1] = hiJ[patch]-lowJ[patch]+1+2*numGhostJ;
        dims[2] = (dimension == 3 ? hiK[patch]-lowK[patch]+1+2*numGhostK : 1);
    }

    vtkRectilinearGrid *rg = vtkRectilinearGrid::New();
    rg->SetDimensions(dims);

    vtkFloatArray  *xcoord = vtkFloatArray::New();
    vtkFloatArray  *ycoord = vtkFloatArray::New();
    vtkFloatArray  *zcoord = vtkFloatArray::New();

    xcoord->SetNumberOfTuples(dims[0]);
    ycoord->SetNumberOfTuples(dims[1]);
    zcoord->SetNumberOfTuples(dims[2]);

    float *ptr = xcoord->GetPointer(0);
    if (!allowedToUseGhosts)
        ptr[0] = lowI[patch]*dx[level];
    else
        ptr[0] = (lowI[patch]-numGhostI)*dx[level];

    for (i = 1; i < dims[0]; i++)
        ptr[i] = ptr[0] + i*dx[level];

    ptr = ycoord->GetPointer(0);
    if (!allowedToUseGhosts)
        ptr[0] = lowJ[patch]*dx[level];
    else
        ptr[0] = (lowJ[patch]-numGhostJ)*dx[level];

    for (i = 1; i < dims[1]; i++)
        ptr[i] = ptr[0] + i*dx[level];

    if (dimension == 3)
    {
        ptr = zcoord->GetPointer(0);
        if (!allowedToUseGhosts)
            ptr[0] = lowK[patch]*dx[level];
        else
            ptr[0] = (lowK[patch]-numGhostK)*dx[level];

        for (i = 1; i < dims[2]; i++)
            ptr[i] = ptr[0] + i*dx[level];
    }
    else
       zcoord->SetTuple1(0, 0.);

    rg->SetXCoordinates(xcoord);
    rg->SetYCoordinates(ycoord);
    rg->SetZCoordinates(zcoord);

    xcoord->Delete();
    ycoord->Delete();
    zcoord->Delete();

    //
    // Determine the indices of the mesh within its group.  Add that to the
    // VTK dataset as field data.
    //
    vtkIntArray *arr = vtkIntArray::New();
    arr->SetNumberOfTuples(3);
    arr->SetValue(0, lowI[patch]);
    arr->SetValue(1, lowJ[patch]);
    arr->SetValue(2, (dimension == 3 ? lowK[patch] : 0));
    arr->SetName("base_index");
    rg->GetFieldData()->AddArray(arr);
    arr->Delete();

    if (allowedToUseGhosts)
    {
        //
        // Store real dims so that pick reports correct indices
        //
        // If: G G R R R R G G G  (G = ghost, R = real)
        //     0 1 2 3 4 5 6 7 9
        // then dims = 9
        // avtRealDims[0] = IDX of node that borders first real zone
        // -> node #2
        // avtRealDims[1] = IDX of node that borders last real zone
        // -> node #6
        // 
        arr = vtkIntArray::New();
        arr->SetNumberOfTuples(6);
        arr->SetValue(0, numGhostI);
        arr->SetValue(1, dims[0]-numGhostI-1);
        arr->SetValue(2, numGhostJ);
        arr->SetValue(3, dims[1]-numGhostJ-1);
        arr->SetValue(4, numGhostK);
        arr->SetValue(5, dims[2]-numGhostK-1);
        arr->SetName("avtRealDims");
        rg->GetFieldData()->AddArray(arr);
        arr->Delete();
    

        //
        // Calculate the problem domian in the current level
        //
        //
        // Generate ghost zone information
        //
        if (numGhostI > 0 || numGhostJ > 0 || numGhostK > 0)
        {
            unsigned char realVal = 0, ghostInternal = 0, ghostExternal = 0;
            avtGhostData::AddGhostZoneType(ghostInternal, 
                                           DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
            avtGhostData::AddGhostZoneType(ghostExternal, 
                                           ZONE_EXTERIOR_TO_PROBLEM);
    
            vtkUnsignedCharArray *ghostCells = vtkUnsignedCharArray::New();
            ghostCells->SetName("avtGhostZones");
    
            ghostCells->Allocate(rg->GetNumberOfCells());
    
            if (dimension == 3)
            {
                for (int k=lowK[patch] - numGhostK; k<hiK[patch] + numGhostK; ++k)
                    for (int j=lowJ[patch] - numGhostJ; j<hiJ[patch] + numGhostJ; ++j)
                        for (int i=lowI[patch] - numGhostI; i<hiI[patch] + numGhostI; ++i)
                        {
                            if (i>=lowI[patch] && i<hiI[patch] &&
                                j>=lowJ[patch] && j<hiJ[patch] && 
                                k>=lowK[patch] && k<hiK[patch])  
                            {
                                ghostCells->InsertNextValue(realVal);
                            }
                            else
                            {
                                if (i>=lowProbI[level] && i<=hiProbI[level] &&
                                    j>=lowProbJ[level] && j<=hiProbJ[level] &&
                                    k>=lowProbK[level] && k<=hiProbK[level])
                                {
                                    ghostCells->InsertNextValue(ghostInternal);
                                }
                                else
                                {
                                    ghostCells->InsertNextValue(ghostExternal);
                                }
                            }
                        }
            }
            else
            {
                for (int j=lowJ[patch] - numGhostJ; j<hiJ[patch] + numGhostJ; ++j)
                    for (int i=lowI[patch] - numGhostI; i<hiI[patch] + numGhostI; ++i)
                    {
                        if (i>=lowI[patch] && i<hiI[patch] &&
                                j>=lowJ[patch] && j<hiJ[patch])
                        {
                            ghostCells->InsertNextValue(realVal);
                        }
                        else
                        {
                            if (i>=lowProbI[level] && i<=hiProbI[level] &&
                                    j>=lowProbJ[level] && j<=hiProbJ[level])
                            {
                                ghostCells->InsertNextValue(ghostInternal);
                            }
                            else
                            {
                                ghostCells->InsertNextValue(ghostExternal);
                            }
                        }
                    }
            }

            rg->GetCellData()->AddArray(ghostCells);
            rg->SetUpdateGhostLevel(0);
            ghostCells->Delete();
        }
    }

    return rg;
}


// ****************************************************************************
//  Method: avtChomboFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
//  Modifcations:
//
//    Mark C. Miller, Thu Apr  6 17:06:33 PDT 2006
//    Added conditional compilation for hssize_t type
//
//    Hank Childs, Tue Jun 20 08:25:45 PDT 2006
//    Add support for ghost zones.
//
//    Gunther H. Wever, Wed Oct  3 17:34:56 PDT 2007
//    Do not strip ghost zones from file and instead add appropriate
//    ghost zone field data (in GetMesh()).
//
//    Hank Childs, Mon Oct  8 17:22:26 PDT 2007
//    Make Gunther's code go live using DB options.
//
//    Gunther H. Weber, Mon Nov  5 17:07:26 PST 2007
//    Use 64-bit arithmetic for offset calculations.
//
//    Gunther H. Weber, Mon Feb  4 14:37:49 PST 2008
//    Read doubles instead of floats from Chombo files.
//
//    Gunther H. Weber, Mon Mar 24 20:46:04 PDT 2008
//    Added support for node centered Chombo data.
//
//    Hank Childs, Sun Jan 25 15:55:58 PST 2009
//    Change test for whether or not we are allowed to use ghost data.
//
//    Gunther H. Weber, Wed Mar 25 13:31:56 PDT 2009
//    Open and close file to prevent file handle depletion
//
// ****************************************************************************

vtkDataArray *
avtChomboFileFormat::GetVar(int patch, const char *varname)
{
    int   i;

    if (!initializedReader)
        InitializeReader();

    int varIdx = -1;
    int nVars = varnames.size();
    for (i = 0 ; i < nVars ; i++)
    {
        if (varnames[i] == varname)
        {
            varIdx = i;
            break;
        }
    }
    if (varIdx < 0)
        EXCEPTION1(InvalidVariableException, varname);

    int level, local_patch;
    GetLevelAndLocalPatchNumber(patch, level, local_patch);

    if (level >= num_levels)
    {
        EXCEPTION1(InvalidVariableException, varname);
    }

    if (local_patch >= patchesPerLevel[level])
    {
        EXCEPTION2(BadDomainException, local_patch, patchesPerLevel[level]);
    }

    hsize_t numGhostI = numGhosts[3*level];
    hsize_t numGhostJ = numGhosts[3*level+1];
    hsize_t numGhostK = numGhosts[3*level+2];

    //
    // Figure out how much data to read and what it's offset is into the
    // bigger array.  This will be needed so we can read a hyperslab from
    // the HDF file.
    //
    int patchStart = patch-local_patch;
    hsize_t nvals = 0;
    for (i = patchStart ; i < patch ; i++)
    {
        hsize_t numZones = nodeCentered ?
            (hsize_t(hiI[i]-lowI[i]+1)+2*numGhostI)
            * (hsize_t(hiJ[i]-lowJ[i]+1)+2*numGhostJ) :
            (hsize_t(hiI[i]-lowI[i])+2*numGhostI)
            * (hsize_t(hiJ[i]-lowJ[i])+2*numGhostJ);
        if (dimension == 3)
            if (nodeCentered)
                numZones *= hsize_t(hiK[i]-lowK[i]+1)+2*numGhostK;
            else
                numZones *= hsize_t(hiK[i]-lowK[i])+2*numGhostK;
        nvals += numZones*nVars;
    }

#if HDF5_VERSION_GE(1,6,4)
    hsize_t start = nvals;
#else
    hssize_t start = nvals;
#endif
    hsize_t amt = nodeCentered ?
        (hsize_t(hiI[patch]-lowI[patch]+1)+2*numGhostI)
        * (hsize_t(hiJ[patch]-lowJ[patch]+1)+2*numGhostJ) :
        (hsize_t(hiI[patch]-lowI[patch])+2*numGhostI)
        * (hsize_t(hiJ[patch]-lowJ[patch])+2*numGhostJ);
    if (dimension == 3)
        if (nodeCentered)
            amt *= hsize_t(hiK[patch]-lowK[patch]+1)+2*numGhostK;
        else
            amt *= hsize_t(hiK[patch]-lowK[patch])+2*numGhostK;

    start += amt*varIdx;

    if (amt > std::numeric_limits<vtkIdType>::max())
    {
        EXCEPTION1(InvalidFilesException, "Grid contains more cells than installed "
                "VTK can handle. Installing a VTK version with 64-bit indices "
                "enabled may help.");
    }

    vtkDoubleArray *farr = vtkDoubleArray::New();
    farr->SetNumberOfComponents(1);
    farr->SetNumberOfTuples(amt);
    double *ptr = farr->GetPointer(0);

    // 
    // Now do the HDF magic.  Disclosure: this code was cobbled together
    // from examples I found on the internet.  If you think that there is a
    // more efficient way to do this (in lines of code or in performance), you
    // are probably right...
    //
    char name[1024];
    SNPRINTF(name, 1024, "level_%d", level);
    if (file_handle < 0)
    {
        file_handle = H5Fopen(filenames[0], H5F_ACC_RDONLY, H5P_DEFAULT);
        if (file_handle < 0)
        {
            EXCEPTION1(InvalidDBTypeException, "Cannot be a Chombo file, since "
                                               "it is not even an HDF5 file.");
        }
    }
    hid_t level_id = H5Gopen(file_handle, name);
    if (level_id < 0)
    {
        EXCEPTION1(InvalidFilesException, "Chombo file does not contain group for requested level.");
    }

    hid_t data = H5Dopen(level_id, "data:datatype=0");
    if (data < 0)
    {
        EXCEPTION1(InvalidFilesException, "Level does not contain data.");
    }

    hid_t space_id = H5Dget_space(data);
    hid_t rank     = H5Sget_simple_extent_ndims(space_id);
    hsize_t dims[1];
    int status_n   = H5Sget_simple_extent_dims(space_id, dims, NULL);
    H5Sselect_hyperslab(space_id, H5S_SELECT_SET, &start, NULL, &amt, NULL);
    
    hid_t memdataspace = H5Screate_simple(1, &amt, NULL);
    
    H5Dread(data, H5T_NATIVE_DOUBLE, memdataspace, space_id, H5P_DEFAULT, ptr);

    H5Sclose(memdataspace);
    H5Sclose(space_id);
    H5Dclose(data);
    H5Gclose(level_id);

    if (!allowedToUseGhosts)
    {
        //
        // Strip out the ghost information.  Note: this is probably an inefficient
        // path.  We would probably be better served leaving the ghost information
        // and not creating ghost zones later in the process.  But that requires
        // handling for external boundaries to the problem, which are not in place
        // yet.  
        //
        if (numGhostI > 0 || numGhostJ > 0 || numGhostK > 0)
        {
            vtkDoubleArray *new_farr = vtkDoubleArray::New();
            size_t new_amt = nodeCentered ?
                size_t(hiI[patch]-lowI[patch]+1)
                * size_t(hiJ[patch]-lowJ[patch]+1) :
                size_t(hiI[patch]-lowI[patch])
                * size_t(hiJ[patch]-lowJ[patch]);
            if (dimension == 3)
                if (nodeCentered)
                    new_amt *= (hiK[patch]-lowK[patch]+1);
                else
                    new_amt *= (hiK[patch]-lowK[patch]);
            new_farr->SetNumberOfTuples(new_amt);
    
            size_t nJ = nodeCentered ? hiJ[patch] - lowJ[patch] + 1 : hiJ[patch] - lowJ[patch];
            size_t nI = nodeCentered ? hiI[patch] - lowI[patch] + 1 : hiI[patch] - lowI[patch];
    
            size_t nJ2 = nJ + 2*numGhostJ;
            size_t nI2 = nI + 2*numGhostI;
    
            double *new_ptr = new_farr->GetPointer(0);
            double *old_ptr = farr->GetPointer(0);
            if (dimension == 3)
            {
                size_t nK = nodeCentered ? hiK[patch] - lowK[patch] + 1 : hiK[patch] - lowK[patch];
                size_t nK2 = nK + 2*numGhostK;
                for (size_t k = 0 ; k < nK ; k++)
                    for (size_t j = 0 ; j < nJ ; j++)
                        for (size_t i = 0 ; i < nI ; i++)
                        {
                            size_t idx_new = hsize_t(k)*nJ*nI + j*nI + i;
                            size_t idx_old = (k+numGhostK)*nJ2*nI2 + (j+numGhostJ)*nI2
                                           + (i+numGhostI);
                            new_ptr[idx_new] = old_ptr[idx_old];
                        }
            }
            else
            {
                for (size_t j = 0 ; j < nJ ; j++)
                    for (size_t i = 0 ; i < nI ; i++)
                    {
                        size_t idx_new = j*nI + i;
                        size_t idx_old = (j+numGhostJ)*nI2 + (i+numGhostI);
                        new_ptr[idx_new] = old_ptr[idx_old];
                    }
            }
            farr->Delete();
            farr = new_farr;
        }
    }

    return farr;
}

// ****************************************************************************
//  Method: avtChomboFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Thu Jan 19 11:17:14 PDT 2006
//
// ****************************************************************************

vtkDataArray *
avtChomboFileFormat::GetVectorVar(int domain, const char *varname)
{
    return NULL;
}


// ****************************************************************************
//  Method: avtBoxlib2DFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Gets the auxiliary data specified.
//
//  Arguments:
//      var        The variable of interest.
//      dom        The domain of interest.
//      type       The type of auxiliary data.
//      <unnamed>  The arguments for that type -- not used.
//      df         Destructor function.
//
//  Returns:    The auxiliary data.
//
//  Programmer: Hank Childs
//  Creation:   January 22, 2006
//
//  Modifications:
//    Kathleen Bonnell, Mon Aug 14 16:40:30 PDT 2006
//    API change for avtIntervalTree.
//
//    Gunther H. Weber, Tue Aug  7 16:01:28 PDT 2007
//    Return material information
// ****************************************************************************

void *
avtChomboFileFormat::GetAuxiliaryData(const char *var, int dom,
                                      const char * type, void *,
                                      DestructorFunction &df)
{
    if (strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
    {
        return GetMaterial(var, dom, type, df);
    }
    else if (strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0)
    {
        int totalPatches = 0;
        for (int level = 0 ; level < num_levels ; level++)
            totalPatches += patchesPerLevel[level];
    
        avtIntervalTree *itree = new avtIntervalTree(totalPatches, dimension);
    
        for (int patch = 0 ; patch < totalPatches ; patch++)
        {
            double bounds[6];
            int level, local_patch;

            GetLevelAndLocalPatchNumber(patch, level, local_patch);

            bounds[0] = lowI[patch]*dx[level];
            bounds[1] = bounds[0] + (hiI[patch]-lowI[patch])*dx[level];
            bounds[2] = lowJ[patch]*dx[level];
            bounds[3] = bounds[2] + (hiJ[patch]-lowJ[patch])*dx[level];
            bounds[4] = 0;
            bounds[5] = 0;
            if (dimension == 3)
            {
                bounds[4] = lowK[patch]*dx[level];
                bounds[5] = bounds[4] + (hiK[patch]-lowK[patch])*dx[level];
            }
            itree->AddElement(patch, bounds);
        }
        itree->Calculate(true);

        df = avtIntervalTree::Destruct;

        return ((void *) itree);
    }

    return NULL;
}

// ****************************************************************************
//  Method: avtChomboFileFormat::GetMaterial
//
//  Purpose:
//      Gets an avtMaterial object for the specified patch
//
//  Notes:      This routine was largely taken from GetMaterial() of the
//              BoxLib database written by Hank Childs and Akira Haddox.
//
//  Programmer: Gunther H. Weber
//  Creation:   August 8, 2007
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 16:28:31 PST 2008
//    Fix problem with GetVar returning doubles.  Also fix memory leak.
//
// ****************************************************************************
    
void *
avtChomboFileFormat::GetMaterial(const char *var, int patch, 
                                   const char *type, DestructorFunction &df)
{
    if (!initializedReader)
        InitializeReader();

    int i;
    vector<string> mnames(nMaterials);
    char str[32];
    for (i = 0; i < nMaterials; ++i)
    {
        sprintf(str, "mat%d", i+1);
        mnames[i] = str;
    }
    
    // Get the material fractions
    vector<double *> mats(nMaterials);
    vector<vtkDoubleArray *> deleteList;
    int nCells = 0;
    for (i = 0; i <= nMaterials - 2; ++i)
    {
	sprintf(str,"fraction-%d", i);
        vtkDoubleArray *doubleArray = (vtkDoubleArray *)(GetVar(patch, str));
	nCells = doubleArray->GetNumberOfTuples();
        mats[i] = doubleArray->GetPointer(0);
        deleteList.push_back(doubleArray);
    }

    // Calculate fractions for additional "missing" material
    double *addMatPtr =  new double[nCells];

    for(unsigned int cellNo = 0; cellNo < nCells; ++cellNo)
    {
	double frac = 1.0;
	for (int matNo = 0; matNo < nMaterials - 1; ++matNo)
	    frac -= mats[matNo][cellNo];
	addMatPtr[cellNo] = frac;
    }

    mats[nMaterials - 1] = addMatPtr;

    // Build the appropriate data structures
    vector<int> material_list(nCells);
    vector<int> mix_mat;
    vector<int> mix_next;
    vector<int> mix_zone;
    vector<float> mix_vf;

    for (i = 0; i < nCells; ++i)
    {
        int j;

        // First look for pure materials
        int nmats = 0;
        int lastMat = -1;
        for (j = 0; j < nMaterials; ++j)
        {
            if (mats[j][i] > 0)
            {
                nmats++;
                lastMat = j;
            }
        }

        if (nmats == 1)
        {
            material_list[i] = lastMat;
            continue;
        }

        // For unpure materials, we need to add entries to the tables.  
        material_list[i] = -1 * (1 + mix_zone.size());
        for (j = 0; j < nMaterials; ++j)
        {
            if (mats[j][i] <= 0)
                continue;
            // For each material that's present, add to the tables
            mix_zone.push_back(i);
            mix_mat.push_back(j);
            mix_vf.push_back(mats[j][i]);
            mix_next.push_back(mix_zone.size() + 1);
        }

        // When we're done, the last entry is a '0' in the mix_next
        mix_next[mix_next.size() - 1] = 0;
    }

    int mixed_size = mix_zone.size();
    avtMaterial * mat = new avtMaterial(nMaterials, mnames, nCells,
                                        &(material_list[0]), mixed_size,
                                        &(mix_mat[0]), &(mix_next[0]),
                                        &(mix_zone[0]), &(mix_vf[0]));
     
    df = avtMaterial::Destruct;

    delete[] addMatPtr;
    for (i = 0 ; i < deleteList.size() ; i++)
        deleteList[i]->Delete();

    return (void*) mat;
}



