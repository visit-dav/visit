// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

#include <PyGlobalAttributes.h>
#include <ObserverToCallback.h>
#include <stdio.h>
#include <Py2and3Support.h>

// ****************************************************************************
// Module: PyGlobalAttributes
//
// Purpose:
//   This class contains attributes associated with the main window.
//
// Note:       Autogenerated by xml2python. Do not modify by hand!
//
// Programmer: xml2python
// Creation:   omitted
//
// ****************************************************************************

//
// This struct contains the Python type information and a GlobalAttributes.
//
struct GlobalAttributesObject
{
    PyObject_HEAD
    GlobalAttributes *data;
    bool        owns;
    PyObject   *parent;
};

//
// Internal prototypes
//
static PyObject *NewGlobalAttributes(int);
std::string
PyGlobalAttributes_ToString(const GlobalAttributes *atts, const char *prefix, const bool forLogging)
{
    std::string str;
    char tmpStr[1000];

    {   const stringVector &sources = atts->GetSources();
        snprintf(tmpStr, 1000, "%ssources = (", prefix);
        str += tmpStr;
        for(size_t i = 0; i < sources.size(); ++i)
        {
            snprintf(tmpStr, 1000, "\"%s\"", sources[i].c_str());
            str += tmpStr;
            if(i < sources.size() - 1)
            {
                snprintf(tmpStr, 1000, ", ");
                str += tmpStr;
            }
        }
        snprintf(tmpStr, 1000, ")\n");
        str += tmpStr;
    }
    {   const intVector &windows = atts->GetWindows();
        snprintf(tmpStr, 1000, "%swindows = (", prefix);
        str += tmpStr;
        for(size_t i = 0; i < windows.size(); ++i)
        {
            snprintf(tmpStr, 1000, "%d", windows[i]);
            str += tmpStr;
            if(i < windows.size() - 1)
            {
                snprintf(tmpStr, 1000, ", ");
                str += tmpStr;
            }
        }
        snprintf(tmpStr, 1000, ")\n");
        str += tmpStr;
    }
    snprintf(tmpStr, 1000, "%sactiveWindow = %d\n", prefix, atts->GetActiveWindow());
    str += tmpStr;
    if(atts->GetIconifiedFlag())
        snprintf(tmpStr, 1000, "%siconifiedFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%siconifiedFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetAutoUpdateFlag())
        snprintf(tmpStr, 1000, "%sautoUpdateFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sautoUpdateFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetReplacePlots())
        snprintf(tmpStr, 1000, "%sreplacePlots = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sreplacePlots = 0\n", prefix);
    str += tmpStr;
    if(atts->GetApplyOperator())
        snprintf(tmpStr, 1000, "%sapplyOperator = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sapplyOperator = 0\n", prefix);
    str += tmpStr;
    if(atts->GetApplySelection())
        snprintf(tmpStr, 1000, "%sapplySelection = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sapplySelection = 0\n", prefix);
    str += tmpStr;
    if(atts->GetApplyWindow())
        snprintf(tmpStr, 1000, "%sapplyWindow = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sapplyWindow = 0\n", prefix);
    str += tmpStr;
    if(atts->GetExecuting())
        snprintf(tmpStr, 1000, "%sexecuting = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sexecuting = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%swindowLayout = %d\n", prefix, atts->GetWindowLayout());
    str += tmpStr;
    if(atts->GetMakeDefaultConfirm())
        snprintf(tmpStr, 1000, "%smakeDefaultConfirm = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%smakeDefaultConfirm = 0\n", prefix);
    str += tmpStr;
    if(atts->GetCloneWindowOnFirstRef())
        snprintf(tmpStr, 1000, "%scloneWindowOnFirstRef = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%scloneWindowOnFirstRef = 0\n", prefix);
    str += tmpStr;
    if(atts->GetAutomaticallyAddOperator())
        snprintf(tmpStr, 1000, "%sautomaticallyAddOperator = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sautomaticallyAddOperator = 0\n", prefix);
    str += tmpStr;
    if(atts->GetTryHarderCyclesTimes())
        snprintf(tmpStr, 1000, "%stryHarderCyclesTimes = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%stryHarderCyclesTimes = 0\n", prefix);
    str += tmpStr;
    if(atts->GetTreatAllDBsAsTimeVarying())
        snprintf(tmpStr, 1000, "%streatAllDBsAsTimeVarying = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%streatAllDBsAsTimeVarying = 0\n", prefix);
    str += tmpStr;
    if(atts->GetCreateMeshQualityExpressions())
        snprintf(tmpStr, 1000, "%screateMeshQualityExpressions = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%screateMeshQualityExpressions = 0\n", prefix);
    str += tmpStr;
    if(atts->GetCreateTimeDerivativeExpressions())
        snprintf(tmpStr, 1000, "%screateTimeDerivativeExpressions = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%screateTimeDerivativeExpressions = 0\n", prefix);
    str += tmpStr;
    if(atts->GetCreateVectorMagnitudeExpressions())
        snprintf(tmpStr, 1000, "%screateVectorMagnitudeExpressions = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%screateVectorMagnitudeExpressions = 0\n", prefix);
    str += tmpStr;
    if(atts->GetNewPlotsInheritSILRestriction())
        snprintf(tmpStr, 1000, "%snewPlotsInheritSILRestriction = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%snewPlotsInheritSILRestriction = 0\n", prefix);
    str += tmpStr;
    if(atts->GetUserDirForSessionFiles())
        snprintf(tmpStr, 1000, "%suserDirForSessionFiles = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%suserDirForSessionFiles = 0\n", prefix);
    str += tmpStr;
    if(atts->GetSaveCrashRecoveryFile())
        snprintf(tmpStr, 1000, "%ssaveCrashRecoveryFile = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%ssaveCrashRecoveryFile = 0\n", prefix);
    str += tmpStr;
    if(atts->GetIgnoreExtentsFromDbs())
        snprintf(tmpStr, 1000, "%signoreExtentsFromDbs = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%signoreExtentsFromDbs = 0\n", prefix);
    str += tmpStr;
    if(atts->GetExpandNewPlots())
        snprintf(tmpStr, 1000, "%sexpandNewPlots = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sexpandNewPlots = 0\n", prefix);
    str += tmpStr;
    if(atts->GetUserRestoreSessionFile())
        snprintf(tmpStr, 1000, "%suserRestoreSessionFile = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%suserRestoreSessionFile = 0\n", prefix);
    str += tmpStr;
    const char *precisionType_names = "Float, Native, Double";
    switch (atts->GetPrecisionType())
    {
      case GlobalAttributes::Float:
          snprintf(tmpStr, 1000, "%sprecisionType = %sFloat  # %s\n", prefix, prefix, precisionType_names);
          str += tmpStr;
          break;
      case GlobalAttributes::Native:
          snprintf(tmpStr, 1000, "%sprecisionType = %sNative  # %s\n", prefix, prefix, precisionType_names);
          str += tmpStr;
          break;
      case GlobalAttributes::Double:
          snprintf(tmpStr, 1000, "%sprecisionType = %sDouble  # %s\n", prefix, prefix, precisionType_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const char *backendType_names = "VTK, VTKM";
    switch (atts->GetBackendType())
    {
      case GlobalAttributes::VTK:
          snprintf(tmpStr, 1000, "%sbackendType = %sVTK  # %s\n", prefix, prefix, backendType_names);
          str += tmpStr;
          break;
      case GlobalAttributes::VTKM:
          snprintf(tmpStr, 1000, "%sbackendType = %sVTKM  # %s\n", prefix, prefix, backendType_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    if(atts->GetRemoveDuplicateNodes())
        snprintf(tmpStr, 1000, "%sremoveDuplicateNodes = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sremoveDuplicateNodes = 0\n", prefix);
    str += tmpStr;
    return str;
}

static PyObject *
GlobalAttributes_Notify(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    obj->data->Notify();
    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_SetSources(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    stringVector vec;

    if (PyUnicode_Check(args))
    {
        char const *val = PyUnicode_AsUTF8(args);
        std::string cval = std::string(val);
        if (val == 0 && PyErr_Occurred())
        {
            PyErr_Clear();
            return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ string");
        }
        vec.resize(1);
        vec[0] = cval;
    }
    else if (PySequence_Check(args))
    {
        vec.resize(PySequence_Size(args));
        for (Py_ssize_t i = 0; i < PySequence_Size(args); i++)
        {
            PyObject *item = PySequence_GetItem(args, i);

            if (!PyUnicode_Check(item))
            {
                Py_DECREF(item);
                return PyErr_Format(PyExc_TypeError, "arg %d is not a unicode string", (int) i);
            }

            char const *val = PyUnicode_AsUTF8(item);
            std::string cval = std::string(val);

            if (val == 0 && PyErr_Occurred())
            {
                Py_DECREF(item);
                PyErr_Clear();
                return PyErr_Format(PyExc_TypeError, "arg %d not interpretable as C++ string", (int) i);
            }
            Py_DECREF(item);

            vec[i] = cval;
        }
    }
    else
        return PyErr_Format(PyExc_TypeError, "arg(s) must be one or more string(s)");

    obj->data->GetSources() = vec;
    // Mark the sources in the object as modified.
    obj->data->SelectSources();

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetSources(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the sources.
    const stringVector &sources = obj->data->GetSources();
    PyObject *retval = PyTuple_New(sources.size());
    for(size_t i = 0; i < sources.size(); ++i)
        PyTuple_SET_ITEM(retval, i, PyString_FromString(sources[i].c_str()));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetWindows(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    intVector vec;

    if (PyNumber_Check(args))
    {
        long val = PyLong_AsLong(args);
        int cval = int(val);
        if (val == -1 && PyErr_Occurred())
        {
            PyErr_Clear();
            return PyErr_Format(PyExc_TypeError, "number not interpretable as C++ int");
        }
        if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
            return PyErr_Format(PyExc_ValueError, "number not interpretable as C++ int");
        vec.resize(1);
        vec[0] = cval;
    }
    else if (PySequence_Check(args) && !PyUnicode_Check(args))
    {
        vec.resize(PySequence_Size(args));
        for (Py_ssize_t i = 0; i < PySequence_Size(args); i++)
        {
            PyObject *item = PySequence_GetItem(args, i);

            if (!PyNumber_Check(item))
            {
                Py_DECREF(item);
                return PyErr_Format(PyExc_TypeError, "arg %d is not a number type", (int) i);
            }

            long val = PyLong_AsLong(item);
            int cval = int(val);

            if (val == -1 && PyErr_Occurred())
            {
                Py_DECREF(item);
                PyErr_Clear();
                return PyErr_Format(PyExc_TypeError, "arg %d not interpretable as C++ int", (int) i);
            }
            if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
            {
                Py_DECREF(item);
                return PyErr_Format(PyExc_ValueError, "arg %d not interpretable as C++ int", (int) i);
            }
            Py_DECREF(item);

            vec[i] = cval;
        }
    }
    else
        return PyErr_Format(PyExc_TypeError, "arg(s) must be one or more ints");

    obj->data->GetWindows() = vec;
    // Mark the windows in the object as modified.
    obj->data->SelectWindows();

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetWindows(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the windows.
    const intVector &windows = obj->data->GetWindows();
    PyObject *retval = PyTuple_New(windows.size());
    for(size_t i = 0; i < windows.size(); ++i)
        PyTuple_SET_ITEM(retval, i, PyInt_FromLong(long(windows[i])));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetActiveWindow(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the activeWindow in the object.
    obj->data->SetActiveWindow(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetActiveWindow(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetActiveWindow()));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetIconifiedFlag(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the iconifiedFlag in the object.
    obj->data->SetIconifiedFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetIconifiedFlag(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetIconifiedFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetAutoUpdateFlag(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the autoUpdateFlag in the object.
    obj->data->SetAutoUpdateFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetAutoUpdateFlag(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetAutoUpdateFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetReplacePlots(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the replacePlots in the object.
    obj->data->SetReplacePlots(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetReplacePlots(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetReplacePlots()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetApplyOperator(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the applyOperator in the object.
    obj->data->SetApplyOperator(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetApplyOperator(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetApplyOperator()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetApplySelection(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the applySelection in the object.
    obj->data->SetApplySelection(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetApplySelection(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetApplySelection()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetApplyWindow(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the applyWindow in the object.
    obj->data->SetApplyWindow(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetApplyWindow(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetApplyWindow()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetExecuting(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the executing in the object.
    obj->data->SetExecuting(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetExecuting(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetExecuting()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetWindowLayout(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the windowLayout in the object.
    obj->data->SetWindowLayout(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetWindowLayout(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetWindowLayout()));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetMakeDefaultConfirm(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the makeDefaultConfirm in the object.
    obj->data->SetMakeDefaultConfirm(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetMakeDefaultConfirm(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetMakeDefaultConfirm()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetCloneWindowOnFirstRef(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the cloneWindowOnFirstRef in the object.
    obj->data->SetCloneWindowOnFirstRef(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetCloneWindowOnFirstRef(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetCloneWindowOnFirstRef()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetAutomaticallyAddOperator(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the automaticallyAddOperator in the object.
    obj->data->SetAutomaticallyAddOperator(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetAutomaticallyAddOperator(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetAutomaticallyAddOperator()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetTryHarderCyclesTimes(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the tryHarderCyclesTimes in the object.
    obj->data->SetTryHarderCyclesTimes(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetTryHarderCyclesTimes(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetTryHarderCyclesTimes()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetTreatAllDBsAsTimeVarying(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the treatAllDBsAsTimeVarying in the object.
    obj->data->SetTreatAllDBsAsTimeVarying(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetTreatAllDBsAsTimeVarying(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetTreatAllDBsAsTimeVarying()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetCreateMeshQualityExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the createMeshQualityExpressions in the object.
    obj->data->SetCreateMeshQualityExpressions(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetCreateMeshQualityExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetCreateMeshQualityExpressions()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetCreateTimeDerivativeExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the createTimeDerivativeExpressions in the object.
    obj->data->SetCreateTimeDerivativeExpressions(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetCreateTimeDerivativeExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetCreateTimeDerivativeExpressions()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetCreateVectorMagnitudeExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the createVectorMagnitudeExpressions in the object.
    obj->data->SetCreateVectorMagnitudeExpressions(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetCreateVectorMagnitudeExpressions(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetCreateVectorMagnitudeExpressions()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetNewPlotsInheritSILRestriction(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the newPlotsInheritSILRestriction in the object.
    obj->data->SetNewPlotsInheritSILRestriction(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetNewPlotsInheritSILRestriction(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetNewPlotsInheritSILRestriction()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetUserDirForSessionFiles(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the userDirForSessionFiles in the object.
    obj->data->SetUserDirForSessionFiles(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetUserDirForSessionFiles(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetUserDirForSessionFiles()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetSaveCrashRecoveryFile(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the saveCrashRecoveryFile in the object.
    obj->data->SetSaveCrashRecoveryFile(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetSaveCrashRecoveryFile(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetSaveCrashRecoveryFile()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetIgnoreExtentsFromDbs(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the ignoreExtentsFromDbs in the object.
    obj->data->SetIgnoreExtentsFromDbs(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetIgnoreExtentsFromDbs(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetIgnoreExtentsFromDbs()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetExpandNewPlots(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the expandNewPlots in the object.
    obj->data->SetExpandNewPlots(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetExpandNewPlots(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetExpandNewPlots()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetUserRestoreSessionFile(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the userRestoreSessionFile in the object.
    obj->data->SetUserRestoreSessionFile(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetUserRestoreSessionFile(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetUserRestoreSessionFile()?1L:0L);
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetPrecisionType(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid precisionType value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Float";
        ss << ", Native";
        ss << ", Double";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the precisionType in the object.
    obj->data->SetPrecisionType(GlobalAttributes::PrecisionType(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetPrecisionType(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetPrecisionType()));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetBackendType(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 2)
    {
        std::stringstream ss;
        ss << "An invalid backendType value was given." << std::endl;
        ss << "Valid values are in the range [0,1]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " VTK";
        ss << ", VTKM";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the backendType in the object.
    obj->data->SetBackendType(GlobalAttributes::BackendType(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetBackendType(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetBackendType()));
    return retval;
}

/*static*/ PyObject *
GlobalAttributes_SetRemoveDuplicateNodes(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the removeDuplicateNodes in the object.
    obj->data->SetRemoveDuplicateNodes(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
GlobalAttributes_GetRemoveDuplicateNodes(PyObject *self, PyObject *args)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetRemoveDuplicateNodes()?1L:0L);
    return retval;
}



PyMethodDef PyGlobalAttributes_methods[GLOBALATTRIBUTES_NMETH] = {
    {"Notify", GlobalAttributes_Notify, METH_VARARGS},
    {"SetSources", GlobalAttributes_SetSources, METH_VARARGS},
    {"GetSources", GlobalAttributes_GetSources, METH_VARARGS},
    {"SetWindows", GlobalAttributes_SetWindows, METH_VARARGS},
    {"GetWindows", GlobalAttributes_GetWindows, METH_VARARGS},
    {"SetActiveWindow", GlobalAttributes_SetActiveWindow, METH_VARARGS},
    {"GetActiveWindow", GlobalAttributes_GetActiveWindow, METH_VARARGS},
    {"SetIconifiedFlag", GlobalAttributes_SetIconifiedFlag, METH_VARARGS},
    {"GetIconifiedFlag", GlobalAttributes_GetIconifiedFlag, METH_VARARGS},
    {"SetAutoUpdateFlag", GlobalAttributes_SetAutoUpdateFlag, METH_VARARGS},
    {"GetAutoUpdateFlag", GlobalAttributes_GetAutoUpdateFlag, METH_VARARGS},
    {"SetReplacePlots", GlobalAttributes_SetReplacePlots, METH_VARARGS},
    {"GetReplacePlots", GlobalAttributes_GetReplacePlots, METH_VARARGS},
    {"SetApplyOperator", GlobalAttributes_SetApplyOperator, METH_VARARGS},
    {"GetApplyOperator", GlobalAttributes_GetApplyOperator, METH_VARARGS},
    {"SetApplySelection", GlobalAttributes_SetApplySelection, METH_VARARGS},
    {"GetApplySelection", GlobalAttributes_GetApplySelection, METH_VARARGS},
    {"SetApplyWindow", GlobalAttributes_SetApplyWindow, METH_VARARGS},
    {"GetApplyWindow", GlobalAttributes_GetApplyWindow, METH_VARARGS},
    {"SetExecuting", GlobalAttributes_SetExecuting, METH_VARARGS},
    {"GetExecuting", GlobalAttributes_GetExecuting, METH_VARARGS},
    {"SetWindowLayout", GlobalAttributes_SetWindowLayout, METH_VARARGS},
    {"GetWindowLayout", GlobalAttributes_GetWindowLayout, METH_VARARGS},
    {"SetMakeDefaultConfirm", GlobalAttributes_SetMakeDefaultConfirm, METH_VARARGS},
    {"GetMakeDefaultConfirm", GlobalAttributes_GetMakeDefaultConfirm, METH_VARARGS},
    {"SetCloneWindowOnFirstRef", GlobalAttributes_SetCloneWindowOnFirstRef, METH_VARARGS},
    {"GetCloneWindowOnFirstRef", GlobalAttributes_GetCloneWindowOnFirstRef, METH_VARARGS},
    {"SetAutomaticallyAddOperator", GlobalAttributes_SetAutomaticallyAddOperator, METH_VARARGS},
    {"GetAutomaticallyAddOperator", GlobalAttributes_GetAutomaticallyAddOperator, METH_VARARGS},
    {"SetTryHarderCyclesTimes", GlobalAttributes_SetTryHarderCyclesTimes, METH_VARARGS},
    {"GetTryHarderCyclesTimes", GlobalAttributes_GetTryHarderCyclesTimes, METH_VARARGS},
    {"SetTreatAllDBsAsTimeVarying", GlobalAttributes_SetTreatAllDBsAsTimeVarying, METH_VARARGS},
    {"GetTreatAllDBsAsTimeVarying", GlobalAttributes_GetTreatAllDBsAsTimeVarying, METH_VARARGS},
    {"SetCreateMeshQualityExpressions", GlobalAttributes_SetCreateMeshQualityExpressions, METH_VARARGS},
    {"GetCreateMeshQualityExpressions", GlobalAttributes_GetCreateMeshQualityExpressions, METH_VARARGS},
    {"SetCreateTimeDerivativeExpressions", GlobalAttributes_SetCreateTimeDerivativeExpressions, METH_VARARGS},
    {"GetCreateTimeDerivativeExpressions", GlobalAttributes_GetCreateTimeDerivativeExpressions, METH_VARARGS},
    {"SetCreateVectorMagnitudeExpressions", GlobalAttributes_SetCreateVectorMagnitudeExpressions, METH_VARARGS},
    {"GetCreateVectorMagnitudeExpressions", GlobalAttributes_GetCreateVectorMagnitudeExpressions, METH_VARARGS},
    {"SetNewPlotsInheritSILRestriction", GlobalAttributes_SetNewPlotsInheritSILRestriction, METH_VARARGS},
    {"GetNewPlotsInheritSILRestriction", GlobalAttributes_GetNewPlotsInheritSILRestriction, METH_VARARGS},
    {"SetUserDirForSessionFiles", GlobalAttributes_SetUserDirForSessionFiles, METH_VARARGS},
    {"GetUserDirForSessionFiles", GlobalAttributes_GetUserDirForSessionFiles, METH_VARARGS},
    {"SetSaveCrashRecoveryFile", GlobalAttributes_SetSaveCrashRecoveryFile, METH_VARARGS},
    {"GetSaveCrashRecoveryFile", GlobalAttributes_GetSaveCrashRecoveryFile, METH_VARARGS},
    {"SetIgnoreExtentsFromDbs", GlobalAttributes_SetIgnoreExtentsFromDbs, METH_VARARGS},
    {"GetIgnoreExtentsFromDbs", GlobalAttributes_GetIgnoreExtentsFromDbs, METH_VARARGS},
    {"SetExpandNewPlots", GlobalAttributes_SetExpandNewPlots, METH_VARARGS},
    {"GetExpandNewPlots", GlobalAttributes_GetExpandNewPlots, METH_VARARGS},
    {"SetUserRestoreSessionFile", GlobalAttributes_SetUserRestoreSessionFile, METH_VARARGS},
    {"GetUserRestoreSessionFile", GlobalAttributes_GetUserRestoreSessionFile, METH_VARARGS},
    {"SetPrecisionType", GlobalAttributes_SetPrecisionType, METH_VARARGS},
    {"GetPrecisionType", GlobalAttributes_GetPrecisionType, METH_VARARGS},
    {"SetBackendType", GlobalAttributes_SetBackendType, METH_VARARGS},
    {"GetBackendType", GlobalAttributes_GetBackendType, METH_VARARGS},
    {"SetRemoveDuplicateNodes", GlobalAttributes_SetRemoveDuplicateNodes, METH_VARARGS},
    {"GetRemoveDuplicateNodes", GlobalAttributes_GetRemoveDuplicateNodes, METH_VARARGS},
    {NULL, NULL}
};

//
// Type functions
//

static void
GlobalAttributes_dealloc(PyObject *v)
{
   GlobalAttributesObject *obj = (GlobalAttributesObject *)v;
   if(obj->parent != 0)
       Py_DECREF(obj->parent);
   if(obj->owns)
       delete obj->data;
}

static PyObject *GlobalAttributes_richcompare(PyObject *self, PyObject *other, int op);
PyObject *
PyGlobalAttributes_getattr(PyObject *self, char *name)
{
    if(strcmp(name, "sources") == 0)
        return GlobalAttributes_GetSources(self, NULL);
    if(strcmp(name, "windows") == 0)
        return GlobalAttributes_GetWindows(self, NULL);
    if(strcmp(name, "activeWindow") == 0)
        return GlobalAttributes_GetActiveWindow(self, NULL);
    if(strcmp(name, "iconifiedFlag") == 0)
        return GlobalAttributes_GetIconifiedFlag(self, NULL);
    if(strcmp(name, "autoUpdateFlag") == 0)
        return GlobalAttributes_GetAutoUpdateFlag(self, NULL);
    if(strcmp(name, "replacePlots") == 0)
        return GlobalAttributes_GetReplacePlots(self, NULL);
    if(strcmp(name, "applyOperator") == 0)
        return GlobalAttributes_GetApplyOperator(self, NULL);
    if(strcmp(name, "applySelection") == 0)
        return GlobalAttributes_GetApplySelection(self, NULL);
    if(strcmp(name, "applyWindow") == 0)
        return GlobalAttributes_GetApplyWindow(self, NULL);
    if(strcmp(name, "executing") == 0)
        return GlobalAttributes_GetExecuting(self, NULL);
    if(strcmp(name, "windowLayout") == 0)
        return GlobalAttributes_GetWindowLayout(self, NULL);
    if(strcmp(name, "makeDefaultConfirm") == 0)
        return GlobalAttributes_GetMakeDefaultConfirm(self, NULL);
    if(strcmp(name, "cloneWindowOnFirstRef") == 0)
        return GlobalAttributes_GetCloneWindowOnFirstRef(self, NULL);
    if(strcmp(name, "automaticallyAddOperator") == 0)
        return GlobalAttributes_GetAutomaticallyAddOperator(self, NULL);
    if(strcmp(name, "tryHarderCyclesTimes") == 0)
        return GlobalAttributes_GetTryHarderCyclesTimes(self, NULL);
    if(strcmp(name, "treatAllDBsAsTimeVarying") == 0)
        return GlobalAttributes_GetTreatAllDBsAsTimeVarying(self, NULL);
    if(strcmp(name, "createMeshQualityExpressions") == 0)
        return GlobalAttributes_GetCreateMeshQualityExpressions(self, NULL);
    if(strcmp(name, "createTimeDerivativeExpressions") == 0)
        return GlobalAttributes_GetCreateTimeDerivativeExpressions(self, NULL);
    if(strcmp(name, "createVectorMagnitudeExpressions") == 0)
        return GlobalAttributes_GetCreateVectorMagnitudeExpressions(self, NULL);
    if(strcmp(name, "newPlotsInheritSILRestriction") == 0)
        return GlobalAttributes_GetNewPlotsInheritSILRestriction(self, NULL);
    if(strcmp(name, "userDirForSessionFiles") == 0)
        return GlobalAttributes_GetUserDirForSessionFiles(self, NULL);
    if(strcmp(name, "saveCrashRecoveryFile") == 0)
        return GlobalAttributes_GetSaveCrashRecoveryFile(self, NULL);
    if(strcmp(name, "ignoreExtentsFromDbs") == 0)
        return GlobalAttributes_GetIgnoreExtentsFromDbs(self, NULL);
    if(strcmp(name, "expandNewPlots") == 0)
        return GlobalAttributes_GetExpandNewPlots(self, NULL);
    if(strcmp(name, "userRestoreSessionFile") == 0)
        return GlobalAttributes_GetUserRestoreSessionFile(self, NULL);
    if(strcmp(name, "precisionType") == 0)
        return GlobalAttributes_GetPrecisionType(self, NULL);
    if(strcmp(name, "Float") == 0)
        return PyInt_FromLong(long(GlobalAttributes::Float));
    if(strcmp(name, "Native") == 0)
        return PyInt_FromLong(long(GlobalAttributes::Native));
    if(strcmp(name, "Double") == 0)
        return PyInt_FromLong(long(GlobalAttributes::Double));

    if(strcmp(name, "backendType") == 0)
        return GlobalAttributes_GetBackendType(self, NULL);
    if(strcmp(name, "VTK") == 0)
        return PyInt_FromLong(long(GlobalAttributes::VTK));
    if(strcmp(name, "VTKM") == 0)
        return PyInt_FromLong(long(GlobalAttributes::VTKM));

    if(strcmp(name, "removeDuplicateNodes") == 0)
        return GlobalAttributes_GetRemoveDuplicateNodes(self, NULL);


    // Add a __dict__ answer so that dir() works
    if (!strcmp(name, "__dict__"))
    {
        PyObject *result = PyDict_New();
        for (int i = 0; PyGlobalAttributes_methods[i].ml_meth; i++)
            PyDict_SetItem(result,
                PyString_FromString(PyGlobalAttributes_methods[i].ml_name),
                PyString_FromString(PyGlobalAttributes_methods[i].ml_name));
        return result;
    }

    return Py_FindMethod(PyGlobalAttributes_methods, self, name);
}

int
PyGlobalAttributes_setattr(PyObject *self, char *name, PyObject *args)
{
    PyObject NULL_PY_OBJ;
    PyObject *obj = &NULL_PY_OBJ;

    if(strcmp(name, "sources") == 0)
        obj = GlobalAttributes_SetSources(self, args);
    else if(strcmp(name, "windows") == 0)
        obj = GlobalAttributes_SetWindows(self, args);
    else if(strcmp(name, "activeWindow") == 0)
        obj = GlobalAttributes_SetActiveWindow(self, args);
    else if(strcmp(name, "iconifiedFlag") == 0)
        obj = GlobalAttributes_SetIconifiedFlag(self, args);
    else if(strcmp(name, "autoUpdateFlag") == 0)
        obj = GlobalAttributes_SetAutoUpdateFlag(self, args);
    else if(strcmp(name, "replacePlots") == 0)
        obj = GlobalAttributes_SetReplacePlots(self, args);
    else if(strcmp(name, "applyOperator") == 0)
        obj = GlobalAttributes_SetApplyOperator(self, args);
    else if(strcmp(name, "applySelection") == 0)
        obj = GlobalAttributes_SetApplySelection(self, args);
    else if(strcmp(name, "applyWindow") == 0)
        obj = GlobalAttributes_SetApplyWindow(self, args);
    else if(strcmp(name, "executing") == 0)
        obj = GlobalAttributes_SetExecuting(self, args);
    else if(strcmp(name, "windowLayout") == 0)
        obj = GlobalAttributes_SetWindowLayout(self, args);
    else if(strcmp(name, "makeDefaultConfirm") == 0)
        obj = GlobalAttributes_SetMakeDefaultConfirm(self, args);
    else if(strcmp(name, "cloneWindowOnFirstRef") == 0)
        obj = GlobalAttributes_SetCloneWindowOnFirstRef(self, args);
    else if(strcmp(name, "automaticallyAddOperator") == 0)
        obj = GlobalAttributes_SetAutomaticallyAddOperator(self, args);
    else if(strcmp(name, "tryHarderCyclesTimes") == 0)
        obj = GlobalAttributes_SetTryHarderCyclesTimes(self, args);
    else if(strcmp(name, "treatAllDBsAsTimeVarying") == 0)
        obj = GlobalAttributes_SetTreatAllDBsAsTimeVarying(self, args);
    else if(strcmp(name, "createMeshQualityExpressions") == 0)
        obj = GlobalAttributes_SetCreateMeshQualityExpressions(self, args);
    else if(strcmp(name, "createTimeDerivativeExpressions") == 0)
        obj = GlobalAttributes_SetCreateTimeDerivativeExpressions(self, args);
    else if(strcmp(name, "createVectorMagnitudeExpressions") == 0)
        obj = GlobalAttributes_SetCreateVectorMagnitudeExpressions(self, args);
    else if(strcmp(name, "newPlotsInheritSILRestriction") == 0)
        obj = GlobalAttributes_SetNewPlotsInheritSILRestriction(self, args);
    else if(strcmp(name, "userDirForSessionFiles") == 0)
        obj = GlobalAttributes_SetUserDirForSessionFiles(self, args);
    else if(strcmp(name, "saveCrashRecoveryFile") == 0)
        obj = GlobalAttributes_SetSaveCrashRecoveryFile(self, args);
    else if(strcmp(name, "ignoreExtentsFromDbs") == 0)
        obj = GlobalAttributes_SetIgnoreExtentsFromDbs(self, args);
    else if(strcmp(name, "expandNewPlots") == 0)
        obj = GlobalAttributes_SetExpandNewPlots(self, args);
    else if(strcmp(name, "userRestoreSessionFile") == 0)
        obj = GlobalAttributes_SetUserRestoreSessionFile(self, args);
    else if(strcmp(name, "precisionType") == 0)
        obj = GlobalAttributes_SetPrecisionType(self, args);
    else if(strcmp(name, "backendType") == 0)
        obj = GlobalAttributes_SetBackendType(self, args);
    else if(strcmp(name, "removeDuplicateNodes") == 0)
        obj = GlobalAttributes_SetRemoveDuplicateNodes(self, args);

    if (obj != NULL && obj != &NULL_PY_OBJ)
        Py_DECREF(obj);

    if (obj == &NULL_PY_OBJ)
    {
        obj = NULL;
        PyErr_Format(PyExc_NameError, "name '%s' is not defined", name);
    }
    else if (obj == NULL && !PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "unknown problem with '%s'", name);

    return (obj != NULL) ? 0 : -1;
}

static int
GlobalAttributes_print(PyObject *v, FILE *fp, int flags)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)v;
    fprintf(fp, "%s", PyGlobalAttributes_ToString(obj->data, "",false).c_str());
    return 0;
}

PyObject *
GlobalAttributes_str(PyObject *v)
{
    GlobalAttributesObject *obj = (GlobalAttributesObject *)v;
    return PyString_FromString(PyGlobalAttributes_ToString(obj->data,"", false).c_str());
}

//
// The doc string for the class.
//
#if PY_MAJOR_VERSION > 2 || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION >= 5)
static const char *GlobalAttributes_Purpose = "This class contains attributes associated with the main window.";
#else
static char *GlobalAttributes_Purpose = "This class contains attributes associated with the main window.";
#endif

//
// Python Type Struct Def Macro from Py2and3Support.h
//
//         VISIT_PY_TYPE_OBJ( VPY_TYPE,
//                            VPY_NAME,
//                            VPY_OBJECT,
//                            VPY_DEALLOC,
//                            VPY_PRINT,
//                            VPY_GETATTR,
//                            VPY_SETATTR,
//                            VPY_STR,
//                            VPY_PURPOSE,
//                            VPY_RICHCOMP,
//                            VPY_AS_NUMBER)

//
// The type description structure
//

VISIT_PY_TYPE_OBJ(GlobalAttributesType,         \
                  "GlobalAttributes",           \
                  GlobalAttributesObject,       \
                  GlobalAttributes_dealloc,     \
                  GlobalAttributes_print,       \
                  PyGlobalAttributes_getattr,   \
                  PyGlobalAttributes_setattr,   \
                  GlobalAttributes_str,         \
                  GlobalAttributes_Purpose,     \
                  GlobalAttributes_richcompare, \
                  0); /* as_number*/

//
// Helper function for comparing.
//
static PyObject *
GlobalAttributes_richcompare(PyObject *self, PyObject *other, int op)
{
    // only compare against the same type 
    if ( Py_TYPE(self) != &GlobalAttributesType
         || Py_TYPE(other) != &GlobalAttributesType)
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    PyObject *res = NULL;
    GlobalAttributes *a = ((GlobalAttributesObject *)self)->data;
    GlobalAttributes *b = ((GlobalAttributesObject *)other)->data;

    switch (op)
    {
       case Py_EQ:
           res = (*a == *b) ? Py_True : Py_False;
           break;
       case Py_NE:
           res = (*a != *b) ? Py_True : Py_False;
           break;
       default:
           res = Py_NotImplemented;
           break;
    }

    Py_INCREF(res);
    return res;
}

//
// Helper functions for object allocation.
//

static GlobalAttributes *defaultAtts = 0;
static GlobalAttributes *currentAtts = 0;

static PyObject *
NewGlobalAttributes(int useCurrent)
{
    GlobalAttributesObject *newObject;
    newObject = PyObject_NEW(GlobalAttributesObject, &GlobalAttributesType);
    if(newObject == NULL)
        return NULL;
    if(useCurrent && currentAtts != 0)
        newObject->data = new GlobalAttributes(*currentAtts);
    else if(defaultAtts != 0)
        newObject->data = new GlobalAttributes(*defaultAtts);
    else
        newObject->data = new GlobalAttributes;
    newObject->owns = true;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

static PyObject *
WrapGlobalAttributes(const GlobalAttributes *attr)
{
    GlobalAttributesObject *newObject;
    newObject = PyObject_NEW(GlobalAttributesObject, &GlobalAttributesType);
    if(newObject == NULL)
        return NULL;
    newObject->data = (GlobalAttributes *)attr;
    newObject->owns = false;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

///////////////////////////////////////////////////////////////////////////////
//
// Interface that is exposed to the VisIt module.
//
///////////////////////////////////////////////////////////////////////////////

PyObject *
GlobalAttributes_new(PyObject *self, PyObject *args)
{
    int useCurrent = 0;
    if (!PyArg_ParseTuple(args, "i", &useCurrent))
    {
        if (!PyArg_ParseTuple(args, ""))
            return NULL;
        else
            PyErr_Clear();
    }

    return (PyObject *)NewGlobalAttributes(useCurrent);
}

//
// Plugin method table. These methods are added to the visitmodule's methods.
//
static PyMethodDef GlobalAttributesMethods[] = {
    {"GlobalAttributes", GlobalAttributes_new, METH_VARARGS},
    {NULL,      NULL}        /* Sentinel */
};

static Observer *GlobalAttributesObserver = 0;

std::string
PyGlobalAttributes_GetLogString()
{
    std::string s("GlobalAtts = GlobalAttributes()\n");
    if(currentAtts != 0)
        s += PyGlobalAttributes_ToString(currentAtts, "GlobalAtts.", true);
    return s;
}

static void
PyGlobalAttributes_CallLogRoutine(Subject *subj, void *data)
{
    typedef void (*logCallback)(const std::string &);
    logCallback cb = (logCallback)data;

    if(cb != 0)
    {
        std::string s("GlobalAtts = GlobalAttributes()\n");
        s += PyGlobalAttributes_ToString(currentAtts, "GlobalAtts.", true);
        cb(s);
    }
}

void
PyGlobalAttributes_StartUp(GlobalAttributes *subj, void *data)
{
    if(subj == 0)
        return;

    currentAtts = subj;
    PyGlobalAttributes_SetDefaults(subj);

    //
    // Create the observer that will be notified when the attributes change.
    //
    if(GlobalAttributesObserver == 0)
    {
        GlobalAttributesObserver = new ObserverToCallback(subj,
            PyGlobalAttributes_CallLogRoutine, (void *)data);
    }

}

void
PyGlobalAttributes_CloseDown()
{
    delete defaultAtts;
    defaultAtts = 0;
    delete GlobalAttributesObserver;
    GlobalAttributesObserver = 0;
}

PyMethodDef *
PyGlobalAttributes_GetMethodTable(int *nMethods)
{
    *nMethods = 1;
    return GlobalAttributesMethods;
}

bool
PyGlobalAttributes_Check(PyObject *obj)
{
    return (obj->ob_type == &GlobalAttributesType);
}

GlobalAttributes *
PyGlobalAttributes_FromPyObject(PyObject *obj)
{
    GlobalAttributesObject *obj2 = (GlobalAttributesObject *)obj;
    return obj2->data;
}

PyObject *
PyGlobalAttributes_New()
{
    return NewGlobalAttributes(0);
}

PyObject *
PyGlobalAttributes_Wrap(const GlobalAttributes *attr)
{
    return WrapGlobalAttributes(attr);
}

void
PyGlobalAttributes_SetParent(PyObject *obj, PyObject *parent)
{
    GlobalAttributesObject *obj2 = (GlobalAttributesObject *)obj;
    obj2->parent = parent;
}

void
PyGlobalAttributes_SetDefaults(const GlobalAttributes *atts)
{
    if(defaultAtts)
        delete defaultAtts;

    defaultAtts = new GlobalAttributes(*atts);
}

