                      Building VisIt on MacOS X 10.3
                     ================================

   This document describes how to build VisIt on MacOS X. Building on MacOS X,
while similar enough to other versions of UNIX but there are enough differences
to warrant these special instructions. Most of the differences arise from how
MacOS X provides support for advanced linking options such as prebinding, which
helps applications launch faster. We build VisIt and all of its support
libraries with prebinding enabled because it substantially improves VisIt's
startup time on MacOS X. Unfortunately, prebinding introduces a lot of
complexity with respect to building VisIt's support libraries because they each
have varying degrees of support for MacOS X. In fact, only Qt has built-in
support for prebinding. To enable prebinding for all of the other support
libraries, follow the instructions in this document for building each library
before finally building VisIt.

VisIt relies on several external libraries which must be built and installed
prior to building VisIt.  This document provides detailed step by step
instructions for building VisIt and each of the dependent libraries.  The
instructions have been designed so that you can cut and paste most of the
commands needed to build the libraries and VisIt from this file into your
shell prompt.


    Library  Version  Description            For More Information
    =======  =======  ===========            ====================
    Mesa     5.0.2    3-D Graphics Library   http://www.mesa3d.org/
    Python   2.3.3    Scripting Language     http://www.python.org
    Qt       3.3.1    GUI Toolkit            http://www.trolltech.com
    VTK      20031028 Visualization Toolkit  http://www.kitware.com
    
    Optional Version  Description            For More Information
    ======== =======  ===========            ====================
    HDF5     1.6.0    I/O library            http://hdf.ncsa.uiuc.edu/HDF5/
    Silo     4.4.3    File I/O library       http://www.llnl.gov/bdiv/meshtv
                                             ftp://ftp.llnl.gov/pub/visit/3rd_party/silo051121.sh
    Mili     1.09     I/O library            (none)
    HDF4     2.0      I/O library            http://hdf.ncsa.uiuc.edu/release4/obtain.html
    netCDF   3.6.0    File I/O library       http://www.unidata.ucar.edu/packages/netcdf/
    CGNS     2.4      File I/O library       http://www.cgns.org
    GDAL     1.3.0    GIS reader library     http://www.gdal.org
    ExodusII 2.0.5    File I/O library       http://endo.sandia.gov/SEACAS/Documentation/SEACAS.html


The public version of VisIt has been built with the above listed versions
of the libraries, so it is known to work properly with those versions.  For
all the packages except VTK and Qt, you can probably use newer versions of the
packages and VisIt should work properly.  For Mesa, you must build a mangled
version of Mesa.  The distribution provided has already been set up to build
a mangled version so no additional work is required if you use it.  For VTK,
you must use the October 28, 2003 distribution provided. The version of Qt
used to build VisIt on MacOS X must be greater than or equal to 3.0.

Most of the third party libraries necessary to build VisIt are available for
download from ftp://ftp.llnl.gov/pub/visit/3rd_party.  It is suggested that
you start there and then go to the "For More Information" web sites for
any remaining libraries.

It is essential that you build all the dependent packages and VisIt using
the same c++ compiler or you will encounter linking problems because different
compilers or different versions of the same compiler may use different name
mangling schemes. For MacOS X, we recommend using g++ 3.3.


==============================================================================
Crucial linker flags for prebinding a library or application
==============================================================================

-prebind             The -prebind flag should be used for applications and
                     libraries that you want to be prebound. Put the -prebind
		     flag in your LDFLAGS or wherever you provide arguments
		     to the linker. Prebinding allows your application to
		     start faster because all symbols are already resolved
		     and resolution is not required when the application is
		     launched. Furthermore, since prebinding requires that
		     all libraries used in the application have distinct, non-
		     overlapping memory ranges, the linker can compute
		     appropriate relocation offsets at link time.

-twolevel_namespace  A two level namespace is what's commonly used on most
                     platforms but MacOS X initially came with just a flat
		     namespace, which prevented duplicate symbols in the
		     same application. A two level namespace allows duplicates
		     and is more forgiving, though possibly error prone if
		     there are multiple symbols with the same name. Two-level
		     symbol resolution also takes a little longer.

-install_name        The -install_name flag inserts the name of the library
                     into the actual dylib file. Normally if you do not
		     provide this flag, the path where you built the library is
		     inserted into the dylib file and applications that link
		     with the dylib look for it in the path stored in the dylib,
		     which easily leads to the library not being found. In order
		     to make sure that the system can find the dylib file used
		     by your application, make sure you build dylib files so
		     their installed name is relative to the executable.
		   
		     For VisIt, which has a bin directory and a separate lib
		     directory for libraries, we set the installation name like
		     this:
		     
		     -install_name,@executable_path/../lib/libfoo.dylib.
		     
		     The above example makes sure that applications in bin that
		     linked with libfoo.dylib look for it in ../lib instead of
		     a hardcoded path.
		 
-seg1addr            The -seg1addr flag tells the linker where the first segment
                     of your library should start in memory. Prebinding is not
		     enabled unless all of your libraries and your application
		     that uses them have memory ranges that do not overlap at
		     all. Computing the segment address for a complex project
		     like VisIt can be tricky and Makefile tricks are required
		     if you want the offset to be computed on the fly,
		     determined by the sizes of your libraries as they are built.
		     To specify the starting segment address, do this:
		     
		     -Wl,-seg1addr,0x20000000

                     Look at VisIt's linkedit.py and configure.in scripts to
		     see how to compute the segment offset on the fly using
		     autoconf and Makefiles.

==============================================================================
Segment offset
==============================================================================

The initial segment offset for VisIt's support libraries begins at 0x...
, right after Qt's ending address. The memory addresses used in this document
reflect the sizes of the libraries as they were built at the time of VisIt 1.3.
We chose segment offsets that pack the libraries into a fairly contiguous
block of memory so no libraries interfere with each other.

==============================================================================
otool
==============================================================================

MacOS X has a utility called otool that allows you to examine the contents of
a dynamic library or an executable. Otool is very handy for determining whether
a dynamic library was actually built with prebinding. Here are the most useful
options for otool:

# Print the Mach header. If the library is prebound, it will have the word
# PREBOUND in the output. If the output does not contain PREBOUND then you
# need to make changes to your library and relink until it is prebound because
# unless an application and *all* of its dependent libraries are prebound,
# it cannot use prebinding.
otool -hv libfoo.dylib

# Print all of the library dependencies
otool -hvL libfoo.dylib

==============================================================================
Building an application that can run on multiple versions of MacOS X
==============================================================================

By default, the linker on MacOS X will resolve all system library dependencies
such that the final linked binary file will depend on a particular version of
the system libraries. For example, this prevents you from building on 
MacOS X 10.3 and running your application on MacOS X 10.4. As of MacOS X 10.3,
there is a special linker flag, called -undefined, that allows system library
dependencies to be left undefined during the link step without breaking 
prebinding, which is crucial to minimizing VisIt's start up time. There is 
also an environment variable called MACOSX_DEPLOYMENT_TARGET that can be 
set to tell the linker which versions of the system libraries to expect. 
Setting the  MACOSX_DEPLOYMENT_TARGET environment variable and using the
-undefined linker flag will help your compiled application run on more than
one version of MacOS X.

To make sure that when you build an application on MacOS X 10.3, it can also 
run on MacOS X 10.4 and beyond, you should set the MACOSX_DEPLOYMENT_TARGET
environment variable before you build your application.

Example:
setenv MACOSX_DEPLOYMENT_TARGET 10.3

You should also add the -undefined linker flag to your LDFLAGS in your
Makefile.

Example:
LDFLAGS="$LDFLAGS -Wl,-undefined,dynamic_lookup"

==============================================================================
Support libraries
==============================================================================

Most of the instructions in this document are for building the various support
libraries that VisIt depends on as prebound dynamic libraries. Few of the
libraries that VisIt uses actually have support in their make system for
producing prebound dynamic libraries so it is imperative that you follow the
directions or VisIt will not be prebound. Remember that you can always use the
otool command to check whether a library or executable is prebound.

Before building VisIt or any of its support libraries, you need to create a
"visit" directory in which the support libraries will be installed. We also 
create a file that contains the path so we can use that in some of the
instructions later on.

mkdir visit
echo `pwd`/visit > visitpath
set VISITPATH="`pwd`/visit"

Also, note when these instructions indicate that a library's source code must
be replaced or modified. VTK requires some source code modifications before
compilation. Since the source exists within VisIt's source code directory, 
take this opportunity to unzip VisIt's source code distribution and set an
environment variable that will be used to identify VisIt's source code 
directory.

gunzip visit051121.tar.gz
tar xf visit051121.tar
setenv VISITSOURCE `pwd`/visit051121

# Make sure that you build a version of VisIt that can run on MacOS X 10.3
# and later.
setenv MACOSX_DEPLOYMENT_TARGET 10.3

==============================================================================
Building Qt as a set of prebound dynamic libraries
==============================================================================

Qt actually builds as a prebound dynamic library but we need to make sure
that it sets an install_name that is relative to our VisIt executables.

# Unzip the Qt source
gunzip qt-mac-free-3.3.1.tar.gz
tar xvf qt-mac-free-3.3.1.tar
cd qt-mac-free-3.3.1

# Build Qt 3.3.1 for MacOS X
setenv QTDIR `pwd`
./configure -thread
make

# Qt built but we need to change it a little and it's easier to do it now
# after it has been built.
cd src
vi Makefile
Change TARGET0 to libqt.dylib
Add -install_name @executable_path/../lib/libqt.dylib -undefined dynamic_lookup to LFLAGS and save
rm ../lib/libqt*
make

# We must also change the qui library that comes with Qt.
cd ../tools/designer/uilib
vi Makefile
Change -lqt-mt to -lqt
Add -install_name @executable_path/../lib/libqui.dylib -undefined dynamic_lookup to LFLAGS and save
rm ../../../lib/libqui*
make
cd ../../../

# Install Qt
mkdir $VISITPATH/qt
mkdir $VISITPATH/qt/bin
mkdir $VISITPATH/qt/include
mkdir $VISITPATH/qt/include/private
mkdir $VISITPATH/qt/lib
cp bin/{designer,findtr,moc,qt20fix,qtrename140} $VISITPATH/qt/bin
cd include; cp *.h $VISITPATH/qt/include
cp private/*.h $VISITPATH/qt/include/private
cd ../lib
cp libqt-mt.3.3.1.dylib $VISITPATH/qt/lib/libqt.dylib
cp libqui.dylib $VISITPATH/qt/lib/libqui.dylib
cd ../..

==============================================================================
Building Mesa as a set of prebound dynamic libraries
==============================================================================		    

Mesa is a 3-D graphics library with an API which is very similar to that of
OpenGL.  It is used for performing off-screen rendering.

#
# Build Mesa
#
tar zxvf Mesa-5.0.2.tar.gz
cd Mesa-5.0.2

#
# Special instructions for building Mesa on MacOS X
#
# The darwin target for building Mesa assumes that you want to build Mesa
# with support for X11. This is not what we want to do for the version of
# Mesa that we'll use for VisIt since we only want offscreen rendering.
#
# 1. Open Make-config and remove all X include files and libraries from
#    the darwin target. Also add -DUSE_MGL_NAMESPACE to the CFLAGS and
#    CCFLAGS so a mangled version of Mesa will be built. Next, change
#    GL_LIB so it will build a library called libMesaGL.dylib instead of
#    libGL.dylib. Finally, edit GLU_LIB_DEPS so it uses -lMesaGL instead
#    of -lGL.
# 2. Open bin/mklib.darwin and look for an if/then/else block that sets
#    different flags for each of the libraries being linked. Change
#    libGL.dylib to libMesaGL.dylib since in the previous instructions,
#    we renamed the Mesa library.
#
#    For libMesaGL.dylib, add:
#       EXTRA_FLAGS="${EXTRA_FLAGS} -prebind -Wl,-seg1addr,0x2098a000,-undefined,dynamic_lookup"
#
#    For libOSMesa.dylib, add:
#       EXTRA_FLAGS="${EXTRA_FLAGS} -prebind -Wl,-seg1addr,0x20bd7000,-undefined,dynamic_lookup"
#
#    The additions above will cause the two modified libraries to be built
#    as prebound dynamic libraries, which will help reduce VisIt's start
#    time.
# 3. Open src/mesa/Makefile.X11 and remove all of the source code files from
#    the DRIVER_SOURCES variable so it is defined as:
#    DRIVER_SOURCES = 
#
# ** Note - After you start building Mesa with these changes, it will fail
#           after successfully building libMesaGL.dylib and libOSMesa.dylib.
#           This is okay since those are the only libraries we want.
#           Continue on to building VTK.
#

#
# Build Mesa by typing in the Mesa-5.0.2 directory.
#
make darwin

#
# Install Mesa
#
mkdir $VISITPATH/mesa
mkdir $VISITPATH/mesa/{include,lib}
mkdir $VISITPATH/mesa/include/GL
cp include/GL/*.h $VISITPATH/mesa/include/GL
cp lib/*.dylib $VISITPATH/mesa/lib
cd ..

==============================================================================
Building CMake in order to build VTK
==============================================================================

CMake is a cross-platform make system used to build VTK. Before building VTK,
we must build CMake

gunzip cmake-1.8.1.tar.gz
tar xf cmake-1.8.1.tar
cd cmake-1.8.1
env CXXFLAGS="" ./bootstrap
make
cd ..

==============================================================================
Building VTK as a set of prebound dynamic libraries
==============================================================================

VTK is an object oriented library for visualizing 3D data.  VisIt uses it
for all its visualization functionality. Follow the directions listed below
to build VTK.  If you have any problems building or installing VTK, read the
VTK/README.html file included in the VTK distribution for more information.

gunzip vtk_cvs_2003_10_28.tar.gz
tar xf vtk_cvs_2003_10_28.tar


Source code and build modifications:
====================================

The above VTK distribution must be modified a little to support features that
VisIt needs in order to run properly. For example, VisIt requires VTK to be built
with support for mangled mesa in order to support offscreen rendering. VisIt
uses offscreen rendering to save images, do scalable rendering in parallel, and
to render images when the CLI is run in -nowin mode. VTK cannot be built with 
mangled mesa support on MacOS X without some modifications to its source code 
and build system. Follow each of the next instructions before building VTK to
ensure that you produce VTK libraries that meet VisIt's needs.

1. Edit VTK/CMakeLists.txt. Look for -flat_namespace and replace it with: 
   -twolevel_namespace. Also delete the -U flag and its argument.

2. Edit VTK/Utilities/ftgl/CMakeLists.txt and look for:
   SET (VTKFTGL_LIBS "${VTKFTGL_LIBS};${OPENGL_LIBRARY}"). Add the following
   code after the above string:

      IF (FTGL_SUPPORT_MANGLE_MESA)
          SET (VTKFTGL_LIBS "${VTKFTGL_LIBS};${MANGLED_MESA_LIBRARY}")
      ENDIF (FTGL_SUPPORT_MANGLE_MESA)

3. Edit VTK/Rendering/CMakeLists.txt and remove the line that contains
   vtkXMesaRenderWindow.cxx.

4. Open VTK/Rendering/vtkGraphicsFactory.cxx and wrap the
   #include "vtkXMesaRenderWindow.h" with #if !defined(__APPLE__) / #endif to
   prevent that header from being included.

5. Open VTK/Rendering/vtkMesaRenderWindow.cxx and change
   #include "vtkXMesaRenderWindow.h" to #include "vtkMesaRenderWindow.h".

6. The vtkImagingFactory class does not support creation of Mesa objects under
   Carbon. Find the code in VTK/Rendering/vtkImagingFactory.cxx that looks like
   this:

   #ifdef VTK_USE_CARBON
     if (!strcmp("CarbonOpenGL",rl))
       {
       if(strcmp(vtkclassname, "vtkTextMapper") == 0)
         {
         return vtkOpenGLFreeTypeTextMapper::New();
         }
       if(strcmp(vtkclassname, "vtkImageMapper") == 0)
         {
         return vtkOpenGLImageMapper::New();
         }
       if(strcmp(vtkclassname, "vtkPolyDataMapper2D") == 0)
         {
         return vtkOpenGLPolyDataMapper2D::New();
         }
       }
   #endif

   Modify that code so it includes the code to create Mesa objects when VTK has
   been instructed to use Mesa. The modified code will look like this:   

   #ifdef VTK_USE_CARBON
     if (!strcmp("CarbonOpenGL",rl))
       {
       if(strcmp(vtkclassname, "vtkTextMapper") == 0)
         {
   #if defined(VTK_USE_MANGLED_MESA)
         if ( vtkImagingFactory::UseMesaClasses )
           {
           return vtkMesaFreeTypeTextMapper::New();
           }
   #endif
         return vtkOpenGLFreeTypeTextMapper::New();
         }
       if(strcmp(vtkclassname, "vtkImageMapper") == 0)
         {
   #if defined(VTK_USE_MANGLED_MESA)
         if ( vtkImagingFactory::UseMesaClasses )
           {
           return vtkMesaImageMapper::New();
           }
   #endif
         return vtkOpenGLImageMapper::New();
         }
       if(strcmp(vtkclassname, "vtkPolyDataMapper2D") == 0)
         {
   #if defined(VTK_USE_MANGLED_MESA)
         if ( vtkImagingFactory::UseMesaClasses )
           {
           return vtkMesaPolyDataMapper2D::New();
           }
   #endif
         return vtkOpenGLPolyDataMapper2D::New();
         }
       }
   #endif

7. Replace vtkCamera.cxx with VisIt's vtkCamera. Issue the following command
   to do so:
     cp $VISITSOURCE/visit_vtk/full/vtkCamera.C VTK/Rendering/vtkCamera.cxx
     cp $VISITSOURCE/visit_vtk/full/vtkCamera.h VTK/Rendering/vtkCamera.h

You may have noticed that we don't do anything in VTK to preclude the use of
vtkCarbonRenderWindow, even though it cannot support Mesa. We register an
override of vtkCarbonRenderWindow later in VisIt's visit_vtk library that
forces VTK to create one of VisIt's vtkOSMesaRenderWindow objects instead
of creating vtkCarbonRenderWindow objects. This allows us to do offscreen
rendering in MacOS X without having to rewrite vtkCarbonRenderWindow.


Configuring VTK:
================

cd VTK
../cmake-1.8.1/bin/ccmake .

The above ccmake program is a menu for configuring VTK. Follow these steps to 
configure VTK and generate its makefiles. You must perform these steps before
you can build VTK.

1. First, press "c" for configure.
2. When it is finished, press "t" for advanced options, and change the 
   options listed below:

    Option                             Value
    =================================================
    SHARED_LIBS                        ON
    CMAKE_BUILD_TYPE                   Release
    CMAKE_VERBOSE_MAKEFILE             TRUE
    VTK_USE_HYBRID                     ON
    BUILD_TESTING                      OFF
    CMAKE_CXX_FLAGS_RELEASE            -O2
    CMAKE_C_FLAGS_RELEASE              -O2
    CMAKE_EXE_LINKER_FLAGS_RELEASE     -prebind
    CMAKE_MODULE_LINKER_FLAGS_RELEASE  -prebind
    CMAKE_SHARED_LINKER_FLAGS_RELEASE  -prebind
    VTK_OPENGL_HAS_MESA                OFF
    VTK_USE_MANGLED_MESA               ON

3. Type "c" to make ccmake configure. When it is done there are more options to
   fill in. The use of $VISITHOME in this case is for illustration purposes only.
   Since you are inside of ccmake, substitute the actual value for $VISITHOME
   instead of using the $VISTIHOME environment variable.

   Option                              Value
   =================================================
   OSMESA_INCLUDE_DIR                  $VISITHOME/mesa/include
   OSMESA_LIBRARY                      $VISITHOME/mesa/lib/libOSMesa.dylib
   MANGLED_MESA_INCLUDE_DIR            $VISITHOME/mesa/include
   MANGLED_MESA_LIBRARY                $VISITHOME/mesa/lib/libMesaGL.dylib
   MANGLED_OSMESA_INCLUDE              $VISITHOME/mesa/include
   MANGLED_OSMESA_LIB                  $VISITHOME/mesa/lib/libOSMesa.dylib

4. Type "c" to configure
5. Type "g" to generate and quit


Building VTK:
=============

Now that VTK's source and build have been modified and you've configured and
generated VTK's Makefiles, you can start building VTK.

make

VTK does not provide targets for building prebound shared libraries. Rather than
change VTK's build process permanently, which I did not see how to do since I am
a CMake novice, I chose to edit the Makefiles generated by CMake after VTK was
built. I needed the size for all of the VTK libraries anyway in order to
calculate good offsets for them. The offset for the first VTK library is after
the last Mesa library so eventually we will have built all of VisIt's support
libraries so that they could be layed out in memory at their starting addresses
and never touch.

Library                 Segment Offset (hex)
=============================================
libvtkzlib.dylib        20be6000
libvtkjpeg.dylib        20bf5000
libvtkpng.dylib         20c18000
libvtktiff.dylib        20c3b000
libvtkexpat.dylib       20c86000
libvtkfreetype.dylib    20ca8000
libvtkftgl.dylib        20cfc000
libvtkDICOMParser.dylib 20d17000
libvtkCommon.dylib      20dec000
libvtkFiltering.dylib   21111000
libvtkGraphics.dylib    2125b000
libvtkIO.dylib          21601000
libvtkImaging.dylib     2192d000
libvtkRendering.dylib   21d06000
libvtkHybrid.dylib      22081000

Since we added -prebind to the flags that are used when trying to link a shared
library, we can open each Makefile for the projects listed above and add the
above offsets after the -prebind flag. Before adding offsets though, you should
remove all of the shared libraries in the VTK/bin directory so make will cause
a relink of the libraries as we build them one by one.

Example:
   1. cd Utilities/zlib
   2. vi Makefile
   3. Search for -prebind
   4. After -prebind, add:
      -Wl,-seg1addr,0x20be6000,-install_name,@executable_path/../lib/libvtkzlib.dylib,-compatibility_version,4.2,-current_version,4.2,-undefined,dynamic_lookup
      
      Be sure to use the right library name in for the -install_name linker flag since that
      name is put into the library so the runtime linker can find the library relative
      to the executable's path. This helps make applications double-clickable.
      
   5. Save and exit vi
   6. make
   
Note: Be sure that you use a different offset for each library or prebinding will
      fail. The offsets for each VTK library are in the above table. Those offsets
      were computed by first building VTK and calculating the size of each library
      and then calculating an offset that arranges them safely one after another
      in a linear block of memory. There are small gaps between the libraries due
      to the algorithm that was used to lay them out in memory and because of
      segment alignment, which is currently 0x1000.
      
#
# Install VTK in the visit directory under the vtk directory.
#
mkdir $VISITPATH/vtk
mkdir $VISITPATH/vtk/{Common,Filtering,Graphics,Hybrid,IO,Imaging,Rendering,MangleMesaInclude,lib}
cp vtkConfigure.h                 $VISITPATH/vtk
cp vtkToolkits.h                  $VISITPATH/vtk
cp vtk*Instantiator.h             $VISITPATH/vtk
cp Utilities/zlib/zlib.h          $VISITPATH/vtk
cp Utilities/zlib/zconf.h         $VISITPATH/vtk
cp Utilities/zlib/zlibDllConfig.h $VISITPATH/vtk
cp Utilities/tiff/*.h             $VISITPATH/vtk
cp Common/*.h                     $VISITPATH/vtk/Common
cp Filtering/*.h                  $VISITPATH/vtk/Filtering
cp Graphics/*.h                   $VISITPATH/vtk/Graphics
cp Hybrid/*.h                     $VISITPATH/vtk/Hybrid
cp IO/*.h                         $VISITPATH/vtk/IO
cp Imaging/*.h                    $VISITPATH/vtk/Imaging
cp Rendering/*.h                  $VISITPATH/vtk/Rendering
cp MangleMesaInclude/*.h          $VISITPATH/vtk/MangleMesaInclude
cp bin/*.dylib                    $VISITPATH/vtk/lib
cd ..

#
# Install the VTK JPEG library under the visit directory in case the
# computer does not have a JPEG library.
#
mkdir $VISITPATH/jpeg $VISITPATH/jpeg/include $VISITPATH/jpeg/lib
cp Utilities/jpeg/*.h             $VISITPATH/jpeg/include
cp bin/libvtkjpeg.dylib           $VISITPATH/jpeg/lib/libjpeg.dylib


The next offset after libvtkHybrid.dylib, which has an offset of 0x22081000 and
a library size of 2,406,052 (0x24b6a4) bytes is:

# Next offset
offset = 0x22081000 + int(float(0x24b6a4) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x222ea000

===============================================================================
Building Python as a prebound dynamic library
===============================================================================

Python is a powerful, free scripting language that is used to drive VisIt's
viewer when running VisIt without a GUI. Python is cross platform and runs on
many UNIXes as well as MS Windows and other platforms. VisIt can be configured
to run without Python if scripting features are not desired.  Follow the
directions listed below to build Python.  If you have any problems building
or installing Python, read the README file in the Python distribution for more
information.

I could not get Python 2.1.2 to build all of the way on Panther (MacOS X 10.3) so I
downloaded the newer Python 2.3.3.

tar zxvf Python-2.3.3.tgz
cd Python-2.3.3
env OPT="-O3 -Wall -Wstrict-prototypes -fno-common -fPIC" ./configure --prefix=`cat ../visitpath`/python
make

# Install Python
make install

# Now that Python is built, we need to create a shared library version.
mkdir tmplib
cd tmplib
ar -x ../libpython2.3.a
echo "char **environ=0;" > environhack.c
gcc -o environhack.o -c environhack.c
gcc -dynamiclib -prebind -Wl,-seg1addr,0x222ea000,-install_name,@executable_path/../lib/libpython2.3.dylib,-compatibility_version,2.3.3,-current_version,2.3.3,-undefined,dynamic_lookup -twolevel_namespace -o libpython2.3.dylib *.o  -framework Carbon
cp libpython2.3.dylib $VISITPATH/python/lib/python2.3/config/libpython2.3.dylib
cd ../..

The next offset after libpython.dylib, which has an offset of 0x222ea000 and a library
size of 3,311,968 (0x328960) bytes is:

# Next offset
offset = 0x222ea000 + int(float(0x328960) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x2263c000

===============================================================================
Building HDF5 as a prebound dynamic library (optional)
===============================================================================

HDF5 is a data storage library that allows you to efficiently write large
volumes of structured storage to a disk file. VisIt can technically be built
without support for HDF5 so it is an optional, but recommended, package. Though
it is optional, we build it before the Silo library because the Silo library
should be built with support for HDF5 when possible. If you don't want to build
HDF5, you can skip this section but you will have to take care that you do not
attempt to build Silo with support for HDF5.

tar zxvf hdf5-1.6.0.tar.gz
cd hdf5-1.6.0
env CFLAGS="-O2 -fPIC" ./configure
make

# The HDF5 libraries get built, even as dylib shared libraries. That's
# not quite good enough though since we want to set the beginning 
# address of the library and make it be prebound. We'll build our own
# version of the library using the prebuilt sources.
cd src
gcc -dynamiclib -prebind -twolevel_namespace -Wl,-seg1addr,0x2263c000,-install_name,@executable_path/../lib/libhdf5.dylib,-compatibility_version,1.6,-current_version,1.6,-undefined,dynamic_lookup -o libhdf5.dylib *.lo -lz

# Install HDF5
mkdir $VISITPATH/hdf5
mkdir $VISITPATH/hdf5/include
mkdir $VISITPATH/hdf5/lib
cp libhdf5.dylib $VISITPATH/hdf5/lib
cp *.h $VISITPATH/hdf5/include
cd ../..

The next offset after libhdf5.dylib, which has an offset of 0x2263c000 and
a library size of 1,055,884 (0x101c8c) bytes is:

# Next offset
offset = 0x2263c000 + int(float(0x101c8c) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x2274b000

===============================================================================
Building Mili as a prebound dynamic library  (optional)
===============================================================================

Mili is a database file format library for finite element codes like ls-dyna.
VisIt has a database reader for this popular LLNL engineering database file
format. Mili file format support is optional and is not required for
VisIt to run.

gunzip mili.tar.gz
tar xvf mili.tar
cd Mili/src

I could not figure out Mili's strange build system, especially since
it does not support MacOS X so I built my own Mili library using a
Makefile that I wrote. Save the following lines to a Makefile in
the Mili's src directory

CC=gcc
CFLAGS = -I. -O2 -fno-common -fPIC
MILI_LDFLAGS=-Wl,-seg1addr,0x227e5000,-undefined,dynamic_lookup
LDFLAGS=-dynamiclib -prebind -twolevel_namespace -Wl,-install_name,@executable_path/../lib/$@
.SUFFIXES : .o .c
MILI_SRC=mili.c direc.c param.c io.c util.c dep.c svar.c srec.c mesh_u.c wrap_c.c io_mem.c eprtf.c sarray.c gahl.c
MILI_OBJ=${MILI_SRC:.c=.o}
MILI_LIB=libmili.dylib
all: $(MILI_LIB)
$(MILI_LIB): $(MILI_OBJ)
	$(CC) -o $@ $(LDFLAGS) $(MILI_LDFLAGS) $(MILI_OBJ)
clean: 
	rm -f *.a *.o $(MILI_LIB)

Now that you're in Mili's source directory and you have a Makefile, 
type: make

# Install Mili
mkdir $VISITPATH/mili
cp libmili.dylib $VISITPATH/mili
cp mili.h $VISITPATH/mili
cp mili_enum.h $VISITPATH/mili
cd ../..

The next offset after libmili.dylib, which has an offset of 0x227b1000 and
a library size of 109,556 (0x1abf4) bytes is:

# Next offset
offset = 0x227e8000 + int(float(0x1abf4) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x22805000

==============================================================================
Building HDF4 as a prebound dynamic library  (optional)
==============================================================================

HDF4 is a data storage library that lets you write large volumes of data to 
disk files and it is the predecessor of HDF5. Like most of the other libraries
mentioned so far, HDF4 does not have a make target to produce a prebound, dynamic
library. In fact, its make target for MacOS X produces a static library. Follow
the instructions below for creating prebound dynamic libraries.

# Unpack HDF4
tar zxvf HDF4.2r0.tar.gz
cd HDF4.2r0

vi configure
# Comment out lines 7147-7169 because the script exits with a failure to
# calculate the size of int*. Insert, at line 7178, ac_cv_sizeof_intp=4
# Save the file and exit.
env CFLAGS="-O2 -fno-common" ./configure --with-jpeg=$VISITPATH/jpeg --disable-fortran
make

# Relink libdf and install it.
cd hdf/src
mkdir tmp
cd tmp
ar -x ../libdf.a
gcc -dynamiclib -prebind -twolevel_namespace -o libdf.dylib *.o -L$VISITPATH/jpeg/lib -ljpeg -lz -Wl,-seg1addr,0x22805000,-install_name,@executable_path/../lib/libdf.dylib,-compatibility_version,2.0,-current_version,2.0,-undefined,dynamic_lookup
mkdir $VISITPATH/hdf4
mkdir $VISITPATH/hdf4/lib
mkdir $VISITPATH/hdf4/include
mv libdf.dylib $VISITPATH/hdf4/lib

# Relink libmfhdf and install it.
cd ../../../mfhdf/libsrc
mkdir tmp
cd tmp
ar -x ../libmfhdf.a
gcc -dynamiclib -prebind -twolevel_namespace -o libmfhdf.dylib *.o L$VISITPATH/jpeg/lib -L$VISITPATH/hdf4/lib -ljpeg -ldf -Wl,-seg1addr,0x228a0000,-install_name,@executable_path/../lib/libmfhdf.dylib,-compatibility_version,2.0,-current_version,2.0,-undefined,dynamic_lookup
mv libmfhdf.dylib $VISITPATH/hdf4/lib
cd ../../..

# Install the HDF4 header files
cp hdf/src/*.h      $VISITPATH/hdf4/include
cp mfhdf/libsrc/*.h $VISITPATH/hdf4/include
cd ..

The next offset after libmfhdf.dylib, which has an offset of 0x228a0000 and
a library size of 112876 bytes is:

# Next offset
offset = 0x228a0000 + int(float(112876) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x228bf000

==============================================================================
Building NetCDF as a prebound dynamic library  (optional)
==============================================================================

NetCDF is a scientific data storage library that lets you write platform-
independent binary files. The default make target produces a static library
so follow these instructions for creating a prebound dynamic library.

# Unpack NetCDF
tar zxvf netcdf.tar.gz
cd netcdf-3.6.0-p1/src

# Make an installation directory for NetCDF
mkdir $VISITPATH/netcdf
mkdir $VISITPATH/netcdf/3.6.0

# Configure NetCDF
./configure --prefix=$VISITPATH/netcdf/3.6.0 FC="" CFLAGS="-O2 -fno-common" CXXFLAGS="-O2 -fno-common"
make

# Install headers, etc.
make install

# Prepare a prebound, dynamic library.
cd libsrc
mkdir tmp
cd tmp
ar -x ../libnetcdf.a
gcc -dynamiclib -prebind -twolevel_namespace -o libnetcdf.dylib *.o -Wl,-seg1addr,0x228bf000,-install_name,@executable_path/../lib/libnetcdf.dylib,-compatibility_version,3.6.0,-current_version,3.6.0,-undefined,dynamic_lookup
rm $VISITPATH/netcdf/3.6.0/lib/*.a
mv libnetcdf.dylib $VISITPATH/netcdf/3.6.0/lib
cd ../../..

# Next offset
offset = 0x228bf000 + int(float(194968) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x228f1000

===============================================================================
Building CGNS as a prebound dynamic library  (optional)
===============================================================================
The CFD General Notation System (CGNS) consists of a collection of 
conventions, and software implementing those conventions, for the storage
and retrieval of CFD (computational fluid dynamics) data. The principal 
target of CGNS is data normally associated with compressible viscous flow
(i.e., the Navier-Stokes equations), but the standard is also applicable
to subclasses such as Euler and potential flows.

# Unpack CGNS
tar zxvf cgnslib_2.4-3.tar.gz
cd cgnslib_2.4

mkdir $VISITPATH/cgns
mkdir $VISITPATH/cgns/2.4
mkdir $VISITPATH/cgns/2.4/include
mkdir $VISITPATH/cgns/2.4/lib

# Configure CGNS
env CFLAGS="-O2 -fno-common" ./configure --prefix=$VISITPATH/cgns/2.4
make

# Install headers, etc.
make install

# Prepare a prebound, dynamic library
cd DARWIN
mkdir tmp
cd tmp
ar -x ../libcgns.a
gcc -dynamiclib -prebind -twolevel_namespace -o libcgns.dylib *.o -Wl,-seg1addr,0x228f1000,-install_name,@executable_path/../lib/libcgns.dylib,-compatibility_version,2.4.0,-current_version,2.4.0,-undefined,dynamic_lookup
rm $VISITPATH/cgns/2.4/lib/libcgns.a
cp libcgns.dylib $VISITPATH/cgns/2.4/lib
cd ../../../

# Next offset
offset = 0x228f1000 + int(float(468428) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x2296a000

===============================================================================
Building GDAL as a prebound dynamic library  (optional)
===============================================================================
GDAL is a translator library for raster geospatial data formats that presents
a single abstract data model to the calling application for all supported
formats. 

# Unpack GDAL
tar zxvf gdal-1.3.0.tar.gz
cd gdal-1.3.0

mkdir $VISITPATH/gdal
mkdir $VISITPATH/gdal/1.3.0

# Configure GDAL
env CXXFLAGS="-O2 -fno-common" CFLAGS="-O2 -fno-common" ./configure --prefix=$VISITPATH/gdal/1.3.0 --with-gif=internal --with-png=internal --with-jpeg=internal --with-libz=internal --with-netcdf=no --without-jasper --enable-static --disable-shared --without-python
make

# Install GDAL headers, etc.
make install

# Prepare a prebound, dynamic library
cd .libs
mkdir tmp
cd tmp
ar -x ../libgdal.a
g++ -dynamiclib -prebind -twolevel_namespace -o libgdal.dylib *.o -Wl,-seg1addr,0x2296a000,-install_name,@executable_path/../lib/libgdal.dylib,-compatibility_version,1.3.0,-current_version,1.3.0,-undefined,dynamic_lookup
rm $VISITPATH/gdal/1.3.0/lib/libgdal.*
cp libgdal.dylib $VISITPATH/gdal/1.3.0/lib
cd ../../..

# Next offset
offset = 0x2296a000 + int(float(4840812) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x22e43000


===============================================================================
Building Exodus II as a prebound dynamic library  (optional)
===============================================================================
EXODUS II is a model developed to store and retrieve data for finite element 
analyses. It is used for preprocessing (problem definition), postprocessing 
(results visualization), as well as code to code data transfer. An EXODUS II
data file is a random access, machine independent, binary file that is written
and read via C, C++, or Fortran library routines which comprise the Application 
Programming Interface. (exodusII is based on netcdf)

# Unpack Exodus II source
tar zxvf exodusii.20010823.tar.gz
cd ACCESS/libraries/exodus/cbind/src

# Build the Exodus II source (note that it requires NetCDF)
set NETCDFLIB=$VISITPATH/netcdf/3.6.0/lib
set NETCDFINC=$VISITPATH/netcdf/3.6.0/include
gcc -O2 -I/usr/include/malloc -I../include -I$NETCDFINC -fno-common -c *.c

# Build a prebound dynamic library
gcc -dynamiclib -prebind -twolevel_namespace -Wl,-seg1addr,0x22e43000,-install_name,@executable_path/../lib/libexoIIv2c.dylib,-compatibility_version,2.0.5,-current_version,2.0.5,-undefined,dynamic_lookup -o libexoIIv2c.dylib *.o -L$NETCDFLIB -lnetcdf

# Install Exodus
mkdir $VISITPATH/exodusII
mkdir $VISITPATH/exodusII/include
mkdir $VISITPATH/exodusII/lib
cp libexoIIv2c.dylib $VISITPATH/exodusII/lib
cp ../include/*.h $VISITPATH/exodusII/include
cp $VISITPATH/netcdf/3.6.0/include/netcdf.h $VISITPATH/exodusII/include
cd ../../../../../

# Next offset
offset = 0x22e43000 + int(float(149480) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x22e6a000


===============================================================================
Building Silo as a prebound dynamic library  (optional)
===============================================================================

Silo is a self-describing, machine-independent scientific file format.
Silo is one of the file formats supported by VisIt.  Follow the directions
listed below to build Silo.  If you have any problems building or installing
Silo, read the INSTALL_NOTES file in the SILO distribution for more
information.

Note that these instructions assume that Silo will be built with HDF5 support.
If you build Silo with HDF5 support then you must have first built HDF5 using
the instructions provided earlier in this document. If you don't want to build
Silo with HDF5 support, replace the --with-hdf5=... with --without-hdf5.
The library segment offsets used assume that Silo will be built with support
for HDF5. If you choose to disable HDF5 support, the offsets will not be 
affected since the HDF5 version of the Silo library should be larger.

# Build silo source into an archive library
sh silo051121.sh
cd silo051121
# Set the values of some helper variables (tcsh)
set HDF5INCLUDE=$VISITDIR/hdf5/include
set HDF5LIB=$VISITDIR/hdf5/lib
env CFLAGS="-O2 -fno-common -fPIC" ./configure --disable-sdx --without-readline --without-exodus --with-hdf5=$HDF5INCLUDE,$HDF5LIB
make

# Turn the archive library into a prebound dynamic library

cd lib
mkdir tmplib
cd tmplib
ar -x ../libsilo.a
gcc -dynamiclib -prebind -twolevel_namespace -Wl,-seg1addr,0x33e43000,-install_name,@executable_path/../lib/libsilo.dylib,-compatibility_version,4.4.3,-current_version,4.4.3,-undefined,dynamic_lookup -o ../libsilo.dylib *.o -L$HDF5LIB -lhdf5
cd ..

# Install Silo
mkdir $VISITDIR/silo
mkdir $VISITDIR/silo/include
mkdir $VISITDIR/silo/lib
cp silo/silo/silo.h   $VISITDIR/silo/include
cp silo/silo/silo.inc $VISITDIR/silo/include
cp silo/sdx/sdx.h     $VISITDIR/silo/include
cp silo/sdx/sdx.inc   $VISITDIR/silo/include
cp lib/libsilo.dylib  $VISITDIR/silo/lib
cd ..

The next offset after libsilo.dylib, which has an offset of 0x33e43000 and a library
size of 669,216 (0xa3620) bytes is:

# Next offset
offset = 0x33e43000 + int(float(0xa3620) * 1.05)
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x33eef000

===============================================================================
Building VisIt with prebinding
===============================================================================

Since we may want to add other libraries to our list of prebound
dynamic libraries, for database reader plugins, etc, we should 
reserve a memory range after the Python library. Suppose all other
libraries that we want can fit in 10Mb. If that assumption becomes invalid,
we can recalculate the offset for the VisIt libraries. The starting address
for the VisIt libraries using the current assumptions would then be:
0x33eef000 + 10Mb

# Next offset
offset = 0x33eef000 + 0x2faf080
# Align the offset to 0x1000 byte boundaries
offset = offset + (0x1000 - offset % 0x1000)
# Next offset
offset = 0x36e9f000

VisIt uses GNU's autoconf system to provide platform independence when
building VisIt in a UNIX environment. Autoconf creates a script called
configure that tests your system for various libraries and programs required
to build VisIt.  Follow the directions listed below to build VisIt.
More information about building VisIt follows after that.

#
# Unzipping VisIt's source code distribution
#
gunzip visit051121.tar.gz
tar xf visit051121.tar
cd visit051121

#
# HDF5 and Silo
#
If you built the Silo library with support for HDF5 using the instructions in
this document then you will need to modify VisIt's configure script somewhat so
programs that require the silo library also get linked with the HDF5 library.
On most other platforms, the Silo library is a static archive with the HDF5
symbols linked into it. These build instructions for MacOS X build Silo as a
dynamic, prebound library using a dynamic HDF5 library.

vi configure
replace -lsilo with: -lsilo -lhdf5
save and quit

#
# Configure VisIt
#
cd config-site
echo VISITHOME=`cat ../../visitpath` > `hostname`.conf
cat Template.conf >> `hostname`.conf
cd ..
env CXXFLAGS="-O2" ./configure

#
# If VisIt failed to configure properly, check the contents of the
# `hostname`.conf file to make sure that it points to the libraries that
# you build. You can look at whitestar.conf, which is a configuration file
# for another MacOS X computer, if you want an example file that works.
#

# Change the Silo optimization level.
The Silo database reader plugin fails to build on MacOS X with GCC3.3 because
it runs out of memory with the default -O2 optimization flag.

cd databases/Silo
vi Makefile
# Look for CXXFLAGS=$(CXXFLAGSORIG) and right after $(CXXFLAGSORIG), add -O1
# so the Silo database reader can build. The default optimization level (-O2)
# causes gcc to run out of memory on some MacOS X computers.


cd ../..


# Build VisIt
make

If you have any problems send e-mail to visit-help@llnl.gov.
