// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

#include <PyMoleculeAttributes.h>
#include <ObserverToCallback.h>
#include <stdio.h>
#include <Py2and3Support.h>
#include <ColorAttribute.h>

// ****************************************************************************
// Module: PyMoleculeAttributes
//
// Purpose:
//   This class contains the plot attributes for the molecule plot.
//
// Note:       Autogenerated by xml2python. Do not modify by hand!
//
// Programmer: xml2python
// Creation:   omitted
//
// ****************************************************************************

//
// This struct contains the Python type information and a MoleculeAttributes.
//
struct MoleculeAttributesObject
{
    PyObject_HEAD
    MoleculeAttributes *data;
    bool        owns;
    PyObject   *parent;
};

//
// Internal prototypes
//
static PyObject *NewMoleculeAttributes(int);
std::string
PyMoleculeAttributes_ToString(const MoleculeAttributes *atts, const char *prefix)
{
    std::string str;
    char tmpStr[1000];

    const char *drawAtomsAs_names = "NoAtoms, SphereAtoms, ImposterAtoms";
    switch (atts->GetDrawAtomsAs())
    {
      case MoleculeAttributes::NoAtoms:
          snprintf(tmpStr, 1000, "%sdrawAtomsAs = %sNoAtoms  # %s\n", prefix, prefix, drawAtomsAs_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::SphereAtoms:
          snprintf(tmpStr, 1000, "%sdrawAtomsAs = %sSphereAtoms  # %s\n", prefix, prefix, drawAtomsAs_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::ImposterAtoms:
          snprintf(tmpStr, 1000, "%sdrawAtomsAs = %sImposterAtoms  # %s\n", prefix, prefix, drawAtomsAs_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const char *scaleRadiusBy_names = "Fixed, Covalent, Atomic, Variable";
    switch (atts->GetScaleRadiusBy())
    {
      case MoleculeAttributes::Fixed:
          snprintf(tmpStr, 1000, "%sscaleRadiusBy = %sFixed  # %s\n", prefix, prefix, scaleRadiusBy_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Covalent:
          snprintf(tmpStr, 1000, "%sscaleRadiusBy = %sCovalent  # %s\n", prefix, prefix, scaleRadiusBy_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Atomic:
          snprintf(tmpStr, 1000, "%sscaleRadiusBy = %sAtomic  # %s\n", prefix, prefix, scaleRadiusBy_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Variable:
          snprintf(tmpStr, 1000, "%sscaleRadiusBy = %sVariable  # %s\n", prefix, prefix, scaleRadiusBy_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const char *drawBondsAs_names = "NoBonds, LineBonds, CylinderBonds";
    switch (atts->GetDrawBondsAs())
    {
      case MoleculeAttributes::NoBonds:
          snprintf(tmpStr, 1000, "%sdrawBondsAs = %sNoBonds  # %s\n", prefix, prefix, drawBondsAs_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::LineBonds:
          snprintf(tmpStr, 1000, "%sdrawBondsAs = %sLineBonds  # %s\n", prefix, prefix, drawBondsAs_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::CylinderBonds:
          snprintf(tmpStr, 1000, "%sdrawBondsAs = %sCylinderBonds  # %s\n", prefix, prefix, drawBondsAs_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const char *colorBonds_names = "ColorByAtom, SingleColor";
    switch (atts->GetColorBonds())
    {
      case MoleculeAttributes::ColorByAtom:
          snprintf(tmpStr, 1000, "%scolorBonds = %sColorByAtom  # %s\n", prefix, prefix, colorBonds_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::SingleColor:
          snprintf(tmpStr, 1000, "%scolorBonds = %sSingleColor  # %s\n", prefix, prefix, colorBonds_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const unsigned char *bondSingleColor = atts->GetBondSingleColor().GetColor();
    snprintf(tmpStr, 1000, "%sbondSingleColor = (%d, %d, %d, %d)\n", prefix, int(bondSingleColor[0]), int(bondSingleColor[1]), int(bondSingleColor[2]), int(bondSingleColor[3]));
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sradiusVariable = \"%s\"\n", prefix, atts->GetRadiusVariable().c_str());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sradiusScaleFactor = %g\n", prefix, atts->GetRadiusScaleFactor());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sradiusFixed = %g\n", prefix, atts->GetRadiusFixed());
    str += tmpStr;
    const char *atomSphereQuality_names = "Low, Medium, High, Super";
    switch (atts->GetAtomSphereQuality())
    {
      case MoleculeAttributes::Low:
          snprintf(tmpStr, 1000, "%satomSphereQuality = %sLow  # %s\n", prefix, prefix, atomSphereQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Medium:
          snprintf(tmpStr, 1000, "%satomSphereQuality = %sMedium  # %s\n", prefix, prefix, atomSphereQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::High:
          snprintf(tmpStr, 1000, "%satomSphereQuality = %sHigh  # %s\n", prefix, prefix, atomSphereQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Super:
          snprintf(tmpStr, 1000, "%satomSphereQuality = %sSuper  # %s\n", prefix, prefix, atomSphereQuality_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    const char *bondCylinderQuality_names = "Low, Medium, High, Super";
    switch (atts->GetBondCylinderQuality())
    {
      case MoleculeAttributes::Low:
          snprintf(tmpStr, 1000, "%sbondCylinderQuality = %sLow  # %s\n", prefix, prefix, bondCylinderQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Medium:
          snprintf(tmpStr, 1000, "%sbondCylinderQuality = %sMedium  # %s\n", prefix, prefix, bondCylinderQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::High:
          snprintf(tmpStr, 1000, "%sbondCylinderQuality = %sHigh  # %s\n", prefix, prefix, bondCylinderQuality_names);
          str += tmpStr;
          break;
      case MoleculeAttributes::Super:
          snprintf(tmpStr, 1000, "%sbondCylinderQuality = %sSuper  # %s\n", prefix, prefix, bondCylinderQuality_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    snprintf(tmpStr, 1000, "%sbondRadius = %g\n", prefix, atts->GetBondRadius());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sbondLineWidth = %d\n", prefix, atts->GetBondLineWidth());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%selementColorTable = \"%s\"\n", prefix, atts->GetElementColorTable().c_str());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sresidueTypeColorTable = \"%s\"\n", prefix, atts->GetResidueTypeColorTable().c_str());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sresidueSequenceColorTable = \"%s\"\n", prefix, atts->GetResidueSequenceColorTable().c_str());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%scontinuousColorTable = \"%s\"\n", prefix, atts->GetContinuousColorTable().c_str());
    str += tmpStr;
    if(atts->GetLegendFlag())
        snprintf(tmpStr, 1000, "%slegendFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%slegendFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetMinFlag())
        snprintf(tmpStr, 1000, "%sminFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sminFlag = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sscalarMin = %g\n", prefix, atts->GetScalarMin());
    str += tmpStr;
    if(atts->GetMaxFlag())
        snprintf(tmpStr, 1000, "%smaxFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%smaxFlag = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%sscalarMax = %g\n", prefix, atts->GetScalarMax());
    str += tmpStr;
    return str;
}

static PyObject *
MoleculeAttributes_Notify(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    obj->data->Notify();
    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_SetDrawAtomsAs(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid drawAtomsAs value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " NoAtoms";
        ss << ", SphereAtoms";
        ss << ", ImposterAtoms";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the drawAtomsAs in the object.
    obj->data->SetDrawAtomsAs(MoleculeAttributes::AtomRenderingMode(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetDrawAtomsAs(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetDrawAtomsAs()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetScaleRadiusBy(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 4)
    {
        std::stringstream ss;
        ss << "An invalid scaleRadiusBy value was given." << std::endl;
        ss << "Valid values are in the range [0,3]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Fixed";
        ss << ", Covalent";
        ss << ", Atomic";
        ss << ", Variable";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the scaleRadiusBy in the object.
    obj->data->SetScaleRadiusBy(MoleculeAttributes::RadiusType(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetScaleRadiusBy(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetScaleRadiusBy()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetDrawBondsAs(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid drawBondsAs value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " NoBonds";
        ss << ", LineBonds";
        ss << ", CylinderBonds";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the drawBondsAs in the object.
    obj->data->SetDrawBondsAs(MoleculeAttributes::BondRenderingMode(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetDrawBondsAs(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetDrawBondsAs()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetColorBonds(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 2)
    {
        std::stringstream ss;
        ss << "An invalid colorBonds value was given." << std::endl;
        ss << "Valid values are in the range [0,1]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " ColorByAtom";
        ss << ", SingleColor";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the colorBonds in the object.
    obj->data->SetColorBonds(MoleculeAttributes::BondColoringMode(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetColorBonds(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetColorBonds()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetBondSingleColor(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    int c[4];
    if(!PyArg_ParseTuple(args, "iiii", &c[0], &c[1], &c[2], &c[3]))
    {
        c[3] = 255;
        if(!PyArg_ParseTuple(args, "iii", &c[0], &c[1], &c[2]))
        {
            double dr, dg, db, da;
            if(PyArg_ParseTuple(args, "dddd", &dr, &dg, &db, &da))
            {
                c[0] = int(dr);
                c[1] = int(dg);
                c[2] = int(db);
                c[3] = int(da);
            }
            else if(PyArg_ParseTuple(args, "ddd", &dr, &dg, &db))
            {
                c[0] = int(dr);
                c[1] = int(dg);
                c[2] = int(db);
                c[3] = 255;
            }
            else
            {
                PyObject *tuple = NULL;
                if(!PyArg_ParseTuple(args, "O", &tuple))
                    return NULL;

                if(!PyTuple_Check(tuple))
                    return NULL;

                // Make sure that the tuple is the right size.
                if(PyTuple_Size(tuple) < 3 || PyTuple_Size(tuple) > 4)
                    return NULL;

                // Make sure that all elements in the tuple are ints.
                for(int i = 0; i < PyTuple_Size(tuple); ++i)
                {
                    PyObject *item = PyTuple_GET_ITEM(tuple, i);
                    if(PyInt_Check(item))
                        c[i] = int(PyInt_AS_LONG(PyTuple_GET_ITEM(tuple, i)));
                    else if(PyFloat_Check(item))
                        c[i] = int(PyFloat_AS_DOUBLE(PyTuple_GET_ITEM(tuple, i)));
                    else
                        return NULL;
                }
            }
        }
        PyErr_Clear();
    }

    // Set the bondSingleColor in the object.
    ColorAttribute ca(c[0], c[1], c[2], c[3]);
    obj->data->SetBondSingleColor(ca);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetBondSingleColor(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the bondSingleColor.
    PyObject *retval = PyTuple_New(4);
    const unsigned char *bondSingleColor = obj->data->GetBondSingleColor().GetColor();
    PyTuple_SET_ITEM(retval, 0, PyInt_FromLong(long(bondSingleColor[0])));
    PyTuple_SET_ITEM(retval, 1, PyInt_FromLong(long(bondSingleColor[1])));
    PyTuple_SET_ITEM(retval, 2, PyInt_FromLong(long(bondSingleColor[2])));
    PyTuple_SET_ITEM(retval, 3, PyInt_FromLong(long(bondSingleColor[3])));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetRadiusVariable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the radiusVariable in the object.
    obj->data->SetRadiusVariable(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetRadiusVariable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetRadiusVariable().c_str());
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetRadiusScaleFactor(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    float cval = float(val);

    if ((val == -1 && PyErr_Occurred()) || cval != cval)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ float");
    }

    Py_XDECREF(packaged_args);

    // Set the radiusScaleFactor in the object.
    obj->data->SetRadiusScaleFactor(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetRadiusScaleFactor(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(double(obj->data->GetRadiusScaleFactor()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetRadiusFixed(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    float cval = float(val);

    if ((val == -1 && PyErr_Occurred()) || cval != cval)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ float");
    }

    Py_XDECREF(packaged_args);

    // Set the radiusFixed in the object.
    obj->data->SetRadiusFixed(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetRadiusFixed(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(double(obj->data->GetRadiusFixed()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetAtomSphereQuality(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 4)
    {
        std::stringstream ss;
        ss << "An invalid atomSphereQuality value was given." << std::endl;
        ss << "Valid values are in the range [0,3]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Low";
        ss << ", Medium";
        ss << ", High";
        ss << ", Super";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the atomSphereQuality in the object.
    obj->data->SetAtomSphereQuality(MoleculeAttributes::DetailLevel(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetAtomSphereQuality(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetAtomSphereQuality()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetBondCylinderQuality(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 4)
    {
        std::stringstream ss;
        ss << "An invalid bondCylinderQuality value was given." << std::endl;
        ss << "Valid values are in the range [0,3]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Low";
        ss << ", Medium";
        ss << ", High";
        ss << ", Super";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the bondCylinderQuality in the object.
    obj->data->SetBondCylinderQuality(MoleculeAttributes::DetailLevel(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetBondCylinderQuality(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetBondCylinderQuality()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetBondRadius(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    float cval = float(val);

    if ((val == -1 && PyErr_Occurred()) || cval != cval)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ float");
    }

    Py_XDECREF(packaged_args);

    // Set the bondRadius in the object.
    obj->data->SetBondRadius(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetBondRadius(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(double(obj->data->GetBondRadius()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetBondLineWidth(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || cval != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the bondLineWidth in the object.
    obj->data->SetBondLineWidth(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetBondLineWidth(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetBondLineWidth()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetElementColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the elementColorTable in the object.
    obj->data->SetElementColorTable(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetElementColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetElementColorTable().c_str());
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetResidueTypeColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the residueTypeColorTable in the object.
    obj->data->SetResidueTypeColorTable(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetResidueTypeColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetResidueTypeColorTable().c_str());
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetResidueSequenceColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the residueSequenceColorTable in the object.
    obj->data->SetResidueSequenceColorTable(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetResidueSequenceColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetResidueSequenceColorTable().c_str());
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetContinuousColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the continuousColorTable in the object.
    obj->data->SetContinuousColorTable(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetContinuousColorTable(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetContinuousColorTable().c_str());
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetLegendFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if ((val == -1 && PyErr_Occurred()) || cval != bool(val))
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the legendFlag in the object.
    obj->data->SetLegendFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetLegendFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetLegendFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetMinFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if ((val == -1 && PyErr_Occurred()) || cval != bool(val))
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the minFlag in the object.
    obj->data->SetMinFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetMinFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetMinFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetScalarMin(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    float cval = float(val);

    if ((val == -1 && PyErr_Occurred()) || cval != cval)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ float");
    }

    Py_XDECREF(packaged_args);

    // Set the scalarMin in the object.
    obj->data->SetScalarMin(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetScalarMin(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(double(obj->data->GetScalarMin()));
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetMaxFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if ((val == -1 && PyErr_Occurred()) || cval != bool(val))
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the maxFlag in the object.
    obj->data->SetMaxFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetMaxFlag(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetMaxFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
MoleculeAttributes_SetScalarMax(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    float cval = float(val);

    if ((val == -1 && PyErr_Occurred()) || cval != cval)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ float");
    }

    Py_XDECREF(packaged_args);

    // Set the scalarMax in the object.
    obj->data->SetScalarMax(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
MoleculeAttributes_GetScalarMax(PyObject *self, PyObject *args)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(double(obj->data->GetScalarMax()));
    return retval;
}



PyMethodDef PyMoleculeAttributes_methods[MOLECULEATTRIBUTES_NMETH] = {
    {"Notify", MoleculeAttributes_Notify, METH_VARARGS},
    {"SetDrawAtomsAs", MoleculeAttributes_SetDrawAtomsAs, METH_VARARGS},
    {"GetDrawAtomsAs", MoleculeAttributes_GetDrawAtomsAs, METH_VARARGS},
    {"SetScaleRadiusBy", MoleculeAttributes_SetScaleRadiusBy, METH_VARARGS},
    {"GetScaleRadiusBy", MoleculeAttributes_GetScaleRadiusBy, METH_VARARGS},
    {"SetDrawBondsAs", MoleculeAttributes_SetDrawBondsAs, METH_VARARGS},
    {"GetDrawBondsAs", MoleculeAttributes_GetDrawBondsAs, METH_VARARGS},
    {"SetColorBonds", MoleculeAttributes_SetColorBonds, METH_VARARGS},
    {"GetColorBonds", MoleculeAttributes_GetColorBonds, METH_VARARGS},
    {"SetBondSingleColor", MoleculeAttributes_SetBondSingleColor, METH_VARARGS},
    {"GetBondSingleColor", MoleculeAttributes_GetBondSingleColor, METH_VARARGS},
    {"SetRadiusVariable", MoleculeAttributes_SetRadiusVariable, METH_VARARGS},
    {"GetRadiusVariable", MoleculeAttributes_GetRadiusVariable, METH_VARARGS},
    {"SetRadiusScaleFactor", MoleculeAttributes_SetRadiusScaleFactor, METH_VARARGS},
    {"GetRadiusScaleFactor", MoleculeAttributes_GetRadiusScaleFactor, METH_VARARGS},
    {"SetRadiusFixed", MoleculeAttributes_SetRadiusFixed, METH_VARARGS},
    {"GetRadiusFixed", MoleculeAttributes_GetRadiusFixed, METH_VARARGS},
    {"SetAtomSphereQuality", MoleculeAttributes_SetAtomSphereQuality, METH_VARARGS},
    {"GetAtomSphereQuality", MoleculeAttributes_GetAtomSphereQuality, METH_VARARGS},
    {"SetBondCylinderQuality", MoleculeAttributes_SetBondCylinderQuality, METH_VARARGS},
    {"GetBondCylinderQuality", MoleculeAttributes_GetBondCylinderQuality, METH_VARARGS},
    {"SetBondRadius", MoleculeAttributes_SetBondRadius, METH_VARARGS},
    {"GetBondRadius", MoleculeAttributes_GetBondRadius, METH_VARARGS},
    {"SetBondLineWidth", MoleculeAttributes_SetBondLineWidth, METH_VARARGS},
    {"GetBondLineWidth", MoleculeAttributes_GetBondLineWidth, METH_VARARGS},
    {"SetElementColorTable", MoleculeAttributes_SetElementColorTable, METH_VARARGS},
    {"GetElementColorTable", MoleculeAttributes_GetElementColorTable, METH_VARARGS},
    {"SetResidueTypeColorTable", MoleculeAttributes_SetResidueTypeColorTable, METH_VARARGS},
    {"GetResidueTypeColorTable", MoleculeAttributes_GetResidueTypeColorTable, METH_VARARGS},
    {"SetResidueSequenceColorTable", MoleculeAttributes_SetResidueSequenceColorTable, METH_VARARGS},
    {"GetResidueSequenceColorTable", MoleculeAttributes_GetResidueSequenceColorTable, METH_VARARGS},
    {"SetContinuousColorTable", MoleculeAttributes_SetContinuousColorTable, METH_VARARGS},
    {"GetContinuousColorTable", MoleculeAttributes_GetContinuousColorTable, METH_VARARGS},
    {"SetLegendFlag", MoleculeAttributes_SetLegendFlag, METH_VARARGS},
    {"GetLegendFlag", MoleculeAttributes_GetLegendFlag, METH_VARARGS},
    {"SetMinFlag", MoleculeAttributes_SetMinFlag, METH_VARARGS},
    {"GetMinFlag", MoleculeAttributes_GetMinFlag, METH_VARARGS},
    {"SetScalarMin", MoleculeAttributes_SetScalarMin, METH_VARARGS},
    {"GetScalarMin", MoleculeAttributes_GetScalarMin, METH_VARARGS},
    {"SetMaxFlag", MoleculeAttributes_SetMaxFlag, METH_VARARGS},
    {"GetMaxFlag", MoleculeAttributes_GetMaxFlag, METH_VARARGS},
    {"SetScalarMax", MoleculeAttributes_SetScalarMax, METH_VARARGS},
    {"GetScalarMax", MoleculeAttributes_GetScalarMax, METH_VARARGS},
    {NULL, NULL}
};

//
// Type functions
//

static void
MoleculeAttributes_dealloc(PyObject *v)
{
   MoleculeAttributesObject *obj = (MoleculeAttributesObject *)v;
   if(obj->parent != 0)
       Py_DECREF(obj->parent);
   if(obj->owns)
       delete obj->data;
}

static PyObject *MoleculeAttributes_richcompare(PyObject *self, PyObject *other, int op);
PyObject *
PyMoleculeAttributes_getattr(PyObject *self, char *name)
{
    if(strcmp(name, "drawAtomsAs") == 0)
        return MoleculeAttributes_GetDrawAtomsAs(self, NULL);
    if(strcmp(name, "NoAtoms") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::NoAtoms));
    if(strcmp(name, "SphereAtoms") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::SphereAtoms));
    if(strcmp(name, "ImposterAtoms") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::ImposterAtoms));

    if(strcmp(name, "scaleRadiusBy") == 0)
        return MoleculeAttributes_GetScaleRadiusBy(self, NULL);
    if(strcmp(name, "Fixed") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Fixed));
    if(strcmp(name, "Covalent") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Covalent));
    if(strcmp(name, "Atomic") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Atomic));
    if(strcmp(name, "Variable") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Variable));

    if(strcmp(name, "drawBondsAs") == 0)
        return MoleculeAttributes_GetDrawBondsAs(self, NULL);
    if(strcmp(name, "NoBonds") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::NoBonds));
    if(strcmp(name, "LineBonds") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::LineBonds));
    if(strcmp(name, "CylinderBonds") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::CylinderBonds));

    if(strcmp(name, "colorBonds") == 0)
        return MoleculeAttributes_GetColorBonds(self, NULL);
    if(strcmp(name, "ColorByAtom") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::ColorByAtom));
    if(strcmp(name, "SingleColor") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::SingleColor));

    if(strcmp(name, "bondSingleColor") == 0)
        return MoleculeAttributes_GetBondSingleColor(self, NULL);
    if(strcmp(name, "radiusVariable") == 0)
        return MoleculeAttributes_GetRadiusVariable(self, NULL);
    if(strcmp(name, "radiusScaleFactor") == 0)
        return MoleculeAttributes_GetRadiusScaleFactor(self, NULL);
    if(strcmp(name, "radiusFixed") == 0)
        return MoleculeAttributes_GetRadiusFixed(self, NULL);
    if(strcmp(name, "atomSphereQuality") == 0)
        return MoleculeAttributes_GetAtomSphereQuality(self, NULL);
    if(strcmp(name, "Low") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Low));
    if(strcmp(name, "Medium") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Medium));
    if(strcmp(name, "High") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::High));
    if(strcmp(name, "Super") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Super));

    if(strcmp(name, "bondCylinderQuality") == 0)
        return MoleculeAttributes_GetBondCylinderQuality(self, NULL);
    if(strcmp(name, "Low") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Low));
    if(strcmp(name, "Medium") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Medium));
    if(strcmp(name, "High") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::High));
    if(strcmp(name, "Super") == 0)
        return PyInt_FromLong(long(MoleculeAttributes::Super));

    if(strcmp(name, "bondRadius") == 0)
        return MoleculeAttributes_GetBondRadius(self, NULL);
    if(strcmp(name, "bondLineWidth") == 0)
        return MoleculeAttributes_GetBondLineWidth(self, NULL);
    if(strcmp(name, "elementColorTable") == 0)
        return MoleculeAttributes_GetElementColorTable(self, NULL);
    if(strcmp(name, "residueTypeColorTable") == 0)
        return MoleculeAttributes_GetResidueTypeColorTable(self, NULL);
    if(strcmp(name, "residueSequenceColorTable") == 0)
        return MoleculeAttributes_GetResidueSequenceColorTable(self, NULL);
    if(strcmp(name, "continuousColorTable") == 0)
        return MoleculeAttributes_GetContinuousColorTable(self, NULL);
    if(strcmp(name, "legendFlag") == 0)
        return MoleculeAttributes_GetLegendFlag(self, NULL);
    if(strcmp(name, "minFlag") == 0)
        return MoleculeAttributes_GetMinFlag(self, NULL);
    if(strcmp(name, "scalarMin") == 0)
        return MoleculeAttributes_GetScalarMin(self, NULL);
    if(strcmp(name, "maxFlag") == 0)
        return MoleculeAttributes_GetMaxFlag(self, NULL);
    if(strcmp(name, "scalarMax") == 0)
        return MoleculeAttributes_GetScalarMax(self, NULL);

    // Try and handle legacy fields

    // bondLineStyle and it's possible enumerations
    bool bondLineStyleFound = false;
    if (strcmp(name, "bondLineStyle") == 0)
    {
        bondLineStyleFound = true;
    }
    else if (strcmp(name, "SOLID") == 0)
    {
        bondLineStyleFound = true;
    }
    else if (strcmp(name, "DASH") == 0)
    {
        bondLineStyleFound = true;
    }
    else if (strcmp(name, "DOT") == 0)
    {
        bondLineStyleFound = true;
    }
    else if (strcmp(name, "DOTDASH") == 0)
    {
        bondLineStyleFound = true;
    }
    if (bondLineStyleFound)
    {
        PyErr_WarnEx(NULL,
            "bondLineStyle is no longer a valid Molecule "
            "attribute.\nIt's value is being ignored, please remove "
            "it from your script.\n", 3);
        return PyInt_FromLong(0L);
    }
    return Py_FindMethod(PyMoleculeAttributes_methods, self, name);
}

int
PyMoleculeAttributes_setattr(PyObject *self, char *name, PyObject *args)
{
    PyObject NULL_PY_OBJ;
    PyObject *obj = &NULL_PY_OBJ;

    if(strcmp(name, "drawAtomsAs") == 0)
        obj = MoleculeAttributes_SetDrawAtomsAs(self, args);
    else if(strcmp(name, "scaleRadiusBy") == 0)
        obj = MoleculeAttributes_SetScaleRadiusBy(self, args);
    else if(strcmp(name, "drawBondsAs") == 0)
        obj = MoleculeAttributes_SetDrawBondsAs(self, args);
    else if(strcmp(name, "colorBonds") == 0)
        obj = MoleculeAttributes_SetColorBonds(self, args);
    else if(strcmp(name, "bondSingleColor") == 0)
        obj = MoleculeAttributes_SetBondSingleColor(self, args);
    else if(strcmp(name, "radiusVariable") == 0)
        obj = MoleculeAttributes_SetRadiusVariable(self, args);
    else if(strcmp(name, "radiusScaleFactor") == 0)
        obj = MoleculeAttributes_SetRadiusScaleFactor(self, args);
    else if(strcmp(name, "radiusFixed") == 0)
        obj = MoleculeAttributes_SetRadiusFixed(self, args);
    else if(strcmp(name, "atomSphereQuality") == 0)
        obj = MoleculeAttributes_SetAtomSphereQuality(self, args);
    else if(strcmp(name, "bondCylinderQuality") == 0)
        obj = MoleculeAttributes_SetBondCylinderQuality(self, args);
    else if(strcmp(name, "bondRadius") == 0)
        obj = MoleculeAttributes_SetBondRadius(self, args);
    else if(strcmp(name, "bondLineWidth") == 0)
        obj = MoleculeAttributes_SetBondLineWidth(self, args);
    else if(strcmp(name, "elementColorTable") == 0)
        obj = MoleculeAttributes_SetElementColorTable(self, args);
    else if(strcmp(name, "residueTypeColorTable") == 0)
        obj = MoleculeAttributes_SetResidueTypeColorTable(self, args);
    else if(strcmp(name, "residueSequenceColorTable") == 0)
        obj = MoleculeAttributes_SetResidueSequenceColorTable(self, args);
    else if(strcmp(name, "continuousColorTable") == 0)
        obj = MoleculeAttributes_SetContinuousColorTable(self, args);
    else if(strcmp(name, "legendFlag") == 0)
        obj = MoleculeAttributes_SetLegendFlag(self, args);
    else if(strcmp(name, "minFlag") == 0)
        obj = MoleculeAttributes_SetMinFlag(self, args);
    else if(strcmp(name, "scalarMin") == 0)
        obj = MoleculeAttributes_SetScalarMin(self, args);
    else if(strcmp(name, "maxFlag") == 0)
        obj = MoleculeAttributes_SetMaxFlag(self, args);
    else if(strcmp(name, "scalarMax") == 0)
        obj = MoleculeAttributes_SetScalarMax(self, args);

    // Try and handle legacy fields
    if(obj == &NULL_PY_OBJ)
    {
        if(strcmp(name, "bondLineStyle") == 0)
        {
            PyErr_WarnEx(NULL, "'bondLineStyle' is obsolete. It is being ignored.", 3);
            Py_INCREF(Py_None);
            obj = Py_None;
        }
    }
    if (obj != NULL && obj != &NULL_PY_OBJ)
        Py_DECREF(obj);

    if (obj == &NULL_PY_OBJ)
    {
        obj = NULL;
        PyErr_Format(PyExc_NameError, "name '%s' is not defined", name);
    }
    else if (obj == NULL && !PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "unknown problem with '%s'", name);

    return (obj != NULL) ? 0 : -1;
}

static int
MoleculeAttributes_print(PyObject *v, FILE *fp, int flags)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)v;
    fprintf(fp, "%s", PyMoleculeAttributes_ToString(obj->data, "").c_str());
    return 0;
}

PyObject *
MoleculeAttributes_str(PyObject *v)
{
    MoleculeAttributesObject *obj = (MoleculeAttributesObject *)v;
    return PyString_FromString(PyMoleculeAttributes_ToString(obj->data,"").c_str());
}

//
// The doc string for the class.
//
#if PY_MAJOR_VERSION > 2 || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION >= 5)
static const char *MoleculeAttributes_Purpose = "This class contains the plot attributes for the molecule plot.";
#else
static char *MoleculeAttributes_Purpose = "This class contains the plot attributes for the molecule plot.";
#endif

//
// Python Type Struct Def Macro from Py2and3Support.h
//
//         VISIT_PY_TYPE_OBJ( VPY_TYPE,
//                            VPY_NAME,
//                            VPY_OBJECT,
//                            VPY_DEALLOC,
//                            VPY_PRINT,
//                            VPY_GETATTR,
//                            VPY_SETATTR,
//                            VPY_STR,
//                            VPY_PURPOSE,
//                            VPY_RICHCOMP,
//                            VPY_AS_NUMBER)

//
// The type description structure
//

VISIT_PY_TYPE_OBJ(MoleculeAttributesType,         \
                  "MoleculeAttributes",           \
                  MoleculeAttributesObject,       \
                  MoleculeAttributes_dealloc,     \
                  MoleculeAttributes_print,       \
                  PyMoleculeAttributes_getattr,   \
                  PyMoleculeAttributes_setattr,   \
                  MoleculeAttributes_str,         \
                  MoleculeAttributes_Purpose,     \
                  MoleculeAttributes_richcompare, \
                  0); /* as_number*/

//
// Helper function for comparing.
//
static PyObject *
MoleculeAttributes_richcompare(PyObject *self, PyObject *other, int op)
{
    // only compare against the same type 
    if ( Py_TYPE(self) != &MoleculeAttributesType
         || Py_TYPE(other) != &MoleculeAttributesType)
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    PyObject *res = NULL;
    MoleculeAttributes *a = ((MoleculeAttributesObject *)self)->data;
    MoleculeAttributes *b = ((MoleculeAttributesObject *)other)->data;

    switch (op)
    {
       case Py_EQ:
           res = (*a == *b) ? Py_True : Py_False;
           break;
       case Py_NE:
           res = (*a != *b) ? Py_True : Py_False;
           break;
       default:
           res = Py_NotImplemented;
           break;
    }

    Py_INCREF(res);
    return res;
}

//
// Helper functions for object allocation.
//

static MoleculeAttributes *defaultAtts = 0;
static MoleculeAttributes *currentAtts = 0;

static PyObject *
NewMoleculeAttributes(int useCurrent)
{
    MoleculeAttributesObject *newObject;
    newObject = PyObject_NEW(MoleculeAttributesObject, &MoleculeAttributesType);
    if(newObject == NULL)
        return NULL;
    if(useCurrent && currentAtts != 0)
        newObject->data = new MoleculeAttributes(*currentAtts);
    else if(defaultAtts != 0)
        newObject->data = new MoleculeAttributes(*defaultAtts);
    else
        newObject->data = new MoleculeAttributes;
    newObject->owns = true;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

static PyObject *
WrapMoleculeAttributes(const MoleculeAttributes *attr)
{
    MoleculeAttributesObject *newObject;
    newObject = PyObject_NEW(MoleculeAttributesObject, &MoleculeAttributesType);
    if(newObject == NULL)
        return NULL;
    newObject->data = (MoleculeAttributes *)attr;
    newObject->owns = false;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

///////////////////////////////////////////////////////////////////////////////
//
// Interface that is exposed to the VisIt module.
//
///////////////////////////////////////////////////////////////////////////////

PyObject *
MoleculeAttributes_new(PyObject *self, PyObject *args)
{
    int useCurrent = 0;
    if (!PyArg_ParseTuple(args, "i", &useCurrent))
    {
        if (!PyArg_ParseTuple(args, ""))
            return NULL;
        else
            PyErr_Clear();
    }

    return (PyObject *)NewMoleculeAttributes(useCurrent);
}

//
// Plugin method table. These methods are added to the visitmodule's methods.
//
static PyMethodDef MoleculeAttributesMethods[] = {
    {"MoleculeAttributes", MoleculeAttributes_new, METH_VARARGS},
    {NULL,      NULL}        /* Sentinel */
};

static Observer *MoleculeAttributesObserver = 0;

std::string
PyMoleculeAttributes_GetLogString()
{
    std::string s("MoleculeAtts = MoleculeAttributes()\n");
    if(currentAtts != 0)
        s += PyMoleculeAttributes_ToString(currentAtts, "MoleculeAtts.");
    return s;
}

static void
PyMoleculeAttributes_CallLogRoutine(Subject *subj, void *data)
{
    typedef void (*logCallback)(const std::string &);
    logCallback cb = (logCallback)data;

    if(cb != 0)
    {
        std::string s("MoleculeAtts = MoleculeAttributes()\n");
        s += PyMoleculeAttributes_ToString(currentAtts, "MoleculeAtts.");
        cb(s);
    }
}

void
PyMoleculeAttributes_StartUp(MoleculeAttributes *subj, void *data)
{
    if(subj == 0)
        return;

    currentAtts = subj;
    PyMoleculeAttributes_SetDefaults(subj);

    //
    // Create the observer that will be notified when the attributes change.
    //
    if(MoleculeAttributesObserver == 0)
    {
        MoleculeAttributesObserver = new ObserverToCallback(subj,
            PyMoleculeAttributes_CallLogRoutine, (void *)data);
    }

}

void
PyMoleculeAttributes_CloseDown()
{
    delete defaultAtts;
    defaultAtts = 0;
    delete MoleculeAttributesObserver;
    MoleculeAttributesObserver = 0;
}

PyMethodDef *
PyMoleculeAttributes_GetMethodTable(int *nMethods)
{
    *nMethods = 1;
    return MoleculeAttributesMethods;
}

bool
PyMoleculeAttributes_Check(PyObject *obj)
{
    return (obj->ob_type == &MoleculeAttributesType);
}

MoleculeAttributes *
PyMoleculeAttributes_FromPyObject(PyObject *obj)
{
    MoleculeAttributesObject *obj2 = (MoleculeAttributesObject *)obj;
    return obj2->data;
}

PyObject *
PyMoleculeAttributes_New()
{
    return NewMoleculeAttributes(0);
}

PyObject *
PyMoleculeAttributes_Wrap(const MoleculeAttributes *attr)
{
    return WrapMoleculeAttributes(attr);
}

void
PyMoleculeAttributes_SetParent(PyObject *obj, PyObject *parent)
{
    MoleculeAttributesObject *obj2 = (MoleculeAttributesObject *)obj;
    obj2->parent = parent;
}

void
PyMoleculeAttributes_SetDefaults(const MoleculeAttributes *atts)
{
    if(defaultAtts)
        delete defaultAtts;

    defaultAtts = new MoleculeAttributes(*atts);
}

