/*****************************************************************************
*
* Copyright (c) 2000 - 2009, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400124
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                              avtKerbelFilter.C                            //
// ************************************************************************* //

#include <avtKerbelFilter.h>
#include <avtExtents.h>
#include <vtkPolyData.h>
#include <vtkDataSet.h>
#include <vtkIdList.h>
#include <vtkFloatArray.h>

// ****************************************************************************
//  Method: avtKerbelFilter constructor
//
//  Programmer: ahern -- generated by xml2info
//  Creation:   Tue Dec 18 16:23:56 PST 2001
//
// ****************************************************************************

avtKerbelFilter::avtKerbelFilter(const KerbelAttributes &a)
{
    atts = a;
}


// ****************************************************************************
//  Method: avtKerbelFilter destructor
//
//  Programmer: ahern -- generated by xml2info
//  Creation:   Tue Dec 18 16:23:56 PST 2001
//
// ****************************************************************************

avtKerbelFilter::~avtKerbelFilter()
{
}

// ****************************************************************************
//  Method: avtKerbelFilter::Execute
//
//  Purpose:
//      Does the actual VTK code to modify the dataset.
//
//  Arguments:
//
//  Programmer: ahern -- generated by xml2info
//  Creation:   Tue Dec 18 16:23:56 PST 2001
//
// ****************************************************************************
void
avtKerbelFilter::Execute(void)
{
    float *center = atts.GetCenter();
    float radius = atts.GetRadius();

    vtkPolyData *polydata = vtkPolyData::New();
        polydata->Allocate(6,6*4);

    vtkPoints *points = vtkPoints::New();
    vtkDataArray *scalars = vtkFloatArray::New();
    scalars->SetNumberOfTuples(8);

    // Define a unit box.
    float point[8][3] = {{-.5,-.5,-.5},   // 0
                         {-.5,-.5, .5},   // 1
                         {-.5, .5,-.5},   // 2
                         {-.5, .5, .5},   // 3
                         { .5,-.5,-.5},   // 4
                         { .5,-.5, .5},   // 5
                         { .5, .5,-.5},   // 6
                         { .5, .5, .5}};  // 7

    for(int i=0;i<8;i++)
    {
        for(int j=0;j<3;j++)
        {
            point[i][j] *= radius;
            point[i][j] += center[j];
        }
        points->InsertNextPoint(point[i]);
        float f = (float)i;
        scalars->SetTuple(i,&f);
    }
    polydata->GetPointData()->SetScalars(scalars);

    vtkIdList *quad = vtkIdList::New();
    quad->SetNumberOfIds(4);

    quad->SetId(0,0);
    quad->SetId(1,1);
    quad->SetId(2,3);
    quad->SetId(3,2);
    polydata->InsertNextCell(VTK_QUAD, quad);

    quad->SetId(0,0);
    quad->SetId(3,4);
    quad->SetId(2,5);
    quad->SetId(1,1);
    polydata->InsertNextCell(VTK_QUAD, quad);

    quad->SetId(0,1);
    quad->SetId(1,5);
    quad->SetId(2,7);
    quad->SetId(3,3);
    polydata->InsertNextCell(VTK_QUAD, quad);

    quad->SetId(0,0);
    quad->SetId(1,4);
    quad->SetId(2,6);
    quad->SetId(3,2);
    polydata->InsertNextCell(VTK_QUAD, quad);

    quad->SetId(0,2);
    quad->SetId(1,3);
    quad->SetId(2,7);
    quad->SetId(3,6);
    polydata->InsertNextCell(VTK_QUAD, quad);

    quad->SetId(0,4);
    quad->SetId(1,5);
    quad->SetId(2,7);
    quad->SetId(3,6);
    polydata->InsertNextCell(VTK_QUAD, quad);

    polydata->SetPoints(points);
    points->Delete();
    scalars->Delete();

    avtDataTree_p tree = new avtDataTree(polydata,0);
    SetOutputDataTree(tree);
}


// ****************************************************************************
//  Method: avtKerbelFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: ahern -- generated by xml2info
//  Creation:   Tue Dec 18 16:23:56 PST 2001
//
// ****************************************************************************

void
avtKerbelFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();

    outAtts.SetVariableDimension(1);
    outAtts.SetTopologicalDimension(2);
    outAtts.SetSpatialDimension(3);

    // Fix up the extents.  We need to totally erase what came from the database.
    avtExtents *ext= outAtts.GetTrueSpatialExtents();
    double newext[6] = {-.5, .5, -.5, .5, -.5, .5};
    float radius = atts.GetRadius();
    float *center = atts.GetCenter();
    for(int i=0;i<6;i++)
        newext[i] *= radius;
    for(int i=0;i<3;i++)
    {
        newext[i*2] += center[i];
        newext[i*2+1] += center[i];
    }
    ext->Set(newext);

}
