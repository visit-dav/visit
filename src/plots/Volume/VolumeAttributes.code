Code: SetFromNode
Prefix:
Postfix:
    if(colorControlPoints.GetNumControlPoints() < 2)
         SetDefaultColorControlPoints();

Target: xml2atts
Initialization: colorControlPoints
    SetDefaultColorControlPoints();

Initialization: freeformOpacity
    for(int i = 0; i < 256; ++i)
        freeformOpacity[i] = (unsigned char)i;

Target: xml2java
Initialization: freeformOpacity
    freeformOpacity = new byte[256];
        for(int i = 0; i < 256; ++i)
            freeformOpacity[i] = (byte)i;

Target: xml2atts
Function: ChangesRequireRecalculation
Declaration: bool ChangesRequireRecalculation(const VolumeAttributes &obj) const;
Definition:
// ****************************************************************************
//  Method:  VolumeAttributes::ChangesRequireRecalculation
//
//  Modifications:
//    Jeremy Meredith, Thu Oct  2 13:27:54 PDT 2003
//    Let changes in rendererType to force a recalculation.  This is 
//    appropriate since the 3D texturing renderer prefers different 
//    dimensions (i.e. powers of two) than the splatting renderer.
//
//    Hank Childs, Mon Dec 15 14:42:26 PST 2003
//    Recalculate if the smooth option was hit.
//
//    Hank Childs, Mon Nov 22 09:37:12 PST 2004
//    Recalculate if the ray trace button was hit.
//
//    Brad Whitlock, Wed Dec 15 09:31:24 PDT 2004
//    Removed doSoftware since it's now part of rendererType.
//
//    Kathleen Bonnell, Thu Mar  3 09:27:40 PST 2005
//    Recalculate if scaling or skewFactor changed for RayCasting.
//
// ****************************************************************************
bool
VolumeAttributes::ChangesRequireRecalculation(const VolumeAttributes &obj) const
{
    if (opacityVariable != obj.opacityVariable)
        return true;
    if (resampleTarget != obj.resampleTarget)
        return true;
    if (rendererType != obj.rendererType)
        return true;
    if (smoothData != obj.smoothData)
        return true;

    if (rendererType == VolumeAttributes::RayCasting)
    {
        if (scaling != obj.scaling)
            return true;
        if (scaling == VolumeAttributes::Skew && skewFactor != obj.skewFactor)
            return true;
    }

    return false;
}

Function: GradientWontChange
Declaration: bool GradientWontChange(const VolumeAttributes &obj) const;
Definition:
// ****************************************************************************
//  Method:  VolumeAttributes::GradientWontChange
//
//  Purpose:
//    Determines if the gradient can avoid being invalidated.
//
//  Arguments:
//    obj        the attributes to compare with
//
//  Programmer:  Jeremy Meredith
//  Creation:    September 30, 2003
//
//  Modifications:
//    Jeremy Meredith, Thu Oct  2 13:30:29 PDT 2003
//    Added rendererType and gradientType to the list of modifications
//    that require re-calculating the gradient.
//
// ****************************************************************************
bool
VolumeAttributes::GradientWontChange(const VolumeAttributes &obj) const
{
    int i;

    // Compare the freeformOpacity arrays.
    bool freeformOpacity_equal = true;
    for(i = 0; i < 256 && freeformOpacity_equal; ++i)
        freeformOpacity_equal = (freeformOpacity[i] == obj.freeformOpacity[i]);

    // Create the return value
    return ((freeformFlag         == obj.freeformFlag) &&
            (opacityControlPoints == obj.opacityControlPoints) &&
            (resampleTarget       == obj.resampleTarget) &&
            (opacityVariable      == obj.opacityVariable) &&
            freeformOpacity_equal &&
            (useColorVarMin       == obj.useColorVarMin) &&
            (colorVarMin          == obj.colorVarMin) &&
            (useColorVarMax       == obj.useColorVarMax) &&
            (colorVarMax          == obj.colorVarMax) &&
            (useOpacityVarMin     == obj.useOpacityVarMin) &&
            (opacityVarMin        == obj.opacityVarMin) &&
            (useOpacityVarMax     == obj.useOpacityVarMax) &&
            (opacityVarMax        == obj.opacityVarMax) &&
            (rendererType         == obj.rendererType) &&
            (gradientType         == obj.gradientType));
}

Function: GetTransferFunction
Declaration: void GetTransferFunction(unsigned char *rgba) const;
Definition:

// ****************************************************************************
// Method: VolumeAttributes::GetTransferFunction
//
// Purpose: 
//   This method calculates the transfer function and stores it in the rgba
//   array that is passed in.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 21 15:44:34 PST 2001
//
// Modifications:
//   Brad Whitlock, Thu Nov 21 15:05:25 PST 2002
//   GetColors has been moved to ColorControlPointList. I updated this code
//   to take that into account.
//
//   Jeremy Meredith, Thu Oct  2 13:29:40 PDT 2003
//   Made the method const.
//
// ****************************************************************************

void
VolumeAttributes::GetTransferFunction(unsigned char *rgba) const
{
    unsigned char rgb[256 * 3];
    unsigned char alphas[256];
    const unsigned char *a_ptr;

    // Figure out the colors
    colorControlPoints.GetColors(rgb, 256);
    // Figure out the opacities
    if(freeformFlag)
        a_ptr = freeformOpacity;
    else
    {
        GetGaussianOpacities(alphas);
        a_ptr = alphas;
    }

    unsigned char *rgb_ptr = rgb;
    unsigned char *rgba_ptr = rgba;
    for(int i = 0; i < 256; ++i)
    {
        // Copy the color
        *rgba_ptr++ = *rgb_ptr++;
        *rgba_ptr++ = *rgb_ptr++;
        *rgba_ptr++ = *rgb_ptr++;
        // Copy the alpha
        *rgba_ptr++ = *a_ptr++;
    }
}

Function: SetDefaultColorControlPoints
Declaration: void SetDefaultColorControlPoints();
Definition:
// ****************************************************************************
// Method: VolumeAttributes::SetDefaultColorControlPoints
//
// Purpose: 
//   This method replaces all of the color control points in the list with the
//   default color control points.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 21 15:44:34 PST 2001
//
// Modifications:
//   
// ****************************************************************************

void
VolumeAttributes::SetDefaultColorControlPoints()
{
    const float positions[] = {0., 0.25, 0.5, 0.75, 1.};
    const unsigned char colors[5][4] = {
        {0,   0,   255, 255},
        {0,   255, 255, 255},
        {0,   255, 0,   255},
        {255, 255, 0,   255},
        {255, 0,   0,   255}};

    // Clear the color control point list.
    colorControlPoints.ClearControlPoints();

    // Set the default control points in the color control point list.
    for(int i = 0; i < 5; ++i)
    {
        ColorControlPoint cpt;
        cpt.SetPosition(positions[i]);
        cpt.SetColors(colors[i]);
        colorControlPoints.AddControlPoints(cpt);
    }
    SelectColorControlPoints();
}

Function: GetGaussianOpacities
Declaration: void GetGaussianOpacities(unsigned char *alphas) const;
Definition:
// ****************************************************************************
// Method: VolumeAttributes::GetGaussianOpacities
//
// Purpose: 
//   This method calculates the opacities using the object's gaussian control
//   point list and stores the results in the alphas array that is passed in.
//
// Arguments:
//   alphas : The return array for the colors.
//
// Programmer: Brad Whitlock
// Creation:   Thu Sep 6 10:23:59 PDT 2001
//
// Modifications:
//    Jeremy Meredith, Thu Oct  2 13:30:00 PDT 2003
//    Made the method const.
//
// ****************************************************************************
#include <math.h>
void
VolumeAttributes::GetGaussianOpacities(unsigned char *alphas) const
{
    int i;
    float values[256];
    for (i=0; i<256; i++)
        values[i] = 0.;

    for (int p=0; p<opacityControlPoints.GetNumControlPoints(); p++)
    {
        const GaussianControlPoint &pt =
                               opacityControlPoints.GetControlPoints(p);
        float pos    = pt.GetX();
        float width  = pt.GetWidth();
        float height = pt.GetHeight();
        float xbias  = pt.GetXBias();
        float ybias  = pt.GetYBias();
        for (int i=0; i<256; i++)
        {
            float x = float(i)/float(256-1);

            // clamp non-zero values to pos +/- width
            if (x > pos+width || x < pos-width)
            {
                values[i] = (values[i] > 0.) ? values[i] : 0.;
                continue;
            }

            // non-zero width
            if (width == 0)
                width = .00001;

            // translate the original x to a new x based on the xbias
            float x0;
            if (xbias==0 || x == pos+xbias)
            {
                x0 = x;
            }
            else if (x > pos+xbias)
            {
                if (width == xbias)
                    x0 = pos;
                else
                    x0 = pos+(x-pos-xbias)*(width/(width-xbias));
            }
            else // (x < pos+xbias)
            {
                if (-width == xbias)
                    x0 = pos;
                else
                    x0 = pos-(x-pos-xbias)*(width/(width+xbias));
            }

            // center around 0 and normalize to -1,1
            float x1 = (x0-pos)/width;

            // do a linear interpolation between:
            //    a gaussian and a parabola        if 0<ybias<1
            //    a parabola and a step function   if 1<ybias<2
            float h0a = exp(-(4*x1*x1));
            float h0b = 1. - x1*x1;
            float h0c = 1.;
            float h1;
            if (ybias < 1)
                h1 = ybias*h0b + (1-ybias)*h0a;
            else
                h1 = (2-ybias)*h0b + (ybias-1)*h0c;
            float h2 = height * h1;
            
            // perform the MAX over different guassians, not the sum
            values[i] = (values[i] > h2) ? values[i] : h2;
        }
    }

    // Convert to unsigned char and return.
    for(i = 0; i < 256; ++i)
    {
        int tmp = int(values[i] * 255.);
        if(tmp < 0)
            tmp = 0;
        else if(tmp > 255)
            tmp = 255;
        alphas[i] = (unsigned char)(tmp);
    }
}

Function: GetOpacities
Declaration: void GetOpacities(unsigned char *alphas);
Definition:
void
VolumeAttributes::GetOpacities(unsigned char *alphas)
{
    if(freeformFlag)
    {
        for(int i = 0; i < 256; ++i)
            alphas[i] = freeformOpacity[i];
    }
    else
        GetGaussianOpacities(alphas);
}

Function: SetSmoothingFlag
Declaration: void SetSmoothingFlag(bool val);
Definition:
void
VolumeAttributes::SetSmoothingFlag(bool val)
{
    colorControlPoints.SetSmoothingFlag(val);
    Select(2, (void *)&colorControlPoints);
}

Function: GetSmoothingFlag
Declaration: bool GetSmoothingFlag() const;
Definition:
bool
VolumeAttributes::GetSmoothingFlag() const
{
    return colorControlPoints.GetSmoothingFlag();
}

Function: SetEqualSpacingFlag
Declaration: void SetEqualSpacingFlag(bool val);
Definition:
void
VolumeAttributes::SetEqualSpacingFlag(bool val)
{
    colorControlPoints.SetEqualSpacingFlag(val);
    Select(2, (void *)&colorControlPoints);
}

Function: GetEqualSpacingFlag
Declaration: bool GetEqualSpacingFlag() const;
Definition:
bool
VolumeAttributes::GetEqualSpacingFlag() const
{
    return colorControlPoints.GetEqualSpacingFlag();
}

Function: AnyNonTransferFunctionMembersAreDifferent
Declaration: bool AnyNonTransferFunctionMembersAreDifferent(const VolumeAttributes &) const;
Definition:
// ****************************************************************************
// Method: VolumeAttributes::AnyNonTransferFunctionMembersAreDifferent
//
// Purpose: 
//   This method returns true if any non-transfer function members are different.
//
// Programmer: Brad Whitlock
// Creation:   Thu Sep 6 10:23:59 PDT 2001
//
// Modifications:
//
// ****************************************************************************

bool
VolumeAttributes::AnyNonTransferFunctionMembersAreDifferent(const VolumeAttributes &rhs) const
{
    bool same = true;
    for(int i = 0; i < NumAttributes(); ++i)
    {
        // Skip any of the transfer function members.
        if(i == ID_colorControlPoints || 
           i == ID_opacityAttenuation || 
           i == ID_freeformFlag || 
           i == ID_opacityControlPoints ||
           i == ID_freeformOpacity)
        {
            continue;
        }
        same &= FieldsEqual(i, &rhs);
    }

    return !same;
}

Target: xml2python
Function: VolumeAttributes_SetFreeformOpacity
Declaration: VolumeAttributes_SetFreeformOpacity
Definition:
// ****************************************************************************
//  Modifications:
//    Kathleen Bonnell, Fri Oct 14 08:24:34 PDT 2005
//    Added custom code, to parse different types of args:
//    (int index, int val) -- sets the opacity value at the specified index
//    (list or tuple object) --  as long as it is numeric and has length
//    of 256, will set the opacity values to the values in the list or tuple.
//
// ****************************************************************************

static PyObject *
VolumeAttributes_SetFreeformOpacity(PyObject *self, PyObject *args)
{
//
// THIS METHOD IS CUSTOM CODED!!!!!!.
//
    VolumeAttributesObject *obj = (VolumeAttributesObject *)self;

    unsigned char *cvals = obj->data->GetFreeformOpacity();
    int opacity, index;
    if(PyArg_ParseTuple(args, "ii", &index, &opacity))
    {
        if(index >= 0 && index < 256)
        {
            if(opacity < 0) opacity = 0;
            if(opacity > 255) opacity = 255;
            cvals[index] = (unsigned char)(opacity);
        }
    }
    else
    {
        PyObject     *tuple;
        if(!PyArg_ParseTuple(args, "O", &tuple))
        {
            return NULL;
        }
        if(PyTuple_Check(tuple) || PyList_Check(tuple))
        {
            if(PySequence_Size(tuple) != 256)
                return NULL;

            PyErr_Clear();
            for(int i = 0; i < PySequence_Size(tuple); ++i)
            {
                int c;
                PyObject *item = PySequence_GetItem(tuple, i);
                if(PyInt_Check(item))
                    c = int(PyInt_AS_LONG(item));
                else if(PyFloat_Check(item))
                    c = int(PyFloat_AS_DOUBLE(item));
                else if(PyLong_Check(item))
                    c = int(PyLong_AsDouble(item));
                else
                    c = 0;
                Py_DECREF(item);
                if(c < 0) c = 0;
                if(c > 255) c = 255;
                cvals[i] = (unsigned char)(c);
           }
        }
        else
            return NULL;
    }

    // Mark the freeformOpacity in the object as modified.
    obj->data->SelectFreeformOpacity();

    Py_INCREF(Py_None);
    return Py_None;
}

