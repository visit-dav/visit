/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                              avtPoincareFilter.C                              //
// ************************************************************************* //

#include <avtPoincareFilter.h>

#include <vtkDataSet.h>
#include <vtkSlicer.h>
#include <vtkPolyData.h>
#include <vtkTubeFilter.h>
#include <vtkPolyLine.h>
#include <vtkStructuredGrid.h>
#include <vtkCleanPolyData.h>

#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkAppendPolyData.h>
#include <vtkSphereSource.h>
#include <vtkFloatArray.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>

#define SIGN(x) ((x) < 0.0 ? -1 : 1)


// ****************************************************************************
//  Method: avtPoincareFilter constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPoincareFilter::avtPoincareFilter() :
  showStreamlines(true),
  showPoints(true),
  override( 0 ),
  hitrate( 0.90 ),
  maxToroidalWinding( 30 ),
  color(3),
  showIslands(0),
  overlaps(1),
  is_curvemesh(0),
  adjust_plane(-1)
{
}


// ****************************************************************************
//  Method: avtPoincareFilter destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPoincareFilter::~avtPoincareFilter()
{
}

static vtkPolyData *
CreateSphere(float val, double rad, double pt[3])
{
    // Create the sphere polydata.
    vtkSphereSource *sphere = vtkSphereSource::New();
    sphere->SetCenter(pt[0], pt[1], pt[2]);
    sphere->SetRadius(rad);
    sphere->SetLatLongTessellation(1);
    sphere->SetPhiResolution(8);
    sphere->SetThetaResolution(8);
    vtkPolyData *sphereData = sphere->GetOutput();
    sphereData->Update();

    // Set the sphere's scalar to val.
    vtkFloatArray *arr = vtkFloatArray::New();
    int npts = sphereData->GetNumberOfPoints();
    arr->SetNumberOfTuples(npts);
    for (int i = 0; i < npts; ++i)
        arr->SetTuple1(i, val);
    arr->SetName("colorVar");
    sphereData->GetPointData()->SetScalars(arr);
    arr->Delete();

    sphereData->Register(NULL);
    sphere->Delete();

    return sphereData;
}


// ****************************************************************************
//  Method: avtPoincareFilter::SetClipPlane
//
//  Purpose:
//      Sets the definition of the clip plane.
//
//  Arguments:
//      pt        Point on plane.
//      norm      Plane Normal.
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::SetClipPlane( const double *pt, const double *norm )
{
  unsigned int nplanes = 6;

  for( unsigned int i=0; i<nplanes; i++ )
    planes.push_back(2.0 * M_PI * (double) i / (double) nplanes );

//  planes.push_back( 0 );

//     clipPlanePt.x = pt[0];
//     clipPlanePt.y = pt[1];
//     clipPlanePt.z = pt[2];
    
//     clipPlaneN.x = norm[0];
//     clipPlaneN.y = norm[1];
//     clipPlaneN.z = norm[2];
//     clipPlaneN.normalize();
}

// ****************************************************************************
//  Method: avtPoincareFilter::PreExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PreExecute(void)
{
    avtStreamlineFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::PostExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PostExecute(void)
{
    avtStreamlineFilter::PostExecute();

    double range[2];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetDataExtents(ds, range, "colorVar");

    avtExtents *e;
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeTrueDataExtents();
    e->Merge(range);
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeCurrentDataExtents();
    e->Merge(range);
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateStreamlineOutput
//
//  Purpose:
//      Create the VTK poly data output from the streamline.
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Dec  23 12:51:29 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::CreateStreamlineOutput( vector<avtStreamlineWrapper *> &streamlines)
{
    cout<<"There are have "<<streamlines.size()<<" streamlines.\n";
    GeneratePoincarePoints(streamlines);
    ClassifyPoincarePoints();
    
    avtDataTree *dt = CreatePoincareOutput();
    SetOutputDataTree(dt);

#if 0
    cout<<"CreateStreamlineOutput()\n";
    cout<<"streamlines sz= "<<streamlines.size()<<endl;
    debug1 << "::CreateStreamlineOutput " << streamlines.size() << endl;

    bool doTubes = true;
    radius = 0.025;
    if (streamlines.size() == 0)
        return;

    // Join all the streamline pieces.
    vtkAppendPolyData *append = vtkAppendPolyData::New();

    for (int i = 0; i < streamlines.size(); i++)
    {
        avtStreamlineWrapper *slSeg = (avtStreamlineWrapper *) streamlines[i];
        vector<float> thetas;
        vtkPolyData *pd = slSeg->GetVTKPolyData(3, 
                                                STREAMLINE_COLOR_SOLID,
                                                STREAMLINE_DISPLAY_LINES,
                                                thetas);
        cout<<"GetPolyData: "<<pd<<endl;
        debug1<<"Done w/ GetVTKPolyData\n";
        
        if (pd == NULL)
            continue;

        vtkCleanPolyData *clean = vtkCleanPolyData::New();
        clean->SetInput(pd);
        clean->Update();
        pd->Delete();

        pd = clean->GetOutput();
        pd->Register(NULL);
        pd->SetSource(NULL);
        clean->Delete();

        if (showStart)
        {
            float val = pd->GetPointData()->GetScalars()->GetTuple1(0);
            double *pt = NULL;
            if (slSeg->dir == avtStreamlineWrapper::FWD)
                pt = pd->GetPoints()->GetPoint(0);
            else
                pt = pd->GetPoints()->GetPoint(
                                       pd->GetPoints()->GetNumberOfPoints()-1);
            vtkPolyData *ball = StartSphere(val, pt);
            
            append->AddInput(ball);
            ball->Delete();
        }
        
        if (doTubes)
        {
            cout<<"Do tubeys"<<endl;
            vtkTubeFilter* tubes = vtkTubeFilter::New();
            tubes->SetRadius(radius);
            tubes->SetNumberOfSides(8);
            tubes->SetRadiusFactor(2.);
            tubes->SetCapping(1);
            tubes->ReleaseDataFlagOn();
            tubes->SetInput(pd);
            tubes->Update();
            
            pd->Delete();
            pd = tubes->GetOutput();
            pd->Register(NULL);
            pd->SetSource(NULL);
            tubes->Delete();
            
            append->AddInput(pd);
            cout<<"DONE Do tubeys"<<endl<<endl;
        }
        /*
        else if (doRibbons)
        {
            vtkRibbonFilter* ribbons = vtkRibbonFilter::New();
            ribbons->SetWidth(radius);

            int nPts = pd->GetPointData()->GetNumberOfTuples();
            
            vtkIdList *ids = vtkIdList::New();
            vtkPoints *pts = vtkPoints::New();
            vtkCellArray *lines = vtkCellArray::New();
            for (int i = 0; i < nPts; i++)
            {
                vtkIdType id = pts->InsertNextPoint(
                                                 pd->GetPoints()->GetPoint(i));
                ids->InsertNextId(id);
            }

            lines->InsertNextCell(ids);
            //Create normals, initialize them. (Remove the init later....)
            vtkFloatArray *normals = vtkFloatArray::New();
            normals->SetNumberOfComponents(3);
            normals->SetNumberOfTuples(nPts);

            vtkPolyLine *lineNormalGenerator = vtkPolyLine::New();
            lineNormalGenerator->GenerateSlidingNormals(pts, lines, normals);
            
            //Now, rotate the normals according to the vorticity..
            //double normal[3], local1[3], local2[3],length,costheta, sintheta;
            double normal[3], tan[3], biNormal[3], p0[3], p1[3];
            for (int i = 0; i < nPts; i++)
            {
                double theta = thetas[i];

                pts->GetPoint(i, p0);
                if (i < nPts-1)
                    pts->GetPoint(i+1, p1);
                else
                {
                    pts->GetPoint(i-1, p0);
                    pts->GetPoint(i, p1);
                }
                for (int j = 0; j < 3; j++)
                    tan[j] = p1[j]-p0[j];

                //cout<<i<<": p= ["<<p0[0]<<" "<<p0[1]<<" "<<p0[2]<<"] ["
                //    <<p1[0]<<" "<<p1[1]<<" "<<p1[2]<<"]\n";
                //cout<<i<<": T=["<<tan[0]<<" "<<tan[1]<<" "<<tan[2]<<"]\n\n";
                normals->GetTuple(i, normal);
                vtkMath::Normalize(tan);
                vtkMath::Normalize(normal);

                vtkMath::Cross(normal, tan, biNormal);
                double cosTheta = cos(theta);
                double sinTheta = sin(theta);
                for (int j = 0; j < 3; j++)
                    normal[j] = cosTheta*normal[j] + sinTheta*biNormal[j];
                
                //cout<<i<<": T=["<<tan[0]<<" "<<tan[1]<<" "<<tan[2]<<"] N= ["
                //    <<normal[0]<<" "<<normal[1]<<" "<<normal[2]<<endl;
                normals->SetTuple(i,normal);
            }

            ids->Delete();
            pts->Delete();
            lines->Delete();
            
            pd->GetPointData()->SetNormals(normals);
            normals->Delete();
            lineNormalGenerator->Delete();

            ribbons->SetInput(pd);
            ribbons->Update();
            
            pd->Delete();
            pd = ribbons->GetOutput();
            pd->Register(NULL);
            pd->SetSource(NULL);

            ribbons->Delete();
            append->AddInput(pd);
        }
        */
        else
        {
            append->AddInput(pd);
            pd->Delete();
        }
    }

    cout<<"Get ready to set some output!\n";
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();

    //ReportStatistics(streamlines);
    cout<<"SetOutputDataTree= "<<outPD<<endl;
    avtDataTree *dt = new avtDataTree(outPD, 0);
    SetOutputDataTree(dt);
#endif
}

// ****************************************************************************
//  Method: avtPoincareFilter::ModifyContract
//
//  Purpose:
//      
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:15:45 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

avtContract_p
avtPoincareFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    avtDataRequest_p out_dr = NULL;

    if (strcmp(in_dr->GetVariable(), "colorVar") == 0)
    {
        // The avtPoincarePlot requested "colorVar", so remove that from the
        // contract now.
        out_dr = new avtDataRequest(in_dr,in_dr->GetOriginalVariable());
    }
    
    avtContract_p out_contract;
    if ( *out_dr )
        out_contract = new avtContract(in_contract, out_dr);
    else
        out_contract = new avtContract(in_contract);

    return avtStreamlineFilter::ModifyContract(out_contract);
}

// ****************************************************************************
//  Method: avtPoincareFilter::Execute
//
//  Purpose:
//      Calculate poincare points.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::Execute()
{
    // Execute the baseclass.
    avtStreamlineFilter::Execute();

    /*

    //Get streamline points. This will be replaced w/ Hank's changes.
    vtkPolyData *inPD = (vtkPolyData *)inDS;
    std::vector<int> slInfo;
    slFilter->GetSLInfo( slInfo );

    terminatedSTreamlines.resize(slInfo.size());
    int cnt = 0;
    for (int i = 0; i < slInfo.size(); i++)
    {
        for (int j = 0; j < slInfo[i]; j++)
        {
            double *polyPt = inPD->GetPoints()->GetPoint(cnt);
            avtVector pt(polyPt[0], polyPt[1], polyPt[2]);
            streamlinePts[i].push_back(pt);
            //cout<<cnt<<": "<<pt<<endl;
            cnt++;
        }
    }

    GeneratePoincarePoints();
    ClassifyPoincarePoints();
    vtkPolyData *poincPD = CreatePoincareOutput();
   
    //Add streamlines to output, if requested.
    if (showStreamlines)
    {
        vtkAppendPolyData *append = vtkAppendPolyData::New();
        append->AddInput(inPD);
        append->AddInput(poincPD);
        append->Update();

        inPD->Delete();
        
        poincPD = append->GetOutput();
        poincPD->Register(NULL);
        poincPD->SetSource(NULL);
        append->Delete();
    }

    return poincPD;
    */
}


// ****************************************************************************
//  Method: avtPoincareFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::UpdateDataObjectInfo(void)
{ 
    avtStreamlineFilter::UpdateDataObjectInfo();

    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    atts.SetTopologicalDimension(1);
    if (! atts.ValidVariable("colorVar"))
    {
        atts.AddVariable("colorVar");
        atts.SetActiveVariable("colorVar");
        atts.SetVariableDimension(1);
    }
}



// ****************************************************************************
//  Method: avtPoincareFilter::GeneratePoincarePoints
//
//  Purpose:
//      Create poincare points from the streamlines.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::GeneratePoincarePoints( vector<avtStreamlineWrapper*> &streamlines)
{
  poincarePts.resize(streamlines.size());

  for ( int i=0; i<streamlines.size(); ++i )
  {
    avtStreamline *sl = streamlines[i]->sl;
    
    avtStreamline::iterator siter = sl->begin();

    while( siter != sl->end() )
    {
      avtVector pt;
      pt.x = (*siter)->front()[0];
      pt.y = (*siter)->front()[1];
      pt.z = (*siter)->front()[2];

      poincarePts[i].push_back(pt);

      ++siter;
    }

    cout << i << ": There are " << poincarePts[i].size() << " fieldline points\n";
  }
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyPoincarePoints
//
//  Purpose:
//      Classify the poincare points.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::ClassifyPoincarePoints()
{
    for ( int i = 0; i < poincarePts.size(); i++ )
    {
      FieldlineInfo fi = FLlib.fieldlineProperties( poincarePts[i],
                                                    override,
                                                    maxToroidalWinding,
                                                    hitrate );

      poincareClassification.push_back( fi );

      double safetyFactor;
      
      if ( fi.poloidalWinding > 0 )
        safetyFactor = (double) fi.toroidalWinding / (double) fi.poloidalWinding;
      else
        safetyFactor = 0;

      cout << i
            << "  ptCnt = " << poincarePts[i].size()
            << "  toroidal windings = " <<  fi.toroidalWinding
            << "  poloiddal windings = " << fi.poloidalWinding
            << "  islands = " << fi.islands
            << "  safety factor = " << safetyFactor
            << endl;
    }

    cout << endl;
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreatePoincareOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtDataTree *
avtPoincareFilter::CreatePoincareOutput()
{
  avtDataTree *dt = new avtDataTree();

  for ( int i=0; i<poincarePts.size(); ++i )
  {
    FieldlineType type           = poincareClassification[i].type;
    unsigned int toroidalWinding = poincareClassification[i].toroidalWinding;
    unsigned int poloidalWinding = poincareClassification[i].poloidalWinding;
    unsigned int islands         = poincareClassification[i].islands;
    unsigned int skip            = poincareClassification[i].skip;
    unsigned int nnodes          = (unsigned int) poincareClassification[i].nnodes;

    bool completeIslands = true;

    // If toroidal winding is zero, skip it.
    if( toroidalWinding == 0 ) 
    {
      std::cerr << i << " SKIPPING TOROIDALWINDING OF 0" << std::endl;

      std::pair< unsigned int, unsigned int > topo( 0, 0 );
//      topology.push_back(topo);

      continue;
    }

    else if( type == UNKNOWN || type == CHAOTIC ) 
    {
      std::cerr << i << " SKIPPING " << std::endl;

      std::pair< unsigned int, unsigned int > topo( 0, 0 );
//      topology.push_back(topo);

      continue;
    }

    // Get the direction of the streamline toroidalWinding.
    Point lastPt = poincarePts[i][0];
    Point currPt = poincarePts[i][1];

    bool CCWstreamline = (atan2( lastPt.y, lastPt.x ) <
                          atan2( currPt.y, currPt.x ));


    // Put all of the points into the bins for each plane.
    std::vector< std::vector< std::vector < Point > > > puncturePts;

    puncturePts.resize( planes.size() );

    unsigned int startIndex = 0;

    for( unsigned int p=0; p<planes.size(); ++p ) 
    {
      Vector planeN;
      Vector planePt(0,0,0);

      // Go through the planes in the same direction as the streamline.
      if( CCWstreamline )
      {
        planeN = Vector( cos(planes[p]),
                         sin(planes[p]),
                         0 );
      }
      else
      {
        planeN = Vector( cos(planes[planes.size()-1-p]),
                         sin(planes[planes.size()-1-p]),
                         0 );
      }

      // Set up the plane equation.
      double plane[4];
      
      plane[0] = planeN.x;
      plane[1] = planeN.y;
      plane[2] = planeN.z;
      plane[3] = planePt.dot(planeN);

//      cerr << "Plane " << p << " is " << plane << endl;
        
//    cerr << "Starting new streamline binning " << c << endl;

      puncturePts[p].resize( toroidalWinding );
      int bin = 0;

      // So to get the winding groups consistant start examining the
      // streamline in the same place for each plane.
      Vector lastPt, currPt( poincarePts[i][startIndex] );
      double lastDist, currDist = planeN.dot( currPt ) - plane[3];

      for( unsigned int j=startIndex+1; j<poincarePts[i].size(); ++j )
      {
        lastPt = currPt;
        currPt = Vector(poincarePts[i][j]);

        lastDist = currDist;
        currDist = Dot( planeN, currPt ) - plane[3];

        // First look at only points that intersect the plane.
        if( SIGN(lastDist) != SIGN(currDist) ) 
        {
          Vector dir(currPt-lastPt);

          double dot = Dot(planeN, dir);

          // If the segment is in the same direction as the plane then
          // find where it intersects the plane.
          if( dot > 0.0 )
          {
            // So to get the winding groups consistant start examining
            // the streamline in the same place for each plane so
            // store the index of the first puncture point.
            if( p == 0 && puncturePts[p][bin].size() == 0 )
              startIndex = j - 1;

            Vector w = lastPt - planePt;

            double t = -Dot(planeN, w ) / dot;

            Point point = Point(lastPt + dir * t);
          
            puncturePts[p][bin].push_back( point );
            
            bin = (bin + 1) % toroidalWinding;

          }
        }
      }
    }
    
    bool VALID = true;

    // Sanity check
    for( unsigned int p=0; p<planes.size(); ++p ) 
    {
      for( unsigned int j=0; j<toroidalWinding; ++j ) 
      {
        if( nnodes > puncturePts[p][j].size() )
          nnodes = puncturePts[p][j].size();

        if( puncturePts[p][j].size() < 1 ) 
        {
          std::cerr << "INVALID - Plane " << p
               << " bin  " << j
               << " number of points " << puncturePts[p][j].size()
               << std::endl;
          VALID = false;

          return NULL;
        }
      }
    }



   // Get the rest of the info only from the phi = zero plane.
    unsigned int p;

    if( CCWstreamline )
      p = 0;
    else
      p = planes.size()-1;

    // Get the centroid of each toroidal winding group and all
    // puncture points.
//    Vector globalCentroid(0,0,0);
    std::vector< Vector > localCentroids;
    std::vector< Vector > localSeparatrices[2];

    localCentroids.resize(toroidalWinding);
    localSeparatrices[0].resize(toroidalWinding);
    localSeparatrices[1].resize(toroidalWinding);

    for( unsigned int j=0; j<toroidalWinding; ++j ) 
    {
      localCentroids[j] = Vector(0,0,0);
      
      for( unsigned int k=0; k<puncturePts[p][j].size(); ++k ) 
        localCentroids[j] += (Vector) puncturePts[p][j][k];

      if( puncturePts[p][j].size() ) 
      {
        localCentroids[j] /= (double) puncturePts[p][j].size();

//        globalCentroid += localCentroids[j];
      }
    }

//    globalCentroid /= toroidalWinding;

    // Get the direction of the points within a group.
//    Vector v0 = (Vector) puncturePts[p][0][0] - globalCentroid;
//    Vector v1 = (Vector) puncturePts[p][0][1] - globalCentroid;

//    bool groupCCW = (FLlib.ccw( v0, v1 ) == 1);
//    cerr << 0.0<< "  " << groupCCW << endl;

    if( type == ISLAND_CHAIN ) 
    {
      for( unsigned int j=0; j<toroidalWinding; ++j ) 
      {
        unsigned int startIndex;
        unsigned int middleIndex;
        unsigned int stopIndex;
        unsigned int nodes;
        
        Vector localCentroid;

        unsigned int turns =
          FLlib.islandProperties( puncturePts[p][j], localCentroid,
              startIndex, middleIndex, stopIndex, nodes );
        
//      cerr << "Island " << i  << "   "
//           << "Turns " << turns  << "   "
//           << "nodes " << nodes  << "   "
//           << "Indexes "
//           << startIndex  << "  "
//           << middleIndex << "  "
//           << stopIndex   << endl;


//      if( turns < 3 )
//      completeIslands = false;

        if( turns >= 2 ) 
        {
//        localSeparatrices[0][j] = (Vector) puncturePts[p][j][startIndex];
//        localSeparatrices[1][j] = (Vector) puncturePts[p][j][middleIndex];
        }

        if( turns == 3 ) 
        {
          unsigned int index0 = (middleIndex - startIndex ) / 2;
          unsigned int index1 = (  stopIndex - middleIndex) / 2;

          //      cerr << "Indexes mid " << nodes << " nodes "
          //           << "  " << ( startIndex + index0)%nodes 
          //           << "  " << (middleIndex - index0)%nodes
          //           << "  " << (middleIndex + index1)%nodes
          //           << "  " << (  stopIndex - index1)%nodes << endl;

          localCentroids[j] =
            ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
              (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] +

              (Vector) puncturePts[p][j][(middleIndex + index1)%nodes] + 
              (Vector) puncturePts[p][j][(  stopIndex - index1)%nodes] ) / 4.0;
        } 
        else if( turns == 2 ) 
        {
          unsigned int index0 = (middleIndex - startIndex ) / 2;

          //      cerr << "Indexes mid " << nodes << " nodes "
          //           << "  " << ( startIndex + index0)%nodes 
          //           << "  " << (middleIndex - index0)%nodes
          //           << "  " << (middleIndex + index1)%nodes
          //           << "  " << (  stopIndex - index1)%nodes << endl;

          localCentroids[j] =
            ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
              (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] ) / 2.0;

        } 
        else if( turns == 1 ) 
        {
          unsigned int index0 = (stopIndex - startIndex ) / 2;

          //      cerr << "Indexes mid " << nodes << " nodes "
          //           << "  " << ( startIndex + index0)%nodes 
          //           << "  " << (middleIndex - index0)%nodes
          //           << "  " << (middleIndex + index1)%nodes
          //           << "  " << (  stopIndex - index1)%nodes << endl;

          localCentroids[j] =
            ( (Vector) puncturePts[p][j][(startIndex + index0)%nodes] + 
              (Vector) puncturePts[p][j][( stopIndex - index0)%nodes] ) / 2.0;
        }
        
//      // Get the principal axes of the island.
//      Vector localCentroid(0,0,0);

//      for( unsigned int k=0; k<puncturePts[p][j].size(); ++k )
//        localCentroid += (Vector) puncturePts[p][j][k];

//      localCentroid /= (float) puncturePts[p][j].size();

//      float Ixx = 0.0;
//      float Ixz = 0.0;
//      float Izz = 0.0;

//      double maxDist = 0;

//      for( unsigned int k=0; k<puncturePts[p][j].size(); k++ ) {

//        Vector vec = (Vector) puncturePts[p][j][k] - localCentroid;

//        if( maxDist < vec.length() )
//          maxDist = vec.length();

//        Ixx += vec.z()*vec.z();
//        Ixz -= vec.x()*vec.z();
//        Izz += vec.x()*vec.x();
//      }

//      float alpha = atan( 2.0 * Ixz / (Ixx - Izz) ) / 2.0;

// //       cerr << "PRINCIPAL AXES " << alpha * 180.0 / M_PI << "    "
// //      << Ixx + Ixz * sin(alpha       )/cos(alpha       ) << "    "
// //      << Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) << endl;

//      if( Ixx + Ixz * sin(alpha       )/cos(alpha       ) >
//          Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) )
//        localCentroid += Vector(  cos(alpha), 0, sin(alpha) ) * maxDist;
//      else
//        localCentroid += Vector( -sin(alpha), 0, cos(alpha) ) * maxDist;

//      localCentroids[j] = localCentroid;

      }
    }  // if( type == ISLAND_CHAIN )

    for( unsigned int p=0; p<planes.size(); p++ ) 
    {
      if( type != RATIONAL ) 
      {
        if( overlaps == 1 || overlaps == 3 )
          FLlib.removeOverlap( puncturePts[p], nnodes,
                               toroidalWinding, poloidalWinding,
                               skip, islands );
        if( overlaps == 2 )
          FLlib.mergeOverlap( puncturePts[p], nnodes,
                              toroidalWinding, poloidalWinding,
                              skip, islands );
        else if( overlaps == 3 )
          FLlib.smoothCurve( puncturePts[p], nnodes,
                             toroidalWinding, poloidalWinding,
                             skip, islands );
      }

      bool VALID = true;

      // Sanity check
      for( unsigned int j=0; j<toroidalWinding; ++j ) 
      {
        if( nnodes > puncturePts[p][j].size() )
          nnodes = puncturePts[p][j].size();

        if( puncturePts[p][j].size() < 1 ) 
        {
          std::cerr << "INVALID - Plane " << p
               << " bin  " << j
               << " number of points " << puncturePts[p][j].size()
               << std::endl;

          VALID = false;

          return NULL;
        }
          
//      cerr << "Surface " << i
//           << " plane " << p
//           << " bin " << j
//           << " base number of nodes " << nnodes
//           << " number of points " << puncturePts[p][j].size()
//           << endl;
      }
    }

    std::cerr << "Surface " << i << " is a " << type << "  "
       << toroidalWinding << ":" << poloidalWinding << " surface ("
       << (double) toroidalWinding / (double) poloidalWinding << ") ";
    
    if( type == ISLAND_CHAIN ) 
      std::cerr << "that contains " << islands << " islands"
        << (completeIslands ? " (Complete)" : "");
    
    std::cerr << " and has " << nnodes << " nodes" << std::endl;
        
    if( type == ISLAND_CHAIN && islands != toroidalWinding ) 
    {
      std::cerr << "WARNING - The island count does not match the toroidalWinding count" 
        << std::endl;
    }
    
    // Record the topology.
    std::pair< unsigned int, unsigned int >
      topo( toroidalWinding, poloidalWinding );

//    topology.push_back(topo);


    if( !showIslands || (showIslands && islands) ) 
    {
      double color_value = 0;

      if( color == 1 )
        color_value = i;
      else if( color == 6 )
        color_value = toroidalWinding;
      else if( color == 7 )
        color_value = poloidalWinding;
      else if( color == 8 )
        color_value = (double) toroidalWinding / (double) poloidalWinding;

       // Currently the surface mesh is a structquad so set the dims - it
      // really should be and unstructured surface so multiple surface
      // can be generated.
      if( is_curvemesh ) 
      {
        loadCurve( dt, puncturePts, color, color_value );
      }
      else
      {
//      VMesh::dimension_type dims(2);
        
//      dims[0] = nnodes;
//      dims[1] = (planes.size()+1) * toroidalWinding;
        
//      MeshHandle new_mesh = CreateMesh(fo,dims);
//      ofield_h = CreateField(fo,new_mesh);
        
//      std::cerr << "Creating a surface of "
//                << dims[0] << "  " << dims[1] << std::endl;

        loadSurface( dt, puncturePts, nnodes, color, color_value,
                     (islands?true:false));
      }
    }

    if (showStreamlines)
    {
      vtkPoints *points = vtkPoints::New();
      vtkCellArray *cells = vtkCellArray::New();
      vtkFloatArray *scalars = vtkFloatArray::New();
      
      cells->InsertNextCell(poincarePts[i].size());
      scalars->Allocate(poincarePts[i].size());
      
      for ( int j=0; j<poincarePts[i].size(); ++j )
      {
          points->InsertPoint(j,
          poincarePts[i][j].x,
          poincarePts[i][j].y,
          poincarePts[i][j].z);

          cells->InsertCellPoint(j);
          scalars->InsertTuple1(j, (double) i);
      }

      // Create a new VTK polyline.
      vtkPolyData *pd = vtkPolyData::New();
      pd->SetPoints(points);
      pd->SetLines(cells);
      scalars->SetName("colorVar");
      pd->GetPointData()->SetScalars(scalars);
      
      pd->Register(NULL);
      pd->SetSource(NULL);

      dt->Merge( new avtDataTree(pd, 0) );

      points->Delete();
      cells->Delete();
      scalars->Delete();
    }
  }

  std::cerr << std::endl << std::endl
            << "count " << poincarePts.size()
//          << "  safetyFactorConsistant  " << safetyFactorConsistant
//          << "  poloidalPeriodicyMatch  " << poloidalPeriodicyMatch
//          << "  poloidalPeriodicyMismatch  " << poloidalPeriodicyMismatch
            << std::endl << std::endl;

  return dt;
}


void
avtPoincareFilter::
loadCurve( avtDataTree *dt,
           vector< vector < vector < Point > > > &nodes,
           unsigned int color,
           double color_value ) 
{
  vtkAppendPolyData *append = vtkAppendPolyData::New();

  // Loop through each plane
  for( unsigned int p=0; p<nodes.size(); ++p ) 
  {
    if( color == 3 )
      color_value = p;

    // Loop through each toroidial group
    for( unsigned int j=0; j<nodes[p].size(); ++j ) 
    {
      //Create groups that represent the toroidial groups.
      vtkPoints *points = vtkPoints::New();
      vtkCellArray *cells = vtkCellArray::New();
      vtkFloatArray *scalars = vtkFloatArray::New();
        
      cells->InsertNextCell(nodes[p][j].size());
      scalars->Allocate(nodes[p][j].size());

      if( color == 4 )
        color_value = j;

      // Loop through each point in toroidial group
      for( unsigned int i=0; i<nodes[p][j].size(); ++i ) 
      {
        points->InsertPoint(i, nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z);
        cells->InsertCellPoint(i);

        if( color == 2 )
          scalars->InsertTuple1(i, (double) (i*nodes[p][j].size()+j));
        else if( color == 5 )
          scalars->InsertTuple1(i, (double) i);
        else
          scalars->InsertTuple1(i, (double) color_value);
      }

      // Create a new VTK polyline.
      vtkPolyData *pd = vtkPolyData::New();
      pd->SetPoints(points);
      pd->SetLines(cells);
      scalars->SetName("colorVar");
      pd->GetPointData()->SetScalars(scalars);
        
      append->AddInput(pd);
        
      points->Delete();
      cells->Delete();
      scalars->Delete();       
    }
  }

  if (showPoints)
  {
    for( unsigned int p=0; p<nodes.size(); ++p ) 
    {
      if( color == 3 )
        color_value = p;

      // Loop through each toroidial group
      for( unsigned int j=0; j<nodes[p].size(); ++j ) 
      {
        if( color == 4 )
          color_value = j;

        // Loop through each point in toroidial group
        for( unsigned int i=1; i<nodes[p][j].size(); ++i )
        {      
          double pt[3] = { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
            
          double rad = 0.005;
            
          vtkPolyData *ball = CreateSphere(-1.0, rad, pt);

//        if( color == 2 )
//          scalars->InsertTuple1(i, (double) (i*nodes[p][j].size()+j));
//        else if( color == 5 )
//          scalars->InsertTuple1(i, (double) i);
//        else
//          scalars->InsertTuple1(i, (double) color_value);

          append->AddInput(ball);
          ball->Delete();
        }
      }
    }
  }

  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  dt->Merge( new avtDataTree(outPD, 0) );
}


void
avtPoincareFilter::
loadSurface( avtDataTree *dt,
             vector< vector < vector < Point > > > &nodes,
             unsigned int nnodes,
             unsigned int color,
             double color_value,
             bool closed_surface) 
{

//  loadCurve( dt, nodes, color, color_value );

  int dims[3];
   
  dims[0] = nnodes + (closed_surface?1:0);
  dims[1] = nodes.size(); // * nodes[0].size() + 1;
  dims[2] = 1;
  
  vtkPoints *points = vtkPoints::New();
  vtkFloatArray *scalars = vtkFloatArray::New();
  
  points->SetNumberOfPoints(dims[0]*dims[1]);
  scalars->Allocate(dims[0]*dims[1]);

  float *points_ptr = (float *) points->GetVoidPointer(0);
  
  // Loop through each toroidial group
//  for( unsigned int j=0; j<nodes[0].size(); ++j )
  for( unsigned int j=0; j<1; ++j )
  {
    if( color == 4 )
      color_value = j;

    // Loop through each plane.
    for( unsigned int p=0; p<nodes.size(); ++p ) 
    {
      // Normally each toroidial group can be displayed in the order
      // received. Except for the last plane where it needs to be
      // adjusted by one group. That is if the streamline started in
      // the "correct" place. This is not always the case so it may be
      // necessary to adjust the winding group location by one.
      unsigned int k, offset = 0;
      
      if( p == adjust_plane )
      {
        k = (j-1 + nodes[p].size()) % nodes[p].size();
        offset = (closed_surface?1:0);
      }
      else
      {
        k = j;
        offset = 0;
      }

      unsigned int jj = nodes.size() * j + p;

      if( color == 3 )
        color_value = jj; //p;

      // Loop through each point in toroidial group. Note the first
      // and last point are the same so that the surface is cylinder.
      for(unsigned int i=0; i<nnodes+(closed_surface?1:0); ++i )
      {
        unsigned int n1 = jj * (nnodes) + i;

        points_ptr[n1*3+0] = nodes[p][k][(i+offset) % nnodes].x;
        points_ptr[n1*3+1] = nodes[p][k][(i+offset) % nnodes].y;
        points_ptr[n1*3+2] = nodes[p][k][(i+offset) % nnodes].z;

        if( color == 2 )
          scalars->InsertTuple1(n1, (double) (i*nodes[p].size()+k));
        else if( color == 5 )
          scalars->InsertTuple1(n1, (double) i);
        else
          scalars->InsertTuple1(n1, (double) color_value);
      }
    }
  }

  /*
  // Add in the first toroidal group from the first plane to complete
  // the torus.
  unsigned int j = 0;

  if( color == 4 )
    color_value = j;

  // Add in the first toroidal group from the first plane to complete
  // the torus.
  unsigned int p = 0;

  // Normally each toroidial group can be displayed in the order
  // received. Except for the last plane where it needs to be
  // adjusted by one group. That is if the streamline started in
  // the "correct" place. This is not always the case so it may be
  // necessary to adjust the winding group location by one.
  unsigned int k, offset = 0;

  if( p == adjust_plane )
  {
    k = (j-1 + nodes[p].size()) % nodes[p].size();
//    offset = (closed_surface?1:0);
  }
  else
  {
    k = j;
    offset = 0;
  }

  unsigned int jj = nodes.size() * nodes[p].size();

  if( color == 3 )
    color_value = jj; //p;

  // Loop through each point in toroidial group. Note the first
  // and last point are the same so that the surface is cylinder.
  for(unsigned int i=0; i<nnodes+(closed_surface?1:0); ++i )
  {
    unsigned int n1 = jj * (nnodes+1) + i;

    points_ptr[n1*3+0] = nodes[p][k][(i+offset) % nnodes].x;
    points_ptr[n1*3+1] = nodes[p][k][(i+offset) % nnodes].y;
    points_ptr[n1*3+2] = nodes[p][k][(i+offset) % nnodes].z;

    if( color == 2 )
      scalars->InsertTuple1(n1, (double) (i*nodes[p].size()+k));
    else if( color == 5 )
      scalars->InsertTuple1(n1, (double) i);
    else
      scalars->InsertTuple1(n1, (double) color_value);
  }
  */
  // Create a new VTK structure grid.
   vtkStructuredGrid *sgrid = vtkStructuredGrid::New();
   sgrid->SetDimensions(dims);
   sgrid->SetPoints(points);
   scalars->SetName("colorVar");
   sgrid->GetPointData()->SetScalars(scalars);

   dt->Merge( new avtDataTree(sgrid, 0) );
        
   points->Delete();
   scalars->Delete();       
}
