/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             Avtpoincarefilter.C                           //
// ************************************************************************* //

#include <avtPoincareFilter.h>

#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkSlicer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatasetExaminer.h>
#include <avtExtents.h>
#include <avtPoincareIC.h>
#include <utility>

#include "FieldlineAnalyzerLib.h"

//#define RATIONAL_SURFACE 1

#ifdef RATIONAL_SURFACE
#include "RationalSurfaceLib.h"
#endif


#ifdef STRAIGHTLINE_SKELETON
#include "skelet.h"
#endif

#define SIGN(x) ((x) < 0.0 ? -1 : 1)

static const int DATA_None = 0;
static const int DATA_SafetyFactorQ = 1;
static const int DATA_SafetyFactorP = 2;
static const int DATA_SafetyFactorQ_NotP = 3;
static const int DATA_SafetyFactorP_NotQ = 4;
static const int DATA_ToroidalWindings = 5;
static const int DATA_PoloidalWindingsQ = 6;
static const int DATA_PoloidalWindingsP = 7;
static const int DATA_FieldlineOrder = 8;
static const int DATA_PointOrder = 9;
static const int DATA_PlaneOrder = 10;
static const int DATA_WindingGroupOrder = 11;
static const int DATA_WindingPointOrder = 12;
static const int DATA_WindingPointOrderModulo = 13;

// ****************************************************************************
//  Method: CreateSphere
//
//  Programmer:
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//   Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
//   Create a vertex instead of a sphere.
//   
//    Dave Pugmire, Mon Jul 12 15:34:29 EDT 2010
//    Remove rad argument.
//    
// ****************************************************************************

static vtkPolyData *
CreateSphere(float val, double p[3])
{
    vtkPoints *pt = vtkPoints::New();
    pt->SetNumberOfPoints(1);
    pt->SetPoint(0, p[0], p[1], p[2]);
    
    vtkPolyData *point = vtkPolyData::New();
    point->SetPoints(pt);
    pt->Delete();

    vtkIdType ids[1] = {0};
    point->Allocate(1);
    point->InsertNextCell(VTK_VERTEX, 1, ids);

    vtkFloatArray *arr = vtkFloatArray::New();
    arr->SetName("colorVar");
    arr->SetNumberOfTuples(1);
    arr->SetTuple1(0, val);
    point->GetPointData()->SetScalars(arr);
    arr->Delete();

    return point;
}


// ****************************************************************************
//  Method: avtPoincareFilter constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//    Dave Pugmire, Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver,
//    Allen Sanderson's new code.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    Add variables for dataValue var.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    Changed color to dataValue
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Initialize points.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
// ****************************************************************************

avtPoincareFilter::avtPoincareFilter() :
    maximumToroidalWinding( 0 ),
    overrideToroidalWinding( 0 ),
    overridePoloidalWinding( 0 ),
    windingPairConfidence( 0.90 ),
    rationalSurfaceFactor( 0.10 ),
    adjust_plane(-1),
    overlaps(1),

    is_curvemesh(1),
    dataValue(DATA_SafetyFactorQ),

    showOPoints( false ),
    OPointMaxIterations(2),
    XPointMaxIterations(2),
    showIslands( false ),
    showLines( true ),
    showPoints( false ),
    verboseFlag( true ),
    pointScale(1)
{
    planes.resize(1);
    planes[0] = 0;
    intersectObj = NULL;
    maxIntersections = 0;
}


// ****************************************************************************
//  Method: avtPoincareFilter destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Zero out streaminePts.
//
// ****************************************************************************

avtPoincareFilter::~avtPoincareFilter()
{
    if (intersectObj)
        intersectObj->Delete();
}

// ****************************************************************************
//  Method: avtPoincareFilter::PreExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PreExecute(void)
{
    avtStreamlineFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::PostExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
// ****************************************************************************

void
avtPoincareFilter::PostExecute(void)
{
    avtStreamlineFilter::PostExecute();
    
    double range[2];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetDataExtents(ds, range, "colorVar");

    avtExtents *e;
    e = GetOutput()->GetInfo().GetAttributes().GetThisProcsOriginalDataExtents();
    e->Merge(range);
    e = GetOutput()->GetInfo().GetAttributes().GetThisProcsActualDataExtents();
    e->Merge(range);
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve and set its properties.
//
//  Programmer: Christoph Garth
//  Creation:   Thu July 15, 2010
//
//  Modifications:
//
//    Hank Childs, Fri Oct  8 23:30:27 PDT 2010
//    Create PoincareICs, not StateRecorderICs.
//
// ****************************************************************************

avtIntegralCurve *
avtPoincareFilter::CreateIntegralCurve( const avtIVPSolver* model,
                                        avtIntegralCurve::Direction dir,
                                        const double& t_start,
                                        const avtVector &p_start,
                                        const avtVector &v_start,
                                        long ID ) 
{
    // need at least these three attributes
    unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;

    avtPoincareIC *rv = new avtPoincareIC( attr, model, dir, 
                                           t_start, p_start, v_start, ID );

    if (intersectObj)
        rv->SetIntersectionCriteria(intersectObj, maxIntersections);

    return rv;
}

// ****************************************************************************
//  Method: avtPoincareFilter::GetStreamlinePoints
//
//  Purpose:
//      Gets the points from the streamline and changes them in to a Vector.
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Dec  23 12:51:29 EST 2008
//
//  Modifications:
//
//    Hank Childs, Fri Jun  4 19:58:30 CDT 2010
//    Use avtStreamlines, not avtStreamlineWrappers.
//
// ****************************************************************************

void
avtPoincareFilter::GetIntegralCurvePoints(std::vector<avtIntegralCurve *> &ics)
{
    for ( int i=0; i<ics.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];

        // Get all of the points from the streamline which are stored
        // as an array and move them into a vector for easier
        // manipulation by the analsysi code.
        poincare_ic->points.resize( poincare_ic->GetNumberOfSamples() );

        for( size_t p=0; p<poincare_ic->points.size(); ++p )
          poincare_ic->points[p] = poincare_ic->GetSample( p ).position;
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::Execute
//
//  Purpose:
//      Calculate poincare points.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Re-organization. GetStreamlinePoints removed.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
// ****************************************************************************

void
avtPoincareFilter::Execute()
{
    avtStreamlineFilter::Execute();

    std::vector<avtIntegralCurve *> ics;
    GetTerminatedIntegralCurves(ics);

    avtDataTree *dt = new avtDataTree();
    
    CreatePoincareOutput( dt, ics );
#ifdef RATIONAL_SURFACE
    CreateRationalOutput( dt, ics );
#endif
    SetOutputDataTree(dt);
}

// ****************************************************************************
//  Method: avtPoincareFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Dave Pugmire
//  Creation:   Mon Aug 17 08:30:06 EDT 2009
//
//  Modifications:
//
//    Hank Childs, Sun Jun  6 11:53:33 CDT 2010
//    Use new names that have integral curves instead of fieldlines.
//
// ****************************************************************************

bool
avtPoincareFilter::ContinueExecute()
{
    debug5 << "Continue execute " << std::endl;

    std::vector<avtIntegralCurve *> ics;
    
    GetTerminatedIntegralCurves(ics);
    GetIntegralCurvePoints(ics);

    if (analysis && (! ClassifyStreamlines(ics) || ! ClassifyRationals(ics)))
    {
      std::vector< int > ids_to_delete;

      // Because points are added the size will change so get the
      // inital size so that we do try to dao anything with the new
      // seeds.
      unsigned int nics = ics.size();

      for ( int i=0; i<nics; ++i )
      {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];
        FieldlineProperties &properties = poincare_ic->properties;

#ifdef STRAIGHTLINE_SKELETON

        // For Island Chains add in the O Points.
        if( showOPoints &&

            (properties.type == FieldlineProperties::ISLAND_PRIMARY_CHAIN ||
             properties.type == FieldlineProperties::ISLAND_SECONDARY_CHAIN ||
             properties.type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS &&
             properties.type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS &&
             properties.analysisState == FieldlineProperties::ADD_O_POINTS &&

            !(poincare_ic->properties.OPoints.empty()) )
        {
          // Change the state of the properties to complete now that
          // the seed point has been stripped off.
          poincare_ic->properties.analysisState =
            FieldlineProperties::TERMINATED;

          if( properties.iteration < OPointMaxIterations )
          {
            std::vector<avtIntegralCurve *> new_ics;
            avtVector vec(0,0,0);

            AddSeedPoint( properties.OPoints[0], vec, new_ics );
          
            for( unsigned int j=0; j<new_ics.size(); ++j )
            {
              std::cerr << "New island seed ids " << new_ics[j]->id << "  ";

              avtPoincareIC * seed_poincare_ic = (avtPoincareIC *) new_ics[j];

              // Transfer and update properties.
              seed_poincare_ic->properties = properties;
              
              seed_poincare_ic->properties.analysisState =
                FieldlineProperties::UNKNOWN_STATE;
              
              seed_poincare_ic->properties.source =
                FieldlineProperties::ISLAND_PRIMARY_CHAIN;
              
              seed_poincare_ic->properties.iteration = properties.iteration + 1;
            }

            std::cerr << std::endl;
          }

          // The source was an island_chain which meant the seed was
          // an intermediate seed so delete it.
          if( properties.source == FieldlineProperties::ISLAND_PRIMARY_CHAIN )
          {
            std::cerr << "Deleting old O Point seed "
                      << poincare_ic->id << std::endl;
            
            ids_to_delete.push_back( poincare_ic->id );
          }
        }
#endif

#ifdef RATIONAL_SURFACE
        /////////////////////////
        // Begin Rational Search
        /////////////////////////
        if( properties.analysisMethod  == FieldlineProperties::DEFAULT_METHOD &&
            properties.type            == FieldlineProperties::RATIONAL &&
            (properties.analysisState  == FieldlineProperties::COMPLETED ||
             properties.analysisState  == FieldlineProperties::TERMINATED) )
        {
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "Found a rational." << std::endl;

          // Update rational's properties
          // The analysis method is Rational_Search for most of the process.

          // The Original_Rational is kept around mainly to help with
          // organization.
          poincare_ic->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
          poincare_ic->properties.searchState  = FieldlineProperties::ORIGINAL_RATIONAL;

          // The Original_Rational has a list of each of the
          // seeds. These get swapped out with better curves over the
          // course of the minimization and this list is used to draw
          // the final curves
          poincare_ic->properties.children = new std::vector< avtPoincareIC* >();
                
          // Initialize seeds
          // Each Seed is marked as a Searching_seed
          // a_IC and c_IC are used later
          // For now, we just create each seed and wait for them to come back
          std::vector<avtVector> seeds = getSeeds(poincare_ic);

          for( unsigned int s=0; s<seeds.size(); ++s )
          {
            if (RATIONAL_DEBUG)
              std::cerr << __LINE__ << "  " << seeds[s] << "  "
                        << "New seed planted";

            std::vector<avtIntegralCurve *> new_ics;
            avtVector vec(0,0,0);

            AddSeedPoint( seeds[s], vec, new_ics );
          
            for( unsigned int j=0; j<new_ics.size(); ++j )
            {
              avtPoincareIC *seed = (avtPoincareIC *) new_ics[j];

              // Transfer and update properties.
              seed->properties = properties;
              seed->source_ic = poincare_ic;
              seed->properties.iteration = properties.iteration + 1;
              seed->maxIntersections = 6 * properties.toroidalWinding + 2;
              seed->properties.type = FieldlineProperties::IRRATIONAL;
              seed->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              seed->properties.searchState = FieldlineProperties::SEARCHING_SEED;
              seed->a_IC = NULL;
              seed->c_IC = NULL;

              poincare_ic->properties.children->push_back(seed);

              if (RATIONAL_DEBUG)
                std::cerr << " with ID :" << seed->id;
            }

            if (RATIONAL_DEBUG)
              std::cerr << std::endl;
          }
        }

        /////////////////////////////////////////////
        // Grab each seed generated by the original_rational
        /////////////////////////////////////////////
        if( properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH &&
            properties.searchState    == FieldlineProperties::SEARCHING_SEED )
        {
          int toroidalWinding    = properties.toroidalWinding;
          int windingGroupOffset = properties.windingGroupOffset;

          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "Found seed  " << poincare_ic->id
                      << std::endl;

          Vector xzplane(0,1,0);
          FieldlineLib fieldlib;

          std::vector<avtVector> seed_puncture_points;
          fieldlib.getPunctures( poincare_ic->points, xzplane,
                                 seed_puncture_points);

          std::vector<avtVector> orig_puncture_points;
          fieldlib.getPunctures( poincare_ic->source_ic->points, xzplane,
                                 orig_puncture_points);
                
          // Find distance between puncture points
          unsigned int index = 0;

          float maxOrigDist =
            rationalDistance( orig_puncture_points, toroidalWinding, index );
          
          float maxDist =
            rationalDistance( seed_puncture_points, toroidalWinding, index );
          
          if (RATIONAL_DEBUG)
          {
            std::cerr << __LINE__ << "  "
                      << "Max original dist: " << maxOrigDist << "  "
                      << "Max distance: " << maxDist << "  "
                      << std::endl;
          }

          // If the puncture pts line up as well as or better than the
          // original rational, it should be good enough.
          if( maxDist < maxOrigDist )
          {
            properties.searchState = FieldlineProperties::WAITING_SEED;
          }
          // Otherwise, we need to minimize
          else
          {
            avtVector maxPuncture = seed_puncture_points[index];
                
            // To start, we need to locate the enclosing points from
            // the original rational
            avtVector origPt1;
            avtVector origPt2;

            for( unsigned int j=0; j<toroidalWinding; ++j )
            {
              avtVector origPt1 = orig_puncture_points[j];
              avtVector origPt2 = orig_puncture_points[(j + windingGroupOffset) % toroidalWinding];
                        
              // Is poincare_ic in region bounded by origPt1 & origPt2?
              // Doing this by searching the area in the rectangle defined by two points
              if ((origPt1[0] < maxPuncture[0] && origPt2[0] > maxPuncture[0] || 
                   origPt1[0] > maxPuncture[0] && origPt2[0] < maxPuncture[0]) && 
                  (origPt1[2] < maxPuncture[2] && origPt2[2] > maxPuncture[2] || 
                   origPt1[2] > maxPuncture[2] && origPt2[2] < maxPuncture[2]))
              {
                // Line equation for the two original punctures
                float m = (origPt2[2]-origPt1[2]) / (origPt2[0]-origPt1[0]);
                float b = origPt2[2] - m * origPt2[0];
                            
                // Perpendicular line passing through current seed
                float m_perp = -1.0f / m;
                float b_perp = maxPuncture[2] - m_perp * maxPuncture[0];
                            
                // Intersection point (Becomes 'c' )
                float x = (b - b_perp) / (m_perp - m);
                float z = m * x + b;
                avtVector intersectionPoint=avtVector(x,0,z);
                            
                // Split the difference as a best first guess (Becomes 'b')
                float new_x = (maxPuncture[0] + x) / 2.0f;
                float new_z = (maxPuncture[2] + z) / 2.0f;
                avtVector newPoint = avtVector(new_x, 0, new_z);

                if (RATIONAL_DEBUG)
                {
                  std::cerr << __LINE__ << "  " << "A point: "
                            << maxPuncture << std::endl;
                  std::cerr << __LINE__ << "  " << "new B point: "
                            << newPoint << std::endl;
                  std::cerr << __LINE__ << "  " << "new C point: "
                            << intersectionPoint << std::endl;
                }

                avtVector zeroVec = avtVector(0,0,0);

                poincare_ic->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                poincare_ic->properties.searchState = FieldlineProperties::MINIMIZING_A;
                          

                //*******************
                // To start the minimization, we need to define three points
                // If the middle point ('b) is already lower than the
                // other two we can go straight to
                // minimization. Otherwise, we have to bracket the
                // minimum.  First things first, setup the two new
                // points (b & c) and send them off
                          

                // Setup 'c' (use the intersection just calculated)
                std::vector<avtIntegralCurve *> new_ics;
                AddSeedPoint( intersectionPoint, zeroVec, new_ics );
                avtPoincareIC *seed_c;

                for( unsigned int k=0; k<new_ics.size(); k++ )
                {
                  seed_c = (avtPoincareIC *) new_ics[k];
                
                  // Transfer and update properties.
                  seed_c->properties = properties;
                  seed_c->source_ic = poincare_ic;
                  seed_c->properties.iteration = properties.iteration + 1;
                  seed_c->maxIntersections = 8 * properties.toroidalWinding + 2;
                  seed_c->properties.type = FieldlineProperties::IRRATIONAL;
                  seed_c->properties.analysisMethod =
                    FieldlineProperties::RATIONAL_SEARCH;
                  seed_c->properties.searchState =
                    FieldlineProperties::MINIMIZING_C;

                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  "
                              << "Start Minimizing, New C ID :"
                              << seed_c->id << std::endl;
                }

                // Setup 'b' (use the new pont just calculated)
                std::vector<avtIntegralCurve *> new_ics_2;
                AddSeedPoint( newPoint, zeroVec, new_ics_2 );
                avtPoincareIC *seed_b;

                for( unsigned int k=0; k<new_ics.size(); k++ )
                {
                  seed_b = (avtPoincareIC *) new_ics_2[k];

                  // Transfer and update properties.
                  seed_b->properties = properties;
                  seed_b->source_ic = poincare_ic;
                  seed_b->properties.iteration = properties.iteration + 1;
                  seed_b->maxIntersections = 8 * properties.toroidalWinding + 2;
                  seed_b->properties.type = FieldlineProperties::IRRATIONAL;
                  seed_b->properties.analysisMethod =
                    FieldlineProperties::RATIONAL_SEARCH;
                  seed_b->properties.searchState =
                    FieldlineProperties::MINIMIZING_B;
                  seed_b->a_bound_dist = maxDist;

                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  "
                              << "Creating B with original pts: "
                              << origPt1 <<" , "<< origPt2 << std::endl;

                  seed_b->properties.rationalPt1 = origPt1;
                  seed_b->properties.rationalPt2 = origPt2;

                  seed_b->a_IC = poincare_ic;
                  seed_b->c_IC = seed_c;

                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "New B ID :"
                              << seed_b->id << std::endl;
                }
              }
            }
          }          
        }
        else if (properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH &&
                 properties.searchState == FieldlineProperties::MINIMIZING_A)
        {
          // Intentionally empty
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "minimizing A" << std::endl;
        }
        else if (properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH &&
                 properties.searchState == FieldlineProperties::MINIMIZING_C)
        {
          // Intentionally empty
          if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "minimizing C" << std::endl;
        }
        else if ( properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH &&
                  properties.searchState == FieldlineProperties::MINIMIZING_B &&
                  poincare_ic->a_IC != NULL && poincare_ic->c_IC != NULL)
        {
          // Base the 1st stage of the minimization on 'b', since it
          // should be near our minimum
          avtPoincareIC *seed = poincare_ic->source_ic;
          if (seed->properties.searchState == FieldlineProperties::ORIGINAL_RATIONAL)
            seed = poincare_ic;
         
          std::vector<avtPoincareIC *> *children = seed->source_ic->properties.children;
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "Found MINIMIZING_B" << std::endl;

          Vector xzplane(0,1,0);
          FieldlineLib fieldlib;
          avtPoincareIC *_a = poincare_ic->a_IC;
          avtPoincareIC *_b = poincare_ic;
          avtPoincareIC *_c = poincare_ic->c_IC;        
          std::vector<avtVector> a_puncturePoints;
          std::vector<avtVector> b_puncturePoints;
          std::vector<avtVector> c_puncturePoints;
          fieldlib.getPunctures(_a->points,xzplane,a_puncturePoints);
          fieldlib.getPunctures(_b->points,xzplane,b_puncturePoints);
          fieldlib.getPunctures(_c->points,xzplane,c_puncturePoints);
                
          // Need to get distances for each a, b & c
          int a_i = findMinimizationIndex(a_puncturePoints,
                                          _b->properties.rationalPt1,
                                          _b->properties.rationalPt2);
          int b_i = findMinimizationIndex(b_puncturePoints,
                                          _b->properties.rationalPt1,
                                          _b->properties.rationalPt2);
          int c_i = findMinimizationIndex(c_puncturePoints,
                                          _b->properties.rationalPt1,
                                          _b->properties.rationalPt2);

          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "a_i, b_i, c_i: "
                      << a_i<<", "<<b_i<<", "<<c_i  << std::endl;

          bool cont = true;

          if (a_i == -1 || b_i == -1 || c_i == -1)
          {
            // One of these curves isn't showing up. Get rid of it if
            // it isn't in the original_rational's list of children
            // (meant to contain the final minimum curves).
            // Otherwise, mark it to draw.
            if(std::find(children->begin(), children->end(), _a) == children->end())
            {
              ids_to_delete.push_back(_a->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_a->id << std::endl;
            }
            else
            {
              _a->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _a->properties.searchState = FieldlineProperties::WAITING_SEED;
            }

            if(std::find(children->begin(), children->end(), _b) == children->end())
            {
              ids_to_delete.push_back(_b->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_b->id << std::endl;
            }
            else
            {
              _b->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _b->properties.searchState = FieldlineProperties::WAITING_SEED;
            }

            if(std::find(children->begin(), children->end(), _c) == children->end())
            {
              ids_to_delete.push_back(_c->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_c->id << std::endl;
            }
            else
            {
              _c->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _c->properties.searchState = FieldlineProperties::WAITING_SEED;
            }

            cont = false;
          }

          if (cont)
          {
            // Find distance between puncture points
            float a_dist = pythDist(a_puncturePoints[a_i],a_puncturePoints[a_i + _a->properties.toroidalWinding]);
            float b_dist = pythDist(b_puncturePoints[b_i],b_puncturePoints[b_i + _b->properties.toroidalWinding]);
            float c_dist = pythDist(c_puncturePoints[c_i],c_puncturePoints[c_i + _c->properties.toroidalWinding]);

            if (RATIONAL_DEBUG)
              std::cerr << __LINE__ << "  " << "a_dist, b_dist, c_dist: "<< a_dist<<", "<<b_dist<<", "<<c_dist  << std::endl;

            ///////////////////////////////////
            // If the b_dist is smaller than a or c, then we know a minimum lies between a & c
            // So, we have the min bracketed and here we setup the actual minimization. It requires 4 curves.
            if (b_dist < a_dist && b_dist < c_dist)
            {
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Got B, minimum is bracketed, setup for minimization" << std::endl;
              std::vector<avtPoincareIC *> *children = seed->source_ic->properties.children;
              
              // A lot of this is just book keeping. Modify with care!
              _a->properties.searchState = FieldlineProperties::MINIMIZING_X0;
              _c->properties.searchState = FieldlineProperties::MINIMIZING_X3;
              _a->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
              _c->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
              _a->properties.rationalPt1 = avtVector(_b->properties.rationalPt1[0], _b->properties.rationalPt1[1], _b->properties.rationalPt1[2]);
              _a->properties.rationalPt2 = avtVector(_b->properties.rationalPt2[0], _b->properties.rationalPt2[1], _b->properties.rationalPt2[2]);
                      
              float bx_ax,cx_bx;
              float a_x,a_z,b_x,b_z,c_x,c_z;
              a_x = a_puncturePoints[a_i][0];
              a_z = a_puncturePoints[a_i][2];
              b_x = b_puncturePoints[b_i][0];
              b_z = b_puncturePoints[b_i][2];
              c_x = c_puncturePoints[c_i][0];
              c_z = c_puncturePoints[c_i][2];
              bx_ax = fabs(pythDist(a_puncturePoints[a_i],b_puncturePoints[b_i]));
              cx_bx = fabs(pythDist(b_puncturePoints[b_i],c_puncturePoints[c_i]));
                
              if (RATIONAL_DEBUG)
              {
                std::cerr << __LINE__ << "  " << "C point"<<c_x<<", "<<c_z << std::endl;
                std::cerr << __LINE__ << "  " << "B point"<<b_x<<", "<<b_z << std::endl;
              }
              float new_x,new_z;
              avtVector newPoint;
              std::vector<avtIntegralCurve *> new_ics;
              avtVector zeroVec = avtVector(0,0,0);
              avtPoincareIC *newIC;
              int j;
              if (cx_bx > bx_ax)
              {
                _b->properties.searchState = FieldlineProperties::MINIMIZING_X1;
                _b->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
                
                new_x = b_x + golden_C * (c_x-b_x);
                new_z = b_z + golden_C * (c_z-b_z);

                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "new x,z: "<<new_x<<", "<<new_z << std::endl; 
                          
                newPoint = avtVector(new_x, 0, new_z);         
                AddSeedPoint( newPoint, zeroVec, new_ics );
                for( j=0; j<new_ics.size(); j++ )
                {
                  newIC = (avtPoincareIC*) new_ics[j];
                  newIC->maxIntersections = 8 * properties.toroidalWinding + 2;
                  newIC->properties = poincare_ic->properties;
                  newIC->properties.searchState = FieldlineProperties::MINIMIZING_X2;
                  newIC->properties.type = FieldlineProperties::IRRATIONAL;
                  newIC->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
                  newIC->properties.iteration = poincare_ic->properties.iteration + 1;
                  newIC->source_ic = seed;

                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " <<  "Bracketed, New X2 id :"<<newIC->id << std::endl;
                }
                _a->GS_x1 = _b;
                _a->GS_x2 = newIC;
                _a->GS_x3 = _c;
                if (RATIONAL_DEBUG)
                {
                  std::cerr << __LINE__ << "  " << "1 x0 ID: "<<_a->id << std::endl;
                  std::cerr << __LINE__ << "  " << "1 x1 ID: "<<_b->id << std::endl; 
                  std::cerr << __LINE__ << "  " << "1 x2 ID: "<<newIC->id << std::endl; 
                  std::cerr << __LINE__ << "  " << "1 x3 ID: "<<_c->id << std::endl;
                }
              }
              else
              {
                _b->properties.searchState = FieldlineProperties::MINIMIZING_X2;
                _b->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
                
                new_x = b_x + golden_C * (c_x-b_x);
                new_z = b_z + golden_C * (c_z-b_z);
                if (RATIONAL_DEBUG)   
                  std::cerr << __LINE__ << "  " << "new x,y: "<<new_x<<", "<<new_z << std::endl; 
                newPoint = avtVector(new_x, 0, new_z);         
                AddSeedPoint( newPoint, zeroVec, new_ics );
                for( j=0; j<new_ics.size(); j++ )
                {
                  newIC = (avtPoincareIC*)new_ics[j];
                  newIC->maxIntersections = 8 * properties.toroidalWinding + 2;
                  newIC->properties = poincare_ic->properties;
                  newIC->properties.searchState = FieldlineProperties::MINIMIZING_X1;
                  newIC->properties.analysisMethod = FieldlineProperties::RATIONAL_MINIMIZE;
                  newIC->properties.type = FieldlineProperties::IRRATIONAL;
                  newIC->properties.iteration = poincare_ic->properties.iteration + 1;
                  newIC->source_ic = seed;
                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "Bracketed, new X1 ID :"<<newIC->id << std::endl;
                }
                _a->GS_x1 = newIC;
                _a->GS_x2 = _b;
                _a->GS_x3 = _c;
                if (RATIONAL_DEBUG)
                {
                  std::cerr << __LINE__ << "  " << "2 x0 ID: "<<_a->id << std::endl;
                  std::cerr << __LINE__ << "  " << "2 x1 ID: "<<newIC->id << std::endl;
                  std::cerr << __LINE__ << "  " << "2 x2 ID: "<<_b->id << std::endl; 
                  std::cerr << __LINE__ << "  " << "2 x3 ID: "<<_c->id << std::endl; 
                }
              }
            }
            ///////////////////////////////////////////////
            // Otherwise, we still need to bracket the minimum
            else
            {
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Minimum needs to be bracketed" << std::endl;
              if(std::find(children->begin(), children->end(), _c) == children->end())
              {
                ids_to_delete.push_back(_c->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Deleting ID: "<<_c->id << std::endl;
              }
              else
              {
                _c->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _c->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              
              float GOLD = 1.618034;
              if (b_dist > a_dist)
              {
                avtPoincareIC *temp = _a;
                _a = _b;
                _b = temp;
                _b->properties.rationalPt1 = _a->properties.rationalPt1;
                _b->properties.rationalPt2 = _a->properties.rationalPt2;
              }
              float a_x = a_puncturePoints[a_i][0];
              float a_z = a_puncturePoints[a_i][2];
              float b_x = b_puncturePoints[b_i][0];
              float b_z = b_puncturePoints[b_i][2];
              
              float c_x = b_x + GOLD * (b_x - a_x);
              float c_z = b_z + GOLD * (b_z - a_z);
              avtVector newPoint = avtVector(c_x,0,c_z);
              std::vector<avtIntegralCurve *> new_ics;
              avtVector zeroVec = avtVector(0,0,0);
              avtPoincareIC *newIC;
              AddSeedPoint( newPoint, zeroVec, new_ics );
              for(int j=0; j<new_ics.size(); j++ )
              {
                newIC = (avtPoincareIC*)new_ics[j];
                newIC->maxIntersections = 8 * properties.toroidalWinding + 2;
                newIC->properties = poincare_ic->properties;
                newIC->properties.searchState = FieldlineProperties::BRACKETING_C;
                newIC->properties.analysisMethod = FieldlineProperties::RATIONAL_BRACKET;
                newIC->properties.type = FieldlineProperties::IRRATIONAL;
                newIC->properties.iteration = poincare_ic->properties.iteration + 1;
                newIC->source_ic = seed;
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Bracketing, New C ID :"<<newIC->id << std::endl;

                newIC->a_IC = _a;
                newIC->b_IC = _b;
                          
                newIC->properties.rationalPt1 = avtVector(_b->properties.rationalPt1[0], _b->properties.rationalPt1[1], _b->properties.rationalPt1[2]);
                newIC->properties.rationalPt2 = avtVector(_b->properties.rationalPt2[0], _b->properties.rationalPt2[1], _b->properties.rationalPt2[2]);
              }
              _a->properties.searchState = FieldlineProperties::BRACKETING_A;
              _b->properties.searchState = FieldlineProperties::BRACKETING_B;
              _a->properties.analysisMethod = FieldlineProperties::RATIONAL_BRACKET;
              _b->properties.analysisMethod = FieldlineProperties::RATIONAL_BRACKET;
              _a->c_IC = newIC;
              _b->c_IC = newIC;
            }
          }
        }
        ///////////////////////////////////////////
        // Bracket the minimum, based on 'C' curve
        ///////////////////////////////////////////
        else if (poincare_ic->properties.analysisMethod == FieldlineProperties::RATIONAL_BRACKET && 
                 poincare_ic->properties.searchState == FieldlineProperties::BRACKETING_C)
            
        {
          if (RATIONAL_DEBUG)
          {
            std::cerr << __LINE__ << "  " << "Bracketing minimum, found BRACKETING_C" << std::endl;
            std::cerr << __LINE__ << "  " << "Surrounding original rational pt1 "<<poincare_ic->properties.rationalPt1 << std::endl;
          }
          
          avtPoincareIC *seed = poincare_ic->source_ic;
          
          // If the source is the original rational, poincare_ic is actually the seed
          if (seed->properties.searchState == FieldlineProperties::ORIGINAL_RATIONAL)
          {
            if (RATIONAL_DEBUG)
              std::cerr << __LINE__ << "  " << "This is the seed." << std::endl;
            seed = poincare_ic;
          }

          std::vector<avtPoincareIC *> *children = seed->source_ic->properties.children;
          
          Vector xzplane(0,1,0);
          FieldlineLib fieldlib;
          avtPoincareIC *_a = poincare_ic->a_IC;
          avtPoincareIC *_b = poincare_ic->b_IC;
          avtPoincareIC *_c = poincare_ic;      
          std::vector<avtVector> a_puncturePoints;
          std::vector<avtVector> b_puncturePoints;
          std::vector<avtVector> c_puncturePoints;
          fieldlib.getPunctures(_a->points,xzplane,a_puncturePoints);
          fieldlib.getPunctures(_b->points,xzplane,b_puncturePoints);
          fieldlib.getPunctures(_c->points,xzplane,c_puncturePoints);

          // Need to get distances
          int a_i = findMinimizationIndex(a_puncturePoints,_b->properties.rationalPt1,_b->properties.rationalPt2);
          int b_i = findMinimizationIndex(b_puncturePoints,_b->properties.rationalPt1,_b->properties.rationalPt2);
          int c_i = findMinimizationIndex(c_puncturePoints,_b->properties.rationalPt1,_b->properties.rationalPt2);
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "a_i, b_i, c_i: "<< a_i<<", "<<b_i<<", "<<c_i  << std::endl;
          bool cont = true;
          if (a_i == -1 || b_i == -1 || c_i == -1)
          {
            // One of these curves isn't showing up
            if(std::find(children->begin(), children->end(), _a) == children->end())
            {
              ids_to_delete.push_back(_a->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_a->id << std::endl;
            }
            else
            {
              _a->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _a->properties.searchState = FieldlineProperties::WAITING_SEED;
            }
            if(std::find(children->begin(), children->end(), _b) == children->end())
            {
              ids_to_delete.push_back(_b->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_b->id << std::endl;
            }
            else
            {
              _b->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _b->properties.searchState = FieldlineProperties::WAITING_SEED;
            }
            if(std::find(children->begin(), children->end(), _c) == children->end())
            {
              ids_to_delete.push_back(_c->id);
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Deleting ID: "<<_c->id << std::endl;
            }
            else
            {
              _c->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _c->properties.searchState = FieldlineProperties::WAITING_SEED;
            }
            cont = false;
          }

          if (cont)
          {
            // Find distance between puncture points
            float a_dist = pythDist(a_puncturePoints[a_i],
                                    a_puncturePoints[a_i + _a->properties.toroidalWinding]);
            float b_dist = pythDist(b_puncturePoints[b_i],
                                    b_puncturePoints[b_i + _b->properties.toroidalWinding]);
            float c_dist = pythDist(c_puncturePoints[c_i],
                                    c_puncturePoints[c_i + _c->properties.toroidalWinding]);

            if (RATIONAL_DEBUG)
              std::cerr << __LINE__ << "  " << "a_dist, b_dist, c_dist: "
                        << a_dist<<", "<<b_dist<<", "<<c_dist  << std::endl;

            if (b_dist > c_dist)
            {
              // USE DEFAULT MAGNIFICATION
              float GOLD = 1.618034;
              if (b_dist > a_dist)
              {
                avtPoincareIC *temp = _a;
                _a = _b;
                _b = temp;
              }
              float c_x = c_puncturePoints[c_i][0];
              float c_z = c_puncturePoints[c_i][2];
              float b_x = b_puncturePoints[b_i][0];
              float b_z = b_puncturePoints[b_i][2];

              c_x = c_x + GOLD * (c_x - b_x);
              c_z = c_z + GOLD * (c_z - b_z);
              avtVector newPoint = avtVector(c_x,0,c_z);
              std::vector<avtIntegralCurve *> new_ics;
              avtVector zeroVec = avtVector(0,0,0);
              avtPoincareIC *newIC;
              AddSeedPoint( newPoint, zeroVec, new_ics );

              for(int j=0; j<new_ics.size(); j++ )
              {
                newIC = (avtPoincareIC*)new_ics[j];
                newIC->maxIntersections = 8 * properties.toroidalWinding + 2;
                newIC->properties = poincare_ic->properties;
                newIC->properties.searchState = FieldlineProperties::BRACKETING_C;
                newIC->properties.analysisMethod = FieldlineProperties::RATIONAL_BRACKET;
                newIC->properties.type = FieldlineProperties::IRRATIONAL;
                newIC->properties.iteration = poincare_ic->properties.iteration + 1;
                newIC->source_ic = seed;
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Bracketing still, New C ID :"<<newIC->id << std::endl;
                newIC->a_IC = _b; //Shifting
                newIC->b_IC = _c; //Shifting
                newIC->properties.rationalPt1 = avtVector(_b->properties.rationalPt1[0], _b->properties.rationalPt1[1], _b->properties.rationalPt1[2]);
                newIC->properties.rationalPt2 = avtVector(_b->properties.rationalPt2[0], _b->properties.rationalPt2[1], _b->properties.rationalPt2[2]);

                _b->c_IC = newIC;
                _c->c_IC = newIC;
              }

              _b->properties.searchState = FieldlineProperties::BRACKETING_A;
              _c->properties.searchState = FieldlineProperties::BRACKETING_B;

              // Not using _a for the rest of the minimization, but it might be a seed so it needs to hangout
              _a->properties.searchState = FieldlineProperties::FINISHED_SEED;
            }
            else
            {
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "Bracketed the minimum, preparing to minimize" << std::endl;
              // We have bracketed a minimum and can minimize now
              _a->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _b->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _c->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                      
              _a->properties.searchState = FieldlineProperties::MINIMIZING_A;
              _b->properties.searchState = FieldlineProperties::MINIMIZING_B;
              _c->properties.searchState = FieldlineProperties::MINIMIZING_C;
                      
              _b->a_IC = _a;
              _b->c_IC = _c;
            }
                    
          }
        }

        // Here's the meat of the minimization, once the bracketing stuff is all done
        // Grab X0, and go
        else if (poincare_ic->properties.analysisMethod == FieldlineProperties::RATIONAL_MINIMIZE &&
                 poincare_ic->properties.searchState == FieldlineProperties::MINIMIZING_X0
                 )
        {
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "Done bracketing, found minimizing X0, finding minimum now" << std::endl;
          Vector xzplane(0,1,0);
          FieldlineLib fieldlib;

          avtPoincareIC *seed = poincare_ic->source_ic;

          // If the source is the original rational, poincare_ic is actually the seed
          if (seed->properties.searchState == FieldlineProperties::ORIGINAL_RATIONAL)
            {
              if (RATIONAL_DEBUG)
                std::cerr << __LINE__ << "  " << "This is the seed." << std::endl;
              seed = poincare_ic;
            }
              
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "original rational: "<<seed->source_ic->properties.searchState << std::endl;
          std::vector<avtPoincareIC *> *children = seed->source_ic->properties.children;

          avtPoincareIC *_x0 = poincare_ic;
          avtPoincareIC *_x1 = poincare_ic->GS_x1;
          avtPoincareIC *_x2 = poincare_ic->GS_x2;      
          avtPoincareIC *_x3 = poincare_ic->GS_x3;      

          if (RATIONAL_DEBUG)
          {
            std::cerr << __LINE__ << "  " << "x0 ID: "<<_x0->id << std::endl;
            std::cerr << __LINE__ << "  " << "x1 ID: "<<_x1->id << std::endl;
            std::cerr << __LINE__ << "  " << "x2 ID: "<<_x2->id << std::endl;
            std::cerr << __LINE__ << "  " << "x3 ID: "<<_x3->id << std::endl;
          }

          std::vector<avtVector> x0_puncturePoints;
          std::vector<avtVector> x1_puncturePoints;
          std::vector<avtVector> x2_puncturePoints;
          std::vector<avtVector> x3_puncturePoints;
          fieldlib.getPunctures(_x0->points,xzplane,x0_puncturePoints);
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "x0 ID: "<<_x0->id << std::endl;
          fieldlib.getPunctures(_x1->points,xzplane,x1_puncturePoints);
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "x1 ID: "<<_x1->id << std::endl;
          fieldlib.getPunctures(_x2->points,xzplane,x2_puncturePoints);
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "x2 ID: "<<_x2->id << std::endl;
          fieldlib.getPunctures(_x3->points,xzplane,x3_puncturePoints);
          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "x3 ID: "<<_x3->id << std::endl;
              
          // Need to get distances, so get the index first
          int x0_i = findMinimizationIndex(x0_puncturePoints,_x0->properties.rationalPt1,_x0->properties.rationalPt2);
          int x1_i = findMinimizationIndex(x1_puncturePoints,_x0->properties.rationalPt1,_x0->properties.rationalPt2);
          int x2_i = findMinimizationIndex(x2_puncturePoints,_x0->properties.rationalPt1,_x0->properties.rationalPt2);
          int x3_i = findMinimizationIndex(x3_puncturePoints,_x0->properties.rationalPt1,_x0->properties.rationalPt2);
              
          // Find distance between puncture points
          float x0_dist = pythDist(x0_puncturePoints[x0_i],x0_puncturePoints[x0_i + _x0->properties.toroidalWinding]);
          float x1_dist = pythDist(x1_puncturePoints[x1_i],x1_puncturePoints[x1_i + _x1->properties.toroidalWinding]);
          float x2_dist = pythDist(x2_puncturePoints[x2_i],x2_puncturePoints[x2_i + _x2->properties.toroidalWinding]);
          float x3_dist = pythDist(x3_puncturePoints[x3_i],x3_puncturePoints[x3_i + _x3->properties.toroidalWinding]);
              
          float x0_x, x0_y, x1_x, x1_y, x2_x, x2_y, x3_x, x3_y;
          x0_x = x0_puncturePoints[x0_i][0]; x0_y = x0_puncturePoints[x0_i][2];
          x1_x = x1_puncturePoints[x1_i][0]; x1_y = x1_puncturePoints[x1_i][2];
          x2_x = x2_puncturePoints[x2_i][0]; x2_y = x2_puncturePoints[x2_i][2];
          x3_x = x3_puncturePoints[x3_i][0]; x3_y = x3_puncturePoints[x3_i][2];
              
          float new_x,new_y;
          avtVector newPoint;
          std::vector<avtIntegralCurve *> new_ics;
          avtVector zeroVec = avtVector(0,0,0);
          avtPoincareIC *newIC;
          int j;     
          double range = fabs(pythDist(x3_puncturePoints[x3_i],x0_puncturePoints[x0_i]));
          double spacing = sqrt(x1_puncturePoints[x1_i][0] * x1_puncturePoints[x1_i][0] + x1_puncturePoints[x1_i][2] * x1_puncturePoints[x1_i][2])  * .001; // Somewhat of a magic number, just trying to narrow down precision
          // Basically, if we aren't close enough
          if (range > spacing)
          {
            if (x2_dist < x1_dist)
            {
              new_x = golden_R * x2_x + golden_C * x3_x;
              new_y = golden_R * x2_y + golden_C * x3_y;
              newPoint = avtVector(new_x, 0, new_y);     
              AddSeedPoint( newPoint, zeroVec, new_ics );
              for( j=0; j<new_ics.size(); j++ )
              {
                newIC = (avtPoincareIC*)new_ics[j];
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Adding ID: "<<newIC->id << std::endl;
                newIC->properties = poincare_ic->properties;
                newIC->source_ic = seed;
              }
              if(std::find(children->begin(), children->end(), _x0) == children->end())
              {
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Deleting ID: "<<_x0->id << std::endl;
                ids_to_delete.push_back(_x0->id);     
              }
              else
              {
                _x0->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x0->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              
              // Shift pointers to prepare for next run
              _x0 = _x1;
              _x1 = _x2;
              _x2 = newIC;
            }
            else
            {
              new_x = golden_R * x1_x + golden_C * x0_x;
              new_y = golden_R * x1_y + golden_C * x0_y;
              newPoint = avtVector(new_x, 0, new_y);     
              AddSeedPoint( newPoint, zeroVec, new_ics );

              for( j=0; j<new_ics.size(); j++ )
              {
                newIC = (avtPoincareIC*)new_ics[j];
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Adding ID: "<<newIC->id << std::endl;
                newIC->properties = poincare_ic->properties;
                newIC->source_ic = seed;
              }
              
              if(std::find(children->begin(), children->end(), _x3) == children->end())
              {
                ids_to_delete.push_back(_x3->id);              
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " << "Deleting ID: "<<_x3->id << std::endl;
              }
              else
              {
                _x3->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x3->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              
              // Shift pointers to prepare for next run
              _x3 = _x2;
              _x2 = _x1;
              _x1 = newIC;
            }

            _x0->GS_x1 = _x1;
            _x0->GS_x2 = _x2;
            _x0->GS_x3 = _x3;
            if (RATIONAL_DEBUG){
              std::cerr << __LINE__ << "  " << _x0->id<<" ID becomes X0" << std::endl;
              std::cerr << __LINE__ << "  " << _x1->id<<" ID becomes X1" << std::endl;
              std::cerr << __LINE__ << "  " << _x2->id<<" ID becomes X2" << std::endl;
              std::cerr << __LINE__ << "  " << _x3->id<<" ID becomes X3" << std::endl;
            }
            _x0->properties.searchState = FieldlineProperties::MINIMIZING_X0;
            _x1->properties.searchState = FieldlineProperties::MINIMIZING_X1;
            _x2->properties.searchState = FieldlineProperties::MINIMIZING_X2;
            _x3->properties.searchState = FieldlineProperties::MINIMIZING_X3;
          }
          // We have minimized!!!
          else
          {
            if (RATIONAL_DEBUG)
              std::cerr << __LINE__ << "  " << "Found the minimum." << std::endl;
            std::vector<avtPoincareIC *>::iterator it = children->begin();
            if (x1_dist < x2_dist)
            {
              _x1->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _x1->properties.searchState = FieldlineProperties::WAITING_SEED;

              if(std::find(children->begin(), children->end(), _x0) == children->end())
              {
                ids_to_delete.push_back(_x0->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<" Deleting ID: "<<_x0->id << std::endl;
              }
              else
              {
                _x0->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x0->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if(std::find(children->begin(), children->end(), _x2) == children->end())
              {
                ids_to_delete.push_back(_x2->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<" Deleting ID: "<<_x2->id << std::endl;
              }
              else
              {
                _x2->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x2->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if(std::find(children->begin(), children->end(), _x3) == children->end())
              {
                ids_to_delete.push_back(_x3->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<"Deleting ID: "<<_x3->id << std::endl;                       
              }
              else
              {
                _x3->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x3->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if (it != children->end())
              {
                if (seed->id != _x1->id)
                {
                  std::replace(children->begin(),children->end(),seed,_x1);
                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "x1 swapped with seed" << std::endl;
                  ids_to_delete.push_back(seed->id);
                }
                else
                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "original seed was already minimum" << std::endl; 
              }
            }
            else
            {
              _x2->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
              _x2->properties.searchState = FieldlineProperties::WAITING_SEED;
              
              if(std::find(children->begin(), children->end(), _x0) == children->end())
              {
                ids_to_delete.push_back(_x0->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<" Deleting ID: "<<_x0->id << std::endl;
              }
              else
              {
                _x0->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x0->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if(std::find(children->begin(), children->end(), _x1) == children->end())
              {
                ids_to_delete.push_back(_x1->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<" Deleting ID: "<<_x1->id << std::endl;
              }
              else
              {
                _x1->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x1->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if(std::find(children->begin(), children->end(), _x3) == children->end())
              {
                ids_to_delete.push_back(_x3->id);
                if (RATIONAL_DEBUG)
                  std::cerr << __LINE__ << "  " <<" Deleting ID: "<<_x3->id << std::endl;                      
              }
              else
              {
                _x3->properties.analysisMethod = FieldlineProperties::RATIONAL_SEARCH;
                _x3->properties.searchState = FieldlineProperties::WAITING_SEED;
              }
              if (it != children->end())
              {
                if (seed->id != _x2->id)
                {
                  std::replace(children->begin(),children->end(),seed,_x2);
                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "x2 swapped with seed" << std::endl;
                  ids_to_delete.push_back(seed->id);
                }
                else
                  if (RATIONAL_DEBUG)
                    std::cerr << __LINE__ << "  " << "original seed was already minimum" << std::endl; 
              }
            }
          }
        }
        
        else
        {
          if (RATIONAL_DEBUG)
          {
            std::cerr << __LINE__ << "  " << "In ContinueExecute - " 
                      << poincare_ic->id << " case fell through" << std::endl;
          }
        }
#endif
      }

      DeleteIntegralCurves( ids_to_delete );

      return true;
    }
    // No analysis requested or analysis complete, no need to
    // continue.
    else
    {
       return false;
    }
}


// ****************************************************************************
//  Method: avtPoincareFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Jeremy Meredith, Wed Apr  8 13:23:10 EDT 2009
//    Set topological dimension and normals request appropriately.
//
// ****************************************************************************

void
avtPoincareFilter::UpdateDataObjectInfo(void)
{ 
    avtStreamlineFilter::UpdateDataObjectInfo();

    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    avtDataValidity   &val  = GetOutput()->GetInfo().GetValidity();
    if (is_curvemesh)
    {
        atts.SetTopologicalDimension(1);
        val.SetNormalsAreInappropriate(true);
    }
    else
    {
        atts.SetTopologicalDimension(2);
        val.SetNormalsAreInappropriate(false);
    }

    if (! atts.ValidVariable("colorVar"))
    {
        atts.AddVariable("colorVar");
        atts.SetActiveVariable("colorVar");
        atts.SetVariableDimension(1);
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyStreamlines
//
//  Purpose:
//      Classify the streamlines (toroidal/poloidal winding).
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new 
//    code.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
//    Hank Childs, Fri Jun  4 19:58:30 CDT 2010
//    Use avtStreamlines, not avtStreamlineWrappers.
//
//    Hank Childs, Fri Oct  8 23:30:27 PDT 2010
//    Max intersections is now represented by an explicit data member, not
//    by generic "termination" field.
//
// ****************************************************************************

bool
avtPoincareFilter::ClassifyStreamlines(std::vector<avtIntegralCurve *> &ics)
{
    FieldlineLib FLlib;
    FLlib.verboseFlag = verboseFlag;

    debug5 << "Classifying Fieldlines " << std::endl;

    bool analysisComplete = true;

    for ( int i=0; i<ics.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];
        FieldlineProperties &properties = poincare_ic->properties;

        // If the analysis is completed then skip it.
        if( properties.analysisMethod != FieldlineProperties::DEFAULT_METHOD ||
            properties.analysisState  == FieldlineProperties::COMPLETED ||
            properties.analysisState  == FieldlineProperties::TERMINATED )
        {
          poincare_ic->status = avtIntegralCurve::STATUS_FINISHED;

          std::cerr <<"Skipping Classified Streamline: id = "
                    << poincare_ic->id << std::endl;

          continue;
        }

        poincare_ic->properties.maxPunctures = maxPunctures;

        FLlib.fieldlineProperties( poincare_ic->points,
                                   poincare_ic->properties,
                                   overrideToroidalWinding,
                                   overridePoloidalWinding,
                                   maximumToroidalWinding,
                                   windingPairConfidence,
                                   rationalSurfaceFactor,
                                   showOPoints );

        // Make the number of punctures 2x because the Poincare analysis
        // uses only the punctures in the same direction as the plane normal
        // while the streamline uses the plane regardless of the normal.

        if( poincare_ic->maxIntersections / 2 >= maxPunctures ||
            poincare_ic->properties.nPuncturesNeeded == 0  ||

            // Did the analysis but the integration can not continue.
            poincare_ic->status == avtIntegralCurve::STATUS_FINISHED )
        {
//           if( poincare_ic->properties.analysisState ==
//               FieldlineProperties::COMPLETED )
//           poincare_ic->properties.analysisState =
//             FieldlineProperties::TERMINATED;

          poincare_ic->status = avtIntegralCurve::STATUS_FINISHED;
        }
        else
        {
          if( poincare_ic->properties.nPuncturesNeeded > maxPunctures )
            poincare_ic->properties.nPuncturesNeeded = maxPunctures;
          
          poincare_ic->maxIntersections =
            2 * poincare_ic->properties.nPuncturesNeeded;
          
          poincare_ic->status = avtIntegralCurve::STATUS_OK;
          
          analysisComplete = false;
        }

        // See if O Points from an island need to be added.
        if( poincare_ic->properties.analysisState &
            FieldlineProperties::ADD_O_POINTS )
          analysisComplete = false;

        double safetyFactor;
        
        if ( poincare_ic->properties.poloidalWinding > 0 )
            safetyFactor = ( (double) poincare_ic->properties.toroidalWinding /
                             (double) poincare_ic->properties.poloidalWinding );
        else
            safetyFactor = 0;

        if(verboseFlag )
         std::cerr << "Classify Streamline: id = "<< poincare_ic->id
               << "  ptCnt = " << poincare_ic->points.size()
               << "  type = " << poincare_ic->properties.type
               << "  toroidal/poloidal windings = "
               << poincare_ic->properties.toroidalWinding << ","
               << poincare_ic->properties.poloidalWinding
               << "  (" << safetyFactor << ")"
               << "  toroidal/poloidal resonance = "
               << poincare_ic->properties.toroidalResonance << ","
               << poincare_ic->properties.poloidalResonance
               << "  windingGroupOffset = "
               << poincare_ic->properties.windingGroupOffset
               << "  islands = " << poincare_ic->properties.islands
               << "  nodes = " << poincare_ic->properties.nnodes
               << "  nPuncturesNeeded = " << poincare_ic->properties.nPuncturesNeeded
               << "  complete " << (poincare_ic->properties.analysisState ==
                                    FieldlineProperties::COMPLETED ?
                                    "Yes " : "No ")
//               << (poincare_ic->ic->status == avtIntegralCurve::STATUS_FINISHED ? 
//                   0 : poincare_ic->ic->maxIntersections )
               << std::endl << std::endl;
    }

    debug5 << "Classifying Streaming "
         << (analysisComplete ? "Analysis completed" : "Analysis was not complete")
         << std::endl;

    return analysisComplete;
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyRationals
//
//  Purpose:
//      Analyze rational seeds.
//
//  Arguments:
//
//  Returns:      bool
//                                      True: if 
//
//  Programmer: Jake Van Alstyne
//  Creation:   Sun Jun 12 11:18:52 PDT 2011
//
//  Modifications:
//
// ****************************************************************************

bool
avtPoincareFilter::ClassifyRationals(std::vector<avtIntegralCurve *> &ics)
{
#ifdef RATIONAL_SURFACE

  bool inRationalSearch = false;
  bool haveNewCompletedRational = false;
  bool seedsAreMinimizing = false;
  bool seedSearching = false;
  bool origFlag = false;
  
  // 2d array - 1st is for each rational, 2nd is the collection of
  // curves belonging to the rational
  std::map<long, std::vector<avtPoincareIC *> > rationalCurves;
  std::map<long, int> rationalCounts; // Number of waiting curves per rational.
  std::map<long, int> waitingCounts;
  
  // Count up waiting streamlines for each original_rational
  // Keep it organized by original_rational
  for( int i=0; i<ics.size(); ++i )
  {
    avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];
    
    FieldlineProperties &properties = poincare_ic->properties;

    // If we have curves involved in the rational search
    if( properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH ||
        properties.analysisMethod == FieldlineProperties::RATIONAL_BRACKET ||
        properties.analysisMethod == FieldlineProperties::RATIONAL_MINIMIZE )
    {
      inRationalSearch = true;

      // Seeds
      if( properties.searchState == FieldlineProperties::SEARCHING_SEED ||
          properties.searchState == FieldlineProperties::WAITING_SEED)
      {   
        seedSearching = true;
        rationalCurves[poincare_ic->source_ic->id].push_back(poincare_ic);
        
        // Initialize and update the counts       
        rationalCounts[poincare_ic->source_ic->id]++;
        
        if( properties.searchState == FieldlineProperties::WAITING_SEED)
          waitingCounts[poincare_ic->source_ic->id]++;
      }
      else if( properties.searchState == FieldlineProperties::MINIMIZING_A ||
               properties.searchState == FieldlineProperties::MINIMIZING_B ||
               properties.searchState == FieldlineProperties::MINIMIZING_C ||
               properties.searchState == FieldlineProperties::MINIMIZING_X0 ||
               properties.searchState == FieldlineProperties::MINIMIZING_X1 ||
               properties.searchState == FieldlineProperties::MINIMIZING_X2 ||
               properties.searchState == FieldlineProperties::MINIMIZING_X3 ||
               properties.searchState == FieldlineProperties::BRACKETING_A || 
               properties.searchState == FieldlineProperties::BRACKETING_B ||
               properties.searchState == FieldlineProperties::BRACKETING_C )
      {
        seedsAreMinimizing = true;
        seedSearching = true;
      }
      else if( properties.searchState == FieldlineProperties::ORIGINAL_RATIONAL)
      {
        if( !seedSearching )
        {
          properties.analysisMethod = FieldlineProperties::DEFAULT_METHOD;

          if (RATIONAL_DEBUG)
            std::cerr << __LINE__ << "  " << "Lone original rational" << std::endl;
          return true;
        }
      }
    }
    // Otherwise, we need to continueExecute if we have a completed rational
    else if( properties.analysisMethod == FieldlineProperties::DEFAULT_METHOD && 
             properties.type           == FieldlineProperties::RATIONAL &&
             (properties.analysisState  == FieldlineProperties::COMPLETED ||
              properties.analysisState  == FieldlineProperties::TERMINATED) )
    {
      if (RATIONAL_DEBUG)
        std::cerr << "HAVE NEW COMPLETED RATIONAL"  << std::endl;

      haveNewCompletedRational = true;
    }
  }
  
  // We aren't doing anything so return that we are done
  if (!inRationalSearch)
    return !haveNewCompletedRational;
  
  std::map<long, std::vector<avtPoincareIC *> >::iterator itr;
  int numRationalCurves, numFinishedCurves;

  for( itr = rationalCurves.begin();  itr != rationalCurves.end(); ++itr )
  { 
    numRationalCurves = 0, numFinishedCurves = 0;
    std::vector<avtPoincareIC *> curves = (*itr).second;
    std::vector<avtPoincareIC *>::iterator inneritr;

    for( inneritr = curves.begin(); inneritr != curves.end(); ++inneritr )
    {
      numRationalCurves++;
      // If all the curves for a rational are waiting
      if( rationalCounts[(*inneritr)->source_ic->id] ==
          waitingCounts[(*inneritr)->source_ic->id] )
      {
        numFinishedCurves++;
        (*inneritr)->properties.searchState = FieldlineProperties::FINISHED_SEED;
      }
    }
  }

  if (seedSearching && origFlag)
    std::cerr << __LINE__ << "  " << "Problem!" << std::endl;
  
  // If we've come this far, then we are done unless there are
  // unfinished curves or there is a new rational
  return (numRationalCurves == numFinishedCurves &&
          !haveNewCompletedRational && !seedsAreMinimizing && !origFlag);
#else
  return true;
#endif
}


// ****************************************************************************
//  Method: avtPoincareFilter::misc crap
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Allen Sanderson
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************
template< class T > int
pairsortfirst( const std::pair < T, T > s0, const std::pair < T, T > s1 )
{
  return (s0.first > s1.first );
}

template< class T > int
pairsortsecond( const std::pair < T, T > s0, const std::pair < T, T > s1 )
{
  return (s0.second > s1.second );
}

void realDFTamp( std::vector< double > &g, std::vector< double > &G )
{
  unsigned int N = g.size();

  G.resize(N/2);

  for(unsigned int i=0; i<N/2; i++)
  {
    double freq = double(i) / double(N);

    double GRe = 0;
    double GIm = 0;

    for( unsigned int j=0; j<N; j++)
    {
      double a = -2.0 * M_PI * double(j) * freq;
//    if(inverse) a *= -1.0;
      double ca = cos(a);
      double sa = sin(a);
      
      GRe += g[j] * ca; // - in[x][1] * sa;
      GIm += g[j] * sa; // + in[x][1] * ca;
    }

    G[i] = sqrt(GRe*GRe + GIm*GIm);
  }
}


// ****************************************************************************
//  Method: avtPoincareFilter::CreatePoincareOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    Add variables for dataValue var.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    Changed color to dataValue
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Replacedstd::cerr/cout with debug5.
//
// ****************************************************************************
void
avtPoincareFilter::CreatePoincareOutput( avtDataTree *dt,
                                         std::vector<avtIntegralCurve *> &ic)
{
    FieldlineLib FLlib;
    FLlib.verboseFlag = verboseFlag;

    debug5 << "Creating output " << std::endl;

    if( verboseFlag ) 
       std::cerr << std::endl << std::endl << "count " << ic.size() << std::endl << std::endl;

    for ( int i=0; i<ic.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ic[i];

        FieldlineProperties &properties = poincare_ic->properties;

        // Skip rational-search curves
        if (properties.analysisMethod != FieldlineProperties::DEFAULT_METHOD)
          continue;

        FieldlineProperties::FieldlineType type = properties.type;
        bool complete =
          (properties.analysisState == FieldlineProperties::COMPLETED);

        unsigned int toroidalWinding    = properties.toroidalWinding;
        unsigned int poloidalWinding    = properties.poloidalWinding;
        unsigned int toroidalWindingP   = properties.toroidalWindingP;
        unsigned int poloidalWindingP   = properties.poloidalWindingP;
        unsigned int toroidalResonance  = properties.toroidalResonance;
        unsigned int poloidalResonance  = properties.poloidalResonance;
        unsigned int windingGroupOffset = properties.windingGroupOffset;
        unsigned int islands            = properties.islands;
        unsigned int islandGroups       = properties.islandGroups;
        unsigned int nnodes             = properties.nnodes;

        std::vector< avtVector > &OPoints = properties.OPoints;

        bool completeIslands = true;

        if( verboseFlag ) 
        {
          double safetyFactor;

          if( poloidalWinding > 0 )
            safetyFactor = (float) toroidalWinding / (float) poloidalWinding;
          else
            safetyFactor = 0;

          std::cerr << "Surface id = " << poincare_ic->id << "  "
                    << "< " << poincare_ic->points[0].x << " "
                    << poincare_ic->points[0].y << " "
                    << poincare_ic->points[0].z << " >  "
                    << toroidalWinding << "," << poloidalWinding << " ("
                    << safetyFactor << ")  ";

          if( type == FieldlineProperties::RATIONAL )
            std::cerr << "rational surface  ";
          
          else if( type == FieldlineProperties::FLUX_SURFACE )
            std::cerr << "flux surface  ";
          
          else if( type == FieldlineProperties::ISLAND_PRIMARY_CHAIN )
            std::cerr << islands << " island chain with resonances: "
                      << toroidalResonance << "," << poloidalResonance << "  ";
          
          else if( type == FieldlineProperties::ISLAND_SECONDARY_CHAIN )
            std::cerr << islands << " islands around "
                      << islandGroups << " islandGroups with resonances: "
                      << toroidalResonance << "," << poloidalResonance << "  ";

          else if( type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS )
          {
            std::cerr << islands << " island chain with an ambiguous axis: "
                      << toroidalWindingP << "," << poloidalWindingP << " ("
                      << (float) toroidalWindingP / (float) poloidalWindingP << ")  ";
          }
          else if( type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS )
          {
            std::cerr << islands << " islands around "
                      << islandGroups << " islandGroups with resonances: "
                      << toroidalResonance << "," << poloidalResonance << "  ";
            std::cerr << islands << " with an ambiguous axis: "
                      << toroidalWindingP << "," << poloidalWindingP << " ("
                      << (float) toroidalWindingP / (float) poloidalWindingP << ")  ";
          }
          else if( type == FieldlineProperties::CHAOTIC )
            std::cerr << "chaotic  ";
          
          else if( type == FieldlineProperties::UNKNOWN_TYPE )
            std::cerr << "unknown  ";

          std::cerr << "with " << nnodes << " nodes"
                    << (complete ? " (Complete)  " : "  ")
                    << std::endl;
          
          if( (type == FieldlineProperties::ISLAND_PRIMARY_CHAIN ||
               type == FieldlineProperties::ISLAND_SECONDARY_CHAIN ||
               type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS ||
               type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS) &&
              toroidalWinding != poloidalWinding &&
              islands != toroidalWinding )
            std::cerr << "WARNING - The island count does not match the toroidalWinding count" << std::endl;
        }
        
        if( toroidalWinding == poloidalWinding )
        {
          if( type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS )
          {
            toroidalWinding = toroidalWindingP;
            poloidalWinding = poloidalWindingP;
            islands = 0;
          }
          else if( type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS )
          {
            toroidalWinding = toroidalWindingP;
            poloidalWinding = poloidalWindingP;
            islands = 0;
          }
          else
          {
            toroidalWinding = poloidalWinding = 1;
            windingGroupOffset = 0;
          }
        }

          
        // If toroidal winding is zero, skip it.
        if( type == FieldlineProperties::CHAOTIC )
        {
          if( showChaotic )
          {
            if( toroidalWinding == 0 )
              toroidalWinding = 1;
            if( poloidalWinding == 0 )
              poloidalWinding = 1;
          }
          else
          {
            continue;
          }
        }
        else if( type == FieldlineProperties::UNKNOWN_TYPE ) 
        {
          if( analysis == 0 )
          {
            toroidalWinding = 1;
            poloidalWinding = 1;
            toroidalWindingP = 1;
            poloidalWindingP = 1;
          }
          else
          {
            if( verboseFlag ) 
              std::cerr << " id = " << poincare_ic->id
                        << " SKIPPING UNKNOWN TYPE " << std::endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            
            continue;
          }
        }
        else if( toroidalWinding == 0 ) 
        {
            if( verboseFlag ) 
              std::cerr << " id = " << poincare_ic->id
                        << " SKIPPING TOROIDAL WINDING OF 0" << std::endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            
            continue;
        }
        else if( poloidalWinding == 0 ) 
        {
            if( verboseFlag ) 
              std::cerr << " id = " << poincare_ic->id
                        << " SKIPPING POLOIDAL WINDING OF 0" << std::endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            
            continue;
        }

        // Get the direction of the streamline toroidalWinding.
        Point lastPt = poincare_ic->points[0];
        Point currPt = poincare_ic->points[1];
        
        bool CCWstreamline = (atan2( lastPt.y, lastPt.x ) <
                              atan2( currPt.y, currPt.x ));
        
        double lastDist, currDist;

        // Put all of the points into the bins for each plane.
        std::vector< std::vector< std::vector < avtVector > > > puncturePts;
        
        puncturePts.resize( planes.size() );

        std::vector < avtVector > distancePts;

        std::vector< std::vector < avtVector > > islandPts;
        
        unsigned int startIndex = 0;
        
        for( unsigned int p=0; p<planes.size(); ++p ) 
        {
            Vector planeN;
            Vector planePt(0,0,0);
            
            if( puncturePlane == 0 ) // Poloidal Plane
            {
              // Go through the planes in the same direction as the streamline.
              if( CCWstreamline )
              {
                planeN = Vector( cos(planes[p]),
                                 sin(planes[p]),
                                 0 );
              }
              else
              {
                planeN = Vector( cos(planes[planes.size()-1-p]),
                                 sin(planes[planes.size()-1-p]),
                                 0 );
              }
            }

            else //if( puncturePlane == 1 ) // Toroidal Plane
            {
              planeN = Vector( 0, 0, -1 );
            }

            // Set up the plane equation.
            double plane[4];
            
            plane[0] = planeN.x;
            plane[1] = planeN.y;
            plane[2] = planeN.z;
            plane[3] = planePt.dot(planeN);
            
            puncturePts[p].resize( toroidalWinding );
            int bin = 0;
            
            // So to get the winding groups consistant start examining
            // the streamline in the same place for each plane.
            currPt = poincare_ic->points[startIndex];
            currDist = planeN.dot( currPt ) - plane[3];
            
            for( unsigned int j=startIndex+1; j<poincare_ic->points.size(); ++j )
            {
                lastPt = currPt;
                currPt = Vector(poincare_ic->points[j]);
                
                lastDist = currDist;
                currDist = Dot( planeN, currPt ) - plane[3];
                
                // First look at only points that intersect the plane.
                if( SIGN(lastDist) != SIGN(currDist) ) 
                {
                    Vector dir(currPt-lastPt);
                    
                    double dot = Dot(planeN, dir);
                    
                    // If the segment is in the same direction as the plane then
                    // find where it intersects the plane.
                    if( dot > 0.0 )
                    {
                        // In order to get the winding groups
                        // consistant start examining the streamline
                        // in the same place for each plane so store
                        // the index of the first puncture point.
                        if( startIndex == 0 )
                            startIndex = j - 1;
                        
                        Vector w = lastPt - planePt;
                        
                        double t = -Dot(planeN, w ) / dot;
                        
                        Point point = Point(lastPt + dir * t);
                        
                        puncturePts[p][bin].push_back( point );
                        
                        if( p == 0 && puncturePts[p][bin].size() > 1 )
                        {
                          int ic = puncturePts[p][bin].size()-2;

                          double len = (puncturePts[p][bin][ic]-
                                        puncturePts[p][bin][ic+1]).length();
                  
                          distancePts.push_back( Point( (float) distancePts.size()/50.0,
                                                    0,
                                                    len) );
                        }

                        bin = (bin + 1) % toroidalWinding;

                    }
                }
            }

            if( p == 0 && islands )
            {
              int offset = nnodes;
              
              islandPts.resize( toroidalWinding );
              
              for( unsigned int j=0; j<toroidalWinding; ++j )
              {
                for( unsigned int k=offset; k<puncturePts[p][j].size(); ++k )
                {
                  double len = (puncturePts[p][j][k-offset]-
                                puncturePts[p][j][k]).length();
                  
                  islandPts[j].push_back( Point( (float) islandPts[j].size()/50.0,
                                                 0,
                                                 -1.5+(float)i*.1+len) );
                  
                }
                
//              std::vector< pair< unsigned int, double > > stats;           
//              FLlib.periodicityStats( islandPts[j], stats, 2 );
              }
            }
        }
        

        // Get the ridgeline points. There is one point between each
        // Z plane puncture.
        Vector planeN( 0, 0, 1 );
        Vector planePt(0,0,0);
        
        // Set up the plane equation.
        double plane[4];

        plane[0] = planeN.x;
        plane[1] = planeN.y;
        plane[2] = planeN.z;
        plane[3] = planePt.dot(planeN);
            
        std::vector < avtVector > ridgelinePts;

        // Start looking for the z max after the first Z plane
        // intersetion is found.
        bool haveFirstIntersection = false;
        double maxZ = 0;

        // To get the winding groups consistant start examining the
        // streamline in the same place for each plane.
        currPt = poincare_ic->points[0];
        currDist = planeN.dot( currPt ) - plane[3];
            
        for( unsigned int j=startIndex+1;
             j<poincare_ic->points.size();
             ++j )
        {
          lastPt = currPt;
          currPt = Vector(poincare_ic->points[j]);
          
          lastDist = currDist;
          currDist = Dot( planeN, currPt ) - plane[3];
          
          // First look at only points that intersect the plane.
          if( SIGN(lastDist) != SIGN(currDist) ) 
          {
            Vector dir(currPt-lastPt);
            
            double dot = Dot(planeN, dir);
            
            // If the segment is in the same direction as the plane then
            // record the max Z value.
            if( dot > 0.0 )
            {
              if( haveFirstIntersection )
              {
                ridgelinePts.push_back( Point( (float) ridgelinePts.size()/50.0,
                                               0,
                                               maxZ) );
              }
              else
                haveFirstIntersection = true;

              maxZ = 0;
            }
          }

          if( maxZ < currPt.z )
            maxZ = currPt.z;
        }

        // Have the puncture points now draw them ...
        for( unsigned int p=0; p<planes.size(); p++ ) 
        {
            if( type == FieldlineProperties::UNKNOWN_TYPE ||
                type == FieldlineProperties::CHAOTIC )
              nnodes = puncturePts[p][0].size();

            else if( type == FieldlineProperties::FLUX_SURFACE )
            {
                if( overlaps == 1 || overlaps == 3 )
                    FLlib.removeOverlap( puncturePts[p], nnodes,
                                         toroidalWinding, poloidalWinding,
                                         windingGroupOffset, islands );
                if( overlaps == 2 )
                    FLlib.mergeOverlap( puncturePts[p], nnodes,
                                        toroidalWinding, poloidalWinding,
                                        windingGroupOffset, islands );
                else if( overlaps == 3 )
                    FLlib.smoothCurve( puncturePts[p], nnodes,
                                       toroidalWinding, poloidalWinding,
                                       windingGroupOffset, islands );
            }
            else if( type == FieldlineProperties::ISLAND_PRIMARY_CHAIN ||
                     type == FieldlineProperties::ISLAND_SECONDARY_CHAIN )
            {
          std::cerr << __LINE__ << "  "
                    << poincare_ic->properties.analysisState << "  "
                    << FieldlineProperties::COMPLETED << std::endl;
              if( overlaps != 0 )
              {
                if( properties.analysisState == FieldlineProperties::COMPLETED ||
                    properties.analysisState == FieldlineProperties::TERMINATED )
                {

                  // Loop through each island.
                  for( unsigned int j=0; j<toroidalWinding; j++ )
                  {
                    // Erase all of the overlapping points.
                    puncturePts[p][j].erase( puncturePts[p][j].begin()+nnodes,
                                             puncturePts[p][j].end() );
                    
                    // Close the island if it is complete
                    puncturePts[p][j].push_back( puncturePts[p][j][0] );
                  }
                }
                else
                {
                  // If the analysis did result in a complete island try
                  // to find the boundary manually
//                if( verboseFlag )
//                 std::cerr << "Cleaning up island " << std::endl;

//                FLlib.removeOverlap( puncturePts[p], nnodes,
//                                     toroidalWinding, poloidalWinding,
//                                     windingGroupOffset, islands );
                }
              }
            }
            else if( type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS ||
                     type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS )
            {
              if( overlaps != 0 )
              {

                if( showLines )
                  nnodes = 2;

                bool tmpPoints = showPoints;

                // Loop through each island.
                for( unsigned int j=0; j<toroidalWinding; j++ )
                {
                  // Erase all of the overlapping points.
                  puncturePts[p][j].erase( puncturePts[p][j].begin()+nnodes,
                                           puncturePts[p][j].end() );

                  if( showLines )
                  {
                    unsigned int n = (j+windingGroupOffset) % toroidalWinding;

                    puncturePts[p][j][1] = puncturePts[p][j][0] +
                      0.9 * (puncturePts[p][n][0] - puncturePts[p][j][0]);
                  }
                }
              }
            }
            
            bool VALID = true;
            
            // Sanity check
            for( unsigned int j=0; j<toroidalWinding; ++j ) 
            {
                if( nnodes > puncturePts[p][j].size() )
                    nnodes = puncturePts[p][j].size();
                
                if( puncturePts[p][j].size() < 1 ) 
                {
                    if( verboseFlag ) 
                     std::cerr << "Clean up check failed - Plane " << p
                           << " bin  " << j
                           << " number of points " << puncturePts[p][j].size()
                           << std::endl;
                    
                    VALID = false;
                    
//                  return NULL;
                }
                
//              std::cerr << "Surface " << i
//                           << " plane " << p
//                           << " bin " << j
//                           << " base number of nodes " << nnodes
//                           << " number of points " << puncturePts[p][j].size()
//                           << std::endl;
            }
        }

        if( !showIslands ||
            (showIslands &&
             (type == FieldlineProperties::ISLAND_PRIMARY_CHAIN ||
              type == FieldlineProperties::ISLAND_SECONDARY_CHAIN)) )
        {
            double color_value;

            if( !analysis )
            {
              dataValue = DATA_FieldlineOrder;
              color_value = poincare_ic->id;
            }
            else if( dataValue == DATA_FieldlineOrder )
                color_value = poincare_ic->id;
            else if( dataValue == DATA_ToroidalWindings )
                color_value = toroidalWinding;
            else if( dataValue == DATA_PoloidalWindingsQ )
                color_value = poloidalWinding;
            else if( dataValue == DATA_PoloidalWindingsP )
                color_value = poloidalWindingP;
            else if( dataValue == DATA_SafetyFactorQ )
                color_value = (double) toroidalWinding / (double) poloidalWinding;
            else if( dataValue == DATA_SafetyFactorP )
            {
              if( poloidalWindingP )
                color_value = (double) toroidalWinding / (double) poloidalWindingP;
              else
                color_value = (double) toroidalWinding / (double) poloidalWinding;
            }
            else if( dataValue == DATA_SafetyFactorQ_NotP )
            {
              if( type != FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS )
                color_value = (double) toroidalWinding / (double) poloidalWinding;
              else if( type != FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS )
                color_value = (double) toroidalResonance / (double) poloidalWinding;
              else
                continue;
            }
            else if( dataValue == DATA_SafetyFactorP_NotQ )
            {
              if( type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS )
                color_value = (double) toroidalWinding / (double) poloidalWindingP;
              else if( type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS )
                color_value = (double) toroidalResonance / (double) poloidalWindingP;
              else
                continue;
            }
            else
              color_value = 0;

            // Currently the surface mesh is a structquad so set the dims - it
            // really should be and unstructured surface so multiple surface
            // can be generated.
            if( is_curvemesh ) 
            {
              if( type == FieldlineProperties::UNKNOWN_TYPE ||
                  type == FieldlineProperties::CHAOTIC )
              {
                bool tmpLines  = showLines;
                bool tmpPoints = showPoints;

                if( windingGroupOffset == 0 )
                {
                  showLines  = false;
                  showPoints = true;
                }

                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value, 0, 0 );

                showLines  = tmpLines;
                showPoints = tmpPoints;
              }
              else if( type == FieldlineProperties::RATIONAL )
              {
                drawRationalCurve( dt, puncturePts, nnodes, islands,
                                   windingGroupOffset,
                                   dataValue, color_value );
              }
              else if( 0 && type == FieldlineProperties::ISLAND_SECONDARY_CHAIN )
              {
                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value,
                                     false,
                                     true );
              }
              else if( type & FieldlineProperties::IRRATIONAL )
              {
                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value,
                                     overlaps ? true : false,
                                     dataValue == DATA_WindingPointOrderModulo );
              }

              if( showOPoints &&
                  (type == FieldlineProperties::ISLAND_PRIMARY_CHAIN ||
                   type == FieldlineProperties::ISLAND_SECONDARY_CHAIN ||
                   type == FieldlineProperties::ISLAND_PRIMARY_AMBIGUOUS_AXIS ||
                   type == FieldlineProperties::ISLAND_SECONDARY_AMBIGUOUS_AXIS) )
              {
                drawPoints( dt, OPoints );
              }
            }
            else
            {
              drawSurface( dt, puncturePts, nnodes, islands,
                           windingGroupOffset,
                           dataValue, color_value );
            }

            if( show1DPlots )
              drawPeriodicity( dt, distancePts,
                               toroidalResonance,
//                             distancePts.size(),
                               nnodes, islands, poloidalWinding,
                               dataValue, color_value, true );

            
            if( show1DPlots )
              drawPeriodicity( dt, ridgelinePts,
                               poloidalResonance,
//                             ridgelinePts.size(),
                               nnodes, islands, poloidalWinding,
                               dataValue, color_value, true );
            

            if( islands && show1DPlots )
            {
              for( unsigned int j=0; j<toroidalWinding; ++j )
              {
                drawPeriodicity( dt, islandPts[j],
                                 islandPts[j].size(),
                                 nnodes, islands, poloidalWinding,
                                 dataValue, color_value, true );
              }
            }
        }
    }
    
    debug5 << "Finished creating poincare output " << std::endl;
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateRationalOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    Add variables for dataValue var.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    Changed color to dataValue
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Replaced cerr/cout with debug5.
//
// ****************************************************************************
void
avtPoincareFilter::CreateRationalOutput( avtDataTree *dt,
                                         std::vector<avtIntegralCurve *> &ic)
{
#ifdef RATIONAL_SURFACE
  FieldlineLib FLlib;
  FLlib.verboseFlag = verboseFlag;

  // Put all of the points into the bins for each plane.
  std::vector< std::vector< std::vector < avtVector > > > puncturePts;

  for ( int i=0; i<ic.size(); ++i )
  {
    avtPoincareIC * poincare_ic = (avtPoincareIC *) ic[i];
    FieldlineProperties &properties = poincare_ic->properties;
    
    if( properties.analysisMethod != FieldlineProperties::RATIONAL_SEARCH ||
        properties.analysisMethod == FieldlineProperties::RATIONAL_SEARCH &&
        properties.searchState    != FieldlineProperties::ORIGINAL_RATIONAL)
      continue;
    
    FieldlineProperties::FieldlineType type = properties.type;
    bool complete = (properties.analysisState == FieldlineProperties::COMPLETED);

    unsigned int toroidalWinding    = properties.toroidalWinding;
    unsigned int poloidalWinding    = properties.poloidalWinding;
    unsigned int windingGroupOffset = properties.windingGroupOffset;
    unsigned int poloidalWindingP   = properties.poloidalWindingP;
    unsigned int islands            = properties.islands;
        
    std::vector< avtPoincareIC *> *children = poincare_ic->properties.children;

    unsigned int nnodes = children->size();       
        
    cerr << "Rational Search Parent: id = " << poincare_ic->id << "  "
         << poincare_ic->points[0] << "  with  "
         << poincare_ic->properties.children->size() << " children"
         << std::endl;
        
    puncturePts.resize( planes.size() );

    for( unsigned int p=0; p<planes.size(); ++p )
    {
      puncturePts[p].resize( toroidalWinding );

      for( unsigned int t = 0; t<toroidalWinding; ++t )
        puncturePts[p][t].resize(children->size());
    }

    for( int j=0; j<children->size(); ++j )
    {       
      avtPoincareIC *child_poincare_ic = children->at(j);

      // Get the direction of the streamline toroidalWinding.
      Point lastPt = child_poincare_ic->points[0];
      Point currPt = child_poincare_ic->points[1];
            
      bool CCWstreamline = (atan2( lastPt.y, lastPt.x ) <
                            atan2( currPt.y, currPt.x ));
            
      double lastDist, currDist;
            
      std::vector < avtVector > distancePts;
            
      std::vector< std::vector < avtVector > > islandPts;
            
      unsigned int startIndex = 0;
            
      for( unsigned int p=0; p<planes.size(); ++p ) 
      {
        Vector planeN;
        Vector planePt(0,0,0);
        
        if( puncturePlane == 0 ) // Poloidal Plane
        {
          // Go through the planes in the same direction as the streamline.
          if( CCWstreamline )
          {
            planeN = Vector( cos(planes[p]),
                             sin(planes[p]),
                             0 );
          }
          else
          {
            planeN = Vector( cos(planes[planes.size()-1-p]),
                             sin(planes[planes.size()-1-p]),
                             0 );
          }
        }
        
        else //if( puncturePlane == 1 ) // Toroidal Plane
        {
          planeN = Vector( 0, 0, -1 );
        }
        
        // Set up the plane equation.
        double plane[4];
        
        plane[0] = planeN.x;
        plane[1] = planeN.y;
        plane[2] = planeN.z;
        plane[3] = planePt.dot(planeN);
                
        int bin = 0;
                
        // So to get the winding groups consistent start examining
        // the streamline in the same place for each plane.
        currPt = child_poincare_ic->points[startIndex];
        currDist = planeN.dot( currPt ) - plane[3];
                
        for( unsigned int k=startIndex+1; k<child_poincare_ic->points.size(); ++k )
        {
          lastPt = currPt;
          currPt = Vector(child_poincare_ic->points[k]);
                    
          lastDist = currDist;
          currDist = Dot( planeN, currPt ) - plane[3];
                    
          // First look at only points that intersect the plane.
          if( SIGN(lastDist) != SIGN(currDist) ) 
          {
            Vector dir(currPt-lastPt);
            
            double dot = Dot(planeN, dir);
            
            // If the segment is in the same direction as the plane then
            // find where it intersects the plane.
            if( dot > 0.0 )
             {
               // In order to get the winding groups
               // consistent start examining the streamline
               // in the same place for each plane so store
               // the index of the first puncture point.
               if( startIndex == 0 )
                 startIndex = k - 1;
                            
               Vector w = lastPt - planePt;
                            
               double t = -Dot(planeN, w ) / dot;
                            
               Point point = Point(lastPt + dir * t);
               puncturePts[p][bin][j] = point;

               if (++bin >= toroidalWinding)
                 break;
             }
          }
        }
      }
    }
 
    // Here, we are done with all the children but still in the parent
            
    // Have the puncture points now draw them ...
    for( unsigned int p=0; p<planes.size(); p++ ) 
    {
      bool VALID = true;
      
      // Sanity check
      for( unsigned int j=0; j<toroidalWinding; ++j ) 
      {
        if( nnodes > puncturePts[p][j].size() )
          nnodes = puncturePts[p][j].size();
        
        if( puncturePts[p][j].size() < 1 ) 
        {
          if( verboseFlag ) 
            cerr << "Rational clean up check failed - Plane " << p
                 << " bin  " << j
                 << " number of points " << puncturePts[p][j].size()
                 << endl;
          
          VALID = false;
          
          //                    return NULL;
        }
        
        //      cerr << "Surface " << i
        //           << " plane " << p
        //           << " bin " << j
        //           << " base number of nodes " << nnodes
        //           << " number of points " << puncturePts[p][j].size()
        //           << endl;
      }

      if( !showIslands )
      {
        double color_value;
        
        if( dataValue == DATA_FieldlineOrder )
          color_value = poincare_ic->id;
        else if( dataValue == DATA_ToroidalWindings )
          color_value = toroidalWinding;
        else if( dataValue == DATA_PoloidalWindingsQ )
          color_value = poloidalWinding;
        else if( dataValue == DATA_PoloidalWindingsP )
          color_value = poloidalWindingP;
        else if( dataValue == DATA_SafetyFactorQ )
          color_value = (double) toroidalWinding / (double) poloidalWinding;
        else if( dataValue == DATA_SafetyFactorP )
        {
          if( poloidalWindingP )
            color_value = (double) toroidalWinding / (double) poloidalWindingP;
          else
            color_value = (double) toroidalWinding / (double) poloidalWinding;
        }
        else if( dataValue == DATA_SafetyFactorQ_NotP )
        {
          if( poloidalWinding == poloidalWindingP )
            color_value = (double) toroidalWinding / (double) poloidalWinding;
          else
            continue;
        }
        else if( dataValue == DATA_SafetyFactorP_NotQ )
        {
          if( poloidalWindingP != poloidalWinding )
            color_value = (double) toroidalWinding / (double) poloidalWindingP;
          else
            continue;
        }
        else
          color_value = 0;
                
        // Currently the surface mesh is a structquad so set the dims - it
        // really should be and unstructured surface so multiple surface
        // can be generated.
        if( is_curvemesh ) 
        {
          drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                               windingGroupOffset,
                               dataValue, color_value,
                               overlaps ? true : false,
                               dataValue == DATA_WindingPointOrderModulo );
        }
        else
        {
          drawSurface( dt, puncturePts, nnodes, islands,
                       windingGroupOffset,
                       dataValue, color_value );
        }
      }
    }
  }
    
  debug5 << "Finished creating rational output " << endl;
#endif
}


// ****************************************************************************
//  Method: avtPoincareFilter::drawRationalCurve
//
//  Purpose: This method is for RATIONAL surfaces.
//           Creates a curve from the puncture points. Each curve
//           represents one toroidal winding group. 
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawRationalCurve( avtDataTree *dt,
                                      std::vector< std::vector < std::vector < avtVector > > > &nodes,
                                      unsigned int nnodes,
                                      unsigned int islands,
                                      unsigned int skip,
                                      unsigned int color,
                                      double color_value ) 
{
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();

    // If an island then only points.
    if( showLines && islands == 0 && toroidalWindings > 1 )
    {
      // Loop through each plane
      for( unsigned int p=0; p<nplanes; ++p ) 
      {
        if( color == DATA_PlaneOrder )
            color_value = p;
        
        //Create groups that represent the toroidial groups.
        vtkPoints *points = vtkPoints::New();
        vtkCellArray *cells = vtkCellArray::New();
        vtkFloatArray *scalars = vtkFloatArray::New();
            
        cells->InsertNextCell(toroidalWindings+1);
        scalars->Allocate    (toroidalWindings+1);

        // Loop through each toroidial group taking just the first
        // point from each group.
        for( unsigned int jj=0; jj<=toroidalWindings*skip; jj+=skip ) 
        {
            unsigned int j = jj % toroidalWindings;

            if( color == DATA_WindingGroupOrder )
                color_value = j;
            
            // Use the first point in each toroidial group
            unsigned int i=0;

            points->InsertPoint(j,
                                nodes[p][j][i].x,
                                nodes[p][j][i].y,
                                nodes[p][j][i].z);

            cells->InsertCellPoint(j);

            if( color == DATA_PointOrder )
              color_value = (i*toroidalWindings+j)*nplanes + p;
            else if( color == DATA_WindingPointOrder )
              color_value = i;
            else if( color == DATA_WindingPointOrderModulo )
              color_value = i % nnodes;
                
            scalars->InsertTuple1(j, color_value);
        }
         
        // Create a new VTK polyline.
        vtkPolyData *pd = vtkPolyData::New();
        pd->SetPoints(points);
        pd->SetLines(cells);
        scalars->SetName("colorVar");
        pd->GetPointData()->SetScalars(scalars);
        append->AddInput(pd);
        
        points->Delete();
        cells->Delete();
        scalars->Delete();
      }   
    }

    if (showPoints || toroidalWindings == 1 )
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_PlaneOrder )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingGroupOrder )
                    color_value = j;

                unsigned int npts;

                if( toroidalWindings > 1 )
                  npts = 1;
                else
                  npts = nodes[p][j].size();

                // Draw each point in the toroidial group
                for( unsigned int i=0; i<npts; ++i )
                {      
                    double pt[3] =
                      { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
                    
                    if( color == DATA_PointOrder )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    vtkPolyData *ball = CreateSphere(color_value, pt);
                    
                    append->AddInput(ball);
                    ball->Delete();
                }
            }
        }
    }
    
    if (0 && showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_PlaneOrder )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingGroupOrder )
                    color_value = j;
                
                //Create groups that represent the toroidial groups.
                vtkPoints *points = vtkPoints::New();
                vtkCellArray *cells = vtkCellArray::New();
                vtkFloatArray *scalars = vtkFloatArray::New();

                scalars->Allocate( nodes[p][j].size() );
        
                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    points->InsertNextPoint(nodes[p][j][i].x,
                                            nodes[p][j][i].y,
                                            nodes[p][j][i].z );
                    
                    vtkIdType id = (vtkIdType)i;
                    cells->InsertNextCell(1, &id);
                    
                    if( color == DATA_PointOrder )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    scalars->InsertTuple1(i, color_value);
                }

                // Create a new VTK point clouds.
                vtkPolyData *pd = vtkPolyData::New();
                pd->SetPoints(points);
                pd->SetVerts(cells);
                scalars->SetName("colorVar");
                pd->GetPointData()->SetScalars(scalars);
                append->AddInput(pd);
    
                points->Delete();
                cells->Delete();
                scalars->Delete();  
            }
        }
    }
    
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();
    
    dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
//  Method: avtPoincareFilter::drawIrrationalCurve
//
//  Purpose: Creates a curve from the puncture points. Each curve
//           represents one toroidal winding group.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawIrrationalCurve( avtDataTree *dt,
                                        std::vector< std::vector < std::vector < avtVector > > > &nodes,
                                        unsigned int nnodes,
                                        unsigned int islands,
                                        unsigned int skip,
                                        unsigned int color,
                                        double color_value,
                                        bool connect,
                                        bool modulo ) 
{
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    connect = 0;
    if (showLines)
    {
      if( !modulo )
      {
        // Determine if the winding group order matches the point
        // ordering. This is only needed when building surfaces.
        Vector intra = nodes[0][   0][1] - nodes[0][0][0];
        Vector inter = nodes[0][skip][0] - nodes[0][0][0];

        int offset;

        if( !islands && connect )
          offset = (Dot( intra, inter ) < 0 ) ? toroidalWindings-skip : skip;
        else
          offset = 0;

        // Loop through each plane
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_PlaneOrder )
              color_value = p;
        
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                //Create groups that represent the toroidial groups.
              vtkPoints *points = vtkPoints::New();
              vtkCellArray *cells = vtkCellArray::New();
              vtkFloatArray *scalars = vtkFloatArray::New();
            
              cells->InsertNextCell(nodes[p][j].size()+(offset?1:0));
              scalars->Allocate    (nodes[p][j].size()+(offset?1:0));
            
              if( color == DATA_WindingGroupOrder )
                color_value = j;
            
              // Loop through each point in toroidial group
              for( unsigned int i=0; i<nodes[p][j].size(); ++i ) 
              {
                  points->InsertPoint(i,
                                      nodes[p][j][i].x,
                                      nodes[p][j][i].y,
                                      nodes[p][j][i].z);

                  cells->InsertCellPoint(i);

                  if( color == DATA_PointOrder )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                  else if( color == DATA_WindingPointOrder )
                    color_value = i;
                  else if( color == DATA_WindingPointOrderModulo )
                    color_value = i % nnodes;
                
                  scalars->InsertTuple1(i, color_value);
              }

              if( offset )
              {
                // Add one point in from the previous neighbor to create
                // a complete boundary.

                unsigned int ii = nodes[p][j].size();
                unsigned int jj = (j+offset) % toroidalWindings;
                
                points->InsertPoint(ii,
                                    nodes[p][jj][0].x,
                                    nodes[p][jj][0].y,
                                    nodes[p][jj][0].z);
                
                cells->InsertCellPoint(ii);

                if( color == DATA_PointOrder )
                  color_value = (ii*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = ii;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = ii % nnodes;
                
                scalars->InsertTuple1(ii, color_value);
              }

            
              // Create a new VTK polyline.
              vtkPolyData *pd = vtkPolyData::New();
              pd->SetPoints(points);
              pd->SetLines(cells);
              scalars->SetName("colorVar");
              pd->GetPointData()->SetScalars(scalars);
              append->AddInput(pd);
            
              points->Delete();
              cells->Delete();
              scalars->Delete();
            }
        }
      }
      else //if( modulo )
      {
        Vector intra = nodes[0][0][0] - nodes[0][0][nnodes];
        Vector inter = nodes[0][0][0] - nodes[0][0][1];

        int offset = Dot( intra, inter ) ? skip : -skip;
        offset = 0;

        // Loop through each plane
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
          if( color == DATA_PlaneOrder )
            color_value = p;
          
          // Loop through each toroidial group
          for( unsigned int j=0; j<toroidalWindings; ++j ) 
          {
//          unsigned int bb = 0;

            if( color == DATA_WindingGroupOrder )
              color_value = j;
            
            for( unsigned int n=0; n<nnodes; ++n ) 
            {
              //Create groups that represent the toroidial groups.
              vtkPoints *points = vtkPoints::New();
              vtkCellArray *cells = vtkCellArray::New();
              vtkFloatArray *scalars = vtkFloatArray::New();

              unsigned int npts = ceil((nodes[p][j].size()-n) / (float) nnodes);
            
              cells->InsertNextCell(npts+(offset?1:0));
              scalars->Allocate    (npts+(offset?1:0));
            
              unsigned int cc = 0;

              // Loop through each point in toroidial group
              for( unsigned int i=n; i<nodes[p][j].size(); i+=nnodes ) 
              {
                points->InsertPoint(cc,
                                    nodes[p][j][i].x,
                                    nodes[p][j][i].y,
                                    nodes[p][j][i].z);

                cells->InsertCellPoint(cc);

                if( color == DATA_PointOrder )
                  color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = i % nnodes;
                
//              color_value = bb++;
                
                scalars->InsertTuple1(cc++, color_value);
              }

              if( offset )
              {
                // Add one point in from the previous neighbor to create
                // a complete boundary.
                unsigned int i = (n+offset+nnodes) % nnodes;
                
                points->InsertPoint(cc,
                                    nodes[p][j][i].x,
                                    nodes[p][j][i].y,
                                    nodes[p][j][i].z);
                
                cells->InsertCellPoint(cc);
                
                if( color == DATA_PointOrder )
                  color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = i % nnodes;

//              color_value = bb++;
                
                scalars->InsertTuple1(cc++, color_value);
              }

              // Create a new VTK polyline.
              vtkPolyData *pd = vtkPolyData::New();
              pd->SetPoints(points);
              pd->SetLines(cells);
              scalars->SetName("colorVar");
              pd->GetPointData()->SetScalars(scalars);
              append->AddInput(pd);
            
              points->Delete();
              cells->Delete();
              scalars->Delete();       
            }
          }
        }
      }
    }
    
    if (showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_PlaneOrder )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingGroupOrder )
                    color_value = j;

                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    double pt[3] =
                      { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
                    
                    if( color == DATA_PointOrder )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    vtkPolyData *ball = CreateSphere(color_value, pt);

                    append->AddInput(ball);
                    ball->Delete();
                }
            }
        }
    }
    
    if (0 && showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_PlaneOrder )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingGroupOrder )
                    color_value = j;

                //Create groups that represent the toroidial groups.
                vtkPoints *points = vtkPoints::New();
                vtkCellArray *cells = vtkCellArray::New();
                vtkFloatArray *scalars = vtkFloatArray::New();

                scalars->Allocate( nodes[p][j].size() );
        
                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    points->InsertNextPoint(nodes[p][j][i].x,
                                            nodes[p][j][i].y,
                                            nodes[p][j][i].z );
                  
                    vtkIdType id = (vtkIdType)i;
                    cells->InsertNextCell(1, &id);
                  
                    if( color == DATA_PointOrder )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                  
                    scalars->InsertTuple1(i, color_value);
                }

                // Create a new VTK point clouds.
                vtkPolyData *pd = vtkPolyData::New();
                pd->SetPoints(points);
                pd->SetVerts(cells);
                scalars->SetName("colorVar");
                pd->GetPointData()->SetScalars(scalars);
                append->AddInput(pd);
    
                points->Delete();
                cells->Delete();
                scalars->Delete();  
            }
        } 
    }
    
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();

    
    dt->Merge( new avtDataTree(outPD, 0) );
}



// ****************************************************************************
//  Method: avtPoincareFilter::drawSurface
//
//  Purpose: Creates a surface from a series the puncture points. The
//           surface is sweep from each toroidal winding group around
//           each plane in the torus. Each is connected together to
//           form a circular cross section.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawSurface( avtDataTree *dt,
                                std::vector< std::vector < std::vector < avtVector > > > &nodes,
                                unsigned int nnodes,
                                unsigned int islands,
                                unsigned int skip,
                                unsigned int color,
                                double color_value,
                                bool modulo ) 
{
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    
    int dims[2];
    
    // Add one to the first dimension to create a closed cylinder. Add
    // one to the second dimension to form a torus.
    dims[0] = nnodes + 1;
    dims[1] = nplanes * toroidalWindings + 1;
    
    // Create an unstructured quad for the island surface.
    vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
    vtkQuad *quad = vtkQuad::New();
    vtkPoints *points = vtkPoints::New();
    vtkFloatArray *scalars = vtkFloatArray::New();
    
    points->SetNumberOfPoints(dims[0]*dims[1]);
    scalars->Allocate(dims[0]*dims[1]);
    
    float *points_ptr = (float *) points->GetVoidPointer(0);

    // Determine if the winding group order matches the point
    // ordering. This is only needed when building surfaces.
    Vector intra = nodes[0][   0][1] - nodes[0][0][0];
    Vector inter = nodes[0][skip][0] - nodes[0][0][0];

    int offset = (Dot( intra, inter ) < 0 ) ? -skip : skip;

    // Loop through each toroidial group
    for( unsigned int j=0; j<toroidalWindings; ++j )
    {
        if( color == DATA_WindingGroupOrder )
            color_value = j;

        // Loop through each plane.
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            // Normally each toroidial winding group can be displayed
            // in the order received. Except for the last plane where
            // it needs to be adjusted by one group. That is if the
            // streamline started in the "correct" place. This is not
            // always the case so it may be necessary to adjust the
            // toroidal winding group location by one.
            unsigned int k;
            
            if( p == adjust_plane )
            {
                k = (j-1 + toroidalWindings) % toroidalWindings;
            }
            else
            {
                k = j;
            }

            unsigned int jj = nplanes * j + p;
            
            if( color == DATA_PlaneOrder )
                color_value = jj;
            
            // Loop through each point in toroidial group.
            for(unsigned int i=0; i<nnodes; ++i )
            {
                unsigned int n1 = jj * dims[0] + i;

                points_ptr[n1*3+0] = nodes[p][k][i].x;
                points_ptr[n1*3+1] = nodes[p][k][i].y;
                points_ptr[n1*3+2] = nodes[p][k][i].z;

                if( color == DATA_PointOrder )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                    color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                    color_value = i % nnodes;
                
                scalars->InsertTuple1(n1, color_value);

                // Create the quad.
                quad->GetPointIds()->SetId( 0,   jj    * dims[0] + i );
                quad->GetPointIds()->SetId( 1,  (jj+1) * dims[0] + i );
                quad->GetPointIds()->SetId( 2,  (jj+1) * dims[0] + i + 1);
                quad->GetPointIds()->SetId( 3,   jj    * dims[0] + i + 1);
                
                grid->InsertNextCell( quad->GetCellType(),
                                      quad->GetPointIds() );                
            }

            // For a surface add in the first point from the adjacent
            // toroidial group. Otherwise for an island add in the
            // first point from the current toroidal group.
            if( !islands )
                k = (k+offset+toroidalWindings) % toroidalWindings;

            unsigned int i = nnodes;

            unsigned int n1 = jj * dims[0] + i;
            
            points_ptr[n1*3+0] = nodes[p][k][0].x;
            points_ptr[n1*3+1] = nodes[p][k][0].y;
            points_ptr[n1*3+2] = nodes[p][k][0].z;
            
            if( color == DATA_PointOrder )
              color_value = (i*toroidalWindings+j)*nplanes + p;
            else if( color == DATA_WindingPointOrder )
              color_value = i;
            else if( color == DATA_WindingPointOrderModulo )
              color_value = i % nnodes;
            
            scalars->InsertTuple1(n1, color_value);
        }
    }
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int j = 0;
    
    if( color == DATA_WindingGroupOrder )
        color_value = j;
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int p = 0;
    
    // Normally each toroidial group can be displayed in the order
    // received. Except for the last plane where it needs to be
    // adjusted by one group. That is if the streamline started in
    // the "correct" place. This is not always the case so it may be
    // necessary to adjust the winding group location by one.
    unsigned int k;
    
    if( p == adjust_plane )
    {
        k = (j-1 + toroidalWindings) % toroidalWindings;
    }
    else
    {
        k = j;
    }
    
    unsigned int jj = nplanes * toroidalWindings;
    
    if( color == DATA_PlaneOrder )
        color_value = jj;
    
    // Loop through each point in toroidial group.
    for(unsigned int i=0; i<nnodes; ++i )
    {
      // Normally each point in a toroidial group can be displayed in
      // the order received. Except when dealing with 1:1 surfaces for
      // the last plane where it needs to be adjusted by one
      // location. That is if the streamline started in the "correct"
      // place. This is not always the case so it may be necessary to
      // adjust the point ordering by one.
      unsigned int ii;

      if( p == adjust_plane && toroidalWindings == 1) 
        ii = (i-1 + nnodes) % nnodes;
      else
        ii = i;

        unsigned int n1 = jj * dims[0] + ii;
        
        points_ptr[n1*3+0] = nodes[p][k][i].x;
        points_ptr[n1*3+1] = nodes[p][k][i].y;
        points_ptr[n1*3+2] = nodes[p][k][i].z;

        if( color == DATA_PointOrder )
            color_value = (i*toroidalWindings+j)*nplanes + p;
        else if( color == DATA_WindingPointOrder )
          color_value = i;
        else if( color == DATA_WindingPointOrderModulo )
          color_value = i % nnodes;
        
        scalars->InsertTuple1(n1, color_value);
    }

    // For a surface add in the first point from the adjacent
    // toroidial group. Otherwise for an island add in the
    // first point from the current toroidal group.
    if( !islands )
        k = (k+offset+toroidalWindings) % toroidalWindings;

    unsigned int i = nnodes;
    unsigned int n1 = jj * dims[0] + i;
    
    points_ptr[n1*3+0] = nodes[p][k][0].x;
    points_ptr[n1*3+1] = nodes[p][k][0].y;
    points_ptr[n1*3+2] = nodes[p][k][0].z;
    
    if( color == DATA_PointOrder )
      color_value = (i*toroidalWindings+j)*nplanes + p;
    else if( color == DATA_WindingPointOrder )
      color_value = i;
    else if( color == DATA_WindingPointOrderModulo )
      color_value = i % nnodes;
    
    scalars->InsertTuple1(n1, color_value);


    // Stuff the points and scalars into the VTK unstructure grid.
    grid->SetPoints(points);
    scalars->SetName("colorVar");
    grid->GetPointData()->SetScalars(scalars);
    dt->Merge( new avtDataTree(grid, 0) );
    
    quad->Delete();
    points->Delete();
    scalars->Delete();
}


void
avtPoincareFilter::drawPeriodicity( avtDataTree *dt,
                                    std::vector < Point  > &nodes,
                                    unsigned int period,
                                    unsigned int nnodes,
                                    unsigned int islands,
                                    unsigned int poloidalWindings,
                                    unsigned int color,
                                    double color_value,
                                    bool ptFlag )
{
  if( period <= 1 )
    period = nodes.size();

  unsigned int colorMax = 0;

  vtkAppendPolyData *append = vtkAppendPolyData::New();

  if( islands )
    poloidalWindings *= nnodes;
  
  if (showLines)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points;
    vtkCellArray *cells;
    vtkFloatArray *scalars;
    
    unsigned int cc = 0;
  
    // Loop through each point in poloidal group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      if( i % period == 0 )
      {
        //Create groups that represent the toroidial groups.
        points = vtkPoints::New();
        cells = vtkCellArray::New();
        scalars = vtkFloatArray::New();

        unsigned int npts = period < (nodes.size()-i) ?
          period : (nodes.size()-i);
      
        cells->InsertNextCell( npts );
        scalars->Allocate    ( npts );
      
        cc = 0;
      }

      if( ptFlag )
        points->InsertPoint(cc,
                            (float) (i % period) / 50.0,
                            nodes[i].y,
                            nodes[i].z);
      else
        points->InsertPoint(cc, nodes[i].x, nodes[i].y, nodes[i].z);
    
      cells->InsertCellPoint(cc);

      if( color == DATA_PointOrder )
        color_value = i;
      else if( color == DATA_WindingGroupOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;
          
      scalars->InsertTuple1(cc, color_value);
        
      ++cc;
            
      if( i % period == 0 )
      {
        // Create a new VTK polyline.
        vtkPolyData *pd = vtkPolyData::New();
        pd->SetPoints(points);
        pd->SetLines(cells);
        scalars->SetName("colorVar");
        pd->GetPointData()->SetScalars(scalars);
        append->AddInput(pd);
        
        points->Delete();
        cells->Delete();
        scalars->Delete();       
      }
    }
  }

  if (showPoints)
  {
    // Loop through each poloidal group
    // Loop through each point in poloidial group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {
      double pt[3] = { nodes[i].x, nodes[i].y, nodes[i].z };
      
      if( ptFlag )
        pt[0] = (float) (i % period) / 50.0;
      else
        pt[0] = nodes[i].x;
          
      if( color == DATA_PointOrder )
        color_value = i;
      else if( color == DATA_WindingGroupOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;

      if( colorMax < color_value )
        colorMax = color_value;
      
      vtkPolyData *ball = CreateSphere(color_value, pt);
      append->AddInput(ball);
      ball->Delete();
    }
  }

  if (0 && showPoints)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkFloatArray *scalars = vtkFloatArray::New();

    scalars->Allocate( nodes.size() );

    // Loop through each poloidal group
    // Loop through each point in poloidial group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      if( ptFlag )
        points->InsertNextPoint( (float) (i % period) / 50.0,
                                 nodes[i].y,
                                 nodes[i].z);
      else
        points->InsertNextPoint(nodes[i].x, nodes[i].y, nodes[i].z);

      vtkIdType id = (vtkIdType)i;
      cells->InsertNextCell(1, &id);
      
      if( color == DATA_PointOrder )
        color_value = i;
      else if( color == DATA_WindingGroupOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;

      if( colorMax < color_value )
        colorMax = color_value;

      scalars->InsertTuple1(i, color_value);
    }
    
    // Create a new VTK point clouds.
    vtkPolyData *pd = vtkPolyData::New();
    pd->SetPoints(points);
    pd->SetVerts(cells);
    scalars->SetName("colorVar");
    pd->GetPointData()->SetScalars(scalars);
    append->AddInput(pd);
    
    points->Delete();
    cells->Delete();
    scalars->Delete();       
  }

  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
//  Method: avtPoincareFilter::drawPoints
//
//  Purpose: Draws a bunch of points.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawPoints( avtDataTree *dt,
                               std::vector < avtVector > &nodes ) 
{
  vtkAppendPolyData *append = vtkAppendPolyData::New();

  if (showPoints)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkFloatArray *scalars = vtkFloatArray::New();

    scalars->Allocate( nodes.size() );

    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      points->InsertNextPoint(nodes[i].x, nodes[i].y, nodes[i].z);

      vtkIdType id = (vtkIdType)i;
      cells->InsertNextCell(1, &id);
      
      scalars->InsertTuple1(i, 0);
    }
    
    // Create a new VTK point clouds.
    vtkPolyData *pd = vtkPolyData::New();
    pd->SetPoints(points);
    pd->SetVerts(cells);
    scalars->SetName("colorVar");
    pd->GetPointData()->SetScalars(scalars);
    append->AddInput(pd);
    
    points->Delete();
    cells->Delete();
    scalars->Delete();       
  }

  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
// Method: avtPoincareFilter::SetIntersectionCriteria
//
// Purpose:
//   Sets the intersection object.
//
// Arguments:
//   obj : Intersection object.
//
// Programmer: Dave Pugmire
// Creation:   11 August 2009
//
// Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::SetIntersectionCriteria(vtkObject *obj, int mi)
{
    if (obj)
    {
        intersectObj = obj;
        intersectObj->Register(NULL);
    }
    maxIntersections = mi;
}
