/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisPoincarePlotWindow.h"

#include <PoincareAttributes.h>
#include <ViewerProxy.h>

#include <QTabWidget>
#include <QCheckBox>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QSpinBox>
#include <QButtonGroup>
#include <QComboBox>
#include <QGroupBox>
#include <QRadioButton>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineWidthWidget.h>
#include <QvisLineStyleWidget.h>
#include <QvisVariableButton.h>
#include <QvisPointControl.h>
#include <QPushButton>
#include <QFileDialog>

#include <stdio.h>
#include <string>

using std::string;

static void
TurnOn(QWidget *w0, QWidget *w1=NULL);
static void
TurnOff(QWidget *w0, QWidget *w1=NULL);

// ****************************************************************************
// Method: QvisPoincarePlotWindow::QvisPoincarePlotWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::QvisPoincarePlotWindow(const int type,
                         PoincareAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisPostableWindowObserver(subj, caption, shortName, notepad)
{
    plotType = type;
    atts = subj;
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::~QvisPoincarePlotWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::~QvisPoincarePlotWindow()
{
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
//   Allen Sanderson, Sun Mar  7 12:49:56 PST 2010
//   Change layout of window for 2.0 interface changes.
//
//   Jeremy Meredith, Fri Apr 30 13:05:20 EDT 2010
//   Fixed all the parents.
//
// ****************************************************************************

void
QvisPoincarePlotWindow::CreateWindowContents()
{
    propertyTabs = new QTabWidget(central);
    topLayout->addWidget(propertyTabs);

    // ----------------------------------------------------------------------
    // First tab
    // ----------------------------------------------------------------------
    firstTab = new QWidget(central);
    propertyTabs->addTab(firstTab, tr("Fieldlines"));
    
    QGridLayout *mainLayout = new QGridLayout(firstTab);

   // Create the source group box.
    QGroupBox *sourceGroup = new QGroupBox(firstTab);
    sourceGroup->setTitle(tr("Source"));
    mainLayout->addWidget(sourceGroup, 0, 0);
//    mainLayout->setStretchFactor(sourceGroup, 100);
    QGridLayout *sourceLayout = new QGridLayout(sourceGroup);
    sourceLayout->setMargin(5);
    sourceLayout->setSpacing(10);

    sourceTypeLabel = new QLabel(tr("Source Type"), sourceGroup);
    sourceLayout->addWidget(sourceTypeLabel, 0, 0);

    sourceTypeCombo = new QComboBox(sourceGroup);
    sourceTypeCombo->addItem(tr("Point"));
    sourceTypeCombo->addItem(tr("Line"));
    connect(sourceTypeCombo, SIGNAL(activated(int)),
           this, SLOT(sourceTypeChanged(int)));
    sourceLayout->addWidget(sourceTypeCombo, 0, 1);


    pointSourceLabel = new QLabel(tr("Location"), sourceGroup);
    sourceLayout->addWidget(pointSourceLabel, 0, 2);
    pointSource = new QLineEdit(sourceGroup);
    connect(pointSource, SIGNAL(returnPressed()),
            this, SLOT(pointSourceProcessText()));
    sourceLayout->addWidget(pointSource, 0, 3);



    lineStartLabel = new QLabel(tr("Start Point"), sourceGroup);
    sourceLayout->addWidget(lineStartLabel, 0, 2);
    lineStart = new QLineEdit(sourceGroup);
    connect(lineStart, SIGNAL(returnPressed()),
            this, SLOT(lineStartProcessText()));
    sourceLayout->addWidget(lineStart, 0, 3);

    lineEndLabel = new QLabel(tr("End Point"), sourceGroup);
    sourceLayout->addWidget(lineEndLabel, 1, 2);
    lineEnd = new QLineEdit(sourceGroup);
    connect(lineEnd, SIGNAL(returnPressed()),
            this, SLOT(lineEndProcessText()));
    sourceLayout->addWidget(lineEnd, 1, 3);

    pointDensityLabel = new QLabel(tr("Point density"), sourceGroup);
    sourceLayout->addWidget(pointDensityLabel, 2, 2);
    pointDensity = new QSpinBox(sourceGroup);
    pointDensity->setMinimum(1);
    pointDensity->setMaximum(10000);
    connect(pointDensity, SIGNAL(valueChanged(int)),
            this, SLOT(pointDensityChanged(int)));
    sourceLayout->addWidget(pointDensity, 2, 3);


   // Create the field group box.
    QGroupBox *fieldGroup = new QGroupBox(central);
    fieldGroup->setTitle(tr("Field"));
    mainLayout->addWidget(fieldGroup, 6, 0, 1, 1);
//    mainLayout->setStretchFactor(fieldGroup, 100);
    QGridLayout *fieldLayout = new QGridLayout(fieldGroup);
    fieldLayout->setMargin(5);
    fieldLayout->setSpacing(10);


    fieldLayout->addWidget( new QLabel(tr("Field"), fieldGroup), 0,0);
    fieldType = new QComboBox(fieldGroup);
    fieldType->addItem(tr("Default"));
    fieldType->addItem(tr("M3D-C1 2D"));
    fieldType->addItem(tr("M3D-C1 3D"));
    fieldType->addItem(tr("NIMROD"));
    fieldType->addItem(tr("Flash"));
    connect(fieldType, SIGNAL(activated(int)),
            this, SLOT(fieldTypeChanged(int)));
    fieldLayout->addWidget(fieldType, 0,1);
    

    // Create the field constant text field.
    fieldConstantLabel = new QLabel(tr("Constant"), fieldGroup);
    fieldConstant = new QLineEdit(fieldGroup);
    connect(fieldConstant, SIGNAL(returnPressed()), this,
            SLOT(fieldConstantProccessText()));
    fieldLayout->addWidget(fieldConstantLabel, 0,2);
    fieldLayout->addWidget(fieldConstant, 0,3);


    // Create the widgets that specify a velocity source.
    velocitySource = new QLineEdit(fieldGroup);
    connect(velocitySource, SIGNAL(returnPressed()),
            this, SLOT(velocitySourceProcessText()));
    velocitySourceLabel = new QLabel(tr("Velocity"), fieldGroup);
    velocitySourceLabel->setBuddy(velocitySource);
    fieldLayout->addWidget(velocitySourceLabel, 1, 2);
    fieldLayout->addWidget(velocitySource, 1, 3);


    // Create the integration group box.
    QGroupBox *integrationGroup = new QGroupBox(central);
    integrationGroup->setTitle(tr("Integration"));
    mainLayout->addWidget(integrationGroup, 7, 0, 5, 2);
//    mainLayout->setStretchFactor(integrationGroup, 100);
    QGridLayout *integrationLayout = new QGridLayout(integrationGroup);
    integrationLayout->setMargin(5);
    integrationLayout->setSpacing(10);


    integrationLayout->addWidget( new QLabel(tr("Integrator"), integrationGroup), 0,0);
    integrationType = new QComboBox(integrationGroup);
    integrationType->addItem(tr("Forward Euler (Single-step)"));
    integrationType->addItem(tr("Leapfrog (Single-step)"));
    integrationType->addItem(tr("Dormand-Prince (Runge-Kutta)"));
    integrationType->addItem(tr("Adams-Bashforth (Multi-step)"));
    integrationType->addItem(tr("Unused"));
    integrationType->addItem(tr("M3D-C1 2D Integrator (M3D-C1 2D fields only)"));
    connect(integrationType, SIGNAL(activated(int)),
            this, SLOT(integrationTypeChanged(int)));
    integrationLayout->addWidget(integrationType, 0,1);
    
    // Create the step length text field.
    maxStepLengthLabel = new QLabel(tr("Step length"), integrationGroup);
    maxStepLength = new QLineEdit(integrationGroup);
    connect(maxStepLength, SIGNAL(returnPressed()),
            this, SLOT(maxStepLengthProcessText()));
    integrationLayout->addWidget(maxStepLengthLabel, 1,0);
    integrationLayout->addWidget(maxStepLength, 1,1);

    limitMaxTimeStep = new QCheckBox(tr("Limit maximum time step"), integrationGroup);
    connect(limitMaxTimeStep, SIGNAL(toggled(bool)), this, SLOT(limitMaxTimeStepChanged(bool)));
    integrationLayout->addWidget(limitMaxTimeStep, 2, 0);
    
    // Create the step length text field.
    maxTimeStep = new QLineEdit(integrationGroup);
    connect(maxTimeStep, SIGNAL(returnPressed()),
            this, SLOT(maxTimeStepProcessText()));
    integrationLayout->addWidget(maxTimeStep, 2,1);

    QGroupBox *toleranceGroup = new QGroupBox(central);
    toleranceGroup->setTitle(tr("Tolerances: max error for step < max(abstol, reltol*velocity_i) for each component i"));
    integrationLayout->addWidget(toleranceGroup, 4, 0, 1, 3);
    QGridLayout *toleranceLayout = new QGridLayout(toleranceGroup);
    toleranceLayout->setMargin(5);
    toleranceLayout->setSpacing(10);

    // Create the relative tolerance text field.
    relTolLabel = new QLabel(tr("Relative tolerance"), toleranceGroup);
    relTol = new QLineEdit(toleranceGroup);
    connect(relTol, SIGNAL(returnPressed()),
            this, SLOT(relTolProcessText()));
    toleranceLayout->addWidget(relTolLabel, 0, 0);
    toleranceLayout->addWidget(relTol, 0, 1);

    // Create the absolute tolerance text field.
    absTolLabel = new QLabel(tr("Absolute tolerance"), toleranceGroup);
    absTol = new QLineEdit(toleranceGroup);
    connect(absTol, SIGNAL(returnPressed()), this, SLOT(absTolProcessText()));
    toleranceLayout->addWidget(absTolLabel, 1, 0);
    toleranceLayout->addWidget(absTol, 1, 1);

    absTolSizeType = new QComboBox(toleranceGroup);
    absTolSizeType->addItem(tr("Absolute"), 0);
    absTolSizeType->addItem(tr("Fraction of Bounding Box"), 1);
    connect(absTolSizeType, SIGNAL(activated(int)), this, SLOT(absTolSizeTypeChanged(int)));
    toleranceLayout->addWidget(absTolSizeType, 1, 2);

    forceNodal = new QCheckBox(tr("Force node centering"), integrationGroup);
    connect(forceNodal, SIGNAL(toggled(bool)), this, SLOT(forceNodalChanged(bool)));
    integrationLayout->addWidget(forceNodal, 9, 0);


    // Create the coordinate group
//     QGroupBox *coordinateGroup = new QGroupBox(firstTab);
//     coordinateGroup->setTitle(tr("Coordinate System"));
//     mainLayout->addWidget(coordinateGroup, 2, 0);

//     QGridLayout *coordinateLayout = new QGridLayout(coordinateGroup);
//     coordinateLayout->setMargin(5);
//     coordinateLayout->setSpacing(10);

//     coordinateButtonGroup = new QButtonGroup(coordinateGroup);
//     QRadioButton *cartesianButton = new QRadioButton(tr("Cartesian"), coordinateGroup);
//     QRadioButton *cylindricalButton = new QRadioButton(tr("Cylindrical"), coordinateGroup);
//     coordinateButtonGroup->addButton(cartesianButton, 0);
//     coordinateButtonGroup->addButton(cylindricalButton, 1);

//     coordinateLayout->addWidget(cartesianButton, 0, 0);
//     coordinateLayout->addWidget(cylindricalButton, 0, 1);

//     connect(coordinateButtonGroup, SIGNAL(buttonClicked(int)), this,
//          SLOT(coordinateButtonGroupChanged(int)));

    // Create the punctures group box.
    QGroupBox *puncturesGroup = new QGroupBox(firstTab);
    puncturesGroup->setTitle(tr("Punctures"));
    mainLayout->addWidget(puncturesGroup, 3, 0);
//    mainLayout->setStretchFactor(puncturesGroup, 100);

    QGridLayout *puncturesLayout = new QGridLayout(puncturesGroup);
    puncturesLayout->setMargin(5);
    puncturesLayout->setSpacing(10);

    minPuncturesLabel = new QLabel(tr("Minimum"), puncturesGroup);
    puncturesLayout->addWidget(minPuncturesLabel, 0, 0);
    minPunctures = new QSpinBox(central);
    minPunctures->setMinimum(1);
    minPunctures->setMaximum(10000);
    connect(minPunctures, SIGNAL(valueChanged(int)),
            this, SLOT(minPuncturesChanged(int)));
    puncturesLayout->addWidget(minPunctures, 0, 1);

    maxPuncturesLabel = new QLabel(tr("Maximum"), puncturesGroup);
    puncturesLayout->addWidget(maxPuncturesLabel, 0, 2);
    maxPunctures = new QSpinBox(central);
    maxPunctures->setMinimum(1);
    maxPunctures->setMaximum(10000);
    connect(maxPunctures, SIGNAL(valueChanged(int)),
            this, SLOT(maxPuncturesChanged(int)));
    puncturesLayout->addWidget(maxPunctures, 0, 3);


    puncturePlaneLabel = new QLabel(tr("Puncture Plane"), firstTab);
    puncturesLayout->addWidget(puncturePlaneLabel, 1, 0);
    puncturePlane = new QWidget(firstTab);
    puncturePlaneButtonGroup= new QButtonGroup(puncturePlane);
    QHBoxLayout *puncturePlaneLayout = new QHBoxLayout(puncturePlane);
    puncturePlaneLayout->setMargin(0);
    puncturePlaneLayout->setSpacing(10);
    QRadioButton *puncturePlaneTypePoloidal =
      new QRadioButton(tr("Poloidal"), puncturePlane);
    puncturePlaneButtonGroup->addButton(puncturePlaneTypePoloidal,0);
    puncturePlaneLayout->addWidget(puncturePlaneTypePoloidal);
    QRadioButton *puncturePlaneTypeTorodial =
      new QRadioButton(tr("Toroidal"), puncturePlane);
    puncturePlaneButtonGroup->addButton(puncturePlaneTypeTorodial,1);
    puncturePlaneLayout->addWidget(puncturePlaneTypeTorodial);
    connect(puncturePlaneButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(puncturePlaneChanged(int)));
    puncturesLayout->addWidget(puncturePlane, 1, 1, 1, 2);

    // ----------------------------------------------------------------------
    // Second tab
    // ----------------------------------------------------------------------
    secondTab = new QWidget(central);
    propertyTabs->addTab(secondTab, tr("Analysis"));
    
    mainLayout = new QGridLayout(secondTab);

    analysisLabel = new QLabel(tr("Analysis type"), secondTab);
    mainLayout->addWidget(analysisLabel, 0, 0, Qt::AlignTop);
    analysis = new QWidget(secondTab);
    analysisButtonGroup= new QButtonGroup(analysis);
    QHBoxLayout *analysisTypeLayout = new QHBoxLayout(analysis);
    analysisTypeLayout->setMargin(0);
    analysisTypeLayout->setSpacing(10);
    QRadioButton *analysisTypeNone =
      new QRadioButton(tr("None - Punctures only"), analysis);
    analysisButtonGroup->addButton(analysisTypeNone,0);
    analysisTypeLayout->addWidget(analysisTypeNone);
    QRadioButton *analysisTypeNormal =
      new QRadioButton(tr("Full"), analysis);
    analysisButtonGroup->addButton(analysisTypeNormal,1);
    analysisTypeLayout->addWidget(analysisTypeNormal);
    connect(analysisButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(analysisChanged(int)));
    mainLayout->addWidget(analysis, 0, 1, Qt::AlignTop);


   // Create the analysis group box.
    QGroupBox *analysisGroup = new QGroupBox(secondTab);
    analysisGroup->setTitle(tr("Analysis"));
    mainLayout->addWidget(analysisGroup, 1, 0, 3, 3, Qt::AlignTop);

    QGridLayout *analysisLayout = new QGridLayout(analysisGroup);
    analysisLayout->setMargin(5);
    analysisLayout->setSpacing(10);

    maximumToroidalWindingLabel =
      new QLabel(tr("Maximum toroidal winding"), secondTab);
    analysisLayout->addWidget(maximumToroidalWindingLabel, 0, 0);
    maximumToroidalWinding = new QSpinBox(secondTab);
    maximumToroidalWinding->setMinimum(0);
    maximumToroidalWinding->setMaximum(1000);
    connect(maximumToroidalWinding, SIGNAL(valueChanged(int)),
            this, SLOT(maximumToroidalWindingChanged(int)));
    analysisLayout->addWidget(maximumToroidalWinding, 0, 1);

    overrideToroidalWindingLabel =
      new QLabel(tr("Override toroidal winding"), secondTab);
    analysisLayout->addWidget(overrideToroidalWindingLabel, 1, 0);
    overrideToroidalWinding = new QSpinBox(secondTab);
    overrideToroidalWinding->setMinimum(0);
    overrideToroidalWinding->setMaximum(1000);
    connect(overrideToroidalWinding, SIGNAL(valueChanged(int)),
            this, SLOT(overrideToroidalWindingChanged(int)));
    analysisLayout->addWidget(overrideToroidalWinding, 1, 1);

    overridePoloidalWindingLabel =
      new QLabel(tr("Override poloidal winding"), secondTab);
    analysisLayout->addWidget(overridePoloidalWindingLabel, 1, 2);
    overridePoloidalWinding = new QSpinBox(secondTab);
    overridePoloidalWinding->setMinimum(0);
    overridePoloidalWinding->setMaximum(1000);
    connect(overridePoloidalWinding, SIGNAL(valueChanged(int)),
            this, SLOT(overridePoloidalWindingChanged(int)));
    analysisLayout->addWidget(overridePoloidalWinding, 1, 3);

    windingPairConfidenceLabel =
      new QLabel(tr("Winding pair confidence"), secondTab);
    analysisLayout->addWidget(windingPairConfidenceLabel, 2, 0);
    windingPairConfidence = new QLineEdit(secondTab);
    connect(windingPairConfidence, SIGNAL(returnPressed()),
            this, SLOT(windingPairConfidenceProcessText()));
    analysisLayout->addWidget(windingPairConfidence, 2, 1);


    rationalSurfaceFactorLabel =
      new QLabel(tr("Rational surface factor"), secondTab);
    analysisLayout->addWidget(rationalSurfaceFactorLabel, 2, 2);
    rationalSurfaceFactor = new QLineEdit(secondTab);
    connect(rationalSurfaceFactor, SIGNAL(returnPressed()),
            this, SLOT(rationalSurfaceFactorProcessText()));
    analysisLayout->addWidget(rationalSurfaceFactor, 2, 3);

    // Create the rational surface group box.
    QGroupBox *rationalSurfaceGroup = new QGroupBox(secondTab);
    rationalSurfaceGroup->setTitle(tr("Rational Surfaces"));
    mainLayout->addWidget(rationalSurfaceGroup, 4, 0, 1, 3, Qt::AlignTop);

    QGridLayout *rationalSurfaceLayout = new QGridLayout(rationalSurfaceGroup);
    rationalSurfaceLayout->setMargin(5);
    rationalSurfaceLayout->setSpacing(10);

    showRationalSurfaces = new QCheckBox(tr("Detect Rational Surfaces"), rationalSurfaceGroup);
    connect(showRationalSurfaces, SIGNAL(toggled(bool)),
            this, SLOT(showRationalSurfacesChanged(bool)));
    rationalSurfaceLayout->addWidget(showRationalSurfaces, 0, 0);

    rationalSurfaceMaxIterationsLabel =
      new QLabel(tr("Maximum iterations"), rationalSurfaceGroup);
    rationalSurfaceMaxIterations = new QSpinBox(rationalSurfaceGroup);
    rationalSurfaceMaxIterations->setRange(0, 10);
    connect(rationalSurfaceMaxIterations, SIGNAL(valueChanged(int)), 
            this, SLOT(rationalSurfaceMaxIterationsChanged(int)));
    rationalSurfaceLayout->addWidget( rationalSurfaceMaxIterationsLabel, 0, 2);
    rationalSurfaceLayout->addWidget( rationalSurfaceMaxIterations, 0, 3);

    // Create the O/X Point group box.
    QGroupBox *criticalPointGroup = new QGroupBox(secondTab);
    criticalPointGroup->setTitle(tr("Critical Points"));
    mainLayout->addWidget(criticalPointGroup, 5, 0, 1, 3, Qt::AlignTop);

    QGridLayout *criticalPointLayout = new QGridLayout(criticalPointGroup);
    criticalPointLayout->setMargin(5);
    criticalPointLayout->setSpacing(10);

    showOPoints = new QCheckBox(tr("Detect O Points"), criticalPointGroup);
    connect(showOPoints, SIGNAL(toggled(bool)),
            this, SLOT(showOPointsChanged(bool)));
    criticalPointLayout->addWidget(showOPoints, 0, 0);

    OPointMaxIterationsLabel =
      new QLabel(tr("Maximum iterations"), criticalPointGroup);
    OPointMaxIterations = new QSpinBox(criticalPointGroup);
    OPointMaxIterations->setRange(0, 10);
    connect(OPointMaxIterations, SIGNAL(valueChanged(int)), 
            this, SLOT(OPointMaxIterationsChanged(int)));
    criticalPointLayout->addWidget( OPointMaxIterationsLabel, 0, 2);
    criticalPointLayout->addWidget( OPointMaxIterations, 0, 3);


    // Create the O Line analysis group box.
    QGroupBox *OLineAnalysisGroup = new QGroupBox(secondTab);
    OLineAnalysisGroup->setTitle(tr("O-Line Analysis"));
    mainLayout->addWidget(OLineAnalysisGroup, 6, 0, 2, 3, Qt::AlignTop);

    QGridLayout *OLineAnalysisLayout = new QGridLayout(OLineAnalysisGroup);
    OLineAnalysisLayout->setMargin(5);
    OLineAnalysisLayout->setSpacing(10);

    performOLineAnalysis = new QCheckBox(tr("Perform O-Line analysis"),
                                OLineAnalysisGroup);
    connect(performOLineAnalysis, SIGNAL(toggled(bool)),
            this, SLOT(performOLineAnalysisChanged(bool)));
    OLineAnalysisLayout->addWidget(performOLineAnalysis, 0, 0);

    OLineToroidalWindingLabel =
      new QLabel(tr("O-Line toroidal windings"), OLineAnalysisGroup);
    OLineToroidalWinding = new QSpinBox(OLineAnalysisGroup);
    OLineToroidalWinding->setRange(1, 999);
    connect(OLineToroidalWinding, SIGNAL(valueChanged(int)), 
            this, SLOT(OLineToroidalWindingChanged(int)));
    OLineAnalysisLayout->addWidget( OLineToroidalWindingLabel, 0, 2);
    OLineAnalysisLayout->addWidget( OLineToroidalWinding, 0, 3);


    OLineAxisFileDialogButton = new QPushButton(secondTab);
    OLineAxisFileDialogButton->setText("O-Line Axis Point File");
    connect(OLineAxisFileDialogButton, SIGNAL(clicked()),
            this, SLOT(OLineAxisFileDialogButtonClicked()));
    OLineAnalysisLayout->addWidget(OLineAxisFileDialogButton, 2, 0);


    OLineAxisFileName = new QLineEdit(secondTab);
    connect(OLineAxisFileName, SIGNAL(returnPressed()),
            this, SLOT(OLineAxisFileNameProcessText()));
    OLineAnalysisLayout->addWidget(OLineAxisFileName, 2, 1, 1, 3);

    // Create the overlaps group box.
    QGroupBox *overlapsGroup = new QGroupBox(secondTab);
    overlapsGroup->setTitle(tr("Overlaps"));
    mainLayout->addWidget(overlapsGroup, 8, 0, 1, 3, Qt::AlignTop);

    QGridLayout *overlapsLayout = new QGridLayout(overlapsGroup);
    overlapsLayout->setMargin(5);
    overlapsLayout->setSpacing(10);

    overlapsLabel = new QLabel(tr("Overlaping curve sections"), secondTab);
    overlapsLayout->addWidget(overlapsLabel, 0, 0, Qt::AlignTop);
    overlaps = new QWidget(secondTab);
    overlapsButtonGroup= new QButtonGroup(overlaps);
    QHBoxLayout *overlapTypeLayout = new QHBoxLayout(overlaps);
    overlapTypeLayout->setMargin(0);
    overlapTypeLayout->setSpacing(10);
    QRadioButton *overlapTypeRaw =
      new QRadioButton(tr("Raw"), overlaps);
    overlapsButtonGroup->addButton(overlapTypeRaw,0);
    overlapTypeLayout->addWidget(overlapTypeRaw);
    QRadioButton *overlapTypeRemove =
      new QRadioButton(tr("Remove"), overlaps);
    overlapsButtonGroup->addButton(overlapTypeRemove,1);
    overlapTypeLayout->addWidget(overlapTypeRemove);
    QRadioButton *overlapTypeMerge =
      new QRadioButton(tr("Merge"), overlaps);
    overlapsButtonGroup->addButton(overlapTypeMerge,2);
    overlapTypeLayout->addWidget(overlapTypeMerge);
    QRadioButton *overlapTypeSmooth =
      new QRadioButton(tr("Smooth"), overlaps);
    overlapsButtonGroup->addButton(overlapTypeSmooth,3);
    overlapTypeLayout->addWidget(overlapTypeSmooth);
    connect(overlapsButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(overlapsChanged(int)));
    overlapsLayout->addWidget(overlaps, 0, 1, Qt::AlignTop);


    // Create the options group box.
    QGroupBox *analysisOptionsGroup = new QGroupBox(secondTab);
    analysisOptionsGroup->setTitle(tr("Options"));
    mainLayout->addWidget(analysisOptionsGroup, 9, 0, 1, 3, Qt::AlignTop);

    QGridLayout *analysisOptionsLayout = new QGridLayout(analysisOptionsGroup);
    analysisOptionsLayout->setMargin(5);
    analysisOptionsLayout->setSpacing(10);

    showChaotic =
      new QCheckBox(tr("Show chaotic fieldlines as points"), analysisOptionsGroup);
    connect(showChaotic, SIGNAL(toggled(bool)),
            this, SLOT(showChaoticChanged(bool)));
    analysisOptionsLayout->addWidget(showChaotic, 0, 0, 1, 2);

    showIslands = new QCheckBox(tr("Show islands only"), analysisOptionsGroup);
    connect(showIslands, SIGNAL(toggled(bool)),
            this, SLOT(showIslandsChanged(bool)));
    analysisOptionsLayout->addWidget(showIslands, 0, 2);


    summaryFlag = new QCheckBox(tr("Summary"), analysisOptionsGroup);
    connect(summaryFlag, SIGNAL(toggled(bool)),
            this, SLOT(summaryFlagChanged(bool)));
    analysisOptionsLayout->addWidget(summaryFlag, 1, 0);

    verboseFlag = new QCheckBox(tr("Verbose"), analysisOptionsGroup);
    connect(verboseFlag, SIGNAL(toggled(bool)),
            this, SLOT(verboseFlagChanged(bool)));
    analysisOptionsLayout->addWidget(verboseFlag, 1, 1);

    show1DPlots = new QCheckBox(tr("Show distance/ridgeline plots"), analysisOptionsGroup);
    connect(show1DPlots, SIGNAL(toggled(bool)),
            this, SLOT(show1DPlotsChanged(bool)));
    analysisOptionsLayout->addWidget(show1DPlots, 1, 2);


    // ----------------------------------------------------------------------
    // Third tab
    // ----------------------------------------------------------------------
    thirdTab = new QWidget(central);
    propertyTabs->addTab(thirdTab, tr("Appearance"));
    
    mainLayout = new QGridLayout(thirdTab);

    // Create the data group box.
    QGroupBox *dataGroup = new QGroupBox(thirdTab);
    dataGroup->setTitle(tr("Data"));
    mainLayout->addWidget(dataGroup, 0, 0);

    QGridLayout *dataLayout = new QGridLayout(dataGroup);
    dataLayout->setMargin(5);
    dataLayout->setSpacing(10);
    dataLayout->setColumnStretch(2, 10);


    dataValueLabel = new QLabel(tr("Data value:"), dataGroup);
    dataLayout->addWidget(dataValueLabel, 0, 0);

    dataValueCombo = new QComboBox(dataGroup);
    dataValueCombo->addItem(tr("None"));
    dataValueCombo->addItem(tr("Safety Factor Q"));
    dataValueCombo->addItem(tr("Safety Factor P"));
    dataValueCombo->addItem(tr("Safety Factor Q if Q==P"));
    dataValueCombo->addItem(tr("Safety Factor P if P!=Q"));
    dataValueCombo->addItem(tr("Toroidal Windings"));
    dataValueCombo->addItem(tr("Poloidal Windings Q"));
    dataValueCombo->addItem(tr("Poloidal Windings P"));
    dataValueCombo->addItem(tr("Fieldline Order"));
    dataValueCombo->addItem(tr("Point Order"));
    dataValueCombo->addItem(tr("Plane Order"));
    dataValueCombo->addItem(tr("Winding Group Order"));
    dataValueCombo->addItem(tr("Winding Point Order"));
    dataValueCombo->addItem(tr("Winding Point Order Modulo"));
    connect(dataValueCombo, SIGNAL(activated(int)),
           this, SLOT(dataValueChanged(int)));
    dataLayout->addWidget(dataValueCombo, 0, 1);

    dataLayout->addWidget(new QLabel(tr("   "), dataGroup), 0, 2);


    // Create the limits group box.
    QGroupBox *limitsGroup = new QGroupBox(thirdTab);
    dataLayout->addWidget(limitsGroup, 1, 0, 1, 3);

    QGridLayout *limitsLayout = new QGridLayout(limitsGroup);
    limitsLayout->setMargin(5);
    limitsLayout->setSpacing(10);

    limitsLayout->addWidget(new QLabel(tr("Limits"), limitsGroup), 0, 0);

    minFlag = new QCheckBox(tr("Minimum"), limitsGroup);
    limitsLayout->addWidget(minFlag, 0, 1);
    connect(minFlag, SIGNAL(toggled(bool)),
            this, SLOT(minFlagChanged(bool)));
    min = new QLineEdit(limitsGroup);
    connect(min, SIGNAL(returnPressed()),
            this, SLOT(minProcessText()));
    limitsLayout->addWidget(min, 0, 2);

    maxFlag = new QCheckBox(tr("Maximum"), limitsGroup);
    connect(maxFlag, SIGNAL(toggled(bool)),
            this, SLOT(maxFlagChanged(bool)));
    limitsLayout->addWidget(maxFlag, 0, 3);

    max = new QLineEdit(limitsGroup);
    connect(max, SIGNAL(returnPressed()),
            this, SLOT(maxProcessText()));
    limitsLayout->addWidget(max, 0, 4);


   // Create the color group box.
    QGroupBox *colorGroup = new QGroupBox(thirdTab);
    colorGroup->setTitle(tr("Color"));
    mainLayout->addWidget(colorGroup, 1, 0);
//    mainLayout->setStretchFactor(colorGroup, 100);
    QGridLayout *colorLayout = new QGridLayout(colorGroup);
    colorLayout->setMargin(5);
    colorLayout->setSpacing(10);
//    colorLayout->setColumnStretch(2, 10);

    singleColorLabel = new QLabel(tr("Single color"), colorGroup);
    singleColor = new QvisColorButton(colorGroup);
    connect(singleColor, SIGNAL(selectedColor(const QColor&)),
            this, SLOT(singleColorChanged(const QColor&)));
    colorLayout->addWidget(singleColorLabel, 0, 0, Qt::AlignLeft);
    colorLayout->addWidget(singleColor, 0, 1, Qt::AlignLeft);

    colorTableNameLabel = new QLabel(tr("Color table"), colorGroup);
    colorTableName = new QvisColorTableButton(colorGroup);
    connect(colorTableName, SIGNAL(selectedColorTable(bool, const QString&)),
            this, SLOT(colorTableNameChanged(bool, const QString&)));
    colorLayout->addWidget(colorTableNameLabel, 0, 0, Qt::AlignLeft);
    colorLayout->addWidget(colorTableName, 0, 1, Qt::AlignLeft);


    // Create the use-color-table-opacity checkbox

    // Create the radio buttons
    opacityButtonsLabel = new QLabel(tr("Opacity"), central);
    colorLayout->addWidget(opacityButtonsLabel, 0, 2, Qt::AlignRight);

    opacityButtons = new QButtonGroup(central);

    opacityButtonSetExplicit = new QRadioButton(tr("Set explicitly"), central);
    opacityButtonSetExplicit->setChecked(true);
    opacityButtons->addButton(opacityButtonSetExplicit, 0);
    colorLayout->addWidget(opacityButtonSetExplicit, 0, 3, Qt::AlignLeft);
    opacityButtonColorTable = new QRadioButton(tr("From color table"), central);
    opacityButtons->addButton(opacityButtonColorTable, 1);
    colorLayout->addWidget(opacityButtonColorTable, 0, 4);

    // Each time a radio button is clicked, call the scale clicked slot.
    connect(opacityButtons, SIGNAL(buttonClicked(int)),
            this, SLOT(setOpaacityClicked(int)));

    //
    // Create the opacity slider
    //
//    opacitySliderLabel = new QLabel(tr("Opacity"), central);
//    colorLayout->addWidget(opacitySliderLabel, 1, 2);

    opacitySlider = new QvisOpacitySlider(0, 255, 25, 255, central);
    opacitySlider->setTickInterval(64);
    opacitySlider->setGradientColor(QColor(0, 0, 0));
    connect(opacitySlider, SIGNAL(valueChanged(int, const void*)),
            this, SLOT(changedOpacity(int, const void*)));
    colorLayout->addWidget(opacitySlider, 1, 3, 1, 2);


    // Create the display group box.
    QGroupBox *displayGroup = new QGroupBox(thirdTab);
    displayGroup->setTitle(tr("Display"));
    mainLayout->addWidget(displayGroup, 2, 0);
//    mainLayout->setStretchFactor(displayGroup, 100);
    QGridLayout *displayLayout = new QGridLayout(displayGroup);
    displayLayout->setMargin(5);
    displayLayout->setSpacing(10);

    meshTypeLabel = new QLabel(tr("Mesh type:"), displayGroup);
    displayLayout->addWidget(meshTypeLabel, 0, 0);

    meshTypeCombo = new QComboBox(displayGroup);
    meshTypeCombo->addItem(tr("Curves"));
    meshTypeCombo->addItem(tr("Surfaces"));
    connect(meshTypeCombo, SIGNAL(activated(int)),
           this, SLOT(meshTypeChanged(int)));
    displayLayout->addWidget(meshTypeCombo, 0, 1);

    numberPlanesLabel = new QLabel(tr("Number of planes"), displayGroup);
    displayLayout->addWidget(numberPlanesLabel, 1, 0);
    numberPlanes = new QSpinBox(displayGroup);
    numberPlanes->setMinimum(1);
    numberPlanes->setMaximum(250);
    connect(numberPlanes, SIGNAL(valueChanged(int)),
            this, SLOT(numberPlanesChanged(int)));
    displayLayout->addWidget(numberPlanes, 1, 1);

    singlePlaneLabel = new QLabel(tr("Base plane (degrees)"), displayGroup);
    displayLayout->addWidget(singlePlaneLabel, 1, 2);
    singlePlane = new QLineEdit(displayGroup);
    connect(singlePlane, SIGNAL(returnPressed()),
            this, SLOT(singlePlaneProcessText()));
    displayLayout->addWidget(singlePlane, 1, 3);

    adjustPlaneLabel = new QLabel(tr("Adjust plane index"), displayGroup);
    displayLayout->addWidget(adjustPlaneLabel, 1, 2);
    adjustPlane = new QSpinBox(displayGroup);
    adjustPlane->setMinimum(-1);
    adjustPlane->setMaximum(250);
    connect(adjustPlane, SIGNAL(valueChanged(int)),
            this, SLOT(adjustPlaneChanged(int)));
    displayLayout->addWidget(adjustPlane, 1, 3);


   // Create the options group box.
    QGroupBox *optionsGroup = new QGroupBox(thirdTab);
    optionsGroup->setTitle(tr("Options"));
    mainLayout->addWidget(optionsGroup, 3, 0);

    QGridLayout *optionsLayout = new QGridLayout(optionsGroup);
    optionsLayout->setMargin(5);
    optionsLayout->setSpacing(10);

    showLines = new QCheckBox(tr("Show Lines"), optionsGroup);
    connect(showLines, SIGNAL(toggled(bool)),
            this, SLOT(showLinesChanged(bool)));
    optionsLayout->addWidget(showLines, 0, 0);

    lineStyleLabel = new QLabel(tr("Line style"), central);
    optionsLayout->addWidget(lineStyleLabel, 1, 0, Qt::AlignRight);
    lineStyle = new QvisLineStyleWidget(0, central);
    connect(lineStyle, SIGNAL(lineStyleChanged(int)),this, SLOT(lineStyleChanged(int)));
    optionsLayout->addWidget(lineStyle, 1, 1);
    
    lineWidthLabel = new QLabel(tr("Line width"), central);
    optionsLayout->addWidget(lineWidthLabel, 1, 2, Qt::AlignRight);
    lineWidth = new QvisLineWidthWidget(0, central);
    connect(lineWidth, SIGNAL(lineWidthChanged(int)), this, SLOT(lineWidthChanged(int)));
    optionsLayout->addWidget(lineWidth, 1, 3, Qt::AlignLeft);

    showPoints = new QCheckBox(tr("Show Points"), optionsGroup);
    connect(showPoints, SIGNAL(toggled(bool)), this, SLOT(showPointsChanged(bool)));
    optionsLayout->addWidget(showPoints, 2, 0);
    pointControl = new QvisPointControl(central, false);
    connect(pointControl, SIGNAL(pointSizeChanged(double)), this, SLOT(pointSizeChanged(double)));
    connect(pointControl, SIGNAL(pointSizePixelsChanged(int)), this, SLOT(pointSizePixelsChanged(int)));
    connect(pointControl, SIGNAL(pointTypeChanged(int)), this, SLOT(pointTypeChanged(int)));
    optionsLayout->addWidget(pointControl, 3, 1, 1,4);

    //
    // Create the misc stuff
    //
    QGroupBox * miscGroup = new QGroupBox(thirdTab);
    miscGroup->setTitle(tr("Misc"));
    mainLayout->addWidget(miscGroup, 4, 0);

    QGridLayout *miscLayout = new QGridLayout(miscGroup);
    miscLayout->setMargin(5);
    miscLayout->setSpacing(10);
 
    // Create the legend toggle
    legendToggle = new QCheckBox(tr("Legend"), miscGroup);
    connect(legendToggle, SIGNAL(toggled(bool)),
            this, SLOT(legendToggled(bool)));
    miscLayout->addWidget(legendToggle, 0, 0);

    // Create the lighting toggle
    lightingToggle = new QCheckBox(tr("Lighting"), miscGroup);
    connect(lightingToggle, SIGNAL(toggled(bool)),
            this, SLOT(lightingToggled(bool)));
    miscLayout->addWidget(lightingToggle, 0, 1);

    // ----------------------------------------------------------------------
    // Fourth tab
    // ----------------------------------------------------------------------
    fourthTab = new QWidget(central);
    propertyTabs->addTab(fourthTab, tr("Parallel"));
    
    mainLayout = new QGridLayout(fourthTab);

    QGroupBox *algoGrp = new QGroupBox(fourthTab);
    algoGrp->setTitle(tr("Parallel fieldline options"));
    mainLayout->addWidget(algoGrp, 0, 0, 1, 4);

    // Algorithm group.
    QGridLayout *algoGLayout = new QGridLayout(algoGrp);
    algoGLayout->setSpacing(10);
    algoGLayout->setColumnStretch(1,10);

    slAlgoLabel = new QLabel(tr("Parallelize across"), algoGrp);
    slAlgo = new QComboBox(algoGrp);
    slAlgo->addItem(tr("Fieldlines"));
    slAlgo->addItem(tr("Domains"));
    slAlgo->addItem(tr("Fieldlines and Domains"));
    connect(slAlgo, SIGNAL(activated(int)),
            this, SLOT(streamlineAlgorithmChanged(int)));
    algoGLayout->addWidget( slAlgoLabel, 1,0);
    algoGLayout->addWidget( slAlgo, 1,1);
    
    maxSLCountLabel = new QLabel(tr("Communication threshold"), algoGrp);
    maxSLCount = new QSpinBox(algoGrp);
    maxSLCount->setMinimum(1);
    maxSLCount->setMaximum(100000);
    connect(maxSLCount, SIGNAL(valueChanged(int)), 
            this, SLOT(maxSLCountChanged(int)));
    algoGLayout->addWidget( maxSLCountLabel, 2,0);
    algoGLayout->addWidget( maxSLCount,2,1);

    maxDomainCacheLabel = new QLabel(tr("Domain cache size"), algoGrp);
    maxDomainCache = new QSpinBox(algoGrp);
    maxDomainCache->setMinimum(1);
    maxDomainCache->setMaximum(100000);
    connect(maxDomainCache, SIGNAL(valueChanged(int)),
            this, SLOT(maxDomainCacheChanged(int)));
    algoGLayout->addWidget( maxDomainCacheLabel, 3,0);
    algoGLayout->addWidget( maxDomainCache, 3,1);

    workGroupSizeLabel = new QLabel(tr("Work group size"), algoGrp);
    workGroupSize = new QSpinBox(algoGrp);
    workGroupSize->setMinimum(2);
    workGroupSize->setMaximum(1000000);
    connect(workGroupSize, SIGNAL(valueChanged(int)),
            this, SLOT(workGroupSizeChanged(int)));
    algoGLayout->addWidget( workGroupSizeLabel, 4,0);
    algoGLayout->addWidget( workGroupSize, 4,1);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateWindow(bool doAll)
{

    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        switch(i)
        {
          case PoincareAttributes::ID_minPunctures:
            minPunctures->blockSignals(true);
            minPunctures->setValue(atts->GetMinPunctures());
            minPunctures->blockSignals(false);
            break;
          case PoincareAttributes::ID_maxPunctures:
            maxPunctures->blockSignals(true);
            maxPunctures->setValue(atts->GetMaxPunctures());
            maxPunctures->blockSignals(false);
            break;
          case PoincareAttributes::ID_puncturePlane:
            puncturePlaneButtonGroup->blockSignals(true);
            if(puncturePlaneButtonGroup->button((int)atts->GetPuncturePlane()) != 0)
                puncturePlaneButtonGroup->button((int)atts->GetPuncturePlane())->setChecked(true);
            puncturePlaneButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_sourceType:
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedPoint)
            {
                pointSource->setEnabled(true);
                pointSourceLabel->setEnabled(true);

                pointSource->show();
                pointSourceLabel->show();
            }
            else
            {
                pointSource->setEnabled(false);
                pointSourceLabel->setEnabled(false);

                pointSource->hide();
                pointSourceLabel->hide();
            }
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedLine)
            {
                lineStart->setEnabled(true);
                lineStartLabel->setEnabled(true);

                lineStartLabel->show();
                lineStart->show();

                lineEnd->setEnabled(true);
                lineEndLabel->setEnabled(true);

                lineEndLabel->show();
                lineEnd->show();

                pointDensity->setEnabled(true);
                pointDensityLabel->setEnabled(true);

                pointDensityLabel->show();
                pointDensity->show();
            }
            else
            {
                lineStart->setEnabled(false);
                lineStartLabel->setEnabled(false);

                lineStartLabel->hide();
                lineStart->hide();

                lineEnd->setEnabled(false);
                lineEndLabel->setEnabled(false);

                lineEndLabel->hide();
                lineEnd->hide();

                pointDensityLabel->setEnabled(false);
                pointDensity->setEnabled(false);

                pointDensityLabel->hide();
                pointDensity->hide();
            }

            sourceTypeCombo->blockSignals(true);
            sourceTypeCombo->setCurrentIndex((int)atts->GetSourceType());
            sourceTypeCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_velocitySource:
            velocitySource->setText(DoublesToQString(atts->GetVelocitySource(), 3));
            break;
          case PoincareAttributes::ID_pointSource:
            pointSource->setText(DoublesToQString(atts->GetPointSource(), 3));
            break;
          case PoincareAttributes::ID_lineStart:
            lineStart->setText(DoublesToQString(atts->GetLineStart(), 3));
            break;
          case PoincareAttributes::ID_lineEnd:
            lineEnd->setText(DoublesToQString(atts->GetLineEnd(), 3));
            break;
          case PoincareAttributes::ID_pointDensity:
            pointDensity->blockSignals(true);
            pointDensity->setValue(atts->GetPointDensity());
            pointDensity->blockSignals(false);
            break;

        case PoincareAttributes::ID_fieldType:
            // Update lots of widget visibility and enabled states.
            UpdateFieldAttributes();

            fieldType->blockSignals(true);
            fieldType->setCurrentIndex(atts->GetFieldType());
            fieldType->blockSignals(false);

            integrationType->blockSignals(true);
            if (atts->GetFieldType() == PoincareAttributes::M3DC12DField)
            {
              atts->SetIntegrationType(PoincareAttributes::M3DC12DIntegrator);
              integrationType->setCurrentIndex(PoincareAttributes::M3DC12DIntegrator);
              UpdateIntegrationAttributes();
            }
            else if (atts->GetFieldType() == PoincareAttributes::NIMRODField)
            {
              atts->SetIntegrationType(PoincareAttributes::AdamsBashforth);
              integrationType->setCurrentIndex(PoincareAttributes::AdamsBashforth);
              UpdateIntegrationAttributes();
            }
            else if (atts->GetIntegrationType() == PoincareAttributes::M3DC12DIntegrator) 
            {
              atts->SetIntegrationType(PoincareAttributes::DormandPrince);
              integrationType->setCurrentIndex(PoincareAttributes::DormandPrince);
              UpdateIntegrationAttributes();
            }
            integrationType->blockSignals(false);

            break;
        case PoincareAttributes::ID_fieldConstant:
            fieldConstant->setText(DoubleToQString(atts->GetFieldConstant()));
            break;
        case PoincareAttributes::ID_integrationType:
            // Update lots of widget visibility and enabled states.
            UpdateIntegrationAttributes();

            integrationType->blockSignals(true);
            integrationType->setCurrentIndex(atts->GetIntegrationType());
            integrationType->blockSignals(false);

            fieldType->blockSignals(true);
            if (atts->GetIntegrationType() == PoincareAttributes::M3DC12DIntegrator)
            {
              atts->SetFieldType(PoincareAttributes::M3DC12DField);
              fieldType->setCurrentIndex(PoincareAttributes::M3DC12DField);
              UpdateFieldAttributes();
            }
            else if (atts->GetFieldType() == PoincareAttributes::M3DC12DField)
            {
              atts->SetFieldType(PoincareAttributes::Default);
              fieldType->setCurrentIndex(PoincareAttributes::Default);
              UpdateFieldAttributes();
            }
            fieldType->blockSignals(false);

            break;
        case PoincareAttributes::ID_maxStepLength:
            maxStepLength->setText(DoubleToQString(atts->GetMaxStepLength()));
            break;
        case PoincareAttributes::ID_relTol:
            relTol->setText(DoubleToQString(atts->GetRelTol()));
            break;
        case PoincareAttributes::ID_absTolSizeType:
            absTolSizeType->blockSignals(true);
            absTolSizeType->setCurrentIndex((int) atts->GetAbsTolSizeType());
            absTolSizeType->blockSignals(false);
            if (atts->GetAbsTolSizeType() == PoincareAttributes::FractionOfBBox)
            {
                QString temp;
                temp.setNum(atts->GetAbsTolBBox());
                absTol->setText(temp);
            }
            if (atts->GetAbsTolSizeType() == PoincareAttributes::Absolute)
            {
                QString temp;
                temp.setNum(atts->GetAbsTolAbsolute());
                absTol->setText(temp);
            }
            break;
        case PoincareAttributes::ID_absTolBBox:
            if (atts->GetAbsTolSizeType() == PoincareAttributes::FractionOfBBox)
            {
                QString temp;
                temp.setNum(atts->GetAbsTolBBox());
                absTol->setText(temp);
            }
            break;
        case PoincareAttributes::ID_absTolAbsolute:
            if (atts->GetAbsTolSizeType() == PoincareAttributes::Absolute)
            {
                QString temp;
                temp.setNum(atts->GetAbsTolAbsolute());
                absTol->setText(temp);
            }
            break;
          case PoincareAttributes::ID_coordinateSystem:
//          coordinateButtonGroup->blockSignals(true);
//             coordinateButtonGroup->button(atts->GetCoordinateSystem())->setChecked(true);;
//             coordinateButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_analysis:
            analysisButtonGroup->blockSignals(true);
            analysisButtonGroup->button((int)atts->GetAnalysis())->setChecked(true);
            if(atts->GetAnalysis() == 0)
            {
              showLines->setChecked(false);
              showPoints->setChecked(true);

              atts->SetShowLines(false);
              atts->SetShowPoints(false);
            }

            analysisButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_maximumToroidalWinding:
            maximumToroidalWinding->blockSignals(true);
            maximumToroidalWinding->setValue(atts->GetMaximumToroidalWinding());
            maximumToroidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_overrideToroidalWinding:
            overrideToroidalWinding->blockSignals(true);
            overrideToroidalWinding->setValue(atts->GetOverrideToroidalWinding());
            overrideToroidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_overridePoloidalWinding:
            overridePoloidalWinding->blockSignals(true);
            overridePoloidalWinding->setValue(atts->GetOverridePoloidalWinding());
            overridePoloidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_windingPairConfidence:
            windingPairConfidence->setText(DoubleToQString(atts->GetWindingPairConfidence()));
            break;

          case PoincareAttributes::ID_rationalSurfaceFactor:
            rationalSurfaceFactor->setText(DoubleToQString(atts->GetRationalSurfaceFactor()));
            break;
          case PoincareAttributes::ID_adjustPlane:
            adjustPlane->blockSignals(true);
            adjustPlane->setValue(atts->GetAdjustPlane());
            adjustPlane->blockSignals(false);
            break;
          case PoincareAttributes::ID_overlaps:
            overlapsButtonGroup->blockSignals(true);
            if(overlapsButtonGroup->button((int)atts->GetOverlaps()) != 0)
                overlapsButtonGroup->button((int)atts->GetOverlaps())->setChecked(true);
            overlapsButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_meshType:
            UpdateMeshTypeAttributes();
            meshTypeCombo->blockSignals(true);
            meshTypeCombo->setCurrentIndex((int)atts->GetMeshType());
            meshTypeCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_numberPlanes:
            // Disconnect the slot before setting the toggle and
            // reconnect it after. This prevents multiple updates.
            disconnect(numberPlanes, SIGNAL(valueChanged(int)),
                       this, SLOT(numberPlanesChanged(int)));
            numberPlanes->setValue(atts->GetNumberPlanes());
            singlePlaneLabel->setEnabled( atts->GetNumberPlanes() == 1 );
            singlePlane->setEnabled( atts->GetNumberPlanes() == 1 );
            connect(numberPlanes, SIGNAL(valueChanged(int)),
                    this, SLOT(numberPlanesChanged(int)));
            break;
          case PoincareAttributes::ID_singlePlane:
            singlePlane->setText(DoubleToQString(atts->GetSinglePlane()));
            break;
          case PoincareAttributes::ID_min:
            min->setText(DoubleToQString(atts->GetMin()));
            break;
          case PoincareAttributes::ID_max:
            max->setText(DoubleToQString(atts->GetMax()));
            break;
          case PoincareAttributes::ID_minFlag:
            // Disconnect the slot before setting the toggle and
            // reconnect it after. This prevents multiple updates.
            disconnect(minFlag, SIGNAL(toggled(bool)),
                       this, SLOT(minFlagChanged(bool)));
            minFlag->setChecked(atts->GetMinFlag());
            min->setEnabled(atts->GetMinFlag());
            connect(minFlag, SIGNAL(toggled(bool)),
                    this, SLOT(minFlagChanged(bool)));
            break;
          case PoincareAttributes::ID_maxFlag:
            // Disconnect the slot before setting the toggle and
            // reconnect it after. This prevents multiple updates.
            disconnect(maxFlag, SIGNAL(toggled(bool)),
                       this, SLOT(maxFlagChanged(bool)));
            maxFlag->setChecked(atts->GetMaxFlag());
            max->setEnabled(atts->GetMaxFlag());
            connect(maxFlag, SIGNAL(toggled(bool)),
                    this, SLOT(maxFlagChanged(bool)));
            break;
          case PoincareAttributes::ID_singleColor:
            { // new scope
                QColor tempcolor = QColor(atts->GetSingleColor().Red(),
                                   atts->GetSingleColor().Green(),
                                   atts->GetSingleColor().Blue());
                singleColor->blockSignals(true);
                singleColor->setButtonColor(tempcolor);
                singleColor->blockSignals(false);
            }
            break;
          case PoincareAttributes::ID_colorTableName:
            colorTableName->blockSignals(true);
            colorTableName->setColorTable(QString(atts->GetColorTableName().c_str()));
            colorTableName->blockSignals(false);
            break;
          case PoincareAttributes::ID_opacity:
            opacitySlider->blockSignals(true);
            opacitySlider->setValue(int((float)atts->GetOpacity() * 255.f));
            opacitySlider->blockSignals(false);
            break;
          case PoincareAttributes::ID_opacityType:
            opacityButtons->blockSignals(true);
            opacityButtons->button(atts->GetOpacityType())->setChecked(true);
            opacitySlider->setEnabled(!atts->GetOpacityType());
//            opacitySliderLabel->setEnabled(!atts->GetOpacityType());
            opacityButtons->blockSignals(false);
            break;
           case PoincareAttributes::ID_dataValue:
            dataValueCombo->blockSignals(true);
            dataValueCombo->setCurrentIndex((int)atts->GetDataValue());

            if( (int) atts->GetDataValue() == 0 )
            {
              singleColorLabel->setEnabled(true);
              singleColorLabel->show();
              singleColor->setEnabled(true);
              singleColor->show();
              
              colorTableNameLabel->setEnabled(false);
              colorTableNameLabel->hide();
              colorTableName->setEnabled(false);
              colorTableName->hide();

              opacityButtonsLabel->setEnabled(false);
              opacityButtonSetExplicit->setEnabled(false);
              opacityButtonColorTable->setEnabled(false);
//            opacitySliderLabel->setEnabled(false);
              opacitySlider->setEnabled(false);
            }
            else
            {
              singleColorLabel->setEnabled(false);
              singleColorLabel->hide();
              singleColor->setEnabled(false);
              singleColor->hide();
              
              colorTableNameLabel->setEnabled(true);
              colorTableNameLabel->show();
              colorTableName->setEnabled(true);
              colorTableName->show();

              opacityButtonsLabel->setEnabled(true);
              opacityButtonSetExplicit->setEnabled(true);
              opacityButtonColorTable->setEnabled(true);
//            opacitySliderLabel->setEnabled(!atts->GetOpacityType());
              opacitySlider->setEnabled(!atts->GetOpacityType());
            }

            dataValueCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_showRationalSurfaces:
            showRationalSurfaces->blockSignals(true);
            showRationalSurfaces->setChecked(atts->GetShowRationalSurfaces());
            showRationalSurfaces->blockSignals(false);
            break;
          case PoincareAttributes::ID_RationalSurfaceMaxIterations:
            rationalSurfaceMaxIterations->blockSignals(true);
            rationalSurfaceMaxIterations->setValue(atts->GetRationalSurfaceMaxIterations());
            rationalSurfaceMaxIterations->blockSignals(false);
            break;
          case PoincareAttributes::ID_showOPoints:
            showOPoints->blockSignals(true);
            showOPoints->setChecked(atts->GetShowOPoints());
            showOPoints->blockSignals(false);
            break;
          case PoincareAttributes::ID_OPointMaxIterations:
            OPointMaxIterations->blockSignals(true);
            OPointMaxIterations->setValue(atts->GetOPointMaxIterations());
            OPointMaxIterations->blockSignals(false);
            break;
          case PoincareAttributes::ID_performOLineAnalysis:
            performOLineAnalysis->blockSignals(true);
            performOLineAnalysis->setChecked(atts->GetPerformOLineAnalysis());
            performOLineAnalysis->blockSignals(false);
            break;
          case PoincareAttributes::ID_OLineToroidalWinding:
            OLineToroidalWinding->blockSignals(true);
            OLineToroidalWinding->setValue(atts->GetOLineToroidalWinding());
            OLineToroidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_OLineAxisFileName:
            OLineAxisFileName->setText(QString(atts->GetOLineAxisFileName().c_str()));
            break;
          case PoincareAttributes::ID_showIslands:
            showIslands->blockSignals(true);
            showIslands->setChecked(atts->GetShowIslands());
            showIslands->blockSignals(false);
            break;
          case PoincareAttributes::ID_showChaotic:
            showChaotic->blockSignals(true);
            showChaotic->setChecked(atts->GetShowChaotic());
            showChaotic->blockSignals(false);
            break;
          case PoincareAttributes::ID_showLines:
            showLines->blockSignals(true);

            if(atts->GetAnalysis() == 0)
            {
              showLines->setChecked(false);
              atts->SetShowLines(false);
            }

            showLines->setChecked(atts->GetShowLines());
            lineWidthLabel->setEnabled( (atts->GetShowLines() == true ) );
            lineStyleLabel->setEnabled( (atts->GetShowLines() == true ) );
            lineWidth->setEnabled( (atts->GetShowLines() == true ) );
            lineStyle->setEnabled( (atts->GetShowLines() == true ) );
            showLines->blockSignals(false);
            break;
          case PoincareAttributes::ID_lineWidth:
            lineWidth->blockSignals(true);
            lineWidth->SetLineWidth(atts->GetLineWidth());
            lineWidth->blockSignals(false);
          case PoincareAttributes::ID_showPoints:
            showPoints->blockSignals(true);
            showPoints->setChecked(atts->GetShowPoints());
            pointControl->setEnabled( (atts->GetShowPoints() == true ) );
            showPoints->blockSignals(false);
            break;
          case PoincareAttributes::ID_pointSize:
            pointControl->blockSignals(true);
            pointControl->SetPointSize(atts->GetPointSize());
            pointControl->blockSignals(false);
            break;
        case PoincareAttributes::ID_pointSizePixels:
            pointControl->blockSignals(true);
            pointControl->SetPointSizePixels(atts->GetPointSizePixels());
            pointControl->blockSignals(false);
            break;
          case PoincareAttributes::ID_pointType:
            pointControl->blockSignals(true);
            pointControl->SetPointType(atts->GetPointType());
            pointControl->blockSignals(false);
            break;
          case PoincareAttributes::ID_show1DPlots:
            show1DPlots->blockSignals(true);
            show1DPlots->setChecked(atts->GetShow1DPlots());
            show1DPlots->blockSignals(false);
            break;
          case PoincareAttributes::ID_SummaryFlag:
            summaryFlag->blockSignals(true);
            summaryFlag->setChecked(atts->GetSummaryFlag());
            summaryFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_verboseFlag:
            verboseFlag->blockSignals(true);
            verboseFlag->setChecked(atts->GetVerboseFlag());
            verboseFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_legendFlag:
            legendToggle->blockSignals(true);
            legendToggle->setChecked(atts->GetLegendFlag());
            legendToggle->blockSignals(false);
            break;
          case PoincareAttributes::ID_lightingFlag:
            lightingToggle->blockSignals(true);
            lightingToggle->setChecked(atts->GetLightingFlag());
            lightingToggle->blockSignals(false);
            break;

        case PoincareAttributes::ID_streamlineAlgorithmType:
            UpdateAlgorithmAttributes();

            slAlgo->blockSignals(true);
            slAlgo->setCurrentIndex(atts->GetStreamlineAlgorithmType());
            slAlgo->blockSignals(false);
            break;
        case PoincareAttributes::ID_maxStreamlineProcessCount:
            maxSLCount->blockSignals(true);
            maxSLCount->setValue(atts->GetMaxStreamlineProcessCount());
            maxSLCount->blockSignals(false);
            break;
        case PoincareAttributes::ID_maxDomainCacheSize:
            maxDomainCache->blockSignals(true);
            maxDomainCache->setValue(atts->GetMaxDomainCacheSize());
            maxDomainCache->blockSignals(false);
            break;
        case PoincareAttributes::ID_workGroupSize:
            workGroupSize->blockSignals(true);
            workGroupSize->setValue(atts->GetWorkGroupSize());
            workGroupSize->blockSignals(false);
            break;

        case PoincareAttributes::ID_forceNodeCenteredData:
            forceNodal->blockSignals(true);
            forceNodal->setChecked(atts->GetForceNodeCenteredData());
            forceNodal->blockSignals(false);
            break;
        }
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::GetCurrentValues(int which_widget)
{
    bool doAll = (which_widget == -1);

    // Do velocitySource
    if(which_widget == PoincareAttributes::ID_velocitySource || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(velocitySource, val, 3))
            atts->SetVelocitySource(val);
        else
        {
            ResettingError(tr("Velocity Source"),
                DoublesToQString(atts->GetVelocitySource(),3));
            atts->SetVelocitySource(atts->GetVelocitySource());
        }
    }

    // Do pointSource
    if(which_widget == PoincareAttributes::ID_pointSource || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(pointSource, val, 3))
            atts->SetPointSource(val);
        else
        {
            ResettingError(tr("Point Source"),
                DoublesToQString(atts->GetPointSource(),3));
            atts->SetPointSource(atts->GetPointSource());
        }
    }

    // Do lineStart
    if(which_widget == PoincareAttributes::ID_lineStart || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(lineStart, val, 3))
            atts->SetLineStart(val);
        else
        {
            ResettingError(tr("Line Point Start"),
                DoublesToQString(atts->GetLineStart(),3));
            atts->SetLineStart(atts->GetLineStart());
        }
    }

    // Do lineEnd
    if(which_widget == PoincareAttributes::ID_lineEnd || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(lineEnd, val, 3))
            atts->SetLineEnd(val);
        else
        {
            ResettingError(tr("Line Point End"),
                DoublesToQString(atts->GetLineEnd(),3));
            atts->SetLineEnd(atts->GetLineEnd());
        }
    }

    // Do fieldConstant
    if(which_widget == PoincareAttributes::ID_fieldConstant || doAll)
    {
        double val;
        if(LineEditGetDouble(fieldConstant, val))
            atts->SetFieldConstant(val);
        else
        {
            ResettingError(tr("field constant"),
                DoubleToQString(atts->GetFieldConstant()));
            atts->SetFieldConstant(atts->GetFieldConstant());
        }
    }

    // Do maxStepLength
    if(which_widget == PoincareAttributes::ID_maxStepLength || doAll)
    {
        double val;
        if(LineEditGetDouble(maxStepLength, val))
            atts->SetMaxStepLength(val);
        else
        {
            ResettingError(tr("Maximum step length"),
                DoubleToQString(atts->GetMaxStepLength()));
            atts->SetMaxStepLength(atts->GetMaxStepLength());
        }
    }

    // Do relTol
    if(which_widget == PoincareAttributes::ID_relTol || doAll)
    {
        double val;
        if(LineEditGetDouble(relTol, val))
            atts->SetRelTol(val);
        else
        {
            ResettingError(tr("Relative tolerance"),
                DoubleToQString(atts->GetRelTol()));
            atts->SetRelTol(atts->GetRelTol());
        }
    }

    // Do absTol
    if ((which_widget == PoincareAttributes::ID_absTolBBox || doAll)
        && atts->GetAbsTolSizeType() == PoincareAttributes::FractionOfBBox)
    {
        double val;
        if(LineEditGetDouble(absTol, val))
            atts->SetAbsTolBBox(val);
        else
        {
            ResettingError(tr("absolute tolerance"),
                DoubleToQString(atts->GetAbsTolBBox()));
                atts->SetAbsTolBBox(atts->GetAbsTolBBox());
        }
    }
    if ((which_widget == PoincareAttributes::ID_absTolAbsolute || doAll)
        && atts->GetAbsTolSizeType() == PoincareAttributes::Absolute)
    {
        double val;
        if(LineEditGetDouble(absTol, val))
            atts->SetAbsTolAbsolute(val);
        else
        {
            ResettingError(tr("absolute tolerance"),
                DoubleToQString(atts->GetAbsTolAbsolute()));
                atts->SetAbsTolAbsolute(atts->GetAbsTolAbsolute());
        }
    }

    // Do windingPairConfidence
    if(which_widget == PoincareAttributes::ID_windingPairConfidence || doAll)
    {
        double val;
        if(LineEditGetDouble(windingPairConfidence, val))
            atts->SetWindingPairConfidence(val);
        else
        {
            ResettingError(tr("windingPairConfidence"),
                DoubleToQString(atts->GetWindingPairConfidence()));
            atts->SetWindingPairConfidence(atts->GetWindingPairConfidence());
        }
    }

    // Do rationalSurfaceFactor
    if(which_widget == PoincareAttributes::ID_rationalSurfaceFactor || doAll)
    {
        double val;
        if(LineEditGetDouble(rationalSurfaceFactor, val))
            atts->SetRationalSurfaceFactor(val);
        else
        {
            ResettingError(tr("rationalSurfaceFactor"),
                DoubleToQString(atts->GetRationalSurfaceFactor()));
            atts->SetRationalSurfaceFactor(atts->GetRationalSurfaceFactor());
        }
    }

    // Do singlePlane
    if(which_widget == PoincareAttributes::ID_singlePlane || doAll)
    {
        double val;
        if(LineEditGetDouble(singlePlane, val))
            atts->SetSinglePlane(val);
        else
        {
            ResettingError(tr("singlePlane"),
                IntToQString((int)(atts->GetSinglePlane())));
            atts->SetSinglePlane(atts->GetSinglePlane());
        }
    }

    // Do min
    if(which_widget == PoincareAttributes::ID_min || doAll)
    {
        double val;
        if(LineEditGetDouble(min, val))
            atts->SetMin(val);
        else
        {
            ResettingError(tr("min"),
                DoubleToQString(atts->GetMin()));
            atts->SetMin(atts->GetMin());
        }
    }

    // Do max
    if(which_widget == PoincareAttributes::ID_max || doAll)
    {
        double val;
        if(LineEditGetDouble(max, val))
            atts->SetMax(val);
        else
        {
            ResettingError(tr("max"),
                DoubleToQString(atts->GetMax()));
            atts->SetMax(atts->GetMax());
        }
    }

    // Do O-Line Axis File Name
    if(which_widget == PoincareAttributes::ID_OLineAxisFileName || doAll)
    {
      if( atts->GetPerformOLineAnalysis() )
      {
        QString val = OLineAxisFileName->text();
        if( val.length() )
            atts->SetOLineAxisFileName(val.toStdString());
        else
        {
            ResettingError(tr("OLineAxisFileName"),
                           QString(atts->GetOLineAxisFileName().c_str()));
            atts->SetOLineAxisFileName(atts->GetOLineAxisFileName());
        }
      }
    }

    if (doAll)
    {
        atts->SetPointSize(pointControl->GetPointSize());
        atts->SetPointSizePixels((int)pointControl->GetPointSizePixels());
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateMeshTypeAttributes
//
// Purpose: 
//   Updates the widgets for the various integration types.
//
// Programmer: Dave Pugmire
// Creation:   Fri Aug 1 16:41:38 EDT 2008
//
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateMeshTypeAttributes()
{
    //Turn off everything.
    singlePlaneLabel->hide();
    singlePlane->hide();
    adjustPlaneLabel->hide();
    adjustPlane->hide();

    switch( atts->GetMeshType() )
    {
    case PoincareAttributes::Curves:
        singlePlaneLabel->show();
        singlePlane->show();
        break;

    case PoincareAttributes::Surfaces:
        adjustPlaneLabel->show();
        adjustPlane->show();
        break;
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateFieldAttributes
//
// Purpose: 
//   Updates the widgets for the various field types.
//
// Programmer: Dave Pugmire
// Creation:   Thu Jul 31 14:41:00 EDT 2008
//
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateFieldAttributes()
{
    switch( atts->GetFieldType() )
    {
    case PoincareAttributes::M3DC12DField:
      if( atts->GetIntegrationType() ==
          PoincareAttributes::M3DC12DIntegrator ) 
        TurnOn(fieldConstant, fieldConstantLabel);
      else
        TurnOff(fieldConstant, fieldConstantLabel);

      TurnOff(velocitySource, velocitySourceLabel);

      break;

    case PoincareAttributes::FlashField:
      TurnOn(fieldConstant, fieldConstantLabel);
      TurnOn(velocitySource, velocitySourceLabel);
      break;

    case PoincareAttributes::NIMRODField:
    default:
      TurnOff(fieldConstant, fieldConstantLabel);
      TurnOff(velocitySource, velocitySourceLabel);

      break;
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateIntegrationAttributes
//
// Purpose: 
//   Updates the widgets for the various integration types.
//
// Programmer: Dave Pugmire
// Creation:   Thu Jul 31 14:41:00 EDT 2008
//
// Modifications:
//
//   Dave Pugmire, Fri Aug 8 16:27:03 EDT 2008
//   Change the step label text based on the integration method.
//
//   Hank Childs, Wed Sep 29 20:22:36 PDT 2010
//   Add support for limiting the maximum time step.
//
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateIntegrationAttributes()
{
    //Turn off everything.
    maxStepLength->hide();
    maxStepLengthLabel->hide();
    limitMaxTimeStep->hide();
    maxTimeStep->hide();
    relTol->hide();
    relTolLabel->hide();
    absTol->hide();
    absTolLabel->hide();
    absTolSizeType->hide();

    switch( atts->GetIntegrationType() )
    {
    case PoincareAttributes::Euler:
    case PoincareAttributes::Leapfrog:
        maxStepLength->show();
        maxStepLengthLabel->show();
      break;

    case PoincareAttributes::DormandPrince:
        limitMaxTimeStep->show();
        maxTimeStep->show();
        relTol->show();
        relTolLabel->show();
        absTol->show();
        absTolLabel->show();
        absTolSizeType->show();
        break;

    case PoincareAttributes::AdamsBashforth:
    case PoincareAttributes::M3DC12DIntegrator:
        maxStepLength->show();
        maxStepLengthLabel->show();
        absTol->show();
        absTolLabel->show();
        absTolSizeType->show();
        break;

    default:
        break;
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateAlgorithmAttributes
//
// Purpose: 
//   Updates the widgets for the various integration types.
//
// Programmer: Dave Pugmire
// Creation:   Fri Aug 1 16:41:38 EDT 2008
//
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateAlgorithmAttributes()
{
    //Turn off everything.
    maxDomainCacheLabel->hide();
    maxDomainCache->hide();
    maxSLCountLabel->hide();
    maxSLCount->hide();
    workGroupSizeLabel->hide();
    workGroupSize->hide();

    switch( atts->GetStreamlineAlgorithmType() )
    {
      case PoincareAttributes::LoadOnDemand:
        maxDomainCacheLabel->show();
        maxDomainCache->show();
        break;
    case PoincareAttributes::ParallelStaticDomains:
        maxSLCountLabel->show();
        maxSLCount->show();
        break;

    case PoincareAttributes::MasterSlave:
        maxDomainCacheLabel->show();
        maxDomainCache->show();
        maxSLCountLabel->show();
        maxSLCount->show();
        workGroupSizeLabel->show();
        workGroupSize->show();
        break;
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::Apply
//
// Purpose: 
//   Called to apply changes in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::Apply(bool ignore)
{
    if(AutoUpdate() || ignore)
    {
        GetCurrentValues(-1);
        atts->Notify();

        GetViewerMethods()->SetPlotOptions(plotType);
    }
    else
        atts->Notify();
}


//
// Qt Slot functions
//


// ****************************************************************************
// Method: QvisPoincarePlotWindow::apply
//
// Purpose: 
//   Qt slot function called when apply button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::apply()
{
    Apply(true);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::makeDefault
//
// Purpose: 
//   Qt slot function called when "Make default" button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::makeDefault()
{
    GetCurrentValues(-1);
    atts->Notify();
    GetViewerMethods()->SetDefaultPlotOptions(plotType);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::reset
//
// Purpose: 
//   Qt slot function called when reset button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::reset()
{
    GetViewerMethods()->ResetPlotOptions(plotType);
}


void
QvisPoincarePlotWindow::sourceTypeChanged(int val)
{
    if(val != atts->GetSourceType())
    {
        atts->SetSourceType(PoincareAttributes::SourceType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::velocitySourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_velocitySource);
    Apply();
}


void
QvisPoincarePlotWindow::pointSourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_pointSource);
    Apply();
}


void
QvisPoincarePlotWindow::lineStartProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineStart);
    Apply();
}


void
QvisPoincarePlotWindow::lineEndProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineEnd);
    Apply();
}


void
QvisPoincarePlotWindow::pointDensityChanged(int val)
{
    atts->SetPointDensity(val);
    Apply();
}


void
QvisPoincarePlotWindow::minPuncturesChanged(int val)
{
    atts->SetMinPunctures(val);
    Apply();
}


void
QvisPoincarePlotWindow::maxPuncturesChanged(int val)
{
    atts->SetMaxPunctures(val);
    Apply();
}


void
QvisPoincarePlotWindow::puncturePlaneChanged(int val)
{
    if(val != atts->GetPuncturePlane())
    {
        atts->SetPuncturePlane(PoincareAttributes::PuncturePlaneType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::fieldTypeChanged(int val)
 {
    if(val != atts->GetFieldType())
    {
        atts->SetFieldType(PoincareAttributes::FieldType(val));
        Apply();
    }
}   


void
QvisPoincarePlotWindow::fieldConstantProccessText()
{
    GetCurrentValues(PoincareAttributes::ID_fieldConstant);
    Apply();
}


void
QvisPoincarePlotWindow::integrationTypeChanged(int val)
{
    if(val == 4) // Unused 
        Apply();
    
    else if(val != atts->GetIntegrationType())
    {
        atts->SetIntegrationType(PoincareAttributes::IntegrationType(val));
        Apply();
    }

}


void
QvisPoincarePlotWindow::maxStepLengthProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxStepLength);
    Apply();
}


void
QvisPoincarePlotWindow::limitMaxTimeStepChanged(bool val)
{
    atts->SetLimitMaximumTimestep(val);
    Apply();
}


void
QvisPoincarePlotWindow::maxTimeStepProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxTimeStep);
    Apply();
}


void
QvisPoincarePlotWindow::relTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_relTol);
    Apply();
}


void
QvisPoincarePlotWindow::absTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_absTolBBox);
    GetCurrentValues(PoincareAttributes::ID_absTolAbsolute);
    Apply();
}


void
QvisPoincarePlotWindow::absTolSizeTypeChanged(int val)
{
    atts->SetAbsTolSizeType((PoincareAttributes::SizeType) val);
    Apply();
}


void
QvisPoincarePlotWindow::coordinateButtonGroupChanged(int val)
{
//     switch( val )
//     {
//         case 0:
//        atts->SetCoordinateSystem(PoincareAttributes::Cartesian);
//        break;
//         case 1:
//        atts->SetCoordinateSystem(PoincareAttributes::Cylindrical);
//        break;
//     }
//     Apply();
}

void
QvisPoincarePlotWindow::analysisChanged(int val)
{
    if(val != atts->GetAnalysis())
    {
        atts->SetAnalysis(PoincareAttributes::AnalysisType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::maximumToroidalWindingChanged(int val)
{
    atts->SetMaximumToroidalWinding(val);
    Apply();
}


void
QvisPoincarePlotWindow::overrideToroidalWindingChanged(int val)
{
    atts->SetOverrideToroidalWinding(val);
    Apply();
}


void
QvisPoincarePlotWindow::overridePoloidalWindingChanged(int val)
{
    atts->SetOverridePoloidalWinding(val);
    Apply();
}


void
QvisPoincarePlotWindow::windingPairConfidenceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_windingPairConfidence);
    Apply();
}


void
QvisPoincarePlotWindow::rationalSurfaceFactorProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_rationalSurfaceFactor);
    Apply();
}


void
QvisPoincarePlotWindow::overlapsChanged(int val)
{
    if(val != atts->GetOverlaps())
    {
        atts->SetOverlaps(PoincareAttributes::OverlapType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::meshTypeChanged(int val)
{
    if(val != atts->GetMeshType())
    {
        atts->SetMeshType(PoincareAttributes::ShowMeshType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::numberPlanesChanged(int val)
{
    atts->SetNumberPlanes(val);
    Apply();
}


void
QvisPoincarePlotWindow::singlePlaneProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_singlePlane);
    Apply();
}


void
QvisPoincarePlotWindow::adjustPlaneChanged(int val)
{
    atts->SetAdjustPlane(val);
    Apply();
}


void
QvisPoincarePlotWindow::minProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_min);
    Apply();
}


void
QvisPoincarePlotWindow::maxProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_max);
    Apply();
}


void
QvisPoincarePlotWindow::minFlagChanged(bool val)
{
    atts->SetMinFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::maxFlagChanged(bool val)
{
    atts->SetMaxFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::colorTypeChanged(int val)
{
    if(val != atts->GetColorType())
    {
        atts->SetColorType(PoincareAttributes::ColoringMethod(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::singleColorChanged(const QColor &color)
{
    ColorAttribute temp(color.red(), color.green(), color.blue());
    atts->SetSingleColor(temp);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::colorTableNameChanged(bool useDefault,
                                              const QString &ctName)
{
    atts->SetColorTableName(ctName.toStdString());
    SetUpdate(false);
    Apply();
}

void
QvisPoincarePlotWindow::setOpaacityClicked(int opacity)
{
    // Only do it if it changed.
    if(opacity != atts->GetOpacityType())
    {
        atts->SetOpacityType(PoincareAttributes::Opacity(opacity));
//        opacitySliderLabel->setEnabled(!opacity);
        opacitySlider->setEnabled(!opacity);
        Apply();
    }
}

void
QvisPoincarePlotWindow::changedOpacity(int opacity, const void*)
{
    atts->SetOpacity((float)opacity/255.);
    Apply();
}

void
QvisPoincarePlotWindow::dataValueChanged(int val)
{
    if(val != atts->GetDataValue())
    {
        atts->SetDataValue(PoincareAttributes::DataValue(val));
        atts->SetColorType(PoincareAttributes::ColoringMethod(val?1:0));
        Apply();
    }
}


void
QvisPoincarePlotWindow::showRationalSurfacesChanged(bool val)
{
    atts->SetShowRationalSurfaces(val);
    Apply();
}


void
QvisPoincarePlotWindow::rationalSurfaceMaxIterationsChanged(int val)
{
    atts->SetRationalSurfaceMaxIterations(val);
    Apply();
}


void
QvisPoincarePlotWindow::showOPointsChanged(bool val)
{
    atts->SetShowOPoints(val);
    Apply();
}


void
QvisPoincarePlotWindow::OPointMaxIterationsChanged(int val)
{
    atts->SetOPointMaxIterations(val);
    Apply();
}


void
QvisPoincarePlotWindow::performOLineAnalysisChanged(bool val)
{
    atts->SetPerformOLineAnalysis(val);
    Apply();
}


void
QvisPoincarePlotWindow::OLineToroidalWindingChanged(int val)
{
    atts->SetOLineToroidalWinding(val);
    Apply();
}


void
QvisPoincarePlotWindow::OLineAxisFileNameProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_OLineAxisFileName);
    Apply();
}

void
QvisPoincarePlotWindow::OLineAxisFileDialogButtonClicked()
{
    QString fileName =
        QFileDialog::getOpenFileName(this, tr("Open O-Line Axis Point File"),
                                 "",
                                 tr(""));

    OLineAxisFileName->setText(fileName);

    GetCurrentValues(PoincareAttributes::ID_OLineAxisFileName);
    Apply();
}


void
QvisPoincarePlotWindow::showIslandsChanged(bool val)
{
    atts->SetShowIslands(val);
    Apply();
}


void
QvisPoincarePlotWindow::showChaoticChanged(bool val)
{
    atts->SetShowChaotic(val);
    Apply();
}


void
QvisPoincarePlotWindow::showLinesChanged(bool val)
{
    atts->SetShowLines(val);
    Apply();
}


void
QvisPoincarePlotWindow::show1DPlotsChanged(bool val)
{
    atts->SetShow1DPlots(val);
    Apply();
}


void
QvisPoincarePlotWindow::showPointsChanged(bool val)
{
    atts->SetShowPoints(val);
    Apply();
}


void
QvisPoincarePlotWindow::summaryFlagChanged(bool val)
{
    atts->SetSummaryFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::verboseFlagChanged(bool val)
{
    atts->SetVerboseFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::legendToggled(bool val)
{
    atts->SetLegendFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::lightingToggled(bool val)
{
    atts->SetLightingFlag(val);
    SetUpdate(false);
    Apply();
}

void
QvisPoincarePlotWindow::streamlineAlgorithmChanged(int val)
{
    if(val != atts->GetStreamlineAlgorithmType())
    {
        atts->SetStreamlineAlgorithmType(PoincareAttributes::StreamlineAlgorithmType(val));
        Apply();
    }
}

void
QvisPoincarePlotWindow::maxSLCountChanged(int val)
{
    atts->SetMaxStreamlineProcessCount(val);
    Apply();
}

void
QvisPoincarePlotWindow::maxDomainCacheChanged(int val)
{
    atts->SetMaxDomainCacheSize(val);
    Apply();
}

void
QvisPoincarePlotWindow::workGroupSizeChanged(int val)
{
    atts->SetWorkGroupSize(val);
    Apply();
}

void
QvisPoincarePlotWindow::pointSizePixelsChanged(int val)
{
    atts->SetPointSizePixels(val);
    Apply();
}

void
QvisPoincarePlotWindow::pointTypeChanged(int val)
{
    atts->SetPointType((PoincareAttributes::PointType)val);
    SetUpdate(false);
    Apply();
}

void
QvisPoincarePlotWindow::pointSizeChanged(double val)
{
    atts->SetPointSize(val); 
    Apply();
}


void
QvisPoincarePlotWindow::lineWidthChanged(int val)
{
    atts->SetLineWidth(val);
    SetUpdate(false);
    Apply();
}

void
QvisPoincarePlotWindow::lineStyleChanged(int val)
{
    atts->SetLineStyle(val);
    SetUpdate(false);
    Apply();
}

void
QvisPoincarePlotWindow::forceNodalChanged(bool val)
{
    atts->SetForceNodeCenteredData(val);
    Apply();
}



static void
TurnOn(QWidget *w0, QWidget *w1)
{
    if (w0)
    {
        w0->setEnabled(true);
        w0->show();
    }
    if (w1)
    {
        w1->setEnabled(true);
        w1->show();
    }
}

static void
TurnOff(QWidget *w0, QWidget *w1)
{
    if (w0)
    {
        w0->setEnabled(false);
        w0->hide();
    }
    if (w1)
    {
        w1->setEnabled(false);
        w1->hide();
    }
}
