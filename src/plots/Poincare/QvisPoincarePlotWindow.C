/*****************************************************************************
*
* Copyright (c) 2000 - 2009, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400124
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisPoincarePlotWindow.h"

#include <PoincareAttributes.h>
#include <ViewerProxy.h>

#include <QTabWidget>
#include <QCheckBox>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QSpinBox>
#include <QButtonGroup>
#include <QComboBox>
#include <QGroupBox>
#include <QRadioButton>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineStyleWidget.h>
#include <QvisLineWidthWidget.h>
#include <QvisVariableButton.h>

#include <stdio.h>
#include <string>

using std::string;

// ****************************************************************************
// Method: QvisPoincarePlotWindow::QvisPoincarePlotWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::QvisPoincarePlotWindow(const int type,
                         PoincareAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisPostableWindowObserver(subj, caption, shortName, notepad)
{
    plotType = type;
    atts = subj;
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::~QvisPoincarePlotWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::~QvisPoincarePlotWindow()
{
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::CreateWindowContents()
{
    propertyTabs = new QTabWidget(central);
    topLayout->addWidget(propertyTabs);

    // ----------------------------------------------------------------------
    // First tab
    // ----------------------------------------------------------------------
    firstTab = new QWidget(central);
    propertyTabs->addTab(firstTab, tr("Streamlines"));
    
    QGridLayout *mainLayout = new QGridLayout(firstTab);

    // Create the punctures group box.
    QGroupBox *puncturesGroup = new QGroupBox(central);
    puncturesGroup->setTitle(tr("Punctures"));
    mainLayout->addWidget(puncturesGroup, 0, 0, 1, 2);
//    mainLayout->setStretchFactor(puncturesGroup, 100);
    QGridLayout *puncturesLayout = new QGridLayout(puncturesGroup);
    puncturesLayout->setSpacing(10);

    minPuncturesLabel = new QLabel(tr("Minimum"), central);
    puncturesLayout->addWidget(minPuncturesLabel,0,0);
    minPunctures = new QLineEdit(central);
    connect(minPunctures, SIGNAL(returnPressed()),
            this, SLOT(minPuncturesProcessText()));
    puncturesLayout->addWidget(minPunctures, 0, 1);

    maxPuncturesLabel = new QLabel(tr("Maximum"), central);
    puncturesLayout->addWidget(maxPuncturesLabel,1,0);
    maxPunctures = new QLineEdit(central);
    connect(maxPunctures, SIGNAL(returnPressed()),
            this, SLOT(maxPuncturesProcessText()));
    puncturesLayout->addWidget(maxPunctures, 1, 1);

   // Create the source group box.
    QGroupBox *sourceGroup = new QGroupBox(central);
    sourceGroup->setTitle(tr("Source"));
    mainLayout->addWidget(sourceGroup, 1, 0, 1, 2);
//    mainLayout->setStretchFactor(sourceGroup, 100);
    QGridLayout *sourceLayout = new QGridLayout(sourceGroup);
    sourceLayout->setSpacing(10);

    sourceTypeLabel = new QLabel(tr("Streamline Source"), central);
    sourceLayout->addWidget(sourceTypeLabel, 0, 0);

    sourceTypeCombo = new QComboBox(firstTab);
    sourceTypeCombo->addItem(tr("Point"));
    sourceTypeCombo->addItem(tr("Line"));
    connect(sourceTypeCombo, SIGNAL(activated(int)),
           this, SLOT(sourceTypeChanged(int)));
    sourceLayout->addWidget(sourceTypeCombo, 0, 1);



    pointSourceLabel = new QLabel(tr("Location"), central);
    sourceLayout->addWidget(pointSourceLabel, 1, 0);
    pointSource = new QLineEdit(central);
    connect(pointSource, SIGNAL(returnPressed()),
            this, SLOT(pointSourceProcessText()));
    sourceLayout->addWidget(pointSource, 1, 1, 1, 2);



    lineStartLabel = new QLabel(tr("Start Point"), central);
    sourceLayout->addWidget(lineStartLabel, 1, 0);
    lineStart = new QLineEdit(central);
    connect(lineStart, SIGNAL(returnPressed()),
            this, SLOT(lineStartProcessText()));
    sourceLayout->addWidget(lineStart, 1, 1, 1, 2);

    lineEndLabel = new QLabel(tr("End Point"), central);
    sourceLayout->addWidget(lineEndLabel, 2, 0);
    lineEnd = new QLineEdit(central);
    connect(lineEnd, SIGNAL(returnPressed()),
            this, SLOT(lineEndProcessText()));
    sourceLayout->addWidget(lineEnd, 2, 1, 1, 2);

    pointDensityLabel = new QLabel(tr("Point density"), central);
    sourceLayout->addWidget(pointDensityLabel, 3, 0);
    pointDensity = new QLineEdit(central);
    connect(pointDensity, SIGNAL(returnPressed()),
            this, SLOT(pointDensityProcessText()));
    sourceLayout->addWidget(pointDensity, 3, 1, 1, 2);





   // Create the integration group box.
    QGroupBox *integrationGroup = new QGroupBox(central);
    integrationGroup->setTitle(tr("Integration"));
    mainLayout->addWidget(integrationGroup, 2, 0, 1, 2);
//    mainLayout->setStretchFactor(integrationGroup, 100);
    QGridLayout *integrationLayout = new QGridLayout(integrationGroup);
    integrationLayout->setSpacing(10);

    integrationTypeLabel = new QLabel(tr("Integrator:"), central);
    integrationLayout->addWidget(integrationTypeLabel,0,0);

    integrationTypeCombo = new QComboBox(firstTab);
    integrationTypeCombo->addItem(tr("DormandPrince"));
    integrationTypeCombo->addItem(tr("AdamsBashforth"));
    integrationTypeCombo->addItem(tr("M3DC1Integrator"));
    connect(integrationTypeCombo, SIGNAL(activated(int)),
           this, SLOT(integrationTypeChanged(int)));
    integrationLayout->addWidget(integrationTypeCombo, 0, 1);

    maxStepLengthLabel = new QLabel(tr("maximum step length"), central);
    integrationLayout->addWidget(maxStepLengthLabel,1,0);
    maxStepLength = new QLineEdit(central);
    connect(maxStepLength, SIGNAL(returnPressed()),
            this, SLOT(maxStepLengthProcessText()));
    integrationLayout->addWidget(maxStepLength, 1,1);

    relTolLabel = new QLabel(tr("rel. tolerance"), central);
    integrationLayout->addWidget(relTolLabel,2,0);
    relTol = new QLineEdit(central);
    connect(relTol, SIGNAL(returnPressed()),
            this, SLOT(relTolProcessText()));
    integrationLayout->addWidget(relTol, 2,1);

    absTolLabel = new QLabel(tr("abs. tolerance"), central);
    integrationLayout->addWidget(absTolLabel,3,0);
    absTol = new QLineEdit(central);
    connect(absTol, SIGNAL(returnPressed()),
            this, SLOT(absTolProcessText()));
    integrationLayout->addWidget(absTol, 3,1);

    // ----------------------------------------------------------------------
    // Second tab
    // ----------------------------------------------------------------------
    secondTab = new QWidget(central);
    propertyTabs->addTab(secondTab, tr("Analysis"));
    
    mainLayout = new QGridLayout(secondTab);

    maxToroidalWindingLabel = new QLabel(tr("Max Toroidal Winding"), central);
    mainLayout->addWidget(maxToroidalWindingLabel,0,0);
    maxToroidalWinding = new QLineEdit(central);
    connect(maxToroidalWinding, SIGNAL(returnPressed()),
            this, SLOT(maxToroidalWindingProcessText()));
    mainLayout->addWidget(maxToroidalWinding, 0,1);

    overrideToroidalWindingLabel = new QLabel(tr("Override Toroidal Winding"), central);
    mainLayout->addWidget(overrideToroidalWindingLabel,1,0);
    overrideToroidalWinding = new QLineEdit(central);
    connect(overrideToroidalWinding, SIGNAL(returnPressed()),
            this, SLOT(overrideToroidalWindingProcessText()));
    mainLayout->addWidget(overrideToroidalWinding, 1,1);

    hitRateLabel = new QLabel(tr("Hit Rate"), central);
    mainLayout->addWidget(hitRateLabel,2,0);
    hitRate = new QLineEdit(central);
    connect(hitRate, SIGNAL(returnPressed()),
            this, SLOT(hitRateProcessText()));
    mainLayout->addWidget(hitRate, 2,1);

    adjustPlaneLabel = new QLabel(tr("Adjust Plane"), central);
    mainLayout->addWidget(adjustPlaneLabel,3,0);
    adjustPlane = new QLineEdit(central);
    connect(adjustPlane, SIGNAL(returnPressed()),
            this, SLOT(adjustPlaneProcessText()));
    mainLayout->addWidget(adjustPlane, 3,1);

    overlapsLabel = new QLabel(tr("Overlaps"), central);
    mainLayout->addWidget(overlapsLabel,4,0, Qt::AlignTop);
    overlaps = new QWidget(central);
    overlapsButtonGroup= new QButtonGroup(overlaps);
    QHBoxLayout *overlapsLayout = new QHBoxLayout(overlaps);
    overlapsLayout->setMargin(0);
    overlapsLayout->setSpacing(10);
    QRadioButton *overlapsOverlapTypeRaw = new QRadioButton(tr("Raw"), overlaps);
    overlapsButtonGroup->addButton(overlapsOverlapTypeRaw,0);
    overlapsLayout->addWidget(overlapsOverlapTypeRaw);
    QRadioButton *overlapsOverlapTypeRemove = new QRadioButton(tr("Remove"), overlaps);
    overlapsButtonGroup->addButton(overlapsOverlapTypeRemove,1);
    overlapsLayout->addWidget(overlapsOverlapTypeRemove);
    QRadioButton *overlapsOverlapTypeMerge = new QRadioButton(tr("Merge"), overlaps);
    overlapsButtonGroup->addButton(overlapsOverlapTypeMerge,2);
    overlapsLayout->addWidget(overlapsOverlapTypeMerge);
    QRadioButton *overlapsOverlapTypeSmooth = new QRadioButton(tr("Smooth"), overlaps);
    overlapsButtonGroup->addButton(overlapsOverlapTypeSmooth,3);
    overlapsLayout->addWidget(overlapsOverlapTypeSmooth);
    connect(overlapsButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(overlapsChanged(int)));
    mainLayout->addWidget(overlaps, 4,1, Qt::AlignTop);

    // ----------------------------------------------------------------------
    // Third tab
    // ----------------------------------------------------------------------
    thirdTab = new QWidget(central);
    propertyTabs->addTab(thirdTab, tr("Display"));
    
    mainLayout = new QGridLayout(thirdTab);

    // Create the display group box.
    QGroupBox *displayGroup = new QGroupBox(central);
    displayGroup->setTitle(tr("Display"));
    mainLayout->addWidget(displayGroup, 0, 0);
//    mainLayout->setStretchFactor(displayGroup, 100);
    QGridLayout *displayLayout = new QGridLayout(displayGroup);
    displayLayout->setSpacing(10);

    meshTypeLabel = new QLabel(tr("Mesh:"), central);
    displayLayout->addWidget(meshTypeLabel,0,0);

    meshTypeCombo = new QComboBox(thirdTab);
    meshTypeCombo->addItem(tr("Curves"));
    meshTypeCombo->addItem(tr("Surfaces"));
    connect(meshTypeCombo, SIGNAL(activated(int)),
           this, SLOT(meshTypeChanged(int)));
    displayLayout->addWidget(meshTypeCombo, 0, 1);

    numberPlanesLabel = new QLabel(tr("Number of planes"), central);
    displayLayout->addWidget(numberPlanesLabel,1,0);
    numberPlanes = new QLineEdit(central);
    connect(numberPlanes, SIGNAL(returnPressed()),
            this, SLOT(numberPlanesProcessText()));
    displayLayout->addWidget(numberPlanes, 1,1);

   // Create the limits group box.
    QGroupBox *limitsGroup = new QGroupBox(central);
    limitsGroup->setTitle(tr("Limits"));
    mainLayout->addWidget(limitsGroup, 1, 0);
//    mainLayout->setStretchFactor(limitsGroup, 100);
    QGridLayout *limitsLayout = new QGridLayout(limitsGroup);
    limitsLayout->setSpacing(10);


    minFlag = new QCheckBox(tr("Minimum"), central);
    limitsLayout->addWidget(minFlag, 0, 0);
    connect(minFlag, SIGNAL(toggled(bool)),
            this, SLOT(minFlagChanged(bool)));
    min = new QLineEdit(central);
    connect(min, SIGNAL(returnPressed()),
            this, SLOT(minProcessText()));
    limitsLayout->addWidget(min, 0, 1);

    maxFlag = new QCheckBox(tr("Maximum"), central);
    connect(maxFlag, SIGNAL(toggled(bool)),
            this, SLOT(maxFlagChanged(bool)));
    limitsLayout->addWidget(maxFlag, 0, 2);

    max = new QLineEdit(central);
    connect(max, SIGNAL(returnPressed()),
            this, SLOT(maxProcessText()));
    limitsLayout->addWidget(max, 0, 3);


   // Create the color group box.
    QGroupBox *colorGroup = new QGroupBox(central);
    colorGroup->setTitle(tr("Color"));
    mainLayout->addWidget(colorGroup, 2, 0);
//    mainLayout->setStretchFactor(colorGroup, 100);
    QGridLayout *colorLayout = new QGridLayout(colorGroup);
    colorLayout->setSpacing(10);


//     colorTypeLabel = new QLabel(tr("Color type"), central);
//     colorLayout->addWidget(colorTypeLabel,6,0);
    colorType = new QWidget(central);
    colorTypeButtonGroup= new QButtonGroup(colorType);
    QVBoxLayout *colorTypeLayout = new QVBoxLayout(colorType);
    colorTypeLayout->setMargin(0);
    colorTypeLayout->setSpacing(10);
    QRadioButton *colorTypeSingleColor = new QRadioButton(tr("Single"), colorType);
    colorTypeButtonGroup->addButton(colorTypeSingleColor,0);
    colorTypeLayout->addWidget(colorTypeSingleColor);
    QRadioButton *colorTypeColorTable = new QRadioButton(tr("Color Table"), colorType);
    colorTypeButtonGroup->addButton(colorTypeColorTable,1);
    colorTypeLayout->addWidget(colorTypeColorTable);
    connect(colorTypeButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(colorTypeChanged(int)));
    colorLayout->addWidget(colorType, 6, 0, 2, 1);

    singleColor = new QvisColorButton(central);
    connect(singleColor, SIGNAL(selectedColor(const QColor&)),
            this, SLOT(singleColorChanged(const QColor&)));
    colorLayout->addWidget(singleColor, 6, 1, Qt::AlignLeft);

    colorTableName = new QvisColorTableButton(central);
    connect(colorTableName, SIGNAL(selectedColorTable(bool, const QString&)),
            this, SLOT(colorTableNameChanged(bool, const QString&)));
    colorLayout->addWidget(colorTableName, 7, 1, Qt::AlignLeft);


    colorByLabel = new QLabel(tr("Color by:"), central);
    colorLayout->addWidget(colorByLabel,8,0);

    colorByCombo = new QComboBox(thirdTab);
    colorByCombo->addItem(tr("OriginalValue"));
    colorByCombo->addItem(tr("InputOrder"));
    colorByCombo->addItem(tr("PointIndex"));
    colorByCombo->addItem(tr("Plane"));
    colorByCombo->addItem(tr("WindingOrder"));
    colorByCombo->addItem(tr("WindingPointOrder"));
    colorByCombo->addItem(tr("ToroidalWindings"));
    colorByCombo->addItem(tr("PoloidalWindings"));
    colorByCombo->addItem(tr("SafetyFactor"));
    colorByCombo->addItem(tr("Confidence"));
    colorByCombo->addItem(tr("RidgelineVariance"));
    connect(integrationTypeCombo, SIGNAL(activated(int)),
           this, SLOT(colorByChanged(int)));
    colorLayout->addWidget(colorByCombo, 8, 1);


   // Create the options group box.
    QGroupBox *optionsGroup = new QGroupBox(central);
    optionsGroup->setTitle(tr("Options"));
    mainLayout->addWidget(optionsGroup, 3, 0);
//    mainLayout->setStretchFactor(optionsGroup, 100);
    QGridLayout *optionsLayout = new QGridLayout(optionsGroup);
    optionsLayout->setSpacing(10);

    showIslands = new QCheckBox(tr("Show Islands"), central);
    connect(showIslands, SIGNAL(toggled(bool)),
            this, SLOT(showIslandsChanged(bool)));
    optionsLayout->addWidget(showIslands, 0, 0);

    showLines = new QCheckBox(tr("Show Lines"), central);
    connect(showLines, SIGNAL(toggled(bool)),
            this, SLOT(showLinesChanged(bool)));
    optionsLayout->addWidget(showLines, 0, 1);

    showPoints = new QCheckBox(tr("Show Points"), central);
    connect(showPoints, SIGNAL(toggled(bool)),
            this, SLOT(showPointsChanged(bool)));
    optionsLayout->addWidget(showPoints, 0, 2);

    verboseFlag = new QCheckBox(tr("verbose"), central);
    connect(verboseFlag, SIGNAL(toggled(bool)),
            this, SLOT(verboseFlagChanged(bool)));
    optionsLayout->addWidget(verboseFlag, 0, 3);

    legendFlag = new QCheckBox(tr("Legend"), central);
    connect(legendFlag, SIGNAL(toggled(bool)),
            this, SLOT(legendFlagChanged(bool)));
    optionsLayout->addWidget(legendFlag, 0, 4);

    lightingFlag = new QCheckBox(tr("Lighting"), central);
    connect(lightingFlag, SIGNAL(toggled(bool)),
            this, SLOT(lightingFlagChanged(bool)));
    optionsLayout->addWidget(lightingFlag, 0, 5);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateWindow(bool doAll)
{

    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        switch(i)
        {
          case PoincareAttributes::ID_minPunctures:
            minPunctures->setText(DoubleToQString(atts->GetMinPunctures()));
            break;
          case PoincareAttributes::ID_maxPunctures:
            maxPunctures->setText(DoubleToQString(atts->GetMaxPunctures()));
            break;
          case PoincareAttributes::ID_sourceType:
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedPoint)
            {
                pointSource->setEnabled(true);
                pointSourceLabel->setEnabled(true);

                pointSource->show();
                pointSourceLabel->show();
            }
            else
            {
                pointSource->setEnabled(false);
                pointSourceLabel->setEnabled(false);

                pointSource->hide();
                pointSourceLabel->hide();
            }
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedLine)
            {
                lineStart->setEnabled(true);
                lineStartLabel->setEnabled(true);

                lineStartLabel->show();
                lineStart->show();

                lineEnd->setEnabled(true);
                lineEndLabel->setEnabled(true);

                lineEndLabel->show();
                lineEnd->show();

                pointDensity->setEnabled(true);
                pointDensityLabel->setEnabled(true);

                pointDensityLabel->show();
                pointDensity->show();
            }
            else
            {
                lineStart->setEnabled(false);
                lineStartLabel->setEnabled(false);

                lineStartLabel->hide();
                lineStart->hide();

                lineEnd->setEnabled(false);
                lineEndLabel->setEnabled(false);

                lineEndLabel->hide();
                lineEnd->hide();

                pointDensityLabel->setEnabled(false);
                pointDensity->setEnabled(false);

                pointDensityLabel->hide();
                pointDensity->hide();
            }

            sourceTypeCombo->blockSignals(true);
            sourceTypeCombo->setCurrentIndex((int)atts->GetSourceType());
            sourceTypeCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_pointSource:
            pointSource->setText(DoublesToQString(atts->GetPointSource(), 3));
            break;
          case PoincareAttributes::ID_lineStart:
            lineStart->setText(DoublesToQString(atts->GetLineStart(), 3));
            break;
          case PoincareAttributes::ID_lineEnd:
            lineEnd->setText(DoublesToQString(atts->GetLineEnd(), 3));
            break;
          case PoincareAttributes::ID_pointDensity:
            pointDensity->setText(IntToQString(atts->GetPointDensity()));
            break;
          case PoincareAttributes::ID_integrationType:
            integrationTypeCombo->blockSignals(true);
            integrationTypeCombo->setCurrentIndex((int)atts->GetIntegrationType());
            integrationTypeCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_maxStepLength:
            maxStepLength->setText(DoubleToQString(atts->GetMaxStepLength()));
            break;
          case PoincareAttributes::ID_relTol:
            relTol->setText(DoubleToQString(atts->GetRelTol()));
            break;
          case PoincareAttributes::ID_absTol:
            absTol->setText(DoubleToQString(atts->GetAbsTol()));
            break;
          case PoincareAttributes::ID_maxToroidalWinding:
            maxToroidalWinding->setText(IntToQString(atts->GetMaxToroidalWinding()));
            break;
          case PoincareAttributes::ID_overrideToroidalWinding:
            overrideToroidalWinding->setText(IntToQString(atts->GetOverrideToroidalWinding()));
            break;
          case PoincareAttributes::ID_hitRate:
            hitRate->setText(DoubleToQString(atts->GetHitRate()));
            break;
          case PoincareAttributes::ID_adjustPlane:
            adjustPlane->setText(IntToQString(atts->GetAdjustPlane()));
            break;
          case PoincareAttributes::ID_overlaps:
            overlapsButtonGroup->blockSignals(true);
            if(overlapsButtonGroup->button((int)atts->GetOverlaps()) != 0)
                overlapsButtonGroup->button((int)atts->GetOverlaps())->setChecked(true);
            overlapsButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_meshType:
            meshTypeCombo->blockSignals(true);
            meshTypeCombo->setCurrentIndex((int)atts->GetMeshType());
            meshTypeCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_numberPlanes:
            numberPlanes->setText(IntToQString(atts->GetNumberPlanes()));
            break;
          case PoincareAttributes::ID_min:
            min->setText(DoubleToQString(atts->GetMin()));
            break;
          case PoincareAttributes::ID_max:
            max->setText(DoubleToQString(atts->GetMax()));
            break;
          case PoincareAttributes::ID_minFlag:
            // Disconnect the slot before setting the toggle and
            // reconnect it after. This prevents multiple updates.
            disconnect(minFlag, SIGNAL(toggled(bool)),
                       this, SLOT(minFlagChanged(bool)));
            minFlag->setChecked(atts->GetMinFlag());
            min->setEnabled(atts->GetMinFlag());
            connect(minFlag, SIGNAL(toggled(bool)),
                    this, SLOT(minFlagChanged(bool)));
            break;
          case PoincareAttributes::ID_maxFlag:
            // Disconnect the slot before setting the toggle and
            // reconnect it after. This prevents multiple updates.
            disconnect(maxFlag, SIGNAL(toggled(bool)),
                       this, SLOT(maxFlagChanged(bool)));
            maxFlag->setChecked(atts->GetMaxFlag());
            max->setEnabled(atts->GetMaxFlag());
            connect(maxFlag, SIGNAL(toggled(bool)),
                    this, SLOT(maxFlagChanged(bool)));
            break;
          case PoincareAttributes::ID_colorType:
            colorTypeButtonGroup->blockSignals(true);
            if(colorTypeButtonGroup->button((int)atts->GetColorType()) != 0)
                colorTypeButtonGroup->button((int)atts->GetColorType())->setChecked(true);

            if (atts->GetColorType() == PoincareAttributes::ColorBySingleColor)
            {
                singleColor->setEnabled(true);
                colorTableName->setEnabled(false);
                colorByCombo->setEnabled(false);
                colorByLabel->setEnabled(false);
            }
            else
            {
                singleColor->setEnabled(false);
                colorTableName->setEnabled(true);
                colorByCombo->setEnabled(true);
                colorByLabel->setEnabled(true);
            }
            colorTypeButtonGroup->blockSignals(false);
            break;
          case PoincareAttributes::ID_singleColor:
            { // new scope
                QColor tempcolor = QColor(atts->GetSingleColor().Red(),
                                   atts->GetSingleColor().Green(),
                                   atts->GetSingleColor().Blue());
                singleColor->blockSignals(true);
                singleColor->setButtonColor(tempcolor);
                singleColor->blockSignals(false);
            }
            break;
          case PoincareAttributes::ID_colorTableName:
            colorTableName->blockSignals(true);
            colorTableName->setColorTable(QString(atts->GetColorTableName().c_str()));
            colorTableName->blockSignals(false);
            break;
          case PoincareAttributes::ID_colorBy:
            colorByCombo->blockSignals(true);
            colorByCombo->setCurrentIndex((int)atts->GetColorBy());
            colorByCombo->blockSignals(false);
            break;
          case PoincareAttributes::ID_showIslands:
            showIslands->blockSignals(true);
            showIslands->setChecked(atts->GetShowIslands());
            showIslands->blockSignals(false);
            break;
          case PoincareAttributes::ID_showLines:
            showLines->blockSignals(true);
            showLines->setChecked(atts->GetShowLines());
            showLines->blockSignals(false);
            break;
          case PoincareAttributes::ID_showPoints:
            showPoints->blockSignals(true);
            showPoints->setChecked(atts->GetShowPoints());
            showPoints->blockSignals(false);
            break;
          case PoincareAttributes::ID_verboseFlag:
            verboseFlag->blockSignals(true);
            verboseFlag->setChecked(atts->GetVerboseFlag());
            verboseFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_legendFlag:
            legendFlag->blockSignals(true);
            legendFlag->setChecked(atts->GetLegendFlag());
            legendFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_lightingFlag:
            lightingFlag->blockSignals(true);
            lightingFlag->setChecked(atts->GetLightingFlag());
            lightingFlag->blockSignals(false);
            break;
        }
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::GetCurrentValues(int which_widget)
{
    bool doAll = (which_widget == -1);

    // Do minPunctures
    if(which_widget == PoincareAttributes::ID_minPunctures || doAll)
    {
        double val;
        if(LineEditGetDouble(minPunctures, val))
            atts->SetMinPunctures(val);
        else
        {
            ResettingError(tr("Minimum number of Punctures"),
                DoubleToQString(atts->GetMinPunctures()));
            atts->SetMinPunctures(atts->GetMinPunctures());
        }
    }

    // Do maxPunctures
    if(which_widget == PoincareAttributes::ID_maxPunctures || doAll)
    {
        double val;
        if(LineEditGetDouble(maxPunctures, val))
            atts->SetMaxPunctures(val);
        else
        {
            ResettingError(tr("Maximum number of Punctures"),
                DoubleToQString(atts->GetMaxPunctures()));
            atts->SetMaxPunctures(atts->GetMaxPunctures());
        }
    }

    // Do pointSource
    if(which_widget == PoincareAttributes::ID_pointSource || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(pointSource, val, 3))
            atts->SetPointSource(val);
        else
        {
            ResettingError(tr("Point Source"),
                DoublesToQString(atts->GetPointSource(),3));
            atts->SetPointSource(atts->GetPointSource());
        }
    }

    // Do lineStart
    if(which_widget == PoincareAttributes::ID_lineStart || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(lineStart, val, 3))
            atts->SetLineStart(val);
        else
        {
            ResettingError(tr("Line Point Start"),
                DoublesToQString(atts->GetLineStart(),3));
            atts->SetLineStart(atts->GetLineStart());
        }
    }

    // Do lineEnd
    if(which_widget == PoincareAttributes::ID_lineEnd || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(lineEnd, val, 3))
            atts->SetLineEnd(val);
        else
        {
            ResettingError(tr("Line Point End"),
                DoublesToQString(atts->GetLineEnd(),3));
            atts->SetLineEnd(atts->GetLineEnd());
        }
    }

    // Do pointDensity
    if(which_widget == PoincareAttributes::ID_pointDensity || doAll)
    {
        int val;
        if(LineEditGetInt(pointDensity, val))
            atts->SetPointDensity(val);
        else
        {
            ResettingError(tr("Point density"),
                IntToQString(atts->GetPointDensity()));
            atts->SetPointDensity(atts->GetPointDensity());
        }
    }

    // Do maxStepLength
    if(which_widget == PoincareAttributes::ID_maxStepLength || doAll)
    {
        double val;
        if(LineEditGetDouble(maxStepLength, val))
            atts->SetMaxStepLength(val);
        else
        {
            ResettingError(tr("maximum step length"),
                DoubleToQString(atts->GetMaxStepLength()));
            atts->SetMaxStepLength(atts->GetMaxStepLength());
        }
    }

    // Do relTol
    if(which_widget == PoincareAttributes::ID_relTol || doAll)
    {
        double val;
        if(LineEditGetDouble(relTol, val))
            atts->SetRelTol(val);
        else
        {
            ResettingError(tr("rel. tolerance"),
                DoubleToQString(atts->GetRelTol()));
            atts->SetRelTol(atts->GetRelTol());
        }
    }

    // Do absTol
    if(which_widget == PoincareAttributes::ID_absTol || doAll)
    {
        double val;
        if(LineEditGetDouble(absTol, val))
            atts->SetAbsTol(val);
        else
        {
            ResettingError(tr("abs. tolerance"),
                DoubleToQString(atts->GetAbsTol()));
            atts->SetAbsTol(atts->GetAbsTol());
        }
    }

    // Do maxToroidalWinding
    if(which_widget == PoincareAttributes::ID_maxToroidalWinding || doAll)
    {
        int val;
        if(LineEditGetInt(maxToroidalWinding, val))
            atts->SetMaxToroidalWinding(val);
        else
        {
            ResettingError(tr("maxToroidalWinding"),
                IntToQString(atts->GetMaxToroidalWinding()));
            atts->SetMaxToroidalWinding(atts->GetMaxToroidalWinding());
        }
    }

    // Do overrideToroidalWinding
    if(which_widget == PoincareAttributes::ID_overrideToroidalWinding || doAll)
    {
        int val;
        if(LineEditGetInt(overrideToroidalWinding, val))
            atts->SetOverrideToroidalWinding(val);
        else
        {
            ResettingError(tr("overrideToroidalWinding"),
                IntToQString(atts->GetOverrideToroidalWinding()));
            atts->SetOverrideToroidalWinding(atts->GetOverrideToroidalWinding());
        }
    }

    // Do hitRate
    if(which_widget == PoincareAttributes::ID_hitRate || doAll)
    {
        double val;
        if(LineEditGetDouble(hitRate, val))
            atts->SetHitRate(val);
        else
        {
            ResettingError(tr("hitRate"),
                DoubleToQString(atts->GetHitRate()));
            atts->SetHitRate(atts->GetHitRate());
        }
    }

    // Do adjustPlane
    if(which_widget == PoincareAttributes::ID_adjustPlane || doAll)
    {
        int val;
        if(LineEditGetInt(adjustPlane, val))
            atts->SetAdjustPlane(val);
        else
        {
            ResettingError(tr("adjustPlane"),
                IntToQString(atts->GetAdjustPlane()));
            atts->SetAdjustPlane(atts->GetAdjustPlane());
        }
    }

    // Do numberPlanes
    if(which_widget == PoincareAttributes::ID_numberPlanes || doAll)
    {
        int val;
        if(LineEditGetInt(numberPlanes, val))
            atts->SetNumberPlanes(val);
        else
        {
            ResettingError(tr("numberPlanes"),
                IntToQString(atts->GetNumberPlanes()));
            atts->SetNumberPlanes(atts->GetNumberPlanes());
        }
    }

    // Do min
    if(which_widget == PoincareAttributes::ID_min || doAll)
    {
        double val;
        if(LineEditGetDouble(min, val))
            atts->SetMin(val);
        else
        {
            ResettingError(tr("min"),
                DoubleToQString(atts->GetMin()));
            atts->SetMin(atts->GetMin());
        }
    }

    // Do max
    if(which_widget == PoincareAttributes::ID_max || doAll)
    {
        double val;
        if(LineEditGetDouble(max, val))
            atts->SetMax(val);
        else
        {
            ResettingError(tr("max"),
                DoubleToQString(atts->GetMax()));
            atts->SetMax(atts->GetMax());
        }
    }

}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::Apply
//
// Purpose: 
//   Called to apply changes in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::Apply(bool ignore)
{
    if(AutoUpdate() || ignore)
    {
        GetCurrentValues(-1);
        atts->Notify();

        GetViewerMethods()->SetPlotOptions(plotType);
    }
    else
        atts->Notify();
}


//
// Qt Slot functions
//


// ****************************************************************************
// Method: QvisPoincarePlotWindow::apply
//
// Purpose: 
//   Qt slot function called when apply button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::apply()
{
    Apply(true);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::makeDefault
//
// Purpose: 
//   Qt slot function called when "Make default" button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::makeDefault()
{
    GetCurrentValues(-1);
    atts->Notify();
    GetViewerMethods()->SetDefaultPlotOptions(plotType);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::reset
//
// Purpose: 
//   Qt slot function called when reset button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::reset()
{
    GetViewerMethods()->ResetPlotOptions(plotType);
}


void
QvisPoincarePlotWindow::minPuncturesProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_minPunctures);
    Apply();
}


void
QvisPoincarePlotWindow::maxPuncturesProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxPunctures);
    Apply();
}


void
QvisPoincarePlotWindow::sourceTypeChanged(int val)
{
    if(val != atts->GetSourceType())
    {
        atts->SetSourceType(PoincareAttributes::SourceType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::pointSourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_pointSource);
    Apply();
}


void
QvisPoincarePlotWindow::lineStartProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineStart);
    Apply();
}


void
QvisPoincarePlotWindow::lineEndProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineEnd);
    Apply();
}


void
QvisPoincarePlotWindow::pointDensityProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_pointDensity);
    Apply();
}


void
QvisPoincarePlotWindow::integrationTypeChanged(int val)
{
    if(val != atts->GetIntegrationType())
    {
        atts->SetIntegrationType(PoincareAttributes::IntegrationType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::maxStepLengthProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxStepLength);
    Apply();
}


void
QvisPoincarePlotWindow::relTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_relTol);
    Apply();
}


void
QvisPoincarePlotWindow::absTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_absTol);
    Apply();
}


void
QvisPoincarePlotWindow::maxToroidalWindingProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxToroidalWinding);
    Apply();
}


void
QvisPoincarePlotWindow::overrideToroidalWindingProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_overrideToroidalWinding);
    Apply();
}


void
QvisPoincarePlotWindow::hitRateProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_hitRate);
    Apply();
}


void
QvisPoincarePlotWindow::adjustPlaneProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_adjustPlane);
    Apply();
}


void
QvisPoincarePlotWindow::overlapsChanged(int val)
{
    if(val != atts->GetOverlaps())
    {
        atts->SetOverlaps(PoincareAttributes::OverlapType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::meshTypeChanged(int val)
{
    if(val != atts->GetMeshType())
    {
        atts->SetMeshType(PoincareAttributes::ShowMeshType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::numberPlanesProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_numberPlanes);
    Apply();
}


void
QvisPoincarePlotWindow::minProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_min);
    Apply();
}


void
QvisPoincarePlotWindow::maxProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_max);
    Apply();
}


void
QvisPoincarePlotWindow::minFlagChanged(bool val)
{
    atts->SetMinFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::maxFlagChanged(bool val)
{
    atts->SetMaxFlag(val);
    Apply();
}


void
QvisPoincarePlotWindow::colorTypeChanged(int val)
{
    if(val != atts->GetColorType())
    {
        atts->SetColorType(PoincareAttributes::ColoringMethod(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::singleColorChanged(const QColor &color)
{
    ColorAttribute temp(color.red(), color.green(), color.blue());
    atts->SetSingleColor(temp);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::colorTableNameChanged(bool useDefault, const QString &ctName)
{
    atts->SetColorTableName(ctName.toStdString());
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::colorByChanged(int val)
{
    if(val != atts->GetColorBy())
    {
        atts->SetColorBy(PoincareAttributes::ColorBy(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::showIslandsChanged(bool val)
{
    atts->SetShowIslands(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::showLinesChanged(bool val)
{
    atts->SetShowLines(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::showPointsChanged(bool val)
{
    atts->SetShowPoints(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::verboseFlagChanged(bool val)
{
    atts->SetVerboseFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::legendFlagChanged(bool val)
{
    atts->SetLegendFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::lightingFlagChanged(bool val)
{
    atts->SetLightingFlag(val);
    SetUpdate(false);
    Apply();
}


