Target: xml2atts
Function: ChangesRequireRecalculation
Declaration: bool ChangesRequireRecalculation(const MeshAttributes &, const int);
Definition:
// ****************************************************************************
//  Modifications:
//
//    Kathleen Bonnell, Wed Aug 22 16:00:32 PDT 2001
//    Changing opaque mode no longer requires recalculation.
//
//    Jeremy Meredith, Mon Dec  9 16:30:54 PST 2002
//    Added smoothing level.
//
//    Jeremy Meredith, Fri Dec 20 11:33:43 PST 2002
//    Added point size variable and its enabled flag.
//
//    Hank Childs, Thu Aug 21 23:05:45 PDT 2003
//    Added point type.
//
//    Kathleen Bonnell, Thu Feb  5 13:07:06 PST 2004
//    Added spatDim argument, added showInternal.
//
//    Kathleen Bonnell, Tue Nov  2 10:32:21 PST 2004
//    Removed point type and point size from test, changed pointSizeVar test
//    so that only true if changes require adding new secondary varaible.
//
//    Kathleen Biagas, Thu Apr 23 13:14:51 PDT 2015
//    Removed never-used oulineOnly and errorTolerance atts.
//
//    Kathleen Biagas, Wed Jun  10 10:00:03 PDT 2020
//    Added test for changing point type.
//
// ****************************************************************************

bool
MeshAttributes::ChangesRequireRecalculation(const MeshAttributes &obj,
                                            const int spatDim)
{
    PointGlyphAttributes pga = obj.GetPointAtts();
    std::string newPointSizeVar = pga.GetPointSizeVar();
    bool needSecondaryVar = (pga.GetPointSizeVarEnabled() &&
                            ((pointAtts.GetPointSizeVar() != newPointSizeVar) &&
                             (newPointSizeVar != "default") &&
                             (newPointSizeVar != "") &&
                             (newPointSizeVar != "\0")));

    // Certain point type changes require a recalculation.
    bool currentPointTypeIsPoint = pointAtts.GetPointType() == Point;
    bool newPointTypeIsPoint     = pga.GetPointType()  == Point;

    bool changingPointType =  pointAtts.GetPointType() != pga.GetPointType() &&
                              currentPointTypeIsPoint != newPointTypeIsPoint;

    return ( needSecondaryVar || changingPointType ||
            (smoothingLevel != obj.smoothingLevel) ||
            (showInternal != obj.showInternal && spatDim == 3));
}

Function: ProcessOldVersions
Declaration: virtual void ProcessOldVersions(DataNode *parentNode, const char *configVersion);
Definition:
// ****************************************************************************
// Method: MeshAttributes::ProcessOldVersions
//
// Purpose:
//   This method allows handling of older config/session files that may
//   contain fields that are no longer present or have been modified/renamed.
//
// Programmer: Kathleen Biagas 
// Creation:   August 8, 2023
//
// ****************************************************************************

#include <visit-config.h>
#ifdef VIEWER
#include <avtCallback.h>
#endif

void
VolumeAttributes::ProcessOldVersions(DataNode *parentNode,
                                     const char *configVersion)
{
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("MeshAttributes");
    if(searchNode == 0)
        return;

#if VISIT_OBSOLETE_AT_VERSION(3,5,0)
#error This code is obsolete in this version of VisIt and should be removed.
#else
    if (VersionLessThan(configVersion, "3.4.0"))
    {
        DataNode *dn = nullptr;
        PointGlyphAttributes pga;
        bool addPointAtts = false;
        if (searchNode->GetNode("pointSize") != nullptr)
        {
#ifdef VIEWER
            avtCallback::IssueWarning(DeprecationMessage("pointSize", "3.5.0"));
#endif
            double dVal = dn->AsDouble();
            pga.SetPointSize(dVal);
            addPointAtts = true;
            searchNode->RemoveNode("compactVariable", true);
        }
        if (searchNode->GetNode("pointSizeVarEnabled") != nullptr)
        {
#ifdef VIEWER
            avtCallback::IssueWarning(DeprecationMessage("pointSizeVarEnabled", "3.5.0"));
#endif
            int iVal = dn->AsInt();
            pga.SetPointSizeVarEnabled(iVal);
            addPointAtts = true;
            searchNode->RemoveNode("pointSizeVarEnabled", true);
        }
        if (searchNode->GetNode("pointSizeVar") != nullptr)
        {
#ifdef VIEWER
            avtCallback::IssueWarning(DeprecationMessage("pointSizeVar", "3.5.0"));
#endif
            std::string sVal = dn->AsString();
            pga.SetPointSizeVar(sVal);
            addPointAtts = true;
            searchNode->RemoveNode("pointSizeVar", true);
        }
        if (searchNode->GetNode("pointType") != nullptr)
        {
#ifdef VIEWER
            avtCallback::IssueWarning(DeprecationMessage("pointType", "3.5.0"));
#endif
            int iVal = dn->AsInt();
            pga.SetPointType(iVal);
            addPointAtts = true;
            searchNode->RemoveNode("pointType", true);
        }
        if (searchNode->GetNode("pointSizePixels") != nullptr)
        {
#ifdef VIEWER
            avtCallback::IssueWarning(DeprecationMessage("pointSizePixels", "3.5.0"));
#endif
            int iVal = dn->AsInt();
            pga.SetPointSizePixels(iVal);
            addPointAtts = true;
            searchNode->RemoveNode("pointSizePixels", true);
        }
        if(addPointAtts)
        {
             // preserve old behavior turn off autoSize
             pga.SetAutoSizeEnabled(false);
             pga.CreateNode(searchNode, true,true);
        }
    }
#endif
}


Target: xml2info
Function: MeshViewerEnginePluginInfo::InitializePlotAtts
Declaration: virtual void InitializePlotAtts(AttributeSubject *atts, const avtPlotMetaData &);
Definition:
// ****************************************************************************
//  Method: MeshViewerEnginePluginInfo::InitializePlotAtts
//
//  Purpose:
//    Initialize the plot attributes to the default attributes.
//
//  Programmer: Mark C. Miller 
//  Creation:   November 3, 2020
// ****************************************************************************
#include <avtPlotMetaData.h>

void
MeshViewerEnginePluginInfo::InitializePlotAtts(AttributeSubject *atts,
    const avtPlotMetaData &plot)
{
    *(MeshAttributes*)atts = *defaultAtts;
    SetAutonomousColors(atts,
        plot.GetBackgroundColor(), plot.GetForegroundColor());
}

Function: MeshViewerEnginePluginInfo::SetAutonomousColors
Declaration: void SetAutonomousColors(AttributeSubject *, double const *, double const *);
Definition:
// ****************************************************************************
//  Method: MeshViewerEnginePluginInfo::SetAutonomousColors
//
//  Purpose:
//    Sets the color for any autonomous color selection modes 
//
//  Programmer: Mark C. Miller 
//  Creation:   November 3, 2020
// ****************************************************************************
#include <avtColorTables.h>

void
MeshViewerEnginePluginInfo::SetAutonomousColors(AttributeSubject *atts,
    double const *bgColor, double const *fgColor)
{
    MeshAttributes *meshAtts = (MeshAttributes *)atts;
    bool attsChanged = false;

    unsigned char bg[3] = {static_cast<unsigned char>(bgColor[0]*255),
                           static_cast<unsigned char>(bgColor[1]*255),
                           static_cast<unsigned char>(bgColor[2]*255)};
    unsigned char fg[3] = {static_cast<unsigned char>(fgColor[0]*255),
                           static_cast<unsigned char>(fgColor[1]*255),
                           static_cast<unsigned char>(fgColor[2]*255)};

    if (meshAtts->GetOpaqueColorSource() == MeshAttributes::OpaqueRandom)
    {
        unsigned char rgb[3] = {bg[0], bg[1], bg[2]};

        // deconflict opaque color with foreground
        avtColorTables *ct = avtColorTables::Instance();
        if (!ct->GetJNDControlPointColor(ct->GetDefaultDiscreteColorTable(),
                                            "MeshColor", fg, rgb))
            ct->GetJNDControlPointColor("distinct", "MeshColor", fg, rgb);

        ColorAttribute c(rgb[0], rgb[1], rgb[2]);
        meshAtts->SetOpaqueColor(c);
        attsChanged = true;
    }

    if (meshAtts->GetMeshColorSource() == MeshAttributes::MeshRandom)
    {
        unsigned char rgb[3] = {fg[0], fg[1], fg[2]};
        ColorAttribute opqc = meshAtts->GetOpaqueColor();

        // deconflict mesh (lines) color with opaque color
        avtColorTables *ct = avtColorTables::Instance();
        if (!ct->GetJNDControlPointColor(ct->GetDefaultDiscreteColorTable(),
                                            "MeshColor", opqc.GetColor(), rgb))
            ct->GetJNDControlPointColor("distinct", "MeshColor", opqc.GetColor(), rgb);

        ColorAttribute c(rgb[0], rgb[1], rgb[2]);
        meshAtts->SetMeshColor(c);
        attsChanged = true;
    }

    // Ensure GUI reflects any color choices made here
    if (attsChanged)
        SetClientAtts(atts);
}



Target: xml2python
Code: PyMeshAttributes_getattr
Prefix:
Postfix:
#include <visit-config.h>

#if VISIT_OBSOLETE_AT_VERSION(3,5,0)
#error This code is obsolete in this version of VisIt and should be removed.
#else
    // Try and handle legacy fields
#define NAME_CHANGE_MESSAGE2(oldname, newname) \
    PyErr_WarnFormat(NULL, 1, "'%s' is no longer a valid Volume attribute.\n" \
                    "It's name has been changed to '%s', " \
                    "please update your script.\n", oldname, newname);

    // point type enums here?
    if((strcmp(name, "Box") == 0) ||
       (strcmp(name, "Axis") == 0) ||
       (strcmp(name, "Icosahedron") == 0) ||
       (strcmp(name, "Octahedron") == 0) ||
       (strcmp(name, "Tetrahedron") == 0) ||
       (strcmp(name, "SphereGeometry") == 0) ||
       (strcmp(name, "Point") == 0) ||
       (strcmp(name, "Sphere") == 0))
    {
        std::string nn = "pointAtts." + std::string(name);
        NAME_CHANGE_MESSAGE2(name, nn);
        GlyphType gtype;
        GlyphType_FromString(name, gtype);
        return PyInt_FromLong(int(gtype)); 
    }
#endif



Code: PyMeshAttributes_setattr
Prefix:
Postfix:
#if VISIT_OBSOLETE_AT_VERSION(3,5,0)
#error This code is obsolete in this version of VisIt. Please remove it
#else
#define NAME_CHANGE_MESSAGE(oldname, newname) \
    PyErr_WarnFormat(NULL, 1, "'%s' is no longer a valid Volume attribute.\n" \
                    "It's name has been changed to '%s', " \
                    "please update your script.\n", oldname, newname);

    // Try and handle legacy fields
    if(obj == &NULL_PY_OBJ)
    {
        PointGlyphAttributes *pga = PyPointGlyphAttributes_FromPyObject(
            MeshAttributes_GetPointAtts(self, args));
        bool setPointAtts = true;
        if(strcmp(name, "pointSize") == 0)
        {
            NAME_CHANGE_MESSAGE(name, "pointAtts.pointSize");
            pga->SetPointSize(PyFloat_AsDouble(args));
        }
        else if(strcmp(name, "pointSizeVarEnabled") == 0)
        {
            NAME_CHANGE_MESSAGE(name, "pointAtts.pointSizeVarEnabled");
            pga->SetPointSizeVarEnabled(bool(PyLong_AsLong(args)));
        }
        else if(strcmp(name, "pointSizeVar") == 0)
        {
            NAME_CHANGE_MESSAGE(name, "pointAtts.pointSizeVar");
            pga->SetPointSizeVar(std::string(PyUnicode_AsUTF8(args)));
        }
        else if(strcmp(name, "pointType") == 0)
        {
            NAME_CHANGE_MESSAGE(name, "pointAtts.pointType");
            pga->SetPointType(GlyphType(PyLong_AsLong(args)));
        }
        else if(strcmp(name, "pointSizePixels") == 0)
        {
            NAME_CHANGE_MESSAGE(name, "pointAtts.pointSizePixels");
            pga->SetPointSizePixels(int(PyLong_AsLong(args)));
        }
        else
        {
            setPointAtts = false;
        }
        if(setPointAtts)
        {
            // handling legacy, turn off autoSize.
            pga->SetAutoSizeEnabled(false);
            PyObject *tup = PyTuple_New(1);
            PyTuple_SetItem(tup, 0,  PyPointGlyphAttributes_Wrap(pga));
            obj = MeshAttributes_SetPointAtts(self, tup);
        }
    }
#endif



