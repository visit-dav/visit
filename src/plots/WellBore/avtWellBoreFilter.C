/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                              avtWellBoreFilter.C                              //
// ************************************************************************* //

#include <avtWellBoreFilter.h>

#include <vtkCellArray.h>
#include <vtkDataSet.h>
#include <vtkFieldData.h>
#include <vtkFloatArray.h>
#include <vtkMath.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>

#include <snprintf.h>

#include <DebugStream.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static int cylinder_quality_levels[4] = {
    3,
    5,
    9,
    17
};

// ****************************************************************************
//  Method: avtWellBoreFilter constructor
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Aug 27 14:59:19 PST 2008
//
// ****************************************************************************

avtWellBoreFilter::avtWellBoreFilter(WellBoreAttributes &wb_atts)
{
    atts = wb_atts;

    CalculateCylPts();
}


// ****************************************************************************
//  Method: avtWellBoreFilter destructor
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Aug 27 14:59:19 PST 2008
//
// ****************************************************************************

avtWellBoreFilter::~avtWellBoreFilter()
{
    for (int detail=0; detail<MAX_DETAIL_LEVELS; detail++)
        delete [] cyl_pts[detail];

    return;
}


// ****************************************************************************
//  Method: avtWellBoreFilter::SetAttributes
//
//  Purpose:
//      Sets the attributes for this filter.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Aug 27 14:59:19 PST 2008
//
// ****************************************************************************

void
avtWellBoreFilter::SetAttributes(const WellBoreAttributes &wb_atts)
{
    atts = wb_atts;
}


// ****************************************************************************
//  Method: avtWellBoreFilter::ExecuteData
//
//  Purpose:
//      Does the actual VTK code to modify the dataset.
//
//  Arguments:
//      inDS      The input dataset.
//      <unused>  The domain number.
//      <unused>  The label.
//
//  Returns:      The output dataset.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Aug 27 14:59:19 PST 2008
//
// ****************************************************************************

avtDataTree_p
avtWellBoreFilter::ExecuteDataTree(vtkDataSet *inDS, int domain,
    std::string label)
{
    if (inDS->GetDataObjectType() != VTK_RECTILINEAR_GRID &&
        inDS->GetDataObjectType() != VTK_STRUCTURED_GRID)
    {
        EXCEPTION1(ImproperUseException,
                   "Expecting a rectilinear or curvilinear grid");
    }

    int dims[3];
    float *xpts = NULL, *ypts = NULL, *zpts = NULL, *pts = NULL;
    if (inDS->GetDataObjectType() == VTK_RECTILINEAR_GRID)
    {
        vtkRectilinearGrid *grid = vtkRectilinearGrid::SafeDownCast(inDS);
        if (grid->GetDataDimension() != 3)
        {
            EXCEPTION1(ImproperUseException, "Expecting a 3D grid");
        }
        xpts = vtkFloatArray::SafeDownCast(grid->GetXCoordinates())
            ->GetPointer(0);
        ypts = vtkFloatArray::SafeDownCast(grid->GetYCoordinates())
            ->GetPointer(0);
        zpts = vtkFloatArray::SafeDownCast(grid->GetZCoordinates())
            ->GetPointer(0);
        grid->GetDimensions(dims);

    }
    else if (inDS->GetDataObjectType() == VTK_STRUCTURED_GRID)
    {
        vtkStructuredGrid *grid = vtkStructuredGrid::SafeDownCast(inDS);
        if (grid->GetDataDimension() != 3)
        {
            EXCEPTION1(ImproperUseException, "Expecting a 3D grid");
        }
        pts = vtkFloatArray::SafeDownCast(grid->GetPoints()->GetData())
            ->GetPointer(0);
        grid->GetDimensions(dims);
    }

    int nWellBores = atts.GetNWellBores();
    const vector<int> wellBores=atts.GetWellBores();

    if (nWellBores <= 0)
    {
        debug3 << "No well bores specified!" << endl;
        GetOutput()->GetInfo().GetValidity().InvalidateOperation();
        return NULL;
    }

    //
    // Determine the base index for the mesh.
    //
    vtkDataArray *arr = inDS->GetFieldData()->GetArray("base_index");
    int baseIndex[3] = {0, 0, 0};
    if (arr != NULL)
    {
        vtkIntArray *ar2 = (vtkIntArray *) arr;
        baseIndex[0] = ar2->GetValue(0);
        baseIndex[1] = ar2->GetValue(1);
        baseIndex[2] = ar2->GetValue(2);
    }

    //
    // Create the data sets and labels for each of the well bores.
    //
    vtkDataSet **out_ds = new vtkDataSet*[nWellBores];
    vector<string> labels;

    int iWellBore = 0;
    for (int i = 0; i < nWellBores; i++)
    {
        out_ds[i] = CreateWell(wellBores, iWellBore, xpts, ypts, zpts, pts,
                               baseIndex, dims);

        //
        // Create the label.
        //
        char label[80];
        SNPRINTF(label, 80, "%d", i);
        labels.push_back(label);
    }

    //
    // Turn the data sets into a data tree.
    //
    avtDataTree_p outDT = NULL;
    outDT = new avtDataTree(nWellBores, out_ds, domain, labels);

    for (int i = 0; i < nWellBores; i++)
    {
        out_ds[i]->Delete();
    }
    delete [] out_ds;

    //
    // Set the levels for the level mapper.
    //
    GetOutput()->GetInfo().GetAttributes().SetLabels(labels);

    return outDT;
}


// ****************************************************************************
//  Method: avtWellBoreFilter::RefashionDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: brugger -- generated by xml2avt
//  Creation:   Wed Aug 27 14:59:19 PST 2008
//
// ****************************************************************************

void
avtWellBoreFilter::RefashionDataObjectInfo(void)
{
    // IF YOU SEE FUNNY THINGS WITH EXTENTS, ETC, YOU CAN CHANGE THAT HERE.
}


// ****************************************************************************
//  Method:  avtWellBoreFilter::CalculateCylPts
//
//  Purpose:
//    Precalculate points for cylinder geometry.
//
//  Programmer: Eric Brugger
//  Creation:   October 1, 2008
//
//  Modifications:
//
// ****************************************************************************

void
avtWellBoreFilter::CalculateCylPts(void)
{
    for (int detail=0; detail<MAX_DETAIL_LEVELS; detail++)
    {
        int cdetail = cylinder_quality_levels[detail];
        cyl_pts[detail] = new float[(cdetail+1)*4];

        for (int b=0; b<=cdetail; b++)
        {
            float theta = 2*M_PI * float(b) / float(cdetail);

            float dx = cos(theta);
            float dy = sin(theta);
            float dz = 0;

            cyl_pts[detail][b*4+0] = dx;
            cyl_pts[detail][b*4+1] = dy;
            cyl_pts[detail][b*4+2] = dz;
            cyl_pts[detail][b*4+3] = 0;
        }
    }
}

// ****************************************************************************
//  Method:  avtWellBoreFilter::GetPoint
//
//  Purpose:
//    Get the next point from the well bores.
//
//  Returns:    True if a point was present, false otherwise.
//
//  Arguments:
//    p         The next point.
//    wellBores The vector of well bores.
//    iWellBore The index of the next well bore.
//
//  Programmer: Eric Brugger
//  Creation:   October 1, 2008
//
//  Modifications:
//
// ****************************************************************************

bool
avtWellBoreFilter::GetPoint(int p[3], const std::vector<int> &wellBores,
    int &iWellBore)
{
    int i;
    for (i = 0; i < 3 && (p[i] = wellBores[iWellBore++]) != -1; i++)
        /* do nothing */;
    return (i == 3);
}

// ****************************************************************************
//  Method:  avtWellBoreFilter::CreateWell
//
//  Purpose:
//    Create the next well from the well description.
//
//  Returns:    A vtk poly data representation of the well.
//
//  Arguments:
//   wellBores  The vector of well bores.
//   iWellBore  The index of the next well bore.
//   xpts       The x points of a rectilinear mesh.
//   ypts       The y points of a rectilinear mesh.
//   zpts       The z points of a rectilinear mesh.
//   pts        The points of a structured mesh.
//   baseIndex  The base index of the mesh.
//   dims       The dimensions of the mesh.
//
//  Programmer: Eric Brugger
//  Creation:   October 1, 2008
//
//  Modifications:
//
// ****************************************************************************

vtkPolyData *
avtWellBoreFilter::CreateWell(const std::vector<int> &wellBores,
    int &iWellBore, float *xpts, float *ypts, float *zpts, float *pts,
    int baseIndex[3], int dims[3])
{
    WellBoreAttributes::WellRenderingMode renderingMode =
        atts.GetDrawWellsAs();
    WellBoreAttributes::DetailLevel cylinderQuality =
        atts.GetWellCylinderQuality();
    float cylinderRadius = atts.GetWellRadius();

    vtkPolyData *polyData = vtkPolyData::New();

    vtkPoints *points = vtkPoints::New();
    polyData->SetPoints(points);
    points->Delete();

    vtkCellArray *lines = NULL;
    vtkCellArray *polys = NULL;
    vtkFloatArray *normals = NULL;
    if (renderingMode == WellBoreAttributes::Lines)
    {
        lines = vtkCellArray::New();
        polyData->SetLines(lines);
        lines->Delete();
    }
    else
    {
        polys = vtkCellArray::New();
        polyData->SetPolys(polys);
        polys->Delete();
        normals = vtkFloatArray::New();
        normals->SetName("Normals");
        normals->SetNumberOfComponents(3);
        polyData->GetPointData()->SetNormals(normals);
        normals->Delete();
    }

    int nx = dims[0];
    int nxy = dims[0] * dims[1];

    int nLines = 0;
    int p1[3], p2[3];

    bool havePoints = GetPoint(p1, wellBores, iWellBore);
    if (havePoints)
        havePoints = GetPoint(p2, wellBores, iWellBore);

    while (havePoints)
    {
        int nChange = 0;
        int nRemainingPoints = 0;
        int iRemainingPoints;
        int i;
        for (i = 0; i < 3; i++)
        {
            int diff = p2[i] - p1[i];
            nChange += (diff != 0) ? 1 : 0;
            if (abs(diff) > abs(nRemainingPoints))
            {
                nRemainingPoints = diff;
                iRemainingPoints = i;
            }
        }
        if (nChange > 1 && abs(nRemainingPoints) > 1)
        {
            p1[0] = p2[0]; p1[1] = p2[1]; p1[2] = p2[2];
            havePoints = GetPoint(p2, wellBores, iWellBore);
        }
        else
        {
            if (p1[0] >= baseIndex[0] && p1[0] < baseIndex[0] + dims[0] &&
                p1[1] >= baseIndex[1] && p1[1] < baseIndex[1] + dims[1] &&
                p1[2] >= baseIndex[2] && p1[2] < baseIndex[2] + dims[2])
            {
                if (nRemainingPoints > 1)
                {
                    p2[iRemainingPoints] = p1[iRemainingPoints] + 1;
                }
                else if (nRemainingPoints < -1)
                {
                    p2[iRemainingPoints] = p1[iRemainingPoints] - 1;
                }
                if (p2[0] >= baseIndex[0] && p2[0] < baseIndex[0] + dims[0] &&
                    p2[1] >= baseIndex[1] && p2[1] < baseIndex[1] + dims[1] &&
                    p2[2] >= baseIndex[2] && p2[2] < baseIndex[2] + dims[2])
                {
                    double coord1[3], coord2[3];
                    if (pts != NULL)
                    {
                        int ndx = ((p1[2] - baseIndex[2]) * nxy +
                                   (p1[1] - baseIndex[1]) * nx +
                                   (p1[0] - baseIndex[0])) * 3;
                        coord1[0] = pts[ndx++];
                        coord1[1] = pts[ndx++];
                        coord1[2] = pts[ndx];
                        ndx = ((p2[2] - baseIndex[2]) * nxy +
                               (p2[1] - baseIndex[1]) * nx +
                               (p2[0] - baseIndex[0])) * 3;
                        coord2[0] = pts[ndx++];
                        coord2[1] = pts[ndx++];
                        coord2[2] = pts[ndx];
                    }
                    else
                    {
                        coord1[0] = xpts[p1[0] - baseIndex[0]];
                        coord1[1] = ypts[p1[1] - baseIndex[1]];
                        coord1[2] = zpts[p1[2] - baseIndex[2]];
                        coord2[0] = xpts[p2[0] - baseIndex[0]];
                        coord2[1] = ypts[p2[1] - baseIndex[1]];
                        coord2[2] = zpts[p2[2] - baseIndex[2]];
                    }

                    if (renderingMode == WellBoreAttributes::Lines)
                    {
                        points->InsertNextPoint(coord1);
                        points->InsertNextPoint(coord2);

                        vtkIdType line[2];
                        line[0] = nLines * 2;
                        line[1] = nLines * 2 + 1;
                        lines->InsertNextCell(2, line);

                        nLines++;
                    }
                    else
                    {
                        float vc[3] = {coord2[0] - coord1[0],
                                       coord2[1] - coord1[1],
                                       coord2[2] - coord1[2]};
                        float va[3];
                        float vb[3];

                        float vc_len = vtkMath::Normalize(vc);
                        if (vc_len != 0)
                        {
                            vtkMath::Perpendiculars(vc, va,vb, 0);

                            int cdetail =
                                cylinder_quality_levels[cylinderQuality];
                            for (int b = 0; b < cdetail; b++)
                            {
                                float *u = &(cyl_pts[cylinderQuality][b*4]);
                                float v[3];

                                v[0] = va[0]*u[0] + vb[0]*u[1];
                                v[1] = va[1]*u[0] + vb[1]*u[1];
                                v[2] = va[2]*u[0] + vb[2]*u[1];

                                float normal[3];
                                normal[0] = -v[0];
                                normal[1] = -v[1];
                                normal[2] = -v[2];
                                normals->InsertNextTuple(normal);
                                normals->InsertNextTuple(normal);

                                double coord[3];
                                coord[0] = coord2[0] + cylinderRadius * v[0];
                                coord[1] = coord2[1] + cylinderRadius * v[1];
                                coord[2] = coord2[2] + cylinderRadius * v[2];
                                points->InsertNextPoint(coord);
                                coord[0] = coord1[0] + cylinderRadius * v[0];
                                coord[1] = coord1[1] + cylinderRadius * v[1];
                                coord[2] = coord1[2] + cylinderRadius * v[2];
                                points->InsertNextPoint(coord);
                            }

                            vtkIdType poly[4];
                            for (int b = 0; b < cdetail; b++)
                            {
                                int offset = nLines * cdetail * 2;
                                poly[0] = offset + b * 2;
                                poly[1] = offset + ((b + 1) % cdetail) * 2;
                                poly[2] = offset + ((b + 1) % cdetail) * 2 + 1;
                                poly[3] = offset + b * 2 + 1;
                                polys->InsertNextCell(4, poly);
                            }

                            nLines++;
                        }
                    }
                }
            }
        }

        if (nRemainingPoints > 1)
        {
            p1[iRemainingPoints]++;
            p2[iRemainingPoints] = p1[iRemainingPoints] + nRemainingPoints - 1;
        }
        else if (nRemainingPoints < -1)
        {
            p1[iRemainingPoints]--;
            p2[iRemainingPoints] = p1[iRemainingPoints] + nRemainingPoints + 1;
        }
        else
        {
            p1[0] = p2[0]; p1[1] = p2[1]; p1[2] = p2[2];
            havePoints = GetPoint(p2, wellBores, iWellBore);
        }
    }

    return polyData;
}
