import os, math, socket, stat, time 

###############################################################################
# Class: JobSubmitter
#
# Purpose:    Base class for job submitter classes, which construct various
#             command lines to submit parallel VisIt jobs.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter(object):
    def __init__(self, launcher):
        super(JobSubmitter,self).__init__()
        self.launcher = launcher
        self.parallel = launcher.parallelArgs

    def hostname(self):
        return self.launcher.hostname()

    def nodename(self):
        return self.launcher.nodename()

    def sectorname(self):
        return self.launcher.sectorname()

    def domainname(self):
        return self.launcher.domainname()

    def Executable(self):
        return []

    def VisItExecutable(self):
        return [os.path.join(self.launcher.visitbindir, self.launcher.generalArgs.exe_name)]

    def HandledHardwareArguments(self):
        return 0

    def LauncherAndSubLauncher(self):
        sep = ""
        if string.find(self.parallel.launch, ",") != -1:
            sep = ","
        if sep == "" and string.find(self.parallel.launch, "/") != -1:
            sep = "/"
        if sep != "":
            s = string.split(self.parallel.launch, sep)
            lname = s[0]
            slname = s[1] 
        else:
            lname = self.parallel.launch
            slname = ""
        return (lname, slname)

    def PPN(self):
        return str(int(math.ceil(float(self.parallel.np) / float(self.parallel.nn))))

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_mpirun
#
# Purpose:    Launch an MPI job with mpirun.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_mpirun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_mpirun,self).__init__(launcher)

    def Executable(self):
        return ["mpirun"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-np", self.parallel.np]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-p", self.parallel.partition]
        if self.parallel.machinefile != None:
            parcmd = parcmd + ["-machinefile", self.parallel.machinefile]
        parcmd = parcmd + self.VisItExecutable()
        parcmd = parcmd + ["-plugindir", GETENV("VISITPLUGINDIR")]
        parcmd = parcmd + ["-visithome", GETENV("VISITHOME")]
        parcmd = parcmd + ["-visitarchhome", GETENV("VISITARCHHOME")]
        parcmd = debugger.CreateCommand(parcmd + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_aprun
#
# Purpose:    Launch an MPI job with aprun.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_aprun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_aprun,self).__init__(launcher)

    def Executable(self):
        return ["aprun"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-n", self.parallel.np]
        if self.parallel.nn != None:
            parcmd = parcmd + ["-N", self.parallel.nn]
        parcmd = parcmd + self.VisItExecutable()
        parcmd = parcmd + ["-plugindir", GETENV("VISITPLUGINDIR")]
        parcmd = parcmd + ["-visithome", GETENV("VISITHOME")]
        parcmd = parcmd + ["-visitarchhome", GETENV("VISITARCHHOME")]
        parcmd = debugger.CreateCommand(parcmd + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_dmpirun
#
# Purpose:    Launch an MPI job with dmpirun.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_dmpirun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_dmpirun, self).__init__(launcher)

    def Executable(self):
        return ["dmpirun"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-np", self.parallel.np]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-p", self.parallel.partition]
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_poe
#
# Purpose:    Launch an MPI job with poe.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_poe(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_poe, self).__init__(launcher)

    def Executable(self):
        return self.VisItExecutable()

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable() + args
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-procs", self.parallel.np]
        if self.parallel.nn != None:
            parcmd = parcmd + ["-nodes", self.parallel.nn]
        if self.parallel.partition != None:
            parcmd = debugger.CreateCommand(parcmd + ["-rmpool", self.parallel.partition])
        return parcmd

###############################################################################
# Class: JobSubmitter_ibrun
#
# Purpose:    Launch an MPI job with poe.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_ibrun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_ibrun, self).__init__(launcher)

    def Executable(self):
        return ["ibrun"]

###############################################################################
# Class: JobSubmitter_prun
#
# Purpose:    Launch an MPI job with prun.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_prun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_prun, self).__init__(launcher)

    def Executable(self):
        return ["prun"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-n", self.parallel.np]
        if self.parallel.nn != None:
            parcmd = parcmd + ["-N", self.parallel.nn]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-p", self.parallel.partition]
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_srun
#
# Purpose:    Launch an MPI job with srun.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_srun(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_srun, self).__init__(launcher)

    def Executable(self):
        return ["srun"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-n", self.parallel.np]
        if self.parallel.nn != None:
            parcmd = parcmd + ["-N", self.parallel.nn]
        if self.parallel.name != None:
            parcmd = parcmd + ["-J", self.parallel.name]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-p", self.parallel.partition]
        if self.parallel.time != None:
            parcmd = parcmd + ["-t", self.parallel.time]
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_psub
#
# Purpose:    Launch an MPI job with psub.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_psub(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_psub, self).__init__(launcher)

    def Executable(self):
        return ["psub"]

    def CreateCommand(self, args, debugger):
        psub, sublauncher = self.LauncherAndSubLauncher()
        sublaunchargs = []
        if self.parallel.sublaunchargs != None: 
            sublaunchargs = sublaunchargs + self.parallel.sublaunchargs
        if sublauncher == "srun" and self.parallel.np != None:
            sublaunchargs = ["srun"] + sublaunchargs + ["-n", self.parallel.np]
        elif sublauncher == "mpirun" and self.parallel.np != None:
            sublaunchargs = ["mpirun"] + sublaunchargs + ["-np", self.parallel.np]

        lpvar = (GETENV("LIBPATH"), GETENV("LIBPATH"))
        if "csh" in GETENV("SHELL"):
            libpathcmd="setenv LIBPATH %s ; setenv LD_LIBRARY_PATH %s" % lpvar
            limitcmd="limit coredumpsize 0"
        else:
            libpathcmd="LIBPATH=%s ; export LIBPATH ; LD_LIBRARY_PATH=%s ; export LD_LIBRARY_PATH" % lpvar
            limitcmd="ulimit -c 0"

        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        parcmd = parcmd + ["-x"]
        # Use both -g and -np to set procs if we have multiple processors
        # per node.  On some machines the -np is used and the -g ignored
        # and on others it is the opposite.
        # Otherwise, syntax is not accepted, so use -ln.
        if self.parallel.np != None and self.parallel.nn != None:
            parcmd = parcmd + ["-g", self.parallel.np, "-np", self.parallel.np, "-ln", self.parallel.nn]
        elif self.parallel.np != None:
            parcmd = parcmd + ["-ln", self.parallel.np]

        if self.parallel.name != None:
            parcmd = parcmd + ["-r", self.parallel.name]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-c", self.parallel.partition]
        if self.parallel.bank != None:
            parcmd = parcmd + ["-b", self.parallel.bank]
        if self.parallel.time != None:
            parcmd = parcmd + ["-tM", self.parallel.time]
        if self.parallel.expedite:
            parcmd = parcmd + ["-expedite"]

        setupcmd = "cd %s ; %s ; %s ;" % (os.path.abspath(os.curdir), limitcmd, libpathcmd)

        sublaunchprecmd = ""
        if self.parallel.sublaunchprecmd != None:
            sublaunchprecmd = string.join(list(self.parallel.sublaunchprecmd) + [";"], " ")
        sublaunchpostcmd = ""
        if self.parallel.sublaunchpostcmd != None:
            sublaunchpostcmd = string.join(list(self.parallel.sublaunchpostcmd) + [";"], " ")

        launchcmd = sublaunchprecmd
        allargs = debugger.CreateCommand(sublaunchargs + self.VisItExecutable() + args)
        launchcmd = launchcmd + string.join(allargs, " ") + " ; "
        launchcmd = launchcmd + sublaunchpostcmd

        parcmd = parcmd + ["-i", setupcmd + launchcmd]
        return parcmd

###############################################################################
# Class: JobSubmitter_salloc
#
# Purpose:    Launch an MPI job with salloc.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_salloc(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_salloc, self).__init__(launcher)

    def Executable(self):
        return ["salloc"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.partition != None:
            parcmd = parcmd + ["-p", self.parallel.partition]
        if self.parallel.time != None:
            parcmd = parcmd + ["-t", self.parallel.time]
        if self.parallel.nn != None:
            parcmd = parcmd + ["-N", self.parallel.nn]
        if self.parallel.np != None:
            parcmd = parcmd + ["-n", self.parallel.np]

        if self.parallel.nn != None:
            parcmd = parcmd + ["--ntasks-per-node=%s" % self.PPN()]

        parcmd = parcmd + ["srun","-N1","-n1","--preserve-env","--mpi=none", "mpirun"]

        if self.parallel.nn != None:
            parcmd = parcmd + ["--npernode", self.PPN()]

        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)

        return parcmd

###############################################################################
# Class: JobSubmitter_sbatch
#
# Purpose:    Launch an MPI job with sbatch.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_sbatch(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_sbatch, self).__init__(launcher)

    def Executable(self):
        return ["sbatch"]

    def PPNArguments(self, ppn):
        return ["--npernode", ppn, "numa_wrapper", "--ppn", ppn]

    def HandledHardwareArguments(self):
        return 1

    def TFileLoadModules(self, tfile):
        return

    def CreateFilename(self):
        tdate = time.asctime()[11:19]
        tuser = self.launcher.username()
        return os.path.join("/tmp", "visit.%s.%s" % (tuser, tdate))

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.partition != None:
           parcmd = parcmd + ["--partition=%s" % self.parallel.partition]
        if self.parallel.bank != None:
           parcmd = parcmd + ["--account=%s" % self.parallel.bank]
        if self.parallel.time != None:
           parcmd = parcmd + ["--time=%s" % self.parallel.time]
        if self.parallel.nn != None:
           parcmd = parcmd + ["--nodes=%s" % self.parallel.nn]
        if self.parallel.np != None:
           parcmd = parcmd + ["--ntasks=%s" % self.parallel.np]

        ppn = "8"
        if self.parallel.nn != None:
            ppn = self.PPN()

        sbatch,sublauncher = self.LauncherAndSubLauncher()
        if sublauncher == "mpiexec":
            mpicmd = ["mpiexec"]
            if self.parallel.sublaunchargs != None:
                mpicmd = mpicmd + self.parallel.sublaunchargs
            mpicmd = mpicmd + self.PPNArguments(ppn)
            mpicmd = mpicmd + self.VisItExecutable() + args
        elif sublauncher == "aprun":
            mpicmd = ["aprun", "-n", self.parallel.np]
            if self.parallel.sublaunchargs != None:
                mpicmd = mpicmd + self.parallel.sublaunchargs
            mpicmd = mpicmd + self.VisItExecutable() + args
        else:
            mpicmd = self.VisItExecutable() + args

        mpicmd = debugger.CreateCommand(mpicmd)

        # Create the tfile
        tfilename = self.CreateFilename()
        try:
            tfile = open(tfilename, "wt")
            tfile.write("#!/bin/sh\n")
            self.TFileLoadModules(tfile)
            tfile.write("cd %s\n" % os.path.abspath(os.curdir))
            tfile.write("ulimit -c 0\n")
            if self.parallel.hw_precmd != None:
                tfile.write(self.parallel.hw_precmd + "\n")
            if self.parallel.sublaunchprecmd != None:
                tfile.write(string.join(self.parallel.sublaunchprecmd, " ") + "\n")
            tfile.write(string.join(mpicmd, " ") + "\n")
            if self.parallel.sublaunchpostcmd != None:
                tfile.write(string.join(self.parallel.sublaunchpostcmd, " ") + "\n")
            if self.parallel.hw_postcmd != None:
                tfile.write(self.parallel.hw_postcmd + "\n")
            tfile.close()
        except:
            exit("Could not create script file to launch %s job." % self.parallel.launcher, 0)

        # The parallel command is the tfile script we just made.
        parcmd = parcmd + [tfilename]
        return parcmd


###############################################################################
# Class: JobSubmitter_bsub
#
# Purpose:    Launch an MPI job with bsub.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_bsub(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_bsub, self).__init__(launcher)

    def Executable(self):
        return ["bsub"]

    def CreateCommand(self, args, debugger):
        bsub, sublauncher = self.LauncherAndSubLauncher()
        parcmd = self.Executable()
        parcmd = parcmd + ["-I"]
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.parallel.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-n", self.parallel.np]
        if self.parallel.partition != None:
            parcmd = parcmd + ["-q", self.parallel.partition]
        if self.parallel.time != None:
            parcmd = parcmd + ["-W", self.parallel.time]
        parcmd = parcmd + [sublauncher]
        if self.parallel.sublaunchargs != None:
            parcmd = parcmd + self.parallel.sublaunchargs
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_yod
#
# Purpose:    Launch an MPI job with yod.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_yod(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_yod, self).__init__(launcher)

    def Executable(self):
        return ["/cougar/bin/yod"]

    def CreateCommand(self, args, debugger):
        parcmd = self.Executable()
        if self.parallel.launchargs != None:
            parcmd = parcmd + self.launchargs
        if self.parallel.np != None:
            parcmd = parcmd + ["-sz", self.parallel.np]
        parcmd = debugger.CreateCommand(parcmd + self.VisItExecutable() + args)
        return parcmd

###############################################################################
# Class: JobSubmitter_qsub
#
# Purpose:    Launch an MPI job with qsub or msub.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class JobSubmitter_qsub(JobSubmitter):
    def __init__(self, launcher):
        super(JobSubmitter_qsub, self).__init__(launcher)
        self.tfilename = ""
        self.useppn = 1
        self.usettc = 0

    def Executable(self):
        plauncher,sublauncher = self.LauncherAndSubLauncher()
        return [plauncher]

    def CreateFilename(self, root):
        tdate = string.replace(time.asctime(), " ", "-")
        tuser = self.launcher.username()
        return os.path.join("/tmp", "%s.%s.%s" % (root, tuser, tdate))

    def HandledHardwareArguments(self):
        return 1

    def TFileLoadModules(self, tfile):
        return

    def TFileSetup(self, tfile):
        tfile.write("cd %s\n" % os.path.abspath(os.curdir))
        tfile.write("ulimit -c 0\n")
        #tfile.write("# Submitted on host %s\n" % self.launcher.hostname())
        #for v in ("LIBPATH", "LD_LIBRARY_PATH", "VISITHOME", "VISITARCHHOME", "VISITPLUGINDIR"):
        #    tfile.write('echo "%s=$%s"\n' % (v,v))

    def mpiexec(self):
        return ["mpiexec"]

    def mpiexec_args(self, args):
        mpicmd = self.mpiexec()
        if self.parallel.sublaunchargs != None:
            mpicmd = mpicmd + self.parallel.sublaunchargs
        if self.parallel.np != None:
            mpicmd = mpicmd + ["-n", self.parallel.np]
        if self.parallel.machinefile != None:
            mpicmd = mpicmd + ["-machinefile", self.parallel.machinefile]
        mpicmd = mpicmd + self.VisItExecutable() + args
        return mpicmd

    def mpirun(self):
        return ["mpirun"]

    def mpirun_args(self, args):
        mpicmd = self.mpirun()
        if self.parallel.sublaunchargs != None:
            mpicmd = mpicmd + self.parallel.sublaunchargs
        if self.parallel.np != None:
            mpicmd = mpicmd + ["-np", self.parallel.np]
        if self.parallel.machinefile != None:
            mpicmd = mpicmd + ["-machinefile", self.parallel.machinefile]
        mpicmd = mpicmd + self.VisItExecutable()
        mpicmd = mpicmd + ["-plugindir", GETENV("VISITPLUGINDIR")]
        mpicmd = mpicmd + args
        return mpicmd

    def srun(self):
        return ["srun"]

    def srun_args(self, args):
        mpicmd = self.srun()
        if self.parallel.sublaunchargs != None:
            mpicmd = mpicmd + self.parallel.sublaunchargs
        if self.parallel.np != None:
            mpicmd = mpicmd + ["-n", self.parallel.np]
        mpicmd = mpicmd + self.VisItExecutable() + args
        return mpicmd

    def aprun(self):
        return ["aprun"]

    def aprun_args(self, args):
        mpicmd = self.aprun()
        if self.parallel.sublaunchargs != None:
            mpicmd = mpicmd + self.parallel.sublaunchargs
        if self.parallel.np != None:
            mpicmd = mpicmd + ["-n", self.parallel.np]
        if self.parallel.np != None and self.parallel.nn != None:
            mpicmd = mpicmd + ["-N", self.PPN()]
        mpicmd = mpicmd + self.VisItExecutable() + args
        return mpicmd

    def ibrun(self):
        return ["ibrun"]

    def ibrun_args(self, args):
        mpicmd = self.ibrun()
        mpicmd = mpicmd + self.VisItExecutable() + args
        return mpicmd

    def Writable(self, d):
        return self.launcher.writepermission(d)

    def HandleCWDPermissions(self):
        args = []
        if not self.Writable(os.path.abspath(os.curdir)):
            msg = """
The directory you started VisIt in does not have write permission.
Using /dev/null for the batch job standard error and standard
output streams.
"""
            self.launcher.warning(msg)
            args = args + ["-e", "/dev/null", "-o", "/dev/null"]
        return args

    def AddEnvironment(self):
        env = ""
        env = env + "LIBPATH=" + GETENV("LIBPATH")
        env = env + ",LD_LIBRARY_PATH=" + GETENV("LD_LIBRARY_PATH")
        env = env + ",VISITHOME=" + GETENV("VISITHOME")
        env = env + ",VISITARCHHOME=" + GETENV("VISITARCHHOME")
        env = env + ",VISITPLUGINDIR=" + GETENV("VISITPLUGINDIR")
        return ["-v", env]

    def LauncherArgs(self):
        args = []
        use_vis = 0
        if self.parallel.launchargs != None:
            i = 0
            while i < len(self.parallel.launchargs):
                larg = self.parallel.launchargs[i]
                if larg == "-l":
                    nextarg = self.parallel.launchargs[i+1]
                    if nextarg == "vis":
                        use_vis = 1
                    else:
                        args = args + [larg, nextarg]
                    i = i + 1
                else:
                    args = args + [larg]
                i = i + 1
        return args, use_vis

    def SetupPPN(self, nodes, procs, ppn, use_vis):
        if use_vis:
            args = ["-l", "nodes=%s:ppn=%s:vis" % (nodes, ppn)]
        elif self.useppn:
            args = ["-l", "nodes=%s:ppn=%s" % (nodes, ppn)]
        else:
            args = ["-l", "nodes=%s" % nodes]
        return args

    def SetupTime(self):
        args = []
        if self.parallel.time != None:
            args = ["-l", "walltime=%s" % self.parallel.time]
        return args

    def AdditionalSetup(self):
        return []

    # Break up creating the command line into customizable stages.
    def AssembleCommandLine(self):
        parcmd = self.Executable()
        parcmd = parcmd + self.HandleCWDPermissions()
        parcmd = parcmd + self.AddEnvironment()
        largs, use_vis = self.LauncherArgs()
        parcmd = parcmd + largs

        nodes = self.parallel.nn
        if nodes == None:
            nodes = self.parallel.np
        ppn = str(int(math.ceil(float(self.parallel.np) / float(nodes))))
        parcmd = parcmd + self.SetupPPN(nodes, self.parallel.np, ppn, use_vis)

        parcmd = parcmd + self.SetupTime()
        parcmd = parcmd + self.AdditionalSetup()

        if self.usettc:
            parcmd = parcmd + ["-l", "ttc=%s" % self.parallel.np]

        if self.parallel.partition != None:
            parcmd = parcmd + ["-q", self.parallel.partition]

        if self.parallel.bank != None:
            parcmd = parcmd + ["-A", self.parallel.bank]

        parcmd = parcmd + [self.tfilename]

        return parcmd

    # Entry point for the job submitter. Create a tfile and a job submission 
    # command line.
    def CreateCommand(self, args, debugger):
        plauncher,sublauncher = self.LauncherAndSubLauncher()

        self.tfilename = self.CreateFilename("visit")
        try:
            # Determine the sublauncher command line.
            if sublauncher == "mpiexec":
                mpicmd = self.mpiexec_args(args)
            elif sublauncher == "mpirun":
                mpicmd = self.mpirun_args(args)
            elif sublauncher == "srun":
                mpicmd = self.srun_args(args)
            elif sublauncher == "ibrun":
                mpicmd = self.ibrun_args(args)
            elif sublauncher == "aprun":
                mpicmd = self.aprun_args(args)
            else:
                mpicmd = self.VisItExecutable() + args

            mpicmd = debugger.CreateCommand(mpicmd)

            # Write the tfile.
            tfile = open(self.tfilename, "wt")
            tfile.write("#!/bin/sh\n")
            self.TFileLoadModules(tfile)
            self.TFileSetup(tfile)

            if self.parallel.hw_precmd != None:
                tfile.write(self.parallel.hw_precmd + "\n")
            if self.parallel.sublaunchprecmd != None:
                tfile.write(string.join(self.parallel.sublaunchprecmd, " ") + "\n")
            tfile.write(string.join(mpicmd, " ") + "\n")
            if self.parallel.sublaunchpostcmd != None:
                tfile.write(string.join(self.parallel.sublaunchpostcmd, " ") + "\n")
            if self.parallel.hw_postcmd != None:
                tfile.write(self.parallel.hw_postcmd + "\n")

            tfile.close()
            os.chmod(self.tfilename, 0775)
        except:
            exit("Can't create the tfile.", 0)

        parcmd = self.AssembleCommandLine()
        return parcmd

###############################################################################
# Class: Debugger
#
# Purpose:    Debugger base class.
#
# Programmer: Brad Whitlock
# Date:       Thu May 31 13:07:04 PDT 2012
#
# Modifications:
#
###############################################################################

class Debugger(object):
    def __init__(self, launcher):
        super(Debugger, self).__init__()
        self.launcher = launcher
        self.debug = launcher.debugArgs

    def GetSourceDirectories(self):
        def sourcedirs(root, d):
            dirnames = []
            try:
                thisroot = os.path.join(root, d)
                files = os.listdir(thisroot)
                dirnames = [thisroot]
                for f in files:
                    if f[0] != "." and f != "CMakeFiles":
                        thisfile = os.path.join(thisroot, f)
                        st = os.stat(thisfile)
                        if st.st_mode & stat.S_IFDIR:
                            dirnames = dirnames + sourcedirs(thisroot, f)
            except OSError:
                # Most likely the directory did not exist.
                pass
            return dirnames

        # The directories to search for sources
        toplevels = ("common", "avt", "databases", "engine", "gui", "launcher", 
                     "mdserver", "operators", "plots", "viewer", "visitpy", 
                     "tools/xml", "tools/xmledit", "visit_vtk", "vtkqt", "winutil")
        dirnames = []
        for d in toplevels:
            dirnames = dirnames + sourcedirs(self.launcher.visithome, d)
        return dirnames

    # This matches the method in JobSubmitter.
    def VisItExecutable(self):
        return [os.path.join(self.launcher.visitbindir, self.launcher.generalArgs.exe_name)]

    # Separate a long chain of arguments, potentially containing launcher
    # commands, etc into launcher arguments and visit arguments. The
    # launcher arguments will consist of everything up to the visit executable
    # name. The visit arguments consist of the visit executable and everything
    # after.
    def SeparateArguments(self, args):
        launchargs = []
        visitargs = []
        exe = self.VisItExecutable()[0]
        foundexe = 0
        for a in args:
            if a == exe:
                foundexe = 1
            if foundexe:
                visitargs = visitargs + [a]
            else:
                launchargs = launchargs + [a]
        return launchargs, visitargs

    def DebuggerArguments(self):
        return self.debug.debuggerArgs[:-1]

    def CreateCommand(self, args):
        return args

###############################################################################
# Class: GDBDebugger
#
# Purpose:    Launch a VisIt component under gdb.
#
# Programmer: Brad Whitlock
# Date:       Thu May 31 13:07:04 PDT 2012
#
# Modifications:
#
###############################################################################

class GDBDebugger(Debugger):
    def __init__(self, launcher):
        super(GDBDebugger, self).__init__(launcher)
        self.filename = ""

    def Executable(self):
        return ["gdb"]

    def CreateCommandFile(self, args):
        self.filename = "%s%s-gdbcommands" % (self.launcher.generalArgs.exe_name, self.launcher.visitver)
        self.filename = os.path.abspath(os.path.join(os.curdir, self.filename))
        try:
            f = open(self.filename, "wt")
            # Write the environment to the gdb file.
            self.launcher.PrintEnvironment(f, "set environment ", "=", 0)
            f.write("path %s\n" % self.launcher.visitbindir)
            f.write("file %s\n" % args[0])

            # Write the directories to search for sources
            dirnames = self.GetSourceDirectories()
            for d in dirnames:
                f.write("directory %s\n" % d)

            # Write the command line arguments.
            f.write("set args %s -dograb\n" % string.join(args[1:], " "))

            # Write breakpoints
            f.write("set breakpoint pending on\n")
            for b in self.debug.breakpoints:
                f.write("break %s\n" % b)
            f.write("run\n")

            # Our gdb isn't interactive in this case, so default to giving a
            # backtrace; that's what someone would want in 90% of the cases.
            # If you really want to control gdb, use -xterm.
            if not self.launcher.generalArgs.newconsole:
                f.write("bt full\n")

            f.close()
        except IOError:
            return 0
        return 1

    def CreateCommand(self, args):
        launcherargs, visitargs = self.SeparateArguments(args)
        if len(launcherargs) > 0:
            self.launcher.error("GDB debugging is not compatible with running in parallel at present.")
            return args

        if self.CreateCommandFile(args):
            args = self.Executable() + self.DebuggerArguments() + ["-q", "-x", self.filename]
        else:
            self.launcher.error("Could not create GDB command file: %s. Running VisIt normally." % self.filename)
        return args

###############################################################################
# Class: TotalviewDebugger
#
# Purpose:    Launch a VisIt component under totalview.
#
# Programmer: Brad Whitlock
# Date:       Thu May 31 13:07:04 PDT 2012
#
# Modifications:
#
###############################################################################

class TotalviewDebugger(Debugger):
    def __init__(self, launcher):
        super(TotalviewDebugger, self).__init__(launcher)

    def Executable(self):
        return ["totalview"]

    def CreateCommand(self, args):
        return self.Executable() + [args[0], "-a", "-dograb"] + self.DebuggerArguments() + args[1:]

###############################################################################
# Class: ValgrindDebugger
#
# Purpose:    Launch a VisIt component under valgrind.
#
# Programmer: Brad Whitlock
# Date:       Thu May 31 13:07:04 PDT 2012
#
# Modifications:
#
###############################################################################

class ValgrindDebugger(Debugger):
    def __init__(self, launcher):
        super(ValgrindDebugger, self).__init__(launcher)

    def Executable(self):
        return ["valgrind"]

    def CreateCommand(self, args):
        # setting this environment variable causes libstdc++ routines to free
        # memory ASAP, instead of leaving it around in pools.  This helps valgrind
        # properly detect leaks, at a performance cost.
        if GETENV("GLIBCXX_FORCE_NEW") == "":
            SETENV("GLIBCXX_FORCE_NEW", "1")

        launcherargs, visitargs = self.SeparateArguments(args)
        vgargs = self.DebuggerArguments()
        if len(vgargs) == 0:
            vgargs = ["--tool=memcheck", "--error-limit=no", "--num-callers=50"]
        return launcherargs + self.Executable() + vgargs + visitargs

###############################################################################
# Class: StraceDebugger
#
# Purpose:    Launch a VisIt component under strace.
#
# Programmer: Brad Whitlock
# Date:       Thu May 31 13:07:04 PDT 2012
#
# Modifications:
#
###############################################################################

class StraceDebugger(Debugger):
    def __init__(self, launcher):
        super(StraceDebugger, self).__init__(launcher)

    def Executable(self):
        return ["strace"]

    def CreateCommand(self, args):
        strace = self.Executable()
        if len(self.debug.debuggerArgs) > 1:
            strace = strace + self.DebuggerArguments()
        else:
            strace = strace + ["-ttt", "-T"]
        launcherargs, visitargs = self.SeparateArguments(args)
        return launcherargs + strace + visitargs

###############################################################################
# Class: DebugMallocDebugger
#
# Purpose:    Launch a VisIt component with malloc debugging on Mac.
#
# Programmer: Brad Whitlock
# Date:       Fri Jun  1 14:07:22 PDT 2012
#
# Modifications:
#
###############################################################################

class DebugMallocDebugger(Debugger):
    def __init__(self, launcher):
        super(DebugMallocDebugger, self).__init__(launcher)

    def CreateCommand(self, args):
        dl = self.launcher.splitpaths(GETENV("DYLD_INSERT_LIBRARIES"))
        libs = self.launcher.quoted(self.launcher.joinpaths(dl + ["/usr/lib/libMallocDebug.A.dylib"]))
        launcherargs, visitargs = self.SeparateArguments(args)
        newcmd = ["env", "DYLD_INSERT_LIBRARIES="+libs, "MallocStackLogging=1"]
        return launcherargs + newcmd + visitargs

###############################################################################
# Class: GeneralArguments
#
# Purpose:    Parse general command line arguments.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class GeneralArguments(object):
    def __init__(self, launcher):
        super(GeneralArguments, self).__init__()
        self.launcher = launcher
        if self.launcher.visitprogram != "visit":
            self.exe_name = self.launcher.visitprogram
        else:
            self.exe_name = "gui"
        self.dv = 0
        self.add_movie_args = 0
        self.diffmode = 0        # 0 = none, 1=diff, 2=diffsum
        self.diffargs = []
        self.scriptfile = None
        self.norun = None
        self.env = 0
        self.arch = 0
        self.host = None
        self.port = None
        self.key = None
        self.publicpluginsonly = 0
        self.compiler = None
        self.objectmode = None
        self.guesshost = 0
        self.sshtunneling = 0
        self.noloopback = 0
        self.viewerdisplay = None
        self.arguments = []
        self.newconsole = 0
        self.clientserver = 0
        self.quiet = 0
        self.setupenv = 0

    def ParseArguments(self, i, args):
        if i >= len(args):
            return 0
        n = 1
        if args[i] in ("-gui", "-cli", "-vcl", "-viewer", "-mdserver", "-engine"):
            self.exe_name = args[i][1:]
        elif args[i] == "-movie":
            self.exe_name = "cli"
            self.add_movie_args = 1
        elif args[i] == "-s":
            self.scriptfile = args[i+1]
            n = 2
        elif args[i] == "-diff":
            self.exe_name = "cli"
            self.diffmode = 1
            self.diffargs = [args[i+1], args[i+2]]
            n = 3
        elif args[i] == "-diffsum":
            self.exe_name = "cli"
            self.diffmode = 2
            self.diffargs = [args[i+1], args[i+2]]
            n = 3
        elif args[i] == "-norun":
            self.norun = args[i+1]
            n = 2
        elif args[i] == "-dv":
            self.dv = 1
        elif args[i] == "-arch":
            self.arch = 1
        elif args[i] == "-env":
            self.env = 1
        elif  args[i] == "-host":
            self.host = args[i+1]
            n = 2
        elif  args[i] == "-port":
            self.port = args[i+1]
            n = 2
        elif  args[i] == "-key":
            self.key = args[i+1]
            n = 2
        elif args[i] == "-publicpluginsonly":
            self.publicpluginsonly = 1
        elif args[i] == "-compiler":
            self.compiler = args[i+1]
            n = 2
        elif args[i] == "-objectmode":
            self.objectmode = args[i+1]
            n = 2
        elif args[i] == "-guesshost":
            self.guesshost = 1
        elif args[i] == "-sshtunneling":
            self.sshtunneling = 1
        elif args[i] == "-noloopback":
            self.noloopback = 1
        elif args[i] == "-newconsole":
            self.newconsole = 1
        elif args[i] == "-xterm":
            self.newconsole = 2
        elif args[i] == "-viewerdisplay":
            self.viewerdisplay = args[i+1]
            n = 2
        elif args[i] == "-clientserver":
            self.clientserver = 1
        elif args[i] == "-quiet":
            self.quiet = 1
        elif args[i] == "-setupenv":
            self.setupenv = 1
        else:
            self.arguments = self.arguments + [args[i]]
        return n

    def ProduceArguments(self, parallel):
        args = []
        if self.dv:
            args = args + ["-dv"]
        if self.publicpluginsonly:
            args = args + ["-publicpluginsonly"]
        if self.norun != None and self.norun != self.exe_name:
            args = args + ["-norun", self.norun]
        if self.viewerdisplay != None:
            args = args + ["-viewerdisplay", self.viewerdisplay]
        if not parallel and self.setupenv:
            args = args + ["-setupenv"]

        if self.scriptfile != None:
            if self.add_movie_args:
                args = args + ["-scriptfile", self.scriptfile]
            else:
                args = args + ["-s", self.scriptfile]

        if self.diffmode > 0:
            d = ["-s", os.path.join(self.launcher.visitscriptdir, "visitdiff.py"), "-vdiff"]
            if self.diffmode == 1:
                args = args + d + self.diffargs
            else:
                args = args + ["-nowin"] + d + self.diffargs + ["-summary_only"]

        if self.add_movie_args:
            args = args + ["-nowin", "-s", os.path.join(self.launcher.visitscriptdir, "makemoviemain.py")]

        args = args + self.arguments

        return args

    def ConnectionArguments(self, parallel):
        # Localhost override to loopback.  The default behavior is that we
        # will always override the given host with the loopback device unless
        # otherwise specified.  This means that the viewer needs to add the
        # -noloopback flag when initiating a remote process (e.g. the vcl
        # with -ssh, or another remote process launched through vcl).  A
        # parallel engine also needs to add the flag since even "local"
        # parallel jobs may run on compute nodes.
        args = []
        remotehost = ""
        remotehost_set = 0
        if self.noloopback:
            args = args + ["-noloopback"]
            # If we're running parallel with -noloopback, check to see if the
            # the -host flag passed the full name for the local host. If so,
            # then let's use the shorter name for the host name.
            if parallel and (self.exe_name[:6] == "engine") and \
               self.host != None and self.launcher.hostname() in self.host:
                remotehost = self.launcher.hostname()
                remotehost_set = 1
        else:
            remotehost = "127.0.0.1"
            remotehost_set = 1
            if parallel and (self.exe_name[:6] == "engine"):
                args = args + ["-noloopback"]

        # Determine remotehost based on whether we're guessing the host or
        # tunneling ssh.
        if self.sshtunneling:
            args = args + ["-sshtunneling"]
            if self.host != None:
                remotehost = self.host
            else:
                # If -sshtunneling was enabled and the host name was not already
                # set then assume localhost.  This should never happen, but just
                # in case, this is the safest solution.
                remotehost = "localhost"
            remotehost_set = 1
        elif self.guesshost:
            remotehost_set = 0
            for k in ("SSH_CLIENT", "SSH2_CLIENT", "SSH_CONNECTION"):
                try:
                    remotehost = string.split(os.environ[k], " ")[0]
                    remotehost_set = 1
                    break
                except:
                    pass
            if remotehost_set == 0:
                exit("""
Error: -guesshost was specified but it was unable to parse the 
SSH_CLIENT/CONNECTION environment variables to get a valid host
name.""", 1)

        if self.noloopback or self.sshtunneling or self.guesshost or self.host != None:
            if remotehost_set:
                args = args + ["-host", remotehost]
            elif self.host != None:
                args = args + ["-host", self.host]

        if self.port != None:
            args = args + ["-port", self.port]
        if self.key != None:
            args = args + ["-key", self.key]
        return args

###############################################################################
# Class: ParallelArguments
#
# Purpose:    Parse parallel command line arguments.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class ParallelArguments(object):
    def __init__(self):
        super(ParallelArguments, self).__init__()
        self.parallel = 0
        self.np = None
        self.nn = None
        self.launch = None
        self.launchargs = None
        self.parlaunch = None
        self.sublaunchargs = None
        self.sublaunchprecmd = None
        self.sublaunchpostcmd = None
        self.name = None
        self.partition = None
        self.bank = None
        self.time = None
        self.workingdir = None
        self.machinefile = None
        self.expedite = 0
        self.launchengine = None
        self.hw_precmd = None
        self.hw_postcmd = None

    def ParseArguments(self, i, args):
        if i >= len(args):
            return 0
        n = 2
        # single arguments
        if args[i] == "-par":
            self.parallel = 1
            n = 1
        elif args[i] == "-expedite":
            self.parallel = 1
            self.expedite = 1
            n = 1
        # double arguments
        elif args[i] == "-np":
            self.parallel = 1
            self.np = args[i+1]
        elif args[i] == "-nn":
            self.parallel = 1
            self.nn = args[i+1]
        elif args[i] == "-l":
            self.launch = args[i+1]
        elif args[i] == "-pl":
            self.parlaunch = args[i+1]
        elif args[i] == "-la":
            self.launchargs = string.split(args[i+1], " ")
        elif args[i] == "-sla":
            self.sublaunchargs = string.split(args[i+1], " ")
        elif args[i] == "-slpre":
            self.sublaunchprecmd = string.split(args[i+1], " ")
        elif args[i] == "-slpost":
            self.sublaunchpostcmd = string.split(args[i+1], " ")
        elif args[i] == "-n":
            self.name = args[i+1]
        elif args[i] == "-p":
            self.partition = args[i+1]
        elif args[i] == "-b":
            self.bank = args[i+1]
        elif args[i] == "-t":
            self.time = args[i+1]
        elif args[i] == "-wd":
            self.workingdir = args[i+1]
        elif args[i] == "-machinefile":
            self.machinefile = args[i+1]
        elif args[i] == "-launchengine":
            if i+1 < len(args):
                if args[i+1][0] == '-':
                    self.launchengine = "localhost"
                    n = 1
                else:
                    self.launchengine = args[i+1]
            else:
                self.launchengine = "localhost"
                n = 1
        elif args[i] == "-hw-pre":
            self.hw_precmd = args[i+1]
        elif args[i] == "-hw-post":
            self.hw_postcmd = args[i+1]
        else:
            # We did not handle the command line argument
            n = 0
        return n

    #
    # Produce arguments for when we're passing the parallel arguments on the 
    # command line for a serially launched component such as the gui.
    #
    def ProduceArguments(self, gather):
        args = []
#        if self.parallel and self.np == None:
#            args = args + ["-par"]
        if self.launch != None:
            args = args + ["-l", self.launch]
        if self.np != None:
            args = args + ["-np", self.np]
        if self.nn != None:
            args = args + ["-nn", self.nn]
        if self.launchargs != None:
            args = args + ["-la", '"' + string.join(self.launchargs, " ") + '"']
        if self.name != None:
            args = args + ["-n", self.name]
        if self.partition != None:
            args = args + ["-p", self.partition]
        if self.bank != None:
            args = args + ["-b", self.bank]
        if self.time != None:
            args = args + ["-t", self.time]
        if self.machinefile != None:
            args = args + ["-machinefile", self.machinefile]

        # Gather the arguments destined for the engine into an -engineargs argument.
        if gather:
            if len(args) > 0:
                args = ["-engineargs", string.join(args, ";")]
            else:
                args = []
            if self.launchengine != None:
                args = args + ["-launchengine", self.launchengine]
            elif self.parallel:
                args = args + ["-launchengine", "localhost"]

        return args

###############################################################################
# Class: DebugArguments
#
# Purpose:    Parse debugger-related command line arguments.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class DebugArguments(object):
    def __init__(self, launcher):
        super(DebugArguments, self).__init__()
        self.launcher = launcher
        self.debugger = None
        self.debuggerArgs = []
        self.breakpoints = []

    def ParseArguments(self, i, args):
        if i >= len(args):
            return 0

        n = 0

        # Check to see if we have a debugger. 
        for d in self.launcher.Debuggers():
            n = 0
            flag = "-" + d
            if args[i] == flag:
                self.debugger = d
                n = 1
                # Read arguments until we hit a VisIt component name.
                try:
                    while 1:
                        nextarg = args[i+n]
                        n = n + 1
                        self.debuggerArgs = self.debuggerArgs + [nextarg]
                        if self.launcher.iscomponent(nextarg):
                            break
                except IndexError:
                    exit("Did not find VisIt component name for %s option." % flag, 1)
                return n

        if args[i] == "-break":
            self.breakpoints = self.breakpoints + [args[i+1]]
            n = 2

        return n

    def ProduceArguments(self):
        args = []
        if self.debugger != None:
            args = ["-" + self.debugger] + self.debuggerArgs

            # Add the breakpoints to the command line.
            for b in self.breakpoints:
                args = args + ["-break", b]
        return args


###############################################################################
# Class: MainLauncher
#
# Purpose:    The main launcher class for internallauncher.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

class MainLauncher(object):
    def __init__(self):
        super(MainLauncher, self).__init__()
        self.visitdir = ""
        self.visithome = ""
        self.visitprogram = ""
        self.visitver = ""
        self.visitpluginver = ""
        self.generalArgs = None
        self.parallelArgs = None
        self.debugArgs = None
        self.os = ""
        self.visitarch = ""
        self.visitarchdir = ""
        self.visitbindir = ""
        self.visitscriptdir = ""
        self.visitlauncher = ""
        self.visitlibdir = ""
        self.visithelpdir = ""
        self.visitresourcedir = ""
        self.visitultradir = ""
        self.visitplugins = ""
        self.publicversion = 0
        self.logging = 0
        self.loggedComponents = ("mdserver",)
        self.plugincategories = ("plots", "operators", "databases")
        self.clientPrograms = ("gui", "cli", "viewer")
        self.componentNames = ("gui", "cli", "viewer", "mdserver", "vcl", "engine_ser", "engine_par", "xmledit")
        self.xterm = ["xterm"]

    def username(self):
        return os.getlogin()

    def hostname(self):
        return socket.gethostname()

    def nodename(self):
        return string.split(self.hostname(), ".")[0]

    def sectorname(self):
        s = self.nodename()
        for d in "0123456789":
            s = string.replace(s, d, "")
        return s

    def domainname(self):
        fullhost = socket.gethostbyname_ex(self.hostname())[0]
        pos = string.find(fullhost, ".")
        if pos != -1:
            return fullhost
        else:
            return fullhost[pos+1:]

    def uname(self, arg):
        p = subprocess.Popen(["uname", arg], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        output = p.communicate()
        return string.lower(output[0][:-1])

    def joinpaths(self, paths):
        unique = []
        for p in paths:
            if p not in unique and p != "":
                unique = unique + [p]
        if len(unique) == 1:
            ret = unique[0]
        else:
            ret = string.join(unique, ":")
        return ret

    def splitpaths(self, paths):
        s = string.split(paths, ":")
        unique = []
        for p in s:
            if p not in unique and p != "":
                unique = unique + [p]
        return unique

    def quoted(self, s):
        if string.find(s, " ") != -1:
            ret = '"' + s + '"'
        else:
            ret = s
        return s

    def writepermission(self, path):
        st = os.stat(path)
        return bool(st.st_mode & stat.S_IWUSR)

    def call(self, args, stdinpipe=0):
        #print args
        self.Logging(args)
        ret = 0
        try:
             if stdinpipe:
                  # Launchers like msub need this in order to work.
                  p = subprocess.Popen(args, stdin=subprocess.PIPE)
             else:
                  p = subprocess.Popen(args)
             p.communicate()
             ret = p.returncode
        except KeyboardInterrupt:
            # Catch so we don't print a Python stack
            ret = -1
        return ret

    def message(self, msg, file=sys.stderr):
        print >> file, msg

    def warning(self, msg):
        print >> sys.stderr, "WARNING: ", msg

    def error(self, msg):
        print >> sys.stderr, "ERROR: ", msg

    def iscomponent(self, name):
        return name in self.componentNames

    ############################################################################
    # Method: Initialize
    #
    # Purpose: Initialize some important members of the object.
    #
    # Arguments:
    #   visitdir       : The VisIt directory (The directory that contains bin)
    #   visitprogram   : The name of the VisIt program (visit, xmledit, ...)
    #   visitver       : The version being run. Can be empty if dev version.
    #   visitpluginver : The version being run.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Initialize(self, visitdir, visitprogram, visitver, visitpluginver):
        self.visitdir = visitdir
        self.visithome = visitdir
        self.visitprogram = visitprogram
        self.visitver = visitver
        self.visitpluginver = visitpluginver
        self.generalArgs = GeneralArguments(self)
        self.parallelArgs = ParallelArguments()
        self.debugArgs = DebugArguments(self)
        self.os = self.uname("-s")

    def SetLogging(self, value):
        self.logging = value

    ############################################################################
    # Method: Logging
    #
    # Purpose: Log when a VisIt process is launched.
    #
    # Notes: This implementation only logs when an mdserver is run.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Logging(self, args):
        if self.logging and self.generalArgs.exe_name in self.loggedComponents:
            user_info = self.username()
            host_info = string.split(self.hostname(), ".")[0]
            date_info = time.asctime()
            cs_info = ""
            if self.generalArgs.clientserver:
                cs_info = "client/server"
            info = string.join([user_info, host_info, date_info, cs_info], " ")+"\n"

            # Read in the existing data. (TODO: change to open for append)
            filename = os.path.join(self.visitdir, "usagelog")
            lines = []
            try:
                lines = open(filename, "rt").readlines() + [info]
            except:
                lines = [info]

            # Write out the new data.
            try:
                f = open(filename, "wt")
                for line in lines:
                    f.write(line)
                f.close()
            except:
                self.error("Could not write usagelog.")

    ############################################################################
    # Method: PrintUsage
    #
    # Purpose: Print the usage.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def PrintUsage(self, fullhelp):
        def filecontents(filename):
            f = open(filename, "rt")
            lines = f.readlines()
            return string.join(lines, "")

        # setup the usage note about full help
        helpnote = "NOTE: For a more complete list of options, use '-fullhelp'.\n"

        usagefile = os.path.join(self.visitresourcedir, "usage", "visitusage.txt")
        usageplusfile = os.path.join(self.visitresourcedir, "usage", "visitusageplus.txt")

        if fullhelp:
            print "\nUSAGE: visit [options]\n"
            print filecontents(usagefile)
            print filecontents(usageplusfile)
        else:
            print "\nUSAGE: visit [options]\n"
            print helpnote
            print filecontents(usagefile)

    ############################################################################
    # Method: ParseArguments
    #
    # Purpose: Read the command line arguments into different objects.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def ParseArguments(self, args):
        # Parse command line arguments.
        i = 0
        try:
            while i < len(args):
                n = self.parallelArgs.ParseArguments(i, args)
                if n > 0:
                    i = i + n
                    continue
                n = self.debugArgs.ParseArguments(i, args)
                if n > 0:
                    i = i + n
                    continue
                n = self.generalArgs.ParseArguments(i, args)
                if n > 0:
                    i = i + n
        except IndexError:
            exit("The %s argument requires additional arguments." % args[i], -1)
            

    ############################################################################
    # Method: DetermineArchitecture
    #
    # Purpose: Determine a list of supported VisIt architecture strings.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def DetermineArchitecture(self):
        """
        Determine names of VisIt architecture strings that are compatible with this platform.
        """
        exe_name = self.generalArgs.exe_name
        compiler = self.generalArgs.compiler
        objectmode = self.generalArgs.objectmode

        supportedarches = []
        if self.os == "linux":
            mach = self.uname("-m")
            if mach == "x86_64": 
                arch = "linux-x86_64"
            elif mach == "ia64": 
                arch = "linux-ia64"
            elif mach == "ppc64": 
                arch = "linux-ppc64"
                # Tack on the BlueGene compiler for the engine.
                if exe_name[:6] == "engine" and compiler != None:
                    arch = arch + "-" + compiler
            elif mach == "alpha": 
                arch = "linux-alpha"
            else:
                arch = "linux-intel"
                if compiler != None:
                    arch = arch + "-" + compiler
            supportedarches.append(arch)
        elif self.os == "darwin":
            #
            # Sometimes uname returns i386 even when it is a 64 bit
            # processor, so we use system_profiler to get the real
            # answer. From http://support.apple.com/kb/ht3696 a
            # Processor Name of "Intel Core Solo" or "Intel Core Duo"
            # is 32 bits and a Processor Name of "Intel Core 2 Duo" or
            # "Intel Quad-Core Xeon" or "Dual-Core Intel Xeon" or
            # "Quad-Core Intel Xeon" is 64 bits.
            #
            # Since we only support the 64 bit version with Mac OS X
            # 10.6 or above, we always choose the 32 bit version prior
            # to 10.6 and in the case of 10.6 or newer, distinguish
            # between 32 and 64 bits using system_profiler.
            #
            pargs = ["/usr/sbin/system_profiler", "-detailLevel", "-2"]
            p = subprocess.Popen(pargs, stdout=subprocess.PIPE)
            output = p.communicate()[0]
            lines = string.split(output, "\n")
            for line in lines:
                procname = string.find(line, "Processor Name")
                if procname != -1:
                    if "Intel Core" in line:
                        supportedarches.append("darwin-i386")
                    else:
                        supportedarches.append("darwin-x86_64")
                        supportedarches.append("darwin-i386")
                    break
        elif self.os == "aix":
            arch = "ibm-aix-pwr"
            arch = arch + objectmode
            if compiler != None:
                arch = arch + "-" + compiler
            supportedarches.append(arch)
        elif self.os == "freebsd":
            mach = uname("-m")
            version = uname("-r")
            supportedarches.append("freebsd-%s-%s" % (version, mach))
        # else
        #    Support for other platforms was removed.
        return supportedarches

    ############################################################################
    # Method: SetupDirectoryNames
    #
    # Purpose: Set up various directory names that can be used to reference
    #          different parts of the VisIt installation.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def SetupDirectoryNames(self, supportedarches):
        if self.visitver == "":
            # If there is no version, then this is a development executable.
            archdir = supportedarches[0]
            self.visitarch = archdir
            self.visitarchdir   = self.visitdir
            self.visitbindir    = self.visitdir + "exe"
            self.visitscriptdir = self.visitdir + "bin"
            self.visitlauncher  = self.visitdir + "bin/visit"
            if self.os == "darwin" and self.generalArgs.exe_name in ("gui", "viewer", "xmledit", "silex"):
                self.visitbindir = os.path.join(self.visitbindir, self.generalArgs.exe_name + ".app/Contents/MacOS")
            self.visitlibdir = self.visitdir + "lib"
            self.visithelpdir = self.visitdir + "help"
            self.visitresourcedir = self.visitdir + "resources"
            self.visitultradir = self.visitdir + "ultrawrapper"
            self.visitplugins = self.visitdir + "plugins"
            self.publicversion = 0
            if not os.path.exists(os.path.join(self.visitbindir, self.generalArgs.exe_name)):
                 msg = "Development version of %s does not exist." % self.generalArgs.exe_name
                 if self.generalArgs.exe_name == "engine_par":
                     msg = msg + "\nNote that a serial engine may still work."
                 exit(msg, 1)
        else:
            # We're running a public version
            archdir = ""
            for arch in supportedarches:
                app = self.visitdir + arch + "/bin/" + self.generalArgs.exe_name
                if os.path.exists(app) or os.path.exists("%s.app" % app):
                    archdir = arch
                    break
            if archdir == "":
                msg = "Version %s of %s does not exist for " % (visitver, self.generalArgs.exe_name)
                if len(supportedarches) > 1:
                    msg = msg + "any of the valid architectures (%s).\n" % string.join(supportedarches, " ")
                else:
                    msg = msg + "the architecture %s.\n" % supportedarches[0]
                if self.generalArgs.exe_name == "engine_par":
                    msg = msg + "Note that a serial engine may still work.\n"
                exit(msg, 1)

            self.visitarch      = archdir
            self.visitarchdir   = self.visitdir + archdir
            self.visitbindir    = self.visitdir + archdir + "/bin"
            self.visitscriptdir = self.visitdir + archdir + "/bin"
            self.visitlauncher  = self.visitdir + "../bin/visit"
            if self.os == "darwin" and self.generalArgs.exe_name in ("gui", "viewer", "xmledit", "silex"):
                self.visitbindir = os.path.join(self.visitbindir, self.generalArgs.exe_name + ".app/Contents/MacOS")
            self.visitlibdir = self.visitdir + archdir + "/lib"
            self.visithelpdir = self.visitdir + archdir + "/help"
            self.visitresourcedir = self.visitdir + archdir + "/resources"
            self.visitultradir = self.visitdir + archdir + "/ultrawrapper"
            self.visitplugins = self.visitdir + archdir + "/plugins"
            self.publicversion = 1

            #print "visitarchdir  =", self.visitarchdir
            #print "visitbindir   =", self.visitbindir
            #print "visitscriptdir=", self.visitscriptdir
            #print "visitlauncher =", self.visitlauncher
            #print "visitlibdir   =", self.visitlibdir
            #print "visithelpdir  =", self.visithelpdir
            #print "visitultradir =", self.visitultradir
            #print "visitplugins  =", self.visitplugins
            #print "publicversion =", self.publicversion

    ############################################################################
    # Method: ConsistencyCheck
    #
    # Purpose: Check the different command line arguments for consistency and
    #          alter their values if needed.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def ConsistencyCheck(self):
        # If no partition has been specified then fill one in if we're using
        # psub as the parallel launcher.
        if self.parallelArgs.partition == None and self.parallelArgs.launch != None:
            if self.parallelArgs.launch[:4] == "psub":
                self.parallelArgs.partition = "pbatch,%s" % self.sectorname()

        # If no launcher was specified then give a default.
        if self.parallelArgs.parallel and self.parallelArgs.launch == None:
            self.parallelArgs.launch = "mpirun"

    ############################################################################
    # Method: Customize
    #
    # Purpose: Method that lets derived classes do top-level custom initialization.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Customize(self):
        return

    ############################################################################
    # Method: UpdateExecutableNames
    #
    # Purpose: Update the name for the executable that we'll run.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def UpdateExecutableNames(self):
        if self.generalArgs.exe_name == "engine":
            np = 1
            if self.parallelArgs.parallel:
                if self.parallelArgs.np != None:
                    try:
                        np = int(self.parallelArgs.np)
                    except:
                        np = 1
            if np > 1:
                self.generalArgs.exe_name = "engine_par"
            else:
                self.generalArgs.exe_name = "engine_ser"
        elif self.generalArgs.exe_name in ("makemili", "visitconvert"):
            if self.parallelArgs.parallel:
                par_lite = os.path.join(self.visitdir, "exe", self.generalArgs.exe_name + "_par_lite")
                if os.path.exists(par_lite):
                    self.generalArgs.exe_name = self.generalArgs.exe_name + "_par_lite"
                else:
                    self.generalArgs.exe_name = self.generalArgs.exe_name + "_par"
            else:
                ser_lite = os.path.join(self.visitdir, "exe", self.generalArgs.exe_name + "_ser_lite")
                if os.path.exists(par_lite):
                    self.generalArgs.exe_name = self.generalArgs.exe_name + "_ser_lite"
                else:
                    self.generalArgs.exe_name = self.generalArgs.exe_name + "_ser"

    ############################################################################
    # Method: PrivatePlugins
    #
    # Purpose: Return the path to the user's private plugins.
    #
    # Programmer: Brad Whitlock
    # Date: Fri Jun  1 09:53:57 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def PrivatePlugins(self):
        return os.path.join(GETENV("HOME"), ".visit", self.visitpluginver, self.visitarch, "plugins")

    ############################################################################
    # Method: SetupEnvironment
    #
    # Purpose: Set up the environment variables that we need to run VisIt.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def SetupEnvironment(self):
        # Get some environment variables and store their original values.
        keys = ("LD_LIBRARY_PATH", "LD_LIBRARY32_PATH", "LD_LIBRARYN32_PATH", 
                "LD_LIBRARY64_PATH", "LIBPATH") #, "PYTHONHOME")
        for k in keys:
            if GETENV("%s_VISITORIG" % k) == "":
                SETENV("%s_VISITORIG" % k, GETENV(k))
    
        for k in keys:
            if GETENV("%s_VISITORIG" % k) == "":
                SETENV(k, self.visitlibdir)
            else:
                SETENV(k, self.joinpaths([self.visitlibdir, GETENV("%s_VISITORIG" % k)]))

        # Set R_HOME in case R has been installed it will be in this location..
        visitrdir = os.path.join(self.visitlibdir, "r_support", "R")
        SETENV("R_HOME", visitrdir)

        # Add /usr/local/lib to the shared library path.  This was added for the
        # c++ library on some sun systems, but it may have broader applicability.
        # Note that we can assume that LD_LIBRARY_PATH is not empty, since it was
        # set to $visitlibdir above.
        SETENV("LD_LIBRARY_PATH", self.joinpaths([GETENV("LD_LIBRARY_PATH"), "/usr/local/lib"]))

        # Get the private plugin directory.
        visitprivateplugins = self.PrivatePlugins()

        if self.os == "darwin":
            fallback = [self.visitlibdir]
            for p in self.plugincategories:
                fallback = fallback + [os.path.join(visitprivateplugins, p)]
            fallback = fallback + ["/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries"]
            e = GETENV("DYLD_FALLBACK_LIBRARY_PATH")
            if e == "":
                SETENV("DYLD_FALLBACK_LIBRARY_PATH", self.joinpaths(fallback))
            else:
                SETENV("DYLD_FALLBACK_LIBRARY_PATH", self.joinpaths(fallback + [e]))

        if self.generalArgs.publicpluginsonly:
            SETENV("VISITPLUGINDIR", self.visitplugins)
        else:
            if GETENV("VISITPLUGINDIRORIG") == "":
                SETENV("VISITPLUGINDIR", GETENV("VISITPLUGINDIR"))
            SETENV("VISITPLUGINDIR", self.joinpaths([GETENV("VISITPLUGINDIRORIG"), visitprivateplugins,self.visitplugins]))

        # If we are using a public version, or if any main plugin directory is
        # not writeable, then we should default to a private plugin installation.
        SETENV("VISITPLUGININSTPUB", self.visitplugins)
        SETENV("VISITPLUGININSTPRI", visitprivateplugins)

        # Only set up the default installation path if needed
        if GETENV("VISITPLUGININST") == "":
            shouldinstallprivate = self.publicversion
            for p in self.plugincategories:
                if os.path.exists(os.path.join(self.visitplugins, p)):
                    shouldinstallprivate = 1

            if shouldinstallprivate:
                SETENV("VISITPLUGININST", visitprivateplugins)
            else:
                SETENV("VISITPLUGININST", self.visitplugins)

        # Set required environment variables
        SETENV("VISITHOME",     self.visithome)
        SETENV("VISITARCHHOME", self.visitarchdir)
        SETENV("VISITHELPHOME", self.visithelpdir)
        SETENV("VISITULTRAHOME", self.visitultradir)

        # Turn off trapping of floating point exceptions.
        SETENV("TRAP_FPE", "")

        # Turn off a warning message when running on Linux systems displaying
        # to a remote display.  The message messes up the communication between
        # the GUI and Viewer.
        SETENV("MESA_GLX_FX", "disable")

        # The -viewerdisplay argument allows the user to specify an argument
        # that the viewer should use, no matter what the GUI was using.  This
        # can be useful for wall-type displays with a separate console, e.g.
        # the console on :0 and the DMX server on :2, you could run
        # env DISPLAY=:0 visit -viewerdisplaay :2
        if self.generalArgs.exe_name == "viewer" and self.generalArgs.viewerdisplay != None:
            SETENV("DISPLAY", self.generalArgs.viewerdisplay)

    ############################################################################
    # Method: PrintEnvironment
    #
    # Purpose: Helper to replicate the environment that VisIt has set up.
    #
    # Arguments:
    #   file       : The file to which we're printing the environment.
    #   set        : The string to use to "setenv" the variable.
    #   eq         : The equal string to use: ' ' or '='
    #   allowempty : Whether to still print the value for the variable if it
    #                is empty.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def PrintEnvironment(self, file, set, eq, allowempty):
        soext = "so"
        if self.os == "darwin":
            soext = "dylib"

        # The environment variables whose values we're printing.
        vars = ["LIBPATH", "VISITHOME", "VISITARCHHOME", "VISITHELPHOME", 
                "VISITULTRAHOME", "VISITPLUGINDIR","TRAP_FPE",
                "MESA_GLX_FX"]
        # vars = vars + ["PYTHONHOME"] # don't set PYTHONHOME
        # A dictionary of extra vars whose source is different 
        diffvars = {}
        # Add a few more variables, depending on platform.
        if self.os == "darwin":
            diffvars = {"DYLD_LIBRARY_PATH" : "DYLD_FALLBACK_LIBRARY_PATH"}
        else:
            ld = ["LD_LIBRARY_PATH", "LD_LIBRARY32_PATH", "LD_LIBRARYN32_PATH", "LD_LIBRARY64_PATH"]
            vars = ld + vars
        # Make one dictionary of the variables to check.
        varnames = {}
        for v in vars:
            varnames[v] = v
        for v in diffvars.keys():
            varnames[v] = diffvars[v]

        # Check each variable.
        sorted_keys = sorted(varnames.keys())
        for var in sorted_keys:
            value = GETENV(varnames[var])
            if value != "" or allowempty:
                file.write(set + var + eq + self.quoted(value) + "\n")

        # The value on this one is not from an environment var.
        visitmesalib = os.path.join(self.visitlibdir, "libOSMesa." + soext)
        file.write(set + "VISIT_MESA_LIB" + eq + "%s\n" % self.quoted(visitmesalib))

    ############################################################################
    # Method: PrintEnvironmentShell
    #
    # Purpose: Print shell commands to replicate the environment that VisIt 
    #          has set up.
    #
    # Programmer: Brad Whitlock
    # Date: Fri Jun  1 10:15:30 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def PrintEnvironmentShell(self, csh_style):
        if csh_style:
            self.PrintEnvironment(sys.stdout, "setenv ", " ", 1)
        else:
            self.PrintEnvironment(sys.stdout, "", "=", 1)

    ############################################################################
    # Method: MakeUserDirectories
    #
    # Purpose: Make the user's ~/.visit plugin subdirectories.
    #
    # Arguments:
    #   pluginver       : The plugin version
    #   supportedarches : The supported architectures.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def MakeUserDirectories(self, pluginver, supportedarches):
        home = GETENV("HOME")
        if home != "":
            for archdir in supportedarches:
                root = home
                for subdir in (".visit", pluginver, archdir, "plugins"):
                    path = os.path.join(root, subdir)
                    if not os.path.exists(path):
                        os.mkdir(path)
                    root = path
                for p in self.plugincategories:
                    path = os.path.join(root, p)
                    if not os.path.exists(path):
                        os.mkdir(path)

    ############################################################################
    # Method: NewConsole
    #
    # Purpose: Launch VisIt in a new console window.
    #
    # Arguments:
    #   args          : The command line arguments for the program we're running.
    #   allowLauncher : If we're running a VisIt command, sometimes we must
    #                   run it through the "visit" script again to make sure that
    #                   the new console's environment gets set up properly. If
    #                   this flag is true then running through the "visit" 
    #                   command is allowed. If not, we're probably running a 
    #                   non-visit command that we can't mess up.
    #
    # Programmer: Brad Whitlock
    # Date: Thu May 31 10:19:44 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def NewConsole(self, args, allowLauncher):
        if self.generalArgs.newconsole:
            title = "VisIt " + self.generalArgs.exe_name + self.visitver

            if allowLauncher:
                visitexe = os.path.join(self.visitbindir, self.generalArgs.exe_name)

                exeflag = "-" + self.generalArgs.exe_name
                if exeflag[-4:] == "_ser" or exeflag[-4:] == "_par":
                    exeflag = exeflag[:-4]

                newcmd = [self.visitlauncher, exeflag]
                if self.visitver != "":
                    newcmd = newcmd + ["-v", self.visitver]
                if args[0] == visitexe:
                    newcmd = newcmd + args[1:]
                else:
                    newcmd = args
            else:
                newcmd = args

            if self.os == "darwin":
                if self.generalArgs.newconsole == 1 and \
                   GETENV("TERM_PROGRAM") == "Apple_Terminal":
                    cdcmd = "cd %s" % os.path.abspath(os.curdir)
                    visitcmd = string.join(newcmd, " ")

                    osascript = subprocess.Popen(["osascript"], stdin=subprocess.PIPE)
                    osascript.stdin.write('tell application "Terminal"\n')
                    osascript.stdin.write('activate\n')
                    osascript.stdin.write('do script with command "%s; %s ; exit"\n' % (cdcmd, visitcmd))
                    osascript.stdin.write('end tell\n')
                    osascript.communicate()

                    # The Apple terminal is launching our command.
                    args = []
                elif "xterm" in GETENV("TERM") and GETENV("DISPLAY") != "":
                    args = self.xterm + ["-title", title, "-e"] + args
                else:
                    self.warning("""
VisIt does not recognize your terminal application so it will ignore the -newconsole argument.""")
            else:
                args = self.xterm + ["-title", title, "-e"] + [string.join(newcmd, " ")]
        return args

    ############################################################################
    # Method: Debuggers
    #
    # Purpose: Return a list of debugger names.
    #
    # Programmer: Brad Whitlock
    # Date: Thu May 31 10:19:44 PDT 2012
    #
    # Modifications:
    #
    ############################################################################
    def Debuggers(self):
        return ["gdb", "totalview", "valgrind", "strace", "debug-malloc"]

    ############################################################################
    # Method: DebuggerFactory
    #
    # Purpose: Return a debugger object for the specified name.
    #
    # Arguments:
    #   debugger : The name of the debugger that we want to instantiate.
    #
    # Programmer: Brad Whitlock
    # Date: Thu May 31 10:19:44 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def DebuggerFactory(self, debugger):
        if debugger == "gdb":
            return GDBDebugger(self)
        elif debugger == "totalview":
            return TotalviewDebugger(self)
        elif debugger == "valgrind":
            return ValgrindDebugger(self)
        elif debugger == "strace":
            return StraceDebugger(self)
        elif debugger == "debug-malloc":
            return DebugMallocDebugger(self)
        # Return a debugger that does not do anything.
        return Debugger(self)

    ############################################################################
    # Method: Debug
    #
    # Purpose: Launch VisIt in a debugger.
    #
    # Arguments:
    #   args : The visit command line before we decorate it for a debugger.
    #
    # Programmer: Brad Whitlock
    # Date: Thu May 31 10:19:44 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Debug(self, args):
        if self.debugArgs.debugger != None:
            if self.debugArgs.debuggerArgs[-1] == self.generalArgs.exe_name:
                # We're debugging this program, try to add debug arguments 
                # to the command line.
                debugger = self.DebuggerFactory(self.debugArgs.debugger)
                if debugger != None:
                    args = debugger.CreateCommand(args)

                # If we're running with a new console then add the command here
                # since we want the debugger to run in a new console.
                args = self.NewConsole(args, 0)
            else:
                # We're not debugging this program so add the arguments back onto
                # the command line.
                args = args + self.debugArgs.ProduceArguments()

                # If we wanted a new console then add it to the command line since
                # we're making it tied to the debugger.
                if self.generalArgs.newconsole == 1:
                    args = args + ["-newconsole"]
                elif self.generalArgs.newconsole == 2:
                    args = args + ["-xterm"]

            # We have a debugger so indicate that the newconsole has been handled.
            self.generalArgs.newconsole = 0

        return args

    ############################################################################
    # Method: Banner
    #
    # Purpose: Produce a banner to print when we run the executable. This method
    #          filters out some arguments from the printed command line.
    #
    # Arguments:
    #   arg0 : The program executable
    #   args : The program arguments
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Banner(self, arg0, args):
        a2 = ["Running: " + arg0]
        i = 1
        while i < len(args):
            if args[i] == "-key":
                i = i + 2
            else:
               if " " in args[i]:
                   a2 = a2 + ['"' + args[i] + '"']
               else:
                   a2 = a2 + [args[i]]
               i = i + 1
        return string.join(a2, " ")

    ############################################################################
    # Method: NoRun
    #
    # Purpose: Determine whether we requested -norun for the current launch.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def NoRun(self):
        if self.generalArgs.norun == None:
            return 0
        if self.parallelArgs.parallel:
            if self.generalArgs.norun in ("engine", "engine_par"):
                return 1
        else:
            exe = self.generalArgs.exe_name
            exe_ser = exe + "_ser"
            if self.generalArgs.norun in (exe, exe_ser):
                return 1
        return 0

    ############################################################################
    # Method: QuoteArguments
    #
    # Purpose: Return args as a single string. Args with spaces are quoted.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################
    def QuoteArguments(self, args):
        a2 = []
        for a in args:
            if ' ' in a:
                a2 = a2 + ['"' + a + '"']
            else:
                a2 = a2 + [a]
        return string.join(a2, " ")

    ############################################################################
    # Method: Launch
    #
    # Purpose: Launch the specified executable.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def Launch(self):
        ret = 0
        if self.parallelArgs.parallel and \
           string.find(self.generalArgs.exe_name, "_par") != -1:
            # Create the appropriate job submitter.
            submitter = self.JobSubmitterFactory(self.parallelArgs.launch)
            if submitter == None:
                exit("No job launcher was specified.", 0)

            # Create the command line arguments
            args = []
            args = args + self.generalArgs.ProduceArguments(1)
            args = args + self.generalArgs.ConnectionArguments(1)
            if self.generalArgs.setupenv:
                # if we're using -setupenv then we need to run through the launcher
                # program once more.
                newargs = [self.visitlauncher, "-engine", "-par", "-quiet"]
                if self.visitver != "":
                    newargs = newargs + ["-v", self.visitver]
                args = newargs + args[1:] + self.parallelArgs.ProduceArguments(0)
            else:
                # Create a debugger object.
                debugger = self.DebuggerFactory(self.debugArgs.debugger)
                # Let the job submitter change the command line arguments.
                args = submitter.CreateCommand(args, debugger)

            if self.NoRun():
                self.message("# SET ENVIRONMENT VARIABLES:", file=sys.stdout)
                self.PrintEnvironmentShell("csh" in GETENV("SHELL"))
                cmd = ""
                if not submitter.HandledHardwareArguments():
                    if self.parallelArgs.hw_precmd != None:
                        cmd = cmd + self.parallelArgs.hw_precmd + "\n"
                cmd = cmd + self.QuoteArguments(args) + "\n"
                if not submitter.HandledHardwareArguments():
                    if self.parallelArgs.hw_postcmd != None:
                        cmd = cmd + self.parallelArgs.hw_postcmd + "\n"
                self.message("\n# RUN USING:\n" + cmd, file=sys.stdout)
            else:
                if not self.generalArgs.quiet:
                    self.message(self.Banner(args[0], args))
                try:
                    # If the job submitter did not handle a hardware-related 
                    # pre-command then execute it now.
                    if not submitter.HandledHardwareArguments():
                        if self.parallelArgs.hw_precmd != None:
                            r = self.call([self.parallelArgs.hw_precmd])

                    # Execute the command created by the job submitter. Note that
                    # we pass 1 for stdinpipe so the process we make will get a new
                    # pipe. This makes msub work, for example.
                    ret = self.call(args, stdinpipe=1)

                    # If the job submitter did not handle a hardware-related 
                    # post-command then execute it now.
                    if not submitter.HandledHardwareArguments():
                        if self.parallelArgs.hw_postcmd != None:
                            r = self.call([self.parallelArgs.hw_postcmd])
                except OSError, e:
                    self.error("Can't launch using %s. %s" % (self.parallelArgs.launch, e.strerror))
        else:
            args = [os.path.join(self.visitbindir, self.generalArgs.exe_name)]
            args = args + self.generalArgs.ProduceArguments(0)
            args = args + self.generalArgs.ConnectionArguments(0)
            if self.generalArgs.exe_name in self.clientPrograms:
                args = args + self.parallelArgs.ProduceArguments(1)

            # Save the first argument.
            arg0 = args[0]

            # Run the command line through some filters that prepend new commands.
            args = self.Debug(args)
            args = self.NewConsole(args, 1)

            if self.NoRun():
                args = args + ["-dir", self.visithome]
                self.message("# SET ENVIRONMENT VARIABLES:", file=sys.stdout)
                self.PrintEnvironmentShell("csh" in GETENV("SHELL"))
                self.message("\n# RUN USING:\n" + self.QuoteArguments(args) + "\n", file=sys.stdout)
            else:
                # Determine the new banner.
                if args[0] != arg0:
                    arg0 = args[0]
                else:
                    d,p = os.path.split(arg0)
                    arg0 = p + self.visitver

                # Run the program
                if len(args) > 0:
                    if not self.generalArgs.quiet:
                        banner = self.Banner(arg0, args)
                        self.message(banner)
                    try:
                        ret = self.call(args)
                    except OSError, e:
                        self.error("Can't run %s. %s" % (args[0], e.strerror))
        return ret

    ############################################################################
    # Method: JobSubmitterFactory
    #
    # Purpose: Return a job submitter object for the indicated launch type.
    #
    # Arguments:
    #   launch : The name of the launcher to create.
    #
    # Programmer: Brad Whitlock
    # Date: Fri May 25 10:48:41 PDT 2012
    #
    # Modifications:
    #
    ############################################################################

    def JobSubmitterFactory(self, launch):
        # If launch has not been set then pick a platform-specific default launcher.
        if launch == None:
            if self.os == "aix":
                launch = "poe"

        # Instantiate a job submitter
        if launch == "mpirun":
            return JobSubmitter_mpirun(self)
        elif launch == "aprun":
            return JobSubmitter_aprun(self)
        elif launch == "dmpirun":
            return JobSubmitter_dmpirun(self)
        elif launch == "poe":
            return JobSubmitter_poe(self)
        elif launch == "ibrun":
            return JobSubmitter_ibrun(self)
        elif launch == "prun":
            return JobSubmitter_prun(self)
        elif launch[:4] == "srun":
            return JobSubmitter_srun(self)
        elif launch[:4] == "psub":
            return JobSubmitter_psub(self)
        elif launch[:6] == "salloc":
            return JobSubmitter_salloc(self)
        elif launch[:6] == "sbatch":
            return JobSubmitter_sbatch(self)
        elif launch[:4] == "bsub":
            return JobSubmitter_bsub(self)
        elif launch[:4] == "qsub" or launch[:4] == "msub":
            return JobSubmitter_qsub(self)
        elif launch == "yod":
            return JobSubmitter_yod(self)
        return None

###############################################################################
# Function: internallauncher
#
# Purpose:    The main entry point.
#
# Programmer: Brad Whitlock
# Date:       Thu May 17 14:22:04 PDT 2012
#
# Modifications:
#
###############################################################################

def internallauncher(launcher, visitdir, visitprogram, visitver, visitpluginver, visitargs):
    #print "running internallauncher "
    #print "visitdir=",visitdir
    #print "visitprogram=",visitprogram
    #print "visitver=",visitver
    #print "visitpluginver=",visitpluginver
    #print "visitargs=", visitargs

    launcher.Initialize(visitdir, visitprogram, visitver, visitpluginver)

    # Note: visit-install will replace the value of logging if we want to 
    # enable logging.
    logging_enabled=0
    launcher.SetLogging(logging_enabled)

    launcher.ParseArguments(visitargs)

    # Determine the supported architectures
    supportedarches = launcher.DetermineArchitecture()
    # If there were no supported architectures, fail.
    if len(supportedarches) < 1:
        exit("This hardware platform is not supported by VisIt.", 1)
    # Print the architectures and exit.
    if launcher.generalArgs.arch:
        self.message(string.join(supportedarches, " "))
        sys.exit(0)

    launcher.ConsistencyCheck()
    launcher.Customize()
    launcher.UpdateExecutableNames()
    launcher.SetupDirectoryNames(supportedarches)
    launcher.SetupEnvironment()
    launcher.MakeUserDirectories(visitpluginver, supportedarches)

    if "-help" in visitargs:
        launcher.PrintUsage(0)
        sys.exit(0)
    elif "-fullhelp" in visitargs:
        launcher.PrintUsage(1)
        sys.exit(0)

    if launcher.generalArgs.env:
        launcher.PrintEnvironmentShell(0)
        sys.exit(0)

    ret = launcher.Launch()
    return ret
