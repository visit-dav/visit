Function: PrintSelf
Declaration: void PrintSelf(ostream &os);
Definition:
// ****************************************************************************
// Method: PickAttributes::PrintSelf
//
// Purpose: 
//   Prints the contents of this class to the passed stream. 
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Reflect new member names (zoneNumber is now elementNumber, nodes is
//   now incidentElements).  Differentiate between zone pick and node pick.
//   
//   Kathleen Bonnell, Wed Jul 23 17:28:30 PDT 2003 
//   Don't print cellPoint if it is invalid (== FLT_MAX). 
//   
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003 
//   Added meshInfo. 
//   
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003 
//   Support logical zone numbers. 
//   
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003 
//   Support multiple types of coordinates. 
//   
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004 
//   Support new pick types 'DomainNode', 'DomainZone'. 
//   
// ****************************************************************************
void
PickAttributes::PrintSelf(ostream &os)
{
    int i;
    std::string fileName;
    int pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;
    if (pickLetter.size() != 0)
        os << "\n" << pickLetter.c_str() << ":  ";
    else 
        os << "\n";
    os << fileName.c_str() << " ";
    os << "timestep " << timeStep << " ";
    if (meshInfo.empty())
    {
        if (domain != -1)
            os << "domain " << domain << "\n";
    }
    else
    {
        os << "\n" << meshInfo.c_str() << "\n";
    }
    os << "active variable:   " << activeVariable.c_str() << "\n";
    os << "selected variables: ";
    for (i = 0; i < variables.size(); i++)
        os << variables[i].c_str() << "  ";
    os << "\n";
    if (pickType == CurveNode)
    {
        os << "PickedPoint: <" << nodePoint[0] << ", " 
                               << nodePoint[1] << ", " 
                               << nodePoint[2] << ">\n";
    }
    else if (pickType == CurveZone)
    {
        os << "EndPoint1: <" << nodePoint[0] << ", " 
                             << nodePoint[1] << ", " 
                             << nodePoint[2] << ">\n";
        os << "EndPoint2: <" << cellPoint[0] << ", " 
                             << cellPoint[1] << ", " 
                             << cellPoint[2] << ">\n";
    }
    else if (cellPoint[0] != FLT_MAX)
    {
        if (!needTransformMessage)
        {
            os << "PickedPoint: <" << cellPoint[0] << ", " 
                                   << cellPoint[1] << ", " 
                                   << cellPoint[2] << ">\n";
        }
        else 
        {
            os << "PickedPoint:  (in transformed space) <" 
               << cellPoint[0] << ", " 
               << cellPoint[1] << ", " 
               << cellPoint[2] << ">\n";
        }
    }
    if (pickType == Zone || pickType == DomainZone)
    {
        os << "Zone " ;
        if (showZoneId)
            os<< elementNumber << " ";
        if (showZoneDomainLogicalCoords && !dzoneCoords.empty())
        {
            os << "d" << dzoneCoords[0].c_str();
        }
        if (showZoneBlockLogicalCoords && !bzoneCoords.empty())
        {
            os << " b" << bzoneCoords[0].c_str();
        }
        os << "\n";
    }
    else if (pickType == Node || pickType == DomainNode)
    {
        os << "Node ";
        if (showNodeId)
            os << elementNumber << " ";
        if (showNodePhysicalCoords && !pnodeCoords.empty())
        {
            os << pnodeCoords[0].c_str() ;
        }
        if (showNodeDomainLogicalCoords && !dnodeCoords.empty())
        {
            os << dnodeCoords[0].c_str() ;
        }
        if (showNodeBlockLogicalCoords && !bnodeCoords.empty())
        {
            os << bnodeCoords[0].c_str() ;
        }
        os << "\n";
    }
    if (displayIncidentElements)
    {
        bool showId;
        if (pickType == Zone || pickType == DomainZone)
        {
            os << "Incident Nodes " ; 
            showId = showNodeId;
        }
        else if (pickType == Node || pickType == DomainNode)
        {
            os << "Incident Zones " ; 
            showId = showZoneId;
        }
        for (i = 0; i < incidentElements.size(); i++)
        {
            if (showId)
                os << incidentElements[i] << "  ";
            if (pickType == Zone || pickType == DomainZone)
            {
                if (showNodePhysicalCoords && !pnodeCoords.empty())
                    os << " " << pnodeCoords[i].c_str() << "\n";
                if (showNodeDomainLogicalCoords && !dnodeCoords.empty())
                    os << " domain " << dnodeCoords[i].c_str() << "\n";
                if (showNodeBlockLogicalCoords && !bnodeCoords.empty())
                    os << " block " << bnodeCoords[i].c_str() << "\n";
            }
            else if (pickType == Node || pickType == DomainNode)
            {
                if (showZoneDomainLogicalCoords && !dzoneCoords.empty())
                    os << " domain " << dzoneCoords[i].c_str() << "\n";
                if (showZoneBlockLogicalCoords && !bzoneCoords.empty())
                    os << " block " << bzoneCoords[i].c_str() << "\n";
            }
        }
        os << "\n";
    }
    for (i = 0; i < varInfo.size(); i++)
        ((PickVarInfo*)varInfo[i])->PrintSelf(os);

    os << "RayPoint 1: <" << rayPoint1[0] << ", " 
                          << rayPoint1[1] << ", " 
                          << rayPoint1[2] << ">\n";
    os << "RayPoint 2: <" << rayPoint2[0] << ", " 
                          << rayPoint2[1] << ", " 
                          << rayPoint2[2] << ">\n";

    if (doTimeCurve)
        os << "Set up to create a time-curve.\n";
}

Function: CreateOutputString
Declaration: void CreateOutputString(std::string &os, bool withLetter = true);
Definition:
// ****************************************************************************
// Method: PickAttributes::CreateOutputString
//
// Purpose: 
//   Creates a single output string containing all the information gathered
//   from a pick. 
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Reflect new member names (zoneNumber is now elementNumber, nodes is
//   now incidentElements).  Differentiate between zone pick and node pick.
//   
//   Kathleen Bonnell, Wed Jul 23 17:28:30 PDT 2003 
//   Don't include cellPoint or pickLetter if invalid.
//   
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003 
//   Added meshInfo.  So that outputstring can be created with (default)
//   or without the 'pickletter', added argument withLetter.
//   
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003 
//   Support logical zone numbers. 
//   
//   Kathleen Bonnell, Tue Dec  2 17:33:13 PST 2003 
//   Minor changes so that picking on Curves does not display unnecessary
//   information. 
//   
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003 
//   Support multiple types of coordinates. 
//   
//   Kathleen Bonnell, Tue Mar 16 16:02:05 PST 2004 
//   Create message regarding invalid variables. 
//   
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004 
//   Support new pick types 'DomainNode', 'DomainZone'. 
//   
// ****************************************************************************
void
PickAttributes::CreateOutputString(std::string &os, bool withLetter)
{
    if (error)
    {
        os = errorMessage;
        return;
    }

    if (!fulfilled)
        return;

    int i;
    char buff[512];
   
    std::string fileName; 
    int pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;

    if (withLetter)
    {
        if (pickLetter.size() != 0)
            SNPRINTF(buff, 512, "\n%s:  ", pickLetter.c_str());
        else 
            SNPRINTF(buff, 512, "\n");
        os += buff;
    }
    os += fileName;
    if (meshInfo.empty())
    {
        if (domain != -1)
        {
            SNPRINTF(buff, 512, "  timestep %d  domain %d\n", timeStep, domain);
        }
        else 
        {
            SNPRINTF(buff, 512, "  timestep %d  \n", timeStep);
        }
    }
    else
    {
        SNPRINTF(buff, 512, "  timestep %d  \n%s\n", timeStep, meshInfo.c_str());
    }
    os += buff;
    if (pickType == CurveNode)
    {
        SNPRINTF(buff, 512, "Point: <%f, %f>\n", nodePoint[0], nodePoint[1]);
        os += buff;
    }
    else if (pickType == CurveZone)
    {
        SNPRINTF(buff, 512, "Point1: <%f, %f>\nPoint2: <%f, %f>\n", 
                  nodePoint[0], nodePoint[1], cellPoint[0], cellPoint[1]);
        os += buff;
    }
    else if (cellPoint[0] != FLT_MAX)
    {
        if (dimension == 2)
        {
            if (!needTransformMessage)
            {
                SNPRINTF(buff, 512, "Point: <%f, %f>\n",
                        cellPoint[0], cellPoint[1]);
            }
            else 
            {
                SNPRINTF(buff, 512, "Point: (in transformed space)\n        <%f, %f>\n",
                        cellPoint[0], cellPoint[1]);
            }
        }
        else 
        {
            if (!needTransformMessage)
            {
                SNPRINTF(buff, 512, "Point: <%f, %f, %f>\n",
                        cellPoint[0], cellPoint[1], cellPoint[2]);
            }
            else 
            {
                SNPRINTF(buff, 512, "Point: (in transformed space) \n       <%f, %f, %f>\n",
                        cellPoint[0], cellPoint[1], cellPoint[2]);
            }
        }
        os += buff;
    }
    bool showZoneCoords = (showZoneDomainLogicalCoords  && !dzoneCoords.empty()) || 
                          (showZoneBlockLogicalCoords && !bzoneCoords.empty());
    bool showNodeCoords = (showNodePhysicalCoords && !pnodeCoords.empty())||
                          (showNodeDomainLogicalCoords && !dnodeCoords.empty())|| 
                          (showNodeBlockLogicalCoords && !bnodeCoords.empty());
    if (pickType == Zone || pickType == DomainZone)
    {
        if (showZoneId || showZoneCoords)
            os += "Zone:  ";
        if (showZoneId)
        {
            SNPRINTF(buff, 512, "%d", elementNumber);
            os += buff;
        }
        if (showZoneDomainLogicalCoords & !dzoneCoords.empty()) 
        {
            SNPRINTF(buff, 512, " domain %s", dzoneCoords[0].c_str());
            os += buff;
        }
        if (showZoneBlockLogicalCoords & !bzoneCoords.empty()) 
        {
            SNPRINTF(buff, 512, " block %s", bzoneCoords[0].c_str());
            os += buff;
        }
        if (showZoneId || showZoneCoords)
            os += "\n";
    }
    else if (pickType == Node || pickType == DomainNode)
    {
        if (showNodeId || showNodeCoords)
            os += "Node:  ";
        if (showNodeId)
        {
            SNPRINTF(buff, 512, "%d", elementNumber);
            os += buff;
        }
        if (showNodePhysicalCoords & !pnodeCoords.empty()) 
        {
            SNPRINTF(buff, 512, " %s", pnodeCoords[0].c_str());
            os += buff;
        }
        if (showNodeDomainLogicalCoords & !dnodeCoords.empty()) 
        {
            SNPRINTF(buff, 512, " domain %s", dnodeCoords[0].c_str());
            os += buff;
        }
        if (showNodeBlockLogicalCoords & !bnodeCoords.empty()) 
        {
            SNPRINTF(buff, 512, " block %s", bnodeCoords[0].c_str());
            os += buff;
        }
        if (showNodeId || showNodeCoords)
            os += "\n";
    }
    if (displayIncidentElements)
    {
        bool showId;
        if (pickType == Zone || pickType == DomainZone)
        {
            os += "Incident Nodes:  " ; 
            if (showNodeCoords)
            {
                os += "\n    "; 
            }
            showId = showNodeId;
        }
        else if (pickType == Node || pickType == DomainNode)
        {
            os += "Incident zones:  " ; 
            if (showZoneCoords)
            {
                os += "\n    "; 
            }
            showId = showZoneId;
        }

        for (i = 0; i < incidentElements.size(); i++)
        {
            if (showId)
            {
                SNPRINTF(buff, 512, "%d  ", incidentElements[i]);
                os += buff; 
            }
            if (pickType == Zone || pickType == DomainZone)
            {
                if (showNodePhysicalCoords & !pnodeCoords.empty()) 
                {
                    SNPRINTF(buff, 512, " %s", pnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNodeDomainLogicalCoords & !dnodeCoords.empty()) 
                {
                    SNPRINTF(buff, 512, " domain %s", dnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNodeBlockLogicalCoords & !bnodeCoords.empty()) 
                {
                    SNPRINTF(buff, 512, " block %s", bnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNodeCoords)
                {
                    os += "\n    "; 
                }
            }
            else if (pickType == Node || pickType == DomainNode)
            {
                if (showZoneDomainLogicalCoords & !dzoneCoords.empty()) 
                {
                    SNPRINTF(buff, 512, " domain %s", dzoneCoords[i].c_str());
                    os += buff;
                }
                if (showZoneBlockLogicalCoords & !bzoneCoords.empty()) 
                {
                    SNPRINTF(buff, 512, " block %s", bzoneCoords[i].c_str());
                    os += buff;
                }
                if (showZoneCoords)
                {
                    os += "\n    "; 
                }
            }
        }
        os += "\n";
    }

    for (i = 0; i < varInfo.size(); i++)
    {
        std::string iv;
        std::string pt = PickType_ToString(pickType);
        //
        // VarInfo does not append a newline char, but we need one here
        //
        ((PickVarInfo*)varInfo[i])->CreateOutputString(iv, pt);
        os += iv;
        os += "\n";
    }
    if (invalidVars.size() > 0)
    {
        os += "The following variables are invalid, and Pick ignored them:\n";
        for (i = 0; i < invalidVars.size(); i++)
        {
            os += "  " + invalidVars[i];
        }
        os += "\n";
    }
}

Function: PrepareForNewPick
Declaration: void PrepareForNewPick();
Definition:
// ****************************************************************************
// Method: PickAttributes::PrepareForNewPick
//
// Purpose: 
//   Clear certain fields in preparation for new pick.  These are fields that
//   will get filled in during the pick process.
//
// Programmer: Kathleen Bonnell 
// Creation:   June 26, 2003 
//
// Modifications:
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003
//   Reset meshInfo.
//   
//   Kathleen Bonnell, Wed Sep 17 17:09:00 PDT 2003 
//   Reset realElementNumber, realIncidentElements.
//   
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003 
//   Reset zoneCoords. 
//   
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003 
//   Support new types of coordinates. 
//   
//   Kathleen Bonnell, Tue Mar 16 16:02:05 PST 2004
//   Clear invalidVars. 
//   
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004 
//   Reset matSelected and needActualCoords. 
//   
// ****************************************************************************

void
PickAttributes::PrepareForNewPick()
{
    clearWindow  = false;
    fulfilled    = false;
    elementNumber   = -1;
    domain          = -1;
    dimension       = -1;
    pickPoint[0] = pickPoint[1] = pickPoint[2] = 0;
    cellPoint[0] = cellPoint[1] = cellPoint[2] = 0;
    nodePoint[0] = nodePoint[1] = nodePoint[2] = 0;
    needTransformMessage = false;

    if (!incidentElements.empty())
        incidentElements.clear();

    if (!pnodeCoords.empty())
        pnodeCoords.clear();

    if (!dnodeCoords.empty())
        dnodeCoords.clear();

    if (!bnodeCoords.empty())
        bnodeCoords.clear();

    if (!dzoneCoords.empty())
        dzoneCoords.clear();

    if (!bzoneCoords.empty())
        bzoneCoords.clear();

    realElementNumber = -1;
    if (!realIncidentElements.empty())
        realIncidentElements.clear();

    meshInfo = "";
    for (int i = 0; i < 6; ++i)
        plotBounds[i] = 0.;

    ClearPickVarInfos();

    if (!invalidVars.empty())
        invalidVars.clear();

    errorMessage = "";
    error = false;

    matSelected = false;

    needActualCoords = false;
}

Function: SetFromNode
Declaration: virtual void SetFromNode(DataNode *parentNode);
Definition:
// ****************************************************************************
// Method: PickAttributes::SetFromNode
//
// Purpose: 
//
// Modifications:
//   
// ****************************************************************************
void
PickAttributes::SetFromNode(DataNode *parentNode)
{
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("PickAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;

    if((node = searchNode->GetNode("variables")) != 0)
        SetVariables(node->AsStringVector());

    if((node = searchNode->GetNode("displayIncidentElements")) != 0)
        SetDisplayIncidentElements(node->AsBool());

    if((node = searchNode->GetNode("showNodeId")) != 0)
        SetShowNodeId(node->AsBool());
    if((node = searchNode->GetNode("showNodeDomainLogicalCoords")) != 0)
        SetShowNodeDomainLogicalCoords(node->AsBool());
    if((node = searchNode->GetNode("showNodeBlockLogicalCoords")) != 0)
        SetShowNodeBlockLogicalCoords(node->AsBool());
    if((node = searchNode->GetNode("showNodePhysicalCoords")) != 0)
        SetShowNodePhysicalCoords(node->AsBool());

    if((node = searchNode->GetNode("showZoneId")) != 0)
        SetShowZoneId(node->AsBool());
    if((node = searchNode->GetNode("showZoneDomainLogicalCoords")) != 0)
        SetShowZoneDomainLogicalCoords(node->AsBool());
    if((node = searchNode->GetNode("showZoneBlockLogicalCoords")) != 0)
        SetShowZoneBlockLogicalCoords(node->AsBool());

    // Clear all the PickVarInfos.
    ClearPickVarInfos();

}

Function: CreateNode
Declaration: virtual bool CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd);
Definition:
// ****************************************************************************
// Method: PickAttributes::CreateNode
//
// Purpose: 
//
// Modifications:
//   
// ****************************************************************************
bool
PickAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    PickAttributes defaultObject;
    bool addToParent = false;
    // Create a node for PickAttributes.
    DataNode *node = new DataNode("PickAttributes");

    if(completeSave || !FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("variables", variables));
    }

    if(completeSave || !FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("displayIncidentElements", displayIncidentElements));
    }

    if(completeSave || !FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showNodeId", showNodeId));
    }

    if(completeSave || !FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showNodeDomainLogicalCoords", 
                                    showNodeDomainLogicalCoords));
    }

    if(completeSave || !FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showNodeBlockLogicalCoords", 
                                    showNodeBlockLogicalCoords));
    }

    if(completeSave || !FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showNodePhysicalCoords", 
                                    showNodePhysicalCoords));
    }

    if(completeSave || !FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showZoneId", 
                                    showZoneId));
    }

    if(completeSave || !FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showZoneDomainLogicalCoords", 
                                    showZoneDomainLogicalCoords));
    }

    if(completeSave || !FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("showZoneBlockLogicalCoords", 
                                    showZoneBlockLogicalCoords));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);

}

