Function: PrintSelf
Declaration: void PrintSelf(ostream &os);
Definition:
// ****************************************************************************
// Method: PickAttributes::PrintSelf
//
// Purpose:
//   Prints the contents of this class to the passed stream.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Reflect new member names (zoneNumber is now elementNumber, nodes is
//   now incidentElements).  Differentiate between zone pick and node pick.
//
//   Kathleen Bonnell, Wed Jul 23 17:28:30 PDT 2003
//   Don't print cellPoint if it is invalid (== FLT_MAX).
//
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003
//   Added meshInfo.
//
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003
//   Support logical zone numbers.
//
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003
//   Support multiple types of coordinates.
//
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004
//   Support new pick types 'DomainNode', 'DomainZone'.
//
//   Kathleen Bonnell, Wed Jun  9 12:24:09 PDT 2004
//   Add conciseOutput.
//
//   Hank Childs, Thu Jun  8 16:21:44 PDT 2006
//   Initialize showId to avoid compiler warning.
//
//   Kathleen Bonnell, Tue Feb 13 12:41:28 PST 2007
//   If meshCoordType not XY, add (Z,R) or (R,Z) to point info.
//
//   Hank Childs, Mon Aug 27 13:59:12 PDT 2007
//   Print out createSpreadsheet.
//
//   Hank Childs, Fri Aug 31 15:35:28 PDT 2007
//   Print out subset name.
//
//   Cyrus Harrison, Mon Sep 17 10:41:25 PDT 200
//   Added support for user settable floating point format string
//
//   Kathleen Bonnell, Tue Jun 24 09:04:23 PDT 2008
//   Minor format change: ensure newline prints after domain (or lack thereof).
//   Change 'preserved' to 'preserve'.
//
//   Kathleen Biagas, Wed Oct 26 13:31:50 PDT 2011
//   Only print timeStep information if requested and not -1.
//
//   Kathleen Biagas, Tue Jul 22 11:35:33 MST 2014
//   Account for global ids.
//
// ****************************************************************************
void
PickAttributes::PrintSelf(ostream &os)
{
    size_t i;

    char buff[512];

    std::string fileName;
    std::string format;
    size_t pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;
    if (pickLetter.size() != 0)
        os << "\n" << pickLetter.c_str() << ":  ";
    else
        os << "\n";
    os << fileName.c_str() << " ";
    if (showTimeStep && timeStep != -1)
        os << "timestep " << timeStep << " ";
    if (meshInfo.empty())
    {
        if (domain != -1)
            os << "domain " << domain ;
        os << "\n";
    }
    else
    {
        os << "\n" << meshInfo.c_str() << "\n";
    }
    if (subsetName != "")
        os << "The subset name is " << subsetName << "\n";
    os << "active variable:   " << activeVariable.c_str() << "\n";
    os << "selected variables: ";
    for (i = 0; i < variables.size(); i++)
        os << variables[i].c_str() << "  ";
    os << "\n";
    if (pickType == CurveNode)
    {
        format = "PickedPoint: <" + floatFormat + ", "
                                  + floatFormat + ", "
                                  + floatFormat + ">\n";
        snprintf(buff, 512, format.c_str(),nodePoint[0],
                                           nodePoint[1],
                                           nodePoint[2]);
        os << buff;
    }
    else if (pickType == CurveZone)
    {
        format = "EndPoint1: <" + floatFormat + ", "
                                + floatFormat + ", "
                                + floatFormat + ">\n";
        snprintf(buff, 512, format.c_str(),nodePoint[0],
                                           nodePoint[1],
                                           nodePoint[2]);
        os << buff;
        format = "EndPoint2: <" + floatFormat + ", "
                                + floatFormat + ", "
                                + floatFormat + ">\n";
        snprintf(buff, 512, format.c_str(),cellPoint[0],
                                           cellPoint[1],
                                           cellPoint[2]);
        os << buff;
    }
    else if (cellPoint[0] != FLT_MAX)
    {
        os << "PickedPoint: ";
        if (meshCoordType == RZ)
            os << "(Z,R) ";
        else if (meshCoordType == ZR)
            os << "(R,Z) ";
        if (needTransformMessage)
        {
            os << " (in transformed space) " ;
        }

        format = "<" + floatFormat + ", "
                     + floatFormat + ", "
                     + floatFormat + ">\n";
        snprintf(buff, 512, format.c_str(),cellPoint[0],
                                           cellPoint[1],
                                           cellPoint[2]);
        os << buff;
    }
    if (pickType == Zone || pickType == DomainZone)
    {
        os << "Zone " ;
        if (showZoneId)
        {
            if (elementIsGhost)
                os<< elementNumber << "(ghost) ";
            else if (elementIsGlobal)
                os<< elementNumber << "(global) ";
            else
                os<< elementNumber << " ";
        }
        if (showZoneDomainLogicalCoords && !dzoneCoords.empty())
        {
            os << "d" << dzoneCoords[0].c_str();
        }
        if (showZoneBlockLogicalCoords && !bzoneCoords.empty())
        {
            os << " b" << bzoneCoords[0].c_str();
        }
        os << "\n";
    }
    else if (pickType == Node || pickType == DomainNode)
    {
        os << "Node ";
        if (showNodeId)
        {
            if (elementIsGhost)
                os << elementNumber << "(ghost) ";
            else if (elementIsGlobal)
                os << elementNumber << "(global) ";
            else
                os << elementNumber << " ";
        }
        if (showNodePhysicalCoords && !pnodeCoords.empty())
        {
            os << pnodeCoords[0].c_str() ;
        }
        if (showNodeDomainLogicalCoords && !dnodeCoords.empty())
        {
            os << dnodeCoords[0].c_str() ;
        }
        if (showNodeBlockLogicalCoords && !bnodeCoords.empty())
        {
            os << bnodeCoords[0].c_str() ;
        }
        os << "\n";
    }
    if (showIncidentElements)
    {
        bool showId = false;
        if (pickType == Zone || pickType == DomainZone)
        {
            os << "Incident Nodes " ;
            showId = showNodeId;
        }
        else if (pickType == Node || pickType == DomainNode)
        {
            os << "Incident Zones " ;
            showId = showZoneId;
        }
        for (i = 0; i < incidentElements.size(); i++)
        {
            if (showId)
            {
                if (ghosts.size() > 0 && ghosts[i])
                    os << incidentElements[i] << "(ghost)  ";
                else
                    os << incidentElements[i] << "  ";
            }
            if (pickType == Zone || pickType == DomainZone)
            {
                if (showNodePhysicalCoords && !pnodeCoords.empty())
                    os << " " << pnodeCoords[i].c_str() << "\n";
                if (showNodeDomainLogicalCoords && !dnodeCoords.empty())
                    os << " domain " << dnodeCoords[i].c_str() << "\n";
                if (showNodeBlockLogicalCoords && !bnodeCoords.empty())
                    os << " block " << bnodeCoords[i].c_str() << "\n";
            }
            else if (pickType == Node || pickType == DomainNode)
            {
                if (showZoneDomainLogicalCoords && !dzoneCoords.empty())
                    os << " domain " << dzoneCoords[i].c_str() << "\n";
                if (showZoneBlockLogicalCoords && !bzoneCoords.empty())
                    os << " block " << bzoneCoords[i].c_str() << "\n";
            }
        }
        os << "\n";
    }
    for (i = 0; i < varInfo.size(); i++)
        ((PickVarInfo*)varInfo[i])->PrintSelf(os);

    format = "RayPoint 1: <" + floatFormat + ", "
                             + floatFormat + ", "
                             + floatFormat + ">\n";

    snprintf(buff, 512, format.c_str(),rayPoint1[0],
                                       rayPoint1[1],
                                       rayPoint1[2]);
    os << buff;
    format = "RayPoint 2: <" + floatFormat + ", "
                             + floatFormat + ", "
                             + floatFormat + ">\n";
    snprintf(buff, 512, format.c_str(),rayPoint2[0],
                                       rayPoint2[1],
                                       rayPoint2[2]);
    os << buff;

    if (doTimeCurve)
        os << "Set up to create a time-curve.\n";

    if (timePreserveCoord)
        os << "Set up for time-curve to preserve picked coord.\n";

    if (timeCurveType == PickAttributes::Single_Y_Axis)
        os << "Set up for time-curve to create a curve plot with single y axis.\n";
    else
        os << "Set up for time-curve to create a curve plot with multiple y axes.\n";

    if (createSpreadsheet)
        os << "Create a spreadsheet with this pick.\n";

    if (conciseOutput)
        os << "Set up to create concise Output.\n";
}

Function: CreateOutputString
Declaration: void CreateOutputString(std::string &os, bool withLetter = true);
Definition:
// ****************************************************************************
// Method: PickAttributes::CreateOutputString
//
// Purpose:
//   Creates a single output string containing all the information gathered
//   from a pick.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Reflect new member names (zoneNumber is now elementNumber, nodes is
//   now incidentElements).  Differentiate between zone pick and node pick.
//
//   Kathleen Bonnell, Wed Jul 23 17:28:30 PDT 2003
//   Don't include cellPoint or pickLetter if invalid.
//
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003
//   Added meshInfo.  So that outputstring can be created with (default)
//   or without the 'pickletter', added argument withLetter.
//
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003
//   Support logical zone numbers.
//
//   Kathleen Bonnell, Tue Dec  2 17:33:13 PST 2003
//   Minor changes so that picking on Curves does not display unnecessary
//   information.
//
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003
//   Support multiple types of coordinates.
//
//   Kathleen Bonnell, Tue Mar 16 16:02:05 PST 2004
//   Create message regarding invalid variables.
//
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004
//   Support new pick types 'DomainNode', 'DomainZone'.
//
//   Kathleen Bonnell, Wed Jun  9 12:24:09 PDT 2004
//   Added 'showTimeStep'.
//
//   Mark C. Miller, Tue Aug 24 19:53:18 PDT 2004
//   Added block/group piece names
//
//   Hank Childs, Thu Jun  8 16:21:44 PDT 2006
//   Initialize showId to avoid compiler warning.
//
//   Kathleen Bonnell, Tue Feb 13 12:41:28 PST 2007
//   If meshCoordType not XY, add (Z,R) or (R,Z) to point info.
//
//   Dave Bremer, Tue Feb 13 15:56:02 PST 2007
//   Add support for blockPieceName as a template string, into which
//   we print the domain.
//
//   Cyrus Harrison, Mon Sep 17 10:13:18 PDT 2007
//   Add support for user settable floating point format string
//
//   Kathleen Biagas, Wed Oct 26 13:31:50 PDT 2011
//   Only print timeStep information if requested and not -1.
//
//   Kathleen Biagas, Wed Mar 08 17:12:07 PST 2012
//   Use plot overrides of showXXX settings if set in plotRequested MapNode.
//
// ****************************************************************************

void
PickAttributes::CreateOutputString(std::string &os, bool withLetter)
{
    if (error)
    {
        os = errorMessage;
        return;
    }

    if (!fulfilled)
        return;

    if (conciseOutput)
    {
        CreateConciseOutputString(os, withLetter);
        return;
    }

    char buff[512];

    std::string fileName;
    std::string format;
    size_t pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;

    if (withLetter)
    {
        if (pickLetter.size() != 0)
            snprintf(buff, 512, "\n%s:  ", pickLetter.c_str());
        else
            snprintf(buff, 512, "\n");
        os += buff;
    }
    os += fileName;
    if (timeStep != -1)
    {
        bool showTS = showTimeStep;
        if (plotRequested.HasNumericEntry("showTimeStep"))
            showTS = plotRequested.GetEntry("showTimeStep")->ToBool();

        if (showTS)
        {
            snprintf(buff, 512, "  timestep %d", timeStep);
            os += buff;
        }
    }

    std::string domStr = (blockPieceName == "" ? "domain" : blockPieceName);
    std::string grpStr = (groupPieceName == "" ? "group" : groupPieceName);

    if (domain != -1 && strstr(domStr.c_str(), "%") != NULL)
    {
        snprintf(buff, 512, domStr.c_str(), domain);
        domStr = buff;
    }

    if (meshInfo.empty())
    {
        if (domain != -1)
        {
            snprintf(buff, 512, "  %s %d\n", domStr.c_str(), domain);
            os += buff;
        }
        else
            os += "\n";
    }
    else
    {
        bool showMN = showMeshName;
        if (plotRequested.HasNumericEntry("showMeshName"))
            showMN = plotRequested.GetEntry("showMeshName")->ToBool();

        if (showMN)
        {
            snprintf(buff, 512, "\n%s\n", meshInfo.c_str());
            os += buff;
        }
    }

    std::string point = "Point";
    if (meshCoordType == RZ)
        point += " (Z,R)";
    else if (meshCoordType == ZR)
        point += " (R,Z)";

    std::string pointString;
    if (plotRequested.HasEntry("pointString"))
        pointString = plotRequested.GetEntry("pointString")->AsString();

    if (pointString.empty())
    {
        if (pickType == CurveNode)
        {
            format = "Point: <" + floatFormat + ", " + floatFormat + ">\n";
            snprintf(buff, 512, format.c_str(), nodePoint[0], nodePoint[1]);
            os += buff;
        }
        else if (pickType == CurveZone)
        {
            format = "Point1: <" + floatFormat + ", " + floatFormat + ">\n"
                    +"Point2: <" + floatFormat + ", " + floatFormat + ">\n";

            snprintf(buff, 512, format.c_str(),
                      nodePoint[0], nodePoint[1], cellPoint[0], cellPoint[1]);
            os += buff;
        }
        else if (cellPoint[0] != FLT_MAX)
        {
            if (dimension == 2)
            {
                if (!needTransformMessage)
                {
                    format = "%s: <" + floatFormat + ", " + floatFormat + ">\n";
                    snprintf(buff, 512, format.c_str(),
                            point.c_str(), cellPoint[0], cellPoint[1]);
                }
                else
                {
                    format = "%s: (in transformed space)\n        <"
                                + floatFormat + ", " + floatFormat + ">\n";
                    snprintf(buff, 512, format.c_str(),
                            point.c_str(), cellPoint[0], cellPoint[1]);
                }
            }
            else
            {
                if (!needTransformMessage)
                {
                    format = "%s: <" + floatFormat + ", "
                                     + floatFormat + ", "
                                     + floatFormat + ">\n";
                    snprintf(buff, 512, format.c_str(),
                            point.c_str(), cellPoint[0], cellPoint[1], cellPoint[2]);
                }
                else
                {
                    format = "%s: (in transformed space) \n       <"
                                     + floatFormat + ", "
                                     + floatFormat + ", "
                                     + floatFormat + ">\n";
                    snprintf(buff, 512, format.c_str(),
                            point.c_str(), cellPoint[0], cellPoint[1], cellPoint[2]);
                }
            }
            os += buff;
        }
    }
    else
    {
        snprintf(buff, 512, "\nPoint: %s\n", pointString.c_str());
        os += buff;
    }

    bool showZDLC = showZoneDomainLogicalCoords;
    if (plotRequested.HasNumericEntry("showZoneDomainLogicalCoords"))
        showZDLC = plotRequested.GetEntry("showZoneDomainLogicalCoords")->ToBool();
    showZDLC &= !dzoneCoords.empty();
    bool showZBLC = showZoneBlockLogicalCoords;
    if (plotRequested.HasNumericEntry("showZoneBlockLogicalCoords"))
        showZBLC = plotRequested.GetEntry("showZoneBlockLogicalCoords")->ToBool();
    showZBLC &= !bzoneCoords.empty();
    bool showZoneCoords = (showZDLC || showZBLC);

    bool showNPC = showNodePhysicalCoords;
    if (plotRequested.HasNumericEntry("showNodePhysicalCoords"))
        showNPC = plotRequested.GetEntry("showNodePhysicalCoords")->ToBool();
    showNPC &= !pnodeCoords.empty();
    bool showNDLC = showNodeDomainLogicalCoords;
    if (plotRequested.HasNumericEntry("showNodeDomainLogicalCoords"))
        showNDLC = plotRequested.GetEntry("showNodeDomainLogicalCoords")->ToBool();
    showNDLC &= !dnodeCoords.empty();
    bool showNBLC = showNodeBlockLogicalCoords;
    if (plotRequested.HasNumericEntry("showNodeBlockLogicalCoords"))
        showNBLC = plotRequested.GetEntry("showNodeBlockLogicalCoords")->ToBool();
    showNBLC &= !bnodeCoords.empty();
    bool showNodeCoords = (showNPC  || showNDLC || showNBLC );

    bool showZId = showZoneId;
    if (plotRequested.HasNumericEntry("showZoneId"))
        showZId = plotRequested.GetEntry("showZoneId")->ToBool();

    bool showNId = showNodeId;
    if (plotRequested.HasNumericEntry("showNodeId"))
        showNId = plotRequested.GetEntry("showNodeId")->ToBool();

    if (pickType == Zone || pickType == DomainZone)
    {
        if (showZId || showZoneCoords)
            os += "Zone:  ";
        if (showZId)
        {
            if (!elementIsGhost)
            {
                if (!showGlobalIds || globalElement == -1)
                    snprintf(buff, 512, "%d", elementNumber);
                else
                    snprintf(buff, 512, "%d (global)", globalElement);
            }
            else
                snprintf(buff, 512, "%d(ghost)", elementNumber);
            os += buff;
        }
        if (showZDLC)
        {
            snprintf(buff, 512, " %s %s", domStr.c_str(), dzoneCoords[0].c_str());
            os += buff;
        }
        if (showZBLC)
        {
            snprintf(buff, 512, " %s %s", grpStr.c_str(), bzoneCoords[0].c_str());
            os += buff;
        }
        if (showZoneId || showZoneCoords)
            os += "\n";
    }
    else if (pickType == Node || pickType == DomainNode)
    {
        if (showNId || showNodeCoords)
            os += "Node:  ";
        if (showNId)
        {
            if (!elementIsGhost)
            {
                if (!showGlobalIds || globalElement == -1)
                    snprintf(buff, 512, "%d", elementNumber);
                else
                    snprintf(buff, 512, "%d (global)", globalElement);
            }
            else
                snprintf(buff, 512, "%d(ghost)", elementNumber);
            os += buff;
        }
        if (showNPC)
        {
            snprintf(buff, 512, " %s", pnodeCoords[0].c_str());
            os += buff;
        }
        if (showNDLC)
        {
            snprintf(buff, 512, " %s %s", domStr.c_str(), dnodeCoords[0].c_str());
            os += buff;
        }
        if (showNBLC)
        {
            snprintf(buff, 512, " %s %s", grpStr.c_str(), bnodeCoords[0].c_str());
            os += buff;
        }
        if (showNodeId || showNodeCoords)
            os += "\n";
    }

    bool showIE = showIncidentElements;
    if (plotRequested.HasNumericEntry("showIncidentElements"))
        showIE = plotRequested.GetEntry("showIncidentElements")->ToBool();

    if (showIE)
    {
        bool showId = false;
        bool showGlobal = globalIncidentElements.size() == incidentElements.size();
        if (pickType == Zone || pickType == DomainZone)
        {
            if (!showGlobal)
                os += "Incident Nodes:  " ;
            else
                os += "Incident Nodes: (global)  " ;
            if (showNodeCoords)
            {
                os += "\n    ";
            }
            showId = showNodeId;
            if (plotRequested.HasNumericEntry("showNodeId"))
                showId = plotRequested.GetEntry("showNodeId")->ToBool();
        }
        else if (pickType == Node || pickType == DomainNode)
        {
            if (!showGlobal)
                os += "Incident Zones:  " ;
            else
                os += "Incident Zones: (global)  " ;
            if (showZoneCoords)
            {
                os += "\n    ";
            }
            showId = showZoneId;
            if (plotRequested.HasNumericEntry("showZoneId"))
                showId = plotRequested.GetEntry("showZoneId")->ToBool();
        }
        for (size_t i = 0; i < incidentElements.size(); i++)
        {
            if (showId)
            {
                if (ghosts.size() > 0 && ghosts[i])
                    snprintf(buff, 512, "%d(ghost)  ", incidentElements[i]);
                else if (showGlobal)
                    snprintf(buff, 512, "%d  ", globalIncidentElements[i]);
                else
                    snprintf(buff, 512, "%d  ", incidentElements[i]);
                os += buff;
            }
            if (pickType == Zone || pickType == DomainZone)
            {
                if (showNPC)
                {
                    snprintf(buff, 512, " %s", pnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNDLC)
                {
                    snprintf(buff, 512, " %s %s", domStr.c_str(), dnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNBLC)
                {
                    snprintf(buff, 512, " %s %s", grpStr.c_str(), bnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNodeCoords)
                {
                    os += "\n    ";
                }
            }
            else if (pickType == Node || pickType == DomainNode)
            {
                if (showZDLC)
                {
                    snprintf(buff, 512, " %s %s", domStr.c_str(), dzoneCoords[i].c_str());
                    os += buff;
                }
                if (showZBLC)
                {
                    snprintf(buff, 512, " %s %s", grpStr.c_str(), bzoneCoords[i].c_str());
                    os += buff;
                }
                if (showZoneCoords)
                {
                    os += "\n    ";
                }
            }
        }
        os += "\n";
    }

    for (size_t i = 0; i < varInfo.size(); i++)
    {
        std::string iv;
        std::string pt = PickType_ToString(pickType);
        //
        // VarInfo does not append a newline char, but we need one here
        //
        PickVarInfo* info = (PickVarInfo*)varInfo[i];
        info->SetFloatFormat(floatFormat);
        info->CreateOutputString(iv, pt);
        os += iv;
        os += "\n";
    }
    if (invalidVars.size() > 0)
    {
        os += "The following variables are invalid, and Pick ignored them:\n";
        for (size_t i = 0; i < invalidVars.size(); i++)
        {
            os += "  " + invalidVars[i];
        }
        os += "\n";
    }
}

Function: PrepareForNewPick
Declaration: void PrepareForNewPick();
Definition:
// ****************************************************************************
// Method: PickAttributes::PrepareForNewPick
//
// Purpose:
//   Clear certain fields in preparation for new pick.  These are fields that
//   will get filled in during the pick process.
//
// Programmer: Kathleen Bonnell
// Creation:   June 26, 2003
//
// Modifications:
//   Kathleen Bonnell, Wed Sep 10 08:02:02 PDT 2003
//   Reset meshInfo.
//
//   Kathleen Bonnell, Wed Sep 17 17:09:00 PDT 2003
//   Reset realElementNumber, realIncidentElements.
//
//   Kathleen Bonnell, Tue Nov 18 10:06:40 PST 2003
//   Reset zoneCoords.
//
//   Kathleen Bonnell, Wed Dec 17 15:19:46 PST 2003
//   Support new types of coordinates.
//
//   Kathleen Bonnell, Tue Mar 16 16:02:05 PST 2004
//   Clear invalidVars.
//
//   Kathleen Bonnell, Tue Jun  1 16:44:44 PDT 2004
//   Reset matSelected and needActualCoords.
//
//   Mark C. Miller, Tue Aug 24 19:37:14 PDT 2004
//   Added code to reset blockPieceName and groupPieceName
//
//   Kathleen Bonnell, Thu Oct 21 15:17:05 PDT 2004
//   Reset requiresPickGlyph.
//
//   Kathleen Bonnell, Fri Jul  8 14:27:26 PDT 2005
//   Reset hasMixedGhostTypes.
//
//   Kathleen Bonnell, Tue Feb 13 12:41:28 PST 2007
//   Reset meshCoordType.
//
//   Brad Whitlock, Tue Jan 20 16:42:30 PST 2009
//   Changed to using local CoordinateType enum.
//
//   Kathleen Bonnell, Thu Feb  3 11:20:11 PST 2011
//   plotBounds changed to a vetor.
//
// ****************************************************************************

void
PickAttributes::PrepareForNewPick()
{
    clearWindow  = false;
    fulfilled    = false;
    elementNumber   = -1;
    domain          = -1;
    dimension       = -1;
    pickPoint[0] = pickPoint[1] = pickPoint[2] = 0;
    cellPoint[0] = cellPoint[1] = cellPoint[2] = 0;
    nodePoint[0] = nodePoint[1] = nodePoint[2] = 0;
    needTransformMessage = false;
    ghostType = 0;
    hasMixedGhostTypes = -1;
    meshCoordType = XY;

    if (!incidentElements.empty())
        incidentElements.clear();

    if (!pnodeCoords.empty())
        pnodeCoords.clear();

    if (!dnodeCoords.empty())
        dnodeCoords.clear();

    if (!bnodeCoords.empty())
        bnodeCoords.clear();

    if (!dzoneCoords.empty())
        dzoneCoords.clear();

    if (!bzoneCoords.empty())
        bzoneCoords.clear();

    realElementNumber = -1;
    if (!realIncidentElements.empty())
        realIncidentElements.clear();

    meshInfo = "";
    if (!plotBounds.empty())
        plotBounds.clear();
    ClearVarInfos();

    if (!invalidVars.empty())
        invalidVars.clear();

    errorMessage = "";
    error = false;

    matSelected = false;

    needActualCoords = false;

    blockPieceName = "";
    groupPieceName = "";

    if (!ghosts.empty())
        ghosts.clear();

    includeGhosts = false;
    elementIsGhost = false;
    requiresGlyphPick = false;
    locationSuccessful = false;

    globalElement = -1;
    if (!globalIncidentElements.empty())
        globalIncidentElements.clear();

    linesData = false;
    inputTopoDim = -1;
}

Function: CreateConciseOutputString
Declaration: void CreateConciseOutputString(std::string &os, bool withLetter = true);
Definition:
// ****************************************************************************
// Method: PickAttributes::CreateConciseOutputString
//
// Purpose:
//   Creates a single output string containing all the information gathered
//   from a pick, condensed to use as little space as possible.
//
// Programmer:  Kathleen Bonnell
// Creation:    June 9, 2004
//
// Modifications:
//
//   Mark C. Miller, Tue Aug 24 19:53:18 PDT 2004
//   Added block/group piece names
//
//   Hank Childs, Thu Jun  8 16:21:44 PDT 2006
//   Initialize showId to avoid compiler warning.
//
//   Dave Bremer, Tue Feb 13 15:56:02 PST 2007
//   Add support for blockPieceName as a template string, into which
//   we print the domain.
//
//   Cyrus Harrison, Mon Sep 17 10:41:25 PDT 200
//   Added support for user settable floating point format string
//
//   Kathleen Biagas, Wed Oct 26 13:31:50 PDT 2011
//   Only print timeStep information if requested and not -1.
//
//   Kathleen Biagas, Wed Mar 08 17:12:07 PST 2012
//   Use plot overrides of showXXX settings if set in plotRequested MapNode.
//
// ****************************************************************************

void
PickAttributes::CreateConciseOutputString(std::string &os, bool withLetter)
{
    char buff[512];

    std::string fileName;
    std::string format;
    size_t pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;

    if (withLetter)
    {
        if (pickLetter.size() != 0)
            snprintf(buff, 512, "\n%s:  ", pickLetter.c_str());
        else
            snprintf(buff, 512, "\n");
        os += buff;
    }
    os += fileName;
    if (timeStep != -1)
    {
        bool showTS = showTimeStep;
        if (plotRequested.HasNumericEntry("showTimeStep"))
            showTS = plotRequested.GetEntry("showTimeStep")->ToBool();

        if (showTS)
        {
            snprintf(buff, 512, "  timestep %d", timeStep);
            os += buff;
        }
    }

    std::string domStr = (blockPieceName == "" ? "domain" : blockPieceName);

    if (meshInfo.empty())
    {
        if (domain != -1)
        {
            if (strstr(domStr.c_str(), "%") != NULL)
            {
                buff[0] = ' ';
                buff[1] = ' ';
                snprintf(buff+2, 510, domStr.c_str(), domain);
            }
            else
                snprintf(buff, 512, "  %s %d", domStr.c_str(), domain);

            os += buff;
        }
    }
    else
    {
        bool showMN = showMeshName;
        if (plotRequested.HasNumericEntry("showMeshName"))
            showMN = plotRequested.GetEntry("showMeshName")->ToBool();

        if (showMN)
        {
            snprintf(buff, 512, "  %s", meshInfo.c_str());
            os += buff;
        }
    }

    std::string pointString;
    if (plotRequested.HasEntry("pointString"))
        pointString = plotRequested.GetEntry("pointString")->AsString();

    if (pointString.empty())
    {
        if (pickType == CurveNode)
        {
            format = " at <" + floatFormat + ", " + floatFormat +  ">\n";
            snprintf(buff, 512, format.c_str() , nodePoint[0], nodePoint[1]);
            os += buff;
        }
        else if (pickType == CurveZone)
        {
            format = " at <" + floatFormat + ", " + floatFormat +  ">"
                     +" & <" + floatFormat + ", " + floatFormat +  ">\b";
            snprintf(buff, 512, format.c_str(),
                      nodePoint[0], nodePoint[1], cellPoint[0], cellPoint[1]);
            os += buff;
        }
        else if (cellPoint[0] != FLT_MAX)
        {
            if (dimension == 2)
            {
                format = " at <" + floatFormat + ", " + floatFormat +  ">\n";
                snprintf(buff, 512, format.c_str(), cellPoint[0], cellPoint[1]);
            }
            else
            {
                format = " at <" + floatFormat + ", "
                                 + floatFormat + ", "
                                 + floatFormat +  ">\n";
                snprintf(buff, 512, format.c_str(),
                            cellPoint[0], cellPoint[1], cellPoint[2]);
            }
            os += buff;
        }
    }
    else
    {
        snprintf(buff, 512, " at %s\n", pointString.c_str());
        os += buff;
    }


    bool showZDLC = showZoneDomainLogicalCoords;
    if (plotRequested.HasNumericEntry("showZoneDomainLogicalCoords"))
        showZDLC = plotRequested.GetEntry("showZoneDomainLogicalCoords")->ToBool();
    bool showZBLC = showZoneBlockLogicalCoords;
    if (plotRequested.HasNumericEntry("showZoneBlockLogicalCoords"))
        showZBLC = plotRequested.GetEntry("showZoneBlockLogicalCoords")->ToBool();
    bool showZoneCoords = (showZDLC && !dzoneCoords.empty())  ||
                          (showZBLC && !bzoneCoords.empty());

    bool showNPC = showNodePhysicalCoords;
    if (plotRequested.HasNumericEntry("showNodePhysicalCoords"))
        showNPC = plotRequested.GetEntry("showNodePhysicalCoords")->ToBool();
    bool showNDLC = showNodeDomainLogicalCoords;
    if (plotRequested.HasNumericEntry("showNodeDomainLogicalCoords"))
        showNDLC = plotRequested.GetEntry("showNodeDomainLogicalCoords")->ToBool();
    bool showNBLC = showNodeBlockLogicalCoords;
    if (plotRequested.HasNumericEntry("showNodeBlockLogicalCoords"))
        showNBLC = plotRequested.GetEntry("showNodeBlockLogicalCoords")->ToBool();
    bool showNodeCoords = (showNPC  && !pnodeCoords.empty()) ||
                          (showNDLC && !dnodeCoords.empty()) ||
                          (showNBLC && !bnodeCoords.empty());

    bool showZId = showZoneId;
    if (plotRequested.HasNumericEntry("showZoneId"))
        showZId = plotRequested.GetEntry("showZoneId")->ToBool();

    bool showNId = showNodeId;
    if (plotRequested.HasNumericEntry("showNodeId"))
        showNId = plotRequested.GetEntry("showNodeId")->ToBool();

    if (pickType == Zone || pickType == DomainZone)
    {
        if (showZId || showZoneCoords)
            os += "Zone: ";
        if (showZId)
        {
            if (!elementIsGhost)
            {
                if (!showGlobalIds || globalElement == -1)
                    snprintf(buff, 512, "%d ", elementNumber);
                else
                    snprintf(buff, 512, "%d (global) ", globalElement);
            }
            else
                snprintf(buff, 512, "%d(ghost) ", elementNumber);
            os += buff;
        }
        if (showZDLC)
        {
            snprintf(buff, 512, "%s ", dzoneCoords[0].c_str());
            os += buff;
        }
        if (showZBLC)
        {
            snprintf(buff, 512, "%s ", bzoneCoords[0].c_str());
            os += buff;
        }
    }
    else if (pickType == Node || pickType == DomainNode)
    {
        if (showNId || showNodeCoords)
            os += "Node: ";
        if (showNId)
        {
            if (!elementIsGhost)
            {
                if (!showGlobalIds || globalElement == -1)
                    snprintf(buff, 512, "%d ", elementNumber);
                else
                    snprintf(buff, 512, "%d (global) ", globalElement);
            }
            else
                snprintf(buff, 512, "%d(ghost) ", elementNumber);
            os += buff;
        }
        if (showNPC)
        {
            snprintf(buff, 512, "%s ", pnodeCoords[0].c_str());
            os += buff;
        }
        if (showNDLC)
        {
            snprintf(buff, 512, "%s ", dnodeCoords[0].c_str());
            os += buff;
        }
        if (showNBLC)
        {
            snprintf(buff, 512, "%s ", bnodeCoords[0].c_str());
            os += buff;
        }
    }

    bool showIE = showIncidentElements;
    if (plotRequested.HasNumericEntry("showIncidentElements"))
        showIE = plotRequested.GetEntry("showIncidentElements")->ToBool();

    if (showIE)
    {
        bool showId = false;
        bool showGlobal = globalIncidentElements.size() == incidentElements.size();
        if (pickType == Zone || pickType == DomainZone)
        {
            os += "  Nodes: " ;
            showId = showNodeId;
            if (plotRequested.HasNumericEntry("showNodeId"))
                showId = plotRequested.GetEntry("showNodeId")->ToBool();

        }
        else if (pickType == Node || pickType == DomainNode)
        {
            os += "  Zones: " ;
            showId = showZoneId;
            if (plotRequested.HasNumericEntry("showZoneId"))
                showId = plotRequested.GetEntry("showZoneId")->ToBool();
        }
        if (showId && showGlobal)
            os += " (global) ";
        for (size_t i = 0; i < incidentElements.size(); i++)
        {
            if (showId)
            {
                if (ghosts.size() > 0 && ghosts[i])
                    snprintf(buff, 512, "%d(ghost) ", incidentElements[i]);
                else if (showGlobal)
                    snprintf(buff, 512, "%d ", globalIncidentElements[i]);
                else
                    snprintf(buff, 512, "%d ", incidentElements[i]);
                os += buff;
            }
            if (pickType == Zone || pickType == DomainZone)
            {
                if (showNPC)
                {
                    snprintf(buff, 512, "%s ", pnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNDLC)
                {
                    snprintf(buff, 512, "%s ", dnodeCoords[i].c_str());
                    os += buff;
                }
                if (showNBLC)
                {
                    snprintf(buff, 512, "%s ", bnodeCoords[i].c_str());
                    os += buff;
                }
            }
            else if (pickType == Node || pickType == DomainNode)
            {
                if (showZDLC)
                {
                    snprintf(buff, 512, "%s ", dzoneCoords[i].c_str());
                    os += buff;
                }
                if (showZBLC)
                {
                    snprintf(buff, 512, "%s ", bzoneCoords[i].c_str());
                    os += buff;
                }
            }
        }
        os += "\n";
    }

    for (size_t i = 0; i < varInfo.size(); i++)
    {
        std::string iv;
        std::string pt = PickType_ToString(pickType);
        //
        // VarInfo does not append a newline char, but we need one here
        //
        PickVarInfo* info = (PickVarInfo*)varInfo[i];
        info->SetFloatFormat(floatFormat);
        info->CreateOutputString(iv, pt);
        os += iv;
        os += "\n";
    }
    if (invalidVars.size() > 0)
    {
        os += "The following variables are invalid, and Pick ignored them:\n";
        for (size_t i = 0; i < invalidVars.size(); i++)
        {
            os += "  " + invalidVars[i];
        }
        os += "\n";
    }
}

Function: SetRayPoint1
Declaration: void SetRayPoint1(const doubleVector &);
Definition:
// ****************************************************************************
// Method: PickAttributes::SetRayPoint1
//
// Purpose:
//   Sets raypoint1 from a doubleVector arg.
//
// Programmer:  Kathleen Bonnell
// Creation:    November 9, 2007
//
// Modifications:
//
// ****************************************************************************

void
PickAttributes::SetRayPoint1(const doubleVector & _v)
{
    rayPoint1[0] = _v[0];
    rayPoint1[1] = _v[1];
    rayPoint1[2] = _v[2];
}

Function: SetRayPoint2
Declaration: void SetRayPoint2(const doubleVector &);
Definition:
// ****************************************************************************
// Method: PickAttributes::SetRayPoint2
//
// Purpose:
//   Sets raypoint2 from a doubleVector arg.
//
// Programmer:  Kathleen Bonnell
// Creation:    November 9, 2007
//
// Modifications:
//
// ****************************************************************************

void
PickAttributes::SetRayPoint2(const doubleVector &_v)
{
    rayPoint2[0] = _v[0];
    rayPoint2[1] = _v[1];
    rayPoint2[2] = _v[2];
}

Function: AddLine
Declaration: void AddLine(const double *_c0, const double *_c1, const int &pos);
Definition:
// ****************************************************************************
// Method: PickAttributes::AddLine
//
// Purpose:
//   Add the a line to the pick. This highlights the cell
//
// Programmer:  Matt Larsen
// Creation:
//
// Modifications:
//
// ****************************************************************************

void
PickAttributes::AddLine(const double *_c0, const double *_c1, const int &pos)
{
    if(!_c0 || !_c1) return; //TODO: is there error checking here?
    // extend vector of points as necessary
    while ((int)cellCoordinates.size() < 6*(pos+1))
        cellCoordinates.push_back(0.0);

    cellCoordinates[pos*6+0] = _c0[0];
    cellCoordinates[pos*6+1] = _c0[1];
    cellCoordinates[pos*6+2] = _c0[2];
    cellCoordinates[pos*6+3] = _c1[0];
    cellCoordinates[pos*6+4] = _c1[1];
    cellCoordinates[pos*6+5] = _c1[2];

}

Function: Notify
Declaration: void Notify();
Definition:
// ****************************************************************************
// Method: PickAttributes::Notify
//
// Purpose:
//    Notifies the observers. This is an override of an inherented method that
//    adds the ability to disable notification. This is desirable when picking
//    ranges of elements, possibly 100+, for visual reasons only and not to
//    encur the overhead of waiting for all the tabs to appear in the GUI.
//
// Programmer:  Matt Larsen
// Creation:    December 12, 2016
//
// Modifications:
//
// ****************************************************************************
//

void
PickAttributes::Notify()
{
    //
    // Check to see if we want to notify the window
    //

    if(notifyEnabled)
    {
        // Call the base class's Notify method.
        Subject::Notify();

        // Now that all the Obsevrers have been called, unselect all the
        // attributes.
        UnSelectAll();
    }
}

Function: ClearLines
Declaration: void ClearLines();
Definition:
// ****************************************************************************
// Method: PickAttributes::ClearLines
//
// Purpose:
//   Clear the vector of lines for cell highlights
//
// Programmer:  Matt Larsen
// Creation:
//
// Modifications:
//
// ****************************************************************************

void
PickAttributes::ClearLines()
{
    cellCoordinates.clear();
}

Function: CreateOutputMapNode
Declaration: void CreateOutputMapNode(MapNode &m, bool withLetter);
Definition:

// ****************************************************************************
// Method: PickAttributes::CreateOutputMapNode
//
// Purpose:
//   Creates a MapNode containing all the information gathered from a pick.
//
// Programmer:  Kathleen Biagas
// Creation:    September 22, 2011
//
// Modifications:
//   Kathleen Biagas, Tue Jul 22 11:35:33 MST 2014
//   Account for showing global ids.
//
// ****************************************************************************

void
PickAttributes::CreateOutputMapNode(MapNode &m, bool withLetter)
{
    if (m.GetNumEntries() != 0)
        m.Reset();

    if (error)
        return;

    if (!fulfilled)
        return;

    if ((pickType == Zone || pickType == DomainZone) && showZoneId)
    {
        if (globalElement == -1)
            m["zone_id"] = elementNumber;
        else
            m["zone_id"] = globalElement;
    }
    else if ((pickType == Node || pickType == DomainNode) && showNodeId)
    {
        if (globalElement == -1)
            m["node_id"] = elementNumber;
        else
            m["node_id"] = globalElement;
    }

    doubleVector p;
    if (pickType == CurveNode)
    {
        p.push_back(nodePoint[0]);
        p.push_back(nodePoint[1]);
        m["point"] = p;
    }
    else if (pickType == CurveZone)
    {
        p.push_back(nodePoint[0]);
        p.push_back(nodePoint[1]);
        m["point1"] = p;
        p[0] = cellPoint[0];
        p[1] = cellPoint[0];
        m["point2"] = p;
    }
    else if (cellPoint[0] != FLT_MAX)
    {
        p.push_back(cellPoint[0]);
        p.push_back(cellPoint[1]);
        if (dimension == 3)
        {
            p.push_back(cellPoint[2]);
        }
        //if (!needTransformMessage)
        {
            m["point"] = p;
        }
#if 0
        else
        {
            m["transformed_point"] = p;
        }
#endif
    }

    std::string fileName;
    size_t pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;

    m["filename"] = fileName;

    if (withLetter)
    {
        m["pick_letter"] = pickLetter;
    }

    if (domain != -1)
    {
        m["domain_id"] = domain;
    }

    if (showTimeStep && timeStep != -1)
    {
        m["timestep"] = timeStep;
    }

    if (showIncidentElements)
    {
        bool showId = false;
        bool showGlobal = globalIncidentElements.size() == incidentElements.size();
        std::string elName;
        std::string ghostName;
        if (pickType == Zone || pickType == DomainZone)
        {
            elName = "incident_nodes";
            ghostName = "ghost_incident_nodes";
            showId = showNodeId;
        }
        else if (pickType == Node || pickType == DomainNode)
        {
            elName = "incident_zones";
            ghostName = "ghost_incident_zones";
            showId = showZoneId;
        }
        if (showId)
        {
            if (showGlobal)
                m[elName] = globalIncidentElements;
            else
                m[elName] = incidentElements;
            intVector els, ghostEls;
            for (size_t i = 0; i < incidentElements.size(); ++i)
            {
                if (ghosts.size() > 0 && ghosts[i])
                    ghostEls.push_back(incidentElements[i]);
                else if (showGlobal)
                    els.push_back(globalIncidentElements[i]);
                else
                    els.push_back(incidentElements[i]);
            }
            m[elName] = els;
            if (!ghostEls.empty())
                m[ghostName] = ghostEls;
        }
    }

    for (size_t i = 0; i < varInfo.size(); ++i)
    {
        std::string pt = PickType_ToString(pickType);
        PickVarInfo* info = (PickVarInfo*)varInfo[i];
        info->CreateOutputMapNode(pt, m);
    }

    if (invalidVars.size() > 0)
    {
        m["invalidVars"] = invalidVars;
    }
}

Function: CreateXMLString
Declaration: void CreateXMLString(std::string &os, bool withLetter = true);
Definition:

// ****************************************************************************
// Method: PickAttributes::CreateXMLString
//
// Purpose:
//   Creates an xml output string containing all the information gathered
//   from a pick.
//
// Programmer:  Kathleen Biagas
// Creation:    September 22, 2011
//
// Modifications:
//
// ****************************************************************************

void
PickAttributes::CreateXMLString(std::string &os, bool withLetter)
{
    if (!os.empty())
        os.clear();

    if (error)
        return;

    if (!fulfilled)
        return;

    MapNode m;

    CreateOutputMapNode(m, withLetter);
    if (m.GetNumEntries()  > 0)
        os = m.ToXML();
}

Target: xml2python
Function: PyPickAttributes_GetLogString
Declaration: std::string PyPickAttributes_GetLogString()
Definition:
std::string
PyPickAttributes_GetLogString()
{
    std::string s("PickAtts = GetPickAttributes()\n");
    if(currentAtts != 0)
        s += PyPickAttributes_ToString(currentAtts, "PickAtts.");
    return s;
}

Function: PyPickAttributes_CallLogRoutine
Declaration: static void PyPickAttributes_CallLogRoutine(Subject *subj, void *data)
Definition:
static void
PyPickAttributes_CallLogRoutine(Subject *subj, void *data)
{
    typedef void (*logCallback)(const std::string &);
    logCallback cb = (logCallback)data;

    if(cb != 0)
    {
        std::string s("PickAtts = GetPickAttributes()\n");
        s += PyPickAttributes_ToString(currentAtts, "PickAtts.");
        cb(s);
    }
}

