#include <QueryAttributes.h>
#include <DataNode.h>
#include <stdio.h>

//
// Enum conversion methods for QueryAttributes::ElementType
//

static const char *ElementType_strings[] = {
"Zone", "Node"};

std::string
QueryAttributes::ElementType_ToString(QueryAttributes::ElementType t)
{
    int index = int(t);
    if(index < 0 || index >= 2) index = 0;
    return ElementType_strings[index];
}

std::string
QueryAttributes::ElementType_ToString(int t)
{
    int index = (t < 0 || t >= 2) ? 0 : t;
    return ElementType_strings[index];
}

bool
QueryAttributes::ElementType_FromString(const std::string &s, QueryAttributes::ElementType &val)
{
    val = QueryAttributes::Zone;
    for(int i = 0; i < 2; ++i)
    {
        if(s == ElementType_strings[i])
        {
            val = (ElementType)i;
            return true;
        }
    }
    return false;
}

// ****************************************************************************
// Method: QueryAttributes::QueryAttributes
//
// Purpose: 
//   Constructor for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

QueryAttributes::QueryAttributes() : AttributeSubject("ss*sFiiFFFdiF")
{
    variables.push_back("default");
    worldPoint[0] = 0;
    worldPoint[1] = 0;
    worldPoint[2] = 0;
    domain = -1;
    element = -1;
    rayPoint1[0] = 0;
    rayPoint1[1] = 0;
    rayPoint1[2] = 0;
    rayPoint2[0] = 0;
    rayPoint2[1] = 0;
    rayPoint2[2] = 0;
    cellPoint[0] = 0;
    cellPoint[1] = 0;
    cellPoint[2] = 0;
    resultsValue = 0;
    elementType = Zone;
    nodePoint[0] = 0;
    nodePoint[1] = 0;
    nodePoint[2] = 0;
}

// ****************************************************************************
// Method: QueryAttributes::QueryAttributes
//
// Purpose: 
//   Copy constructor for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

QueryAttributes::QueryAttributes(const QueryAttributes &obj) : AttributeSubject("ss*sFiiFFFdiF")
{
    name = obj.name;
    variables = obj.variables;
    resultsMessage = obj.resultsMessage;
    worldPoint[0] = obj.worldPoint[0];
    worldPoint[1] = obj.worldPoint[1];
    worldPoint[2] = obj.worldPoint[2];

    domain = obj.domain;
    element = obj.element;
    rayPoint1[0] = obj.rayPoint1[0];
    rayPoint1[1] = obj.rayPoint1[1];
    rayPoint1[2] = obj.rayPoint1[2];

    rayPoint2[0] = obj.rayPoint2[0];
    rayPoint2[1] = obj.rayPoint2[1];
    rayPoint2[2] = obj.rayPoint2[2];

    cellPoint[0] = obj.cellPoint[0];
    cellPoint[1] = obj.cellPoint[1];
    cellPoint[2] = obj.cellPoint[2];

    resultsValue = obj.resultsValue;
    elementType = obj.elementType;
    nodePoint[0] = obj.nodePoint[0];
    nodePoint[1] = obj.nodePoint[1];
    nodePoint[2] = obj.nodePoint[2];


    SelectAll();
}

// ****************************************************************************
// Method: QueryAttributes::~QueryAttributes
//
// Purpose: 
//   Destructor for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

QueryAttributes::~QueryAttributes()
{
    // nothing here
}

// ****************************************************************************
// Method: QueryAttributes::operator = 
//
// Purpose: 
//   Assignment operator for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
QueryAttributes::operator = (const QueryAttributes &obj)
{
    name = obj.name;
    variables = obj.variables;
    resultsMessage = obj.resultsMessage;
    worldPoint[0] = obj.worldPoint[0];
    worldPoint[1] = obj.worldPoint[1];
    worldPoint[2] = obj.worldPoint[2];

    domain = obj.domain;
    element = obj.element;
    rayPoint1[0] = obj.rayPoint1[0];
    rayPoint1[1] = obj.rayPoint1[1];
    rayPoint1[2] = obj.rayPoint1[2];

    rayPoint2[0] = obj.rayPoint2[0];
    rayPoint2[1] = obj.rayPoint2[1];
    rayPoint2[2] = obj.rayPoint2[2];

    cellPoint[0] = obj.cellPoint[0];
    cellPoint[1] = obj.cellPoint[1];
    cellPoint[2] = obj.cellPoint[2];

    resultsValue = obj.resultsValue;
    elementType = obj.elementType;
    nodePoint[0] = obj.nodePoint[0];
    nodePoint[1] = obj.nodePoint[1];
    nodePoint[2] = obj.nodePoint[2];


    SelectAll();
}

// ****************************************************************************
// Method: QueryAttributes::operator == 
//
// Purpose: 
//   Comparison operator == for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
QueryAttributes::operator == (const QueryAttributes &obj) const
{
    int i;

    // Compare the worldPoint arrays.
    bool worldPoint_equal = true;
    for(i = 0; i < 3 && worldPoint_equal; ++i)
        worldPoint_equal = (worldPoint[i] == obj.worldPoint[i]);

    // Compare the rayPoint1 arrays.
    bool rayPoint1_equal = true;
    for(i = 0; i < 3 && rayPoint1_equal; ++i)
        rayPoint1_equal = (rayPoint1[i] == obj.rayPoint1[i]);

    // Compare the rayPoint2 arrays.
    bool rayPoint2_equal = true;
    for(i = 0; i < 3 && rayPoint2_equal; ++i)
        rayPoint2_equal = (rayPoint2[i] == obj.rayPoint2[i]);

    // Compare the cellPoint arrays.
    bool cellPoint_equal = true;
    for(i = 0; i < 3 && cellPoint_equal; ++i)
        cellPoint_equal = (cellPoint[i] == obj.cellPoint[i]);

    // Compare the nodePoint arrays.
    bool nodePoint_equal = true;
    for(i = 0; i < 3 && nodePoint_equal; ++i)
        nodePoint_equal = (nodePoint[i] == obj.nodePoint[i]);

    // Create the return value
    return ((name == obj.name) &&
            (variables == obj.variables) &&
            (resultsMessage == obj.resultsMessage) &&
            worldPoint_equal &&
            (domain == obj.domain) &&
            (element == obj.element) &&
            rayPoint1_equal &&
            rayPoint2_equal &&
            cellPoint_equal &&
            (resultsValue == obj.resultsValue) &&
            (elementType == obj.elementType) &&
            nodePoint_equal);
}

// ****************************************************************************
// Method: QueryAttributes::operator != 
//
// Purpose: 
//   Comparison operator != for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
QueryAttributes::operator != (const QueryAttributes &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: QueryAttributes::TypeName
//
// Purpose: 
//   Type name method for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

const std::string
QueryAttributes::TypeName() const
{
    return "QueryAttributes";
}

// ****************************************************************************
// Method: QueryAttributes::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
QueryAttributes::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const QueryAttributes *tmp = (const QueryAttributes *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: QueryAttributes::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
QueryAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new QueryAttributes(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: QueryAttributes::NewInstance
//
// Purpose: 
//   NewInstance method for the QueryAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
QueryAttributes::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new QueryAttributes(*this);
    else
        retval = new QueryAttributes;

    return retval;
}

// ****************************************************************************
// Method: QueryAttributes::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
QueryAttributes::SelectAll()
{
    Select(0, (void *)&name);
    Select(1, (void *)&variables);
    Select(2, (void *)&resultsMessage);
    Select(3, (void *)worldPoint, 3);
    Select(4, (void *)&domain);
    Select(5, (void *)&element);
    Select(6, (void *)rayPoint1, 3);
    Select(7, (void *)rayPoint2, 3);
    Select(8, (void *)cellPoint, 3);
    Select(9, (void *)&resultsValue);
    Select(10, (void *)&elementType);
    Select(11, (void *)nodePoint, 3);
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: QueryAttributes::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
QueryAttributes::CreateNode(DataNode *parentNode, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    QueryAttributes defaultObject;
    bool addToParent = false;
    // Create a node for QueryAttributes.
    DataNode *node = new DataNode("QueryAttributes");

    if(!FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("name", name));
    }

    if(!FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("variables", variables));
    }

    if(!FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("resultsMessage", resultsMessage));
    }

    if(!FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("worldPoint", worldPoint, 3));
    }

    if(!FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("domain", domain));
    }

    if(!FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("element", element));
    }

    if(!FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("rayPoint1", rayPoint1, 3));
    }

    if(!FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("rayPoint2", rayPoint2, 3));
    }

    if(!FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("cellPoint", cellPoint, 3));
    }

    if(!FieldsEqual(9, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("resultsValue", resultsValue));
    }

    if(!FieldsEqual(10, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("elementType", ElementType_ToString(elementType)));
    }

    if(!FieldsEqual(11, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("nodePoint", nodePoint, 3));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: QueryAttributes::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
QueryAttributes::SetFromNode(DataNode *parentNode)
{
    int i;
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("QueryAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;
    if((node = searchNode->GetNode("name")) != 0)
        SetName(node->AsString());
    if((node = searchNode->GetNode("variables")) != 0)
        SetVariables(node->AsStringVector());
    if((node = searchNode->GetNode("resultsMessage")) != 0)
        SetResultsMessage(node->AsString());
    if((node = searchNode->GetNode("worldPoint")) != 0)
        SetWorldPoint(node->AsFloatArray());
    if((node = searchNode->GetNode("domain")) != 0)
        SetDomain(node->AsInt());
    if((node = searchNode->GetNode("element")) != 0)
        SetElement(node->AsInt());
    if((node = searchNode->GetNode("rayPoint1")) != 0)
        SetRayPoint1(node->AsFloatArray());
    if((node = searchNode->GetNode("rayPoint2")) != 0)
        SetRayPoint2(node->AsFloatArray());
    if((node = searchNode->GetNode("cellPoint")) != 0)
        SetCellPoint(node->AsFloatArray());
    if((node = searchNode->GetNode("resultsValue")) != 0)
        SetResultsValue(node->AsDouble());
    if((node = searchNode->GetNode("elementType")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 2)
                SetElementType(ElementType(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            ElementType value;
            if(ElementType_FromString(node->AsString(), value))
                SetElementType(value);
        }
    }
    if((node = searchNode->GetNode("nodePoint")) != 0)
        SetNodePoint(node->AsFloatArray());
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
QueryAttributes::SetName(const std::string &name_)
{
    name = name_;
    Select(0, (void *)&name);
}

void
QueryAttributes::SetVariables(const stringVector &variables_)
{
    variables = variables_;
    Select(1, (void *)&variables);
}

void
QueryAttributes::SetResultsMessage(const std::string &resultsMessage_)
{
    resultsMessage = resultsMessage_;
    Select(2, (void *)&resultsMessage);
}

void
QueryAttributes::SetWorldPoint(const float *worldPoint_)
{
    worldPoint[0] = worldPoint_[0];
    worldPoint[1] = worldPoint_[1];
    worldPoint[2] = worldPoint_[2];
    Select(3, (void *)worldPoint, 3);
}

void
QueryAttributes::SetDomain(int domain_)
{
    domain = domain_;
    Select(4, (void *)&domain);
}

void
QueryAttributes::SetElement(int element_)
{
    element = element_;
    Select(5, (void *)&element);
}

void
QueryAttributes::SetRayPoint1(const float *rayPoint1_)
{
    rayPoint1[0] = rayPoint1_[0];
    rayPoint1[1] = rayPoint1_[1];
    rayPoint1[2] = rayPoint1_[2];
    Select(6, (void *)rayPoint1, 3);
}

void
QueryAttributes::SetRayPoint2(const float *rayPoint2_)
{
    rayPoint2[0] = rayPoint2_[0];
    rayPoint2[1] = rayPoint2_[1];
    rayPoint2[2] = rayPoint2_[2];
    Select(7, (void *)rayPoint2, 3);
}

void
QueryAttributes::SetCellPoint(const float *cellPoint_)
{
    cellPoint[0] = cellPoint_[0];
    cellPoint[1] = cellPoint_[1];
    cellPoint[2] = cellPoint_[2];
    Select(8, (void *)cellPoint, 3);
}

void
QueryAttributes::SetResultsValue(double resultsValue_)
{
    resultsValue = resultsValue_;
    Select(9, (void *)&resultsValue);
}

void
QueryAttributes::SetElementType(QueryAttributes::ElementType elementType_)
{
    elementType = elementType_;
    Select(10, (void *)&elementType);
}

void
QueryAttributes::SetNodePoint(const float *nodePoint_)
{
    nodePoint[0] = nodePoint_[0];
    nodePoint[1] = nodePoint_[1];
    nodePoint[2] = nodePoint_[2];
    Select(11, (void *)nodePoint, 3);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const std::string &
QueryAttributes::GetName() const
{
    return name;
}

std::string &
QueryAttributes::GetName()
{
    return name;
}

const stringVector &
QueryAttributes::GetVariables() const
{
    return variables;
}

stringVector &
QueryAttributes::GetVariables()
{
    return variables;
}

const std::string &
QueryAttributes::GetResultsMessage() const
{
    return resultsMessage;
}

std::string &
QueryAttributes::GetResultsMessage()
{
    return resultsMessage;
}

const float *
QueryAttributes::GetWorldPoint() const
{
    return worldPoint;
}

float *
QueryAttributes::GetWorldPoint()
{
    return worldPoint;
}

int
QueryAttributes::GetDomain() const
{
    return domain;
}

int
QueryAttributes::GetElement() const
{
    return element;
}

const float *
QueryAttributes::GetRayPoint1() const
{
    return rayPoint1;
}

float *
QueryAttributes::GetRayPoint1()
{
    return rayPoint1;
}

const float *
QueryAttributes::GetRayPoint2() const
{
    return rayPoint2;
}

float *
QueryAttributes::GetRayPoint2()
{
    return rayPoint2;
}

const float *
QueryAttributes::GetCellPoint() const
{
    return cellPoint;
}

float *
QueryAttributes::GetCellPoint()
{
    return cellPoint;
}

double
QueryAttributes::GetResultsValue() const
{
    return resultsValue;
}

QueryAttributes::ElementType
QueryAttributes::GetElementType() const
{
    return ElementType(elementType);
}

const float *
QueryAttributes::GetNodePoint() const
{
    return nodePoint;
}

float *
QueryAttributes::GetNodePoint()
{
    return nodePoint;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
QueryAttributes::SelectName()
{
    Select(0, (void *)&name);
}

void
QueryAttributes::SelectVariables()
{
    Select(1, (void *)&variables);
}

void
QueryAttributes::SelectResultsMessage()
{
    Select(2, (void *)&resultsMessage);
}

void
QueryAttributes::SelectWorldPoint()
{
    Select(3, (void *)worldPoint, 3);
}

void
QueryAttributes::SelectRayPoint1()
{
    Select(6, (void *)rayPoint1, 3);
}

void
QueryAttributes::SelectRayPoint2()
{
    Select(7, (void *)rayPoint2, 3);
}

void
QueryAttributes::SelectCellPoint()
{
    Select(8, (void *)cellPoint, 3);
}

void
QueryAttributes::SelectNodePoint()
{
    Select(11, (void *)nodePoint, 3);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: QueryAttributes::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
QueryAttributes::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "name";
        case 1:  return "variables";
        case 2:  return "resultsMessage";
        case 3:  return "worldPoint";
        case 4:  return "domain";
        case 5:  return "element";
        case 6:  return "rayPoint1";
        case 7:  return "rayPoint2";
        case 8:  return "cellPoint";
        case 9:  return "resultsValue";
        case 10:  return "elementType";
        case 11:  return "nodePoint";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: QueryAttributes::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
QueryAttributes::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_string;
        case 1:  return FieldType_stringVector;
        case 2:  return FieldType_string;
        case 3:  return FieldType_floatArray;
        case 4:  return FieldType_int;
        case 5:  return FieldType_int;
        case 6:  return FieldType_floatArray;
        case 7:  return FieldType_floatArray;
        case 8:  return FieldType_floatArray;
        case 9:  return FieldType_double;
        case 10:  return FieldType_enum;
        case 11:  return FieldType_floatArray;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: QueryAttributes::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
QueryAttributes::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "string";
        case 1:  return "stringVector";
        case 2:  return "string";
        case 3:  return "floatArray";
        case 4:  return "int";
        case 5:  return "int";
        case 6:  return "floatArray";
        case 7:  return "floatArray";
        case 8:  return "floatArray";
        case 9:  return "double";
        case 10:  return "enum";
        case 11:  return "floatArray";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: QueryAttributes::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Oct 10 12:27:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
QueryAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    int i;

    const QueryAttributes &obj = *((const QueryAttributes*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        retval = (name == obj.name);
        }
        break;
    case 1:
        {  // new scope
        retval = (variables == obj.variables);
        }
        break;
    case 2:
        {  // new scope
        retval = (resultsMessage == obj.resultsMessage);
        }
        break;
    case 3:
        {  // new scope
        // Compare the worldPoint arrays.
        bool worldPoint_equal = true;
        for(i = 0; i < 3 && worldPoint_equal; ++i)
            worldPoint_equal = (worldPoint[i] == obj.worldPoint[i]);

        retval = worldPoint_equal;
        }
        break;
    case 4:
        {  // new scope
        retval = (domain == obj.domain);
        }
        break;
    case 5:
        {  // new scope
        retval = (element == obj.element);
        }
        break;
    case 6:
        {  // new scope
        // Compare the rayPoint1 arrays.
        bool rayPoint1_equal = true;
        for(i = 0; i < 3 && rayPoint1_equal; ++i)
            rayPoint1_equal = (rayPoint1[i] == obj.rayPoint1[i]);

        retval = rayPoint1_equal;
        }
        break;
    case 7:
        {  // new scope
        // Compare the rayPoint2 arrays.
        bool rayPoint2_equal = true;
        for(i = 0; i < 3 && rayPoint2_equal; ++i)
            rayPoint2_equal = (rayPoint2[i] == obj.rayPoint2[i]);

        retval = rayPoint2_equal;
        }
        break;
    case 8:
        {  // new scope
        // Compare the cellPoint arrays.
        bool cellPoint_equal = true;
        for(i = 0; i < 3 && cellPoint_equal; ++i)
            cellPoint_equal = (cellPoint[i] == obj.cellPoint[i]);

        retval = cellPoint_equal;
        }
        break;
    case 9:
        {  // new scope
        retval = (resultsValue == obj.resultsValue);
        }
        break;
    case 10:
        {  // new scope
        retval = (elementType == obj.elementType);
        }
        break;
    case 11:
        {  // new scope
        // Compare the nodePoint arrays.
        bool nodePoint_equal = true;
        for(i = 0; i < 3 && nodePoint_equal; ++i)
            nodePoint_equal = (nodePoint[i] == obj.nodePoint[i]);

        retval = nodePoint_equal;
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

void
QueryAttributes::Reset()
{
    name    = " ";
    resultsMessage  = " ";
    if (!variables.empty())
    {
        variables.clear();
        variables.push_back("default");
    }
    worldPoint[0] = worldPoint[1] = worldPoint[2] = 0.;
    rayPoint1[0] = rayPoint1[1] = rayPoint1[2] = 0.;
    rayPoint2[0] = rayPoint2[1] = rayPoint2[2] = 0.;
    domain = -1;
    element = -1;
    elementType = Zone;
    SelectAll();
}

void
QueryAttributes::PrintSelf(ostream &os)
{
    int i;
    os << "\n" << name.c_str() << ":  ";
    os << "selected variables: ";
    for (i = 0; i < variables.size(); i++)
        os << variables[i].c_str() << "  ";
    os << "\n";
    os << "Results: <" << resultsMessage.c_str() << ">\n";
    os << "World point: <" << worldPoint[0] << ", " << worldPoint[1] 
       << ", " << worldPoint[2] << ">\n"; 
    os << "Domain:      " << domain << "\n";
    os << "Element:        " << element << "\n";
    if (elementType == Zone)
    os << "Element type is Zone " << endl;
    else
    os << "Element type is Nod " << endl;
    os << "Ray point 1: <" << rayPoint1[0] << ", " << rayPoint1[1] 
       << ", " << rayPoint1[2] << ">\n"; 
    os << "Ray point 2: <" << rayPoint2[0] << ", " << rayPoint2[1] 
       << ", " << rayPoint2[2] << ">\n"; 
}

