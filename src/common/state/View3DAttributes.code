Function: RotateAxis
Declaration: void View3DAttributes::RotateAxis(int axis, double angle);
Definition:
// **************************************************************************
// Function: RotateAxis
//
// Purpose: Modify the view by rotating it a given number of degrees about
//          the given axis
//
// Programmer: Mark Miller (orig. by Eric Brugger in QvisViewWindow.C)
// Creation:   May 15, 2008
// **************************************************************************

void View3DAttributes::RotateAxis(int axis, double angle)
{
    double angleRadians;
    double v1[3], v2[3], v3[3];
    double t1[16], t2[16], m1[16], m2[16], r[16];
    double ma[16], mb[16], mc[16];
    double rM[16];
    double viewNormal_tmp[3];
    double viewUp_tmp[3];
    double viewFocus_tmp[3];
    double dist;

    //
    // Calculate the rotation matrix in screen coordinates.
    //
    angleRadians = angle * (3.141592653589793 / 180.);
    switch (axis)
    {
      case 0:
        r[0]  = 1.;
        r[1]  = 0.;
        r[2]  = 0.;
        r[3]  = 0.;
        r[4]  = 0.;
        r[5]  = cos(angleRadians);
        r[6]  = - sin(angleRadians);
        r[7]  = 0.;
        r[8]  = 0.;
        r[9]  = sin(angleRadians);
        r[10] = cos(angleRadians);
        r[11] = 0.;
        r[12] = 0.;
        r[13] = 0.;
        r[14] = 0.;
        r[15] = 1.;
        break;

      case 1:
        r[0]  = cos(angleRadians);
        r[1]  = 0.;
        r[2]  = sin(angleRadians);
        r[3]  = 0.;
        r[4]  = 0.;
        r[5]  = 1.;
        r[6]  = 0.;
        r[7]  = 0.;
        r[8]  = - sin(angleRadians);
        r[9]  = 0.;
        r[10]  = cos(angleRadians);
        r[11] = 0.;
        r[12] = 0.;
        r[13] = 0.;
        r[14] = 0.;
        r[15] = 1.;
        break;

      case 2:
        r[0]  = cos(angleRadians);
        r[1]  = - sin(angleRadians);
        r[2]  = 0.;
        r[3]  = 0.;
        r[4]  = sin(angleRadians);
        r[5]  = cos(angleRadians);
        r[6]  = 0.;
        r[7]  = 0.;
        r[8]  = 0.;
        r[9]  = 0.;
        r[10]  = 1.;
        r[11] = 0.;
        r[12] = 0.;
        r[13] = 0.;
        r[14] = 0.;
        r[15] = 1.;
        break;
    }

    //
    // Calculate the matrix to rotate from object coordinates to screen
    // coordinates and its inverse.
    //
    v1[0] = GetViewNormal()[0];
    v1[1] = GetViewNormal()[1];
    v1[2] = GetViewNormal()[2];

    v2[0] = GetViewUp()[0];
    v2[1] = GetViewUp()[1];
    v2[2] = GetViewUp()[2];

    v3[0] =   v2[1]*v1[2] - v2[2]*v1[1];
    v3[1] = - v2[0]*v1[2] + v2[2]*v1[0];
    v3[2] =   v2[0]*v1[1] - v2[1]*v1[0];

    m1[0]  = v3[0];
    m1[1]  = v2[0];
    m1[2]  = v1[0];
    m1[3]  = 0.;
    m1[4]  = v3[1];
    m1[5]  = v2[1];
    m1[6]  = v1[1];
    m1[7]  = 0.;
    m1[8]  = v3[2];
    m1[9]  = v2[2];
    m1[10] = v1[2];
    m1[11] = 0.;
    m1[12] = 0.;
    m1[13] = 0.;
    m1[14] = 0.;
    m1[15] = 1.;
    m2[0]  = m1[0];
    m2[1]  = m1[4];
    m2[2]  = m1[8];
    m2[3]  = m1[12];
    m2[4]  = m1[1];
    m2[5]  = m1[5];
    m2[6]  = m1[9];
    m2[7]  = m1[13];
    m2[8]  = m1[2];
    m2[9]  = m1[6];
    m2[10] = m1[10];
    m2[11] = m1[14];
    m2[12] = m1[3];
    m2[13] = m1[7];
    m2[14] = m1[11];
    m2[15] = m1[15];

    //
    // Calculate the translation to the center of rotation (and its
    // inverse).
    //
    t1[0]  = 1.;
    t1[1]  = 0.;
    t1[2]  = 0.;
    t1[3]  = 0.;
    t1[4]  = 0.;
    t1[5]  = 1.;
    t1[6]  = 0.;
    t1[7]  = 0.;
    t1[8]  = 0.;
    t1[9]  = 0.;
    t1[10] = 1.;
    t1[11] = 0.;
    t1[12] = -GetCenterOfRotation()[0];
    t1[13] = -GetCenterOfRotation()[1];
    t1[14] = -GetCenterOfRotation()[2];
    t1[15] = 1.;

    t2[0]  = 1.;
    t2[1]  = 0.;
    t2[2]  = 0.;
    t2[3]  = 0.;
    t2[4]  = 0.;
    t2[5]  = 1.;
    t2[6]  = 0.;
    t2[7]  = 0.;
    t2[8]  = 0.;
    t2[9]  = 0.;
    t2[10] = 1.;
    t2[11] = 0.;
    t2[12] = GetCenterOfRotation()[0];
    t2[13] = GetCenterOfRotation()[1];
    t2[14] = GetCenterOfRotation()[2];
    t2[14] = GetCenterOfRotation()[2];
    t2[15] = 1.;

    //
    // Form the composite transformation matrix t1 X m1 X r X m2 X t2.
    //
    ma[0]  = t1[0]*m1[0]  + t1[1]*m1[4]  + t1[2]*m1[8]   + t1[3]*m1[12];
    ma[1]  = t1[0]*m1[1]  + t1[1]*m1[5]  + t1[2]*m1[9]   + t1[3]*m1[13];
    ma[2]  = t1[0]*m1[2]  + t1[1]*m1[6]  + t1[2]*m1[10]  + t1[3]*m1[14];
    ma[3]  = t1[0]*m1[3]  + t1[1]*m1[7]  + t1[2]*m1[11]  + t1[3]*m1[15];
    ma[4]  = t1[4]*m1[0]  + t1[5]*m1[4]  + t1[6]*m1[8]   + t1[7]*m1[12];
    ma[5]  = t1[4]*m1[1]  + t1[5]*m1[5]  + t1[6]*m1[9]   + t1[7]*m1[13];
    ma[6]  = t1[4]*m1[2]  + t1[5]*m1[6]  + t1[6]*m1[10]  + t1[7]*m1[14];
    ma[7]  = t1[4]*m1[3]  + t1[5]*m1[7]  + t1[6]*m1[11]  + t1[7]*m1[15];
    ma[8]  = t1[8]*m1[0]  + t1[9]*m1[4]  + t1[10]*m1[8]  + t1[11]*m1[12];
    ma[9]  = t1[8]*m1[1]  + t1[9]*m1[5]  + t1[10]*m1[9]  + t1[11]*m1[13];
    ma[10] = t1[8]*m1[2]  + t1[9]*m1[6]  + t1[10]*m1[10] + t1[11]*m1[14];
    ma[11] = t1[8]*m1[3]  + t1[9]*m1[7]  + t1[10]*m1[11] + t1[11]*m1[15];
    ma[12] = t1[12]*m1[0] + t1[13]*m1[4] + t1[14]*m1[8]  + t1[15]*m1[12];
    ma[13] = t1[12]*m1[1] + t1[13]*m1[5] + t1[14]*m1[9]  + t1[15]*m1[13];
    ma[14] = t1[12]*m1[2] + t1[13]*m1[6] + t1[14]*m1[10] + t1[15]*m1[14];
    ma[15] = t1[12]*m1[3] + t1[13]*m1[7] + t1[14]*m1[11] + t1[15]*m1[15];

    mb[0]  = ma[0]*r[0]  + ma[1]*r[4]  + ma[2]*r[8]   + ma[3]*r[12];
    mb[1]  = ma[0]*r[1]  + ma[1]*r[5]  + ma[2]*r[9]   + ma[3]*r[13];
    mb[2]  = ma[0]*r[2]  + ma[1]*r[6]  + ma[2]*r[10]  + ma[3]*r[14];
    mb[3]  = ma[0]*r[3]  + ma[1]*r[7]  + ma[2]*r[11]  + ma[3]*r[15];
    mb[4]  = ma[4]*r[0]  + ma[5]*r[4]  + ma[6]*r[8]   + ma[7]*r[12];
    mb[5]  = ma[4]*r[1]  + ma[5]*r[5]  + ma[6]*r[9]   + ma[7]*r[13];
    mb[6]  = ma[4]*r[2]  + ma[5]*r[6]  + ma[6]*r[10]  + ma[7]*r[14];
    mb[7]  = ma[4]*r[3]  + ma[5]*r[7]  + ma[6]*r[11]  + ma[7]*r[15];
    mb[8]  = ma[8]*r[0]  + ma[9]*r[4]  + ma[10]*r[8]  + ma[11]*r[12];
    mb[9]  = ma[8]*r[1]  + ma[9]*r[5]  + ma[10]*r[9]  + ma[11]*r[13];
    mb[10] = ma[8]*r[2]  + ma[9]*r[6]  + ma[10]*r[10] + ma[11]*r[14];
    mb[11] = ma[8]*r[3]  + ma[9]*r[7]  + ma[10]*r[11] + ma[11]*r[15];
    mb[12] = ma[12]*r[0] + ma[13]*r[4] + ma[14]*r[8]  + ma[15]*r[12];
    mb[13] = ma[12]*r[1] + ma[13]*r[5] + ma[14]*r[9]  + ma[15]*r[13];
    mb[14] = ma[12]*r[2] + ma[13]*r[6] + ma[14]*r[10] + ma[15]*r[14];
    mb[15] = ma[12]*r[3] + ma[13]*r[7] + ma[14]*r[11] + ma[15]*r[15];

    mc[0]  = mb[0]*m2[0]  + mb[1]*m2[4]  + mb[2]*m2[8]   + mb[3]*m2[12];
    mc[1]  = mb[0]*m2[1]  + mb[1]*m2[5]  + mb[2]*m2[9]   + mb[3]*m2[13];
    mc[2]  = mb[0]*m2[2]  + mb[1]*m2[6]  + mb[2]*m2[10]  + mb[3]*m2[14];
    mc[3]  = mb[0]*m2[3]  + mb[1]*m2[7]  + mb[2]*m2[11]  + mb[3]*m2[15];
    mc[4]  = mb[4]*m2[0]  + mb[5]*m2[4]  + mb[6]*m2[8]   + mb[7]*m2[12];
    mc[5]  = mb[4]*m2[1]  + mb[5]*m2[5]  + mb[6]*m2[9]   + mb[7]*m2[13];
    mc[6]  = mb[4]*m2[2]  + mb[5]*m2[6]  + mb[6]*m2[10]  + mb[7]*m2[14];
    mc[7]  = mb[4]*m2[3]  + mb[5]*m2[7]  + mb[6]*m2[11]  + mb[7]*m2[15];
    mc[8]  = mb[8]*m2[0]  + mb[9]*m2[4]  + mb[10]*m2[8]  + mb[11]*m2[12];
    mc[9]  = mb[8]*m2[1]  + mb[9]*m2[5]  + mb[10]*m2[9]  + mb[11]*m2[13];
    mc[10] = mb[8]*m2[2]  + mb[9]*m2[6]  + mb[10]*m2[10] + mb[11]*m2[14];
    mc[11] = mb[8]*m2[3]  + mb[9]*m2[7]  + mb[10]*m2[11] + mb[11]*m2[15];
    mc[12] = mb[12]*m2[0] + mb[13]*m2[4] + mb[14]*m2[8]  + mb[15]*m2[12];
    mc[13] = mb[12]*m2[1] + mb[13]*m2[5] + mb[14]*m2[9]  + mb[15]*m2[13];
    mc[14] = mb[12]*m2[2] + mb[13]*m2[6] + mb[14]*m2[10] + mb[15]*m2[14];
    mc[15] = mb[12]*m2[3] + mb[13]*m2[7] + mb[14]*m2[11] + mb[15]*m2[15];

    rM[0]  = mc[0]*t2[0]  + mc[1]*t2[4]  + mc[2]*t2[8]   + mc[3]*t2[12];
    rM[1]  = mc[0]*t2[1]  + mc[1]*t2[5]  + mc[2]*t2[9]   + mc[3]*t2[13];
    rM[2]  = mc[0]*t2[2]  + mc[1]*t2[6]  + mc[2]*t2[10]  + mc[3]*t2[14];
    rM[3]  = mc[0]*t2[3]  + mc[1]*t2[7]  + mc[2]*t2[11]  + mc[3]*t2[15];
    rM[4]  = mc[4]*t2[0]  + mc[5]*t2[4]  + mc[6]*t2[8]   + mc[7]*t2[12];
    rM[5]  = mc[4]*t2[1]  + mc[5]*t2[5]  + mc[6]*t2[9]   + mc[7]*t2[13];
    rM[6]  = mc[4]*t2[2]  + mc[5]*t2[6]  + mc[6]*t2[10]  + mc[7]*t2[14];
    rM[7]  = mc[4]*t2[3]  + mc[5]*t2[7]  + mc[6]*t2[11]  + mc[7]*t2[15];
    rM[8]  = mc[8]*t2[0]  + mc[9]*t2[4]  + mc[10]*t2[8]  + mc[11]*t2[12];
    rM[9]  = mc[8]*t2[1]  + mc[9]*t2[5]  + mc[10]*t2[9]  + mc[11]*t2[13];
    rM[10] = mc[8]*t2[2]  + mc[9]*t2[6]  + mc[10]*t2[10] + mc[11]*t2[14];
    rM[11] = mc[8]*t2[3]  + mc[9]*t2[7]  + mc[10]*t2[11] + mc[11]*t2[15];
    rM[12] = mc[12]*t2[0] + mc[13]*t2[4] + mc[14]*t2[8]  + mc[15]*t2[12];
    rM[13] = mc[12]*t2[1] + mc[13]*t2[5] + mc[14]*t2[9]  + mc[15]*t2[13];
    rM[14] = mc[12]*t2[2] + mc[13]*t2[6] + mc[14]*t2[10] + mc[15]*t2[14];
    rM[15] = mc[12]*t2[3] + mc[13]*t2[7] + mc[14]*t2[11] + mc[15]*t2[15];

    //
    // Calculate the new view normal and view up.
    //
    viewNormal_tmp[0] = GetViewNormal()[0] * rM[0] +
                    GetViewNormal()[1] * rM[4] +
                    GetViewNormal()[2] * rM[8];
    viewNormal_tmp[1] = GetViewNormal()[0] * rM[1] +
                    GetViewNormal()[1] * rM[5] +
                    GetViewNormal()[2] * rM[9];
    viewNormal_tmp[2] = GetViewNormal()[0] * rM[2] +
                    GetViewNormal()[1] * rM[6] +
                    GetViewNormal()[2] * rM[10];
    dist = sqrt(viewNormal_tmp[0]*viewNormal_tmp[0] + viewNormal_tmp[1]*viewNormal_tmp[1] +
                viewNormal_tmp[2]*viewNormal_tmp[2]);
    viewNormal_tmp[0] /= dist;
    viewNormal_tmp[1] /= dist;
    viewNormal_tmp[2] /= dist;

    SetViewNormal(viewNormal_tmp);

    viewUp_tmp[0] = GetViewUp()[0] * rM[0] +
                GetViewUp()[1] * rM[4] +
                GetViewUp()[2] * rM[8];
    viewUp_tmp[1] = GetViewUp()[0] * rM[1] +
                GetViewUp()[1] * rM[5] +
                GetViewUp()[2] * rM[9];
    viewUp_tmp[2] = GetViewUp()[0] * rM[2] +
                GetViewUp()[1] * rM[6] +
                GetViewUp()[2] * rM[10];
    dist = sqrt(viewUp_tmp[0]*viewUp_tmp[0] + viewUp_tmp[1]*viewUp_tmp[1] +
                viewUp_tmp[2]*viewUp_tmp[2]);
    viewUp_tmp[0] /= dist;
    viewUp_tmp[1] /= dist;
    viewUp_tmp[2] /= dist;

    SetViewUp(viewUp_tmp);

    if (GetCenterOfRotationSet())
    {
        viewFocus_tmp[0] = GetFocus()[0] * rM[0]  +
                       GetFocus()[1] * rM[4]  +
                       GetFocus()[2] * rM[8]  +
                       rM[12];
        viewFocus_tmp[1] = GetFocus()[0] * rM[1]  +
                       GetFocus()[1] * rM[5]  +
                       GetFocus()[2] * rM[9]  +
                       rM[13];
        viewFocus_tmp[2] = GetFocus()[0] * rM[2]  +
                       GetFocus()[1] * rM[6]  +
                       GetFocus()[2] * rM[10] +
                       rM[14];

        SetFocus(viewFocus_tmp);
    }
}

Target: xml2python
Function: View3DAttributes_RotateAxis
Declaration: View3DAttributes_RotateAxis
Definition:
// ****************************************************************************
// Method: RotateAxis
//
// Purpose: Python method to define the 'user-defined' method RotateAxis for
// the python object so a use could do something like...
//
//    v = GetView3D()
//    v.RotateAxis(2,30.0)
//
// Programmer: Mark C. Miller
// Created:    May 15, 2008
//
// ****************************************************************************

/*static*/ PyObject *
View3DAttributes_RotateAxis(PyObject *self, PyObject *args)
{
//
// THIS METHOD IS CUSTOM CODED!!!!!!.
//
    View3DAttributesObject *obj = (View3DAttributesObject *)self;

    int ival;
    double dval;
    if(!PyArg_ParseTuple(args, "id", &ival, &dval))
        return NULL;

    // Call the C++ method to change the view.
    obj->data->RotateAxis(ival, dval);

    Py_INCREF(Py_None);
    return Py_None;
}

