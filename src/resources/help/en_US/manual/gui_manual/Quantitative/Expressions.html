

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8.1. Expressions &mdash; VisIt User Manual 2.11 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="VisIt User Manual 2.11 documentation" href="../../index.html"/>
        <link rel="up" title="8. Quantitative Analysis" href="index.html"/>
        <link rel="next" title="8.2. Query" href="Query.html"/>
        <link rel="prev" title="8. Quantitative Analysis" href="index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> VisIt User Manual
          

          
          </a>

          
            
            
              <div class="version">
                local build
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">GUI Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Intro/index.html">1. Introduction to VisIt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../WorkingWithFiles/index.html">2. Working with Databases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Plots/index.html">3. Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Operators/index.html">4. Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../SavingPrinting/index.html">5. Saving and Printing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../VisualizationWindows/index.html">6. Visualization Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Subsetting/index.html">7. Subsetting</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">8. Quantitative Analysis</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">8.1. Expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#expression-window">8.1.1. Expression Window</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#creating-a-new-expression">8.1.1.1. Creating a new expression</a></li>
<li class="toctree-l5"><a class="reference internal" href="#deleting-an-expression">8.1.1.2. Deleting an expression</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#expression-grammar">8.1.2. Expression grammar</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#math-operators">8.1.2.1. Math operators</a></li>
<li class="toctree-l5"><a class="reference internal" href="#constants">8.1.2.2. Constants</a></li>
<li class="toctree-l5"><a class="reference internal" href="#vectors">8.1.2.3. Vectors</a></li>
<li class="toctree-l5"><a class="reference internal" href="#lists">8.1.2.4. Lists</a></li>
<li class="toctree-l5"><a class="reference internal" href="#identifiers">8.1.2.5. Identifiers</a></li>
<li class="toctree-l5"><a class="reference internal" href="#functions">8.1.2.6. Functions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#database-variables">8.1.2.7. Database variables</a></li>
<li class="toctree-l5"><a class="reference internal" href="#databases">8.1.2.8. Databases</a></li>
<li class="toctree-l5"><a class="reference internal" href="#qualified-file-variables">8.1.2.9. Qualified file variables</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-expressions">8.1.3. Built-in expressions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#arithmetic-operator-expressions-math-expressions">8.1.3.1. Arithmetic Operator Expressions (Math Expressions)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#relational-conditional-and-logical-expressions">8.1.3.2. Relational, Conditional and Logical Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#trigonometric-expressions">8.1.3.3. Trigonometric Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#vector-and-color-expressions">8.1.3.4. Vector and Color Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#tensor-expressions">8.1.3.5. Tensor Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#array-expressions">8.1.3.6. Array Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#material-expressions">8.1.3.7. Material Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mesh-expressions">8.1.3.8. Mesh Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mesh-quality-expressions">8.1.3.9. Mesh Quality Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#comparison-expressions">8.1.3.10. Comparison Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#image-processing-expressions">8.1.3.11. Image Processing Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#miscellaneous-expressions">8.1.3.12. Miscellaneous Expressions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#time-iteration-expressions">8.1.3.13. Time Iteration Expressions</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#expression-compatibility-gotchas">8.1.4. Expression Compatibility Gotchas</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#tensor-rank-compatibility">8.1.4.1. Tensor Rank Compatibility</a></li>
<li class="toctree-l5"><a class="reference internal" href="#centering-compatibility">8.1.4.2. Centering Compatibility</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mesh-compatibility">8.1.4.3. Mesh Compatibility</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#automatic-expressions">8.1.5. Automatic expressions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="Query.html">8.2. Query</a></li>
<li class="toctree-l3"><a class="reference internal" href="Pick.html">8.3. Pick</a></li>
<li class="toctree-l3"><a class="reference internal" href="Lineout.html">8.4. Lineout</a></li>
<li class="toctree-l3"><a class="reference internal" href="DataLevelComparisonsWizard.html">8.5. Data Level Comparisons Wizard</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../MakingItPretty/index.html">9. Making it pretty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Animation/index.html">10. Animation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../InteractiveTools/index.html">11. Interactive Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../MultipleDatabaseAndWindows/index.html">12. Multiple Databases and Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ClientServer/index.html">13. Client Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ComputeEngines/index.html">14. Compute Engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Preferences/index.html">15. Preferences</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Help/index.html">16. Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="../StartupOptions/index.html">17. Startup Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Building/index.html">18. Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BuildingOnWindows/index.html">19. Building on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Acknowledgments/index.html">20. Acknowledgments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../glossary.html">21. Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Contributing/index.html">22. Contributing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../cli_manual/index.html">CLI Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev_manual/index.html">Developer Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">VisIt User Manual</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">VisIt GUI User Manual</a> &raquo;</li>
        
          <li><a href="index.html">8. Quantitative Analysis</a> &raquo;</li>
        
      <li>8.1. Expressions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/gui_manual/Quantitative/Expressions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>8.1. Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h1>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last">Confirm the text here adequately characterizes that an expression has
value everywhere over the whole mesh it is defined on. Its a field.</p>
</div>
<p>Scientific simulations often keep track of several dozen variables as they
run. However, only a small subset of those variables are usually written
to a simulation database to save disk space. Sometimes variables can be
derived from other variables using a variable expression. <a class="reference external" href="https://visit.llnl.gov">VisIt</a> provides
variable expressions to allow scientists to create derived variables using
variables that are stored in the database. Expressions are extremely powerful
because they allow users to analyze new data without necessarily having to
rerun a simulation. Variables created using expressions behave just like
variables stored in a database; they appear in menus where database variables
appear and can be visualized like any other database variable.</p>
<div class="section" id="expression-window">
<h2>8.1.1. Expression Window<a class="headerlink" href="#expression-window" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://visit.llnl.gov">VisIt</a> provides an <strong>Expression Window</strong>, shown in
<a class="reference internal" href="#expressionwindow"><span class="std std-numref">Figure 8.1</span></a>, that allows users to create new
variables that can be used in visualizations. Users can open the
<strong>Expression Window</strong> by clicking on the <strong>Expressions</strong> option in the
<strong>Main Window’s Controls</strong> menu. The <strong>Expression Window</strong> is divided
vertically into two main areas with the <strong>Expression list</strong> on the left
and the <strong>Definition</strong> area on the right.
The <strong>Expression list</strong> contains the list of expressions. The <strong>Definition</strong>
area displays the definition of the expression that is highlighted in
the <strong>Expression list</strong> and provides controls to edit the expression
definition.</p>
<div class="figure" id="id4">
<span id="expressionwindow"></span><img alt="../../_images/expressionwindow.png" src="../../_images/expressionwindow.png" />
<p class="caption"><span class="caption-number">Fig. 8.1 </span><span class="caption-text">Expression Window</span></p>
</div>
<p>Expressions in <a class="reference external" href="https://visit.llnl.gov">VisIt</a> are created either manually by the user or automatically
by various means including…</p>
<ul class="simple">
<li>Preferences<ul>
<li>Mesh quality expressions</li>
<li>Time derivative expressions</li>
<li>Vector magnitude expressions</li>
</ul>
</li>
<li>GUI wizards</li>
<li>Operators</li>
<li>Databases</li>
</ul>
<p>By default, the <strong>Expression list</strong> will display only those expressions
created manually by the user. A check box near the bottom of the
<strong>Expression list</strong> controls the display of automatically created
expressions. When this box is checked, the <strong>Expression list</strong> will also
include expressions created automatically by <strong>Preferences</strong> and <strong>Databases</strong>
but not expressions created automatically by <strong>GUI wizards</strong> or <strong>Operators</strong>.</p>
<div class="section" id="creating-a-new-expression">
<h3>8.1.1.1. Creating a new expression<a class="headerlink" href="#creating-a-new-expression" title="Permalink to this headline">¶</a></h3>
<p>Users can create a new expression by clicking on the <strong>Expression Window’s New</strong>
button. When the user clicks on the <strong>New</strong> button, <a class="reference external" href="https://visit.llnl.gov">VisIt</a> adds a new expression
and shows its new, empty definition in the <strong>Definitions</strong> area. The initial
name for a new expression is <em>“unnamed”</em> followed by some integer suffix.
As the user types a new name for the expression into the <strong>Name</strong> text field,
the expression’s name in the <strong>Expression list</strong> will update.</p>
<p>Each expression also has a <strong>Type</strong> that specifies the type of variable
the expression produces. The available types are:</p>
<ul class="simple">
<li>Scalar</li>
<li>Vector</li>
<li>Tensor</li>
<li>Symmetric Tensor</li>
<li>Array</li>
<li>Curve</li>
</ul>
<p>Users must be sure to select the appropriate type for any expression they
create. The selected type determines the menu in which the variable appears
and subsequently the plots that can operate on the variable.</p>
<p>To edit an expression’s definition, users can type a new expression
comprised of constants, variable names, and even other <a class="reference external" href="https://visit.llnl.gov">VisIt</a> expressions into
the <strong>Definition</strong> text field. The expression definition can span multiple
lines as the <a class="reference external" href="https://visit.llnl.gov">VisIt</a> expression parser ignores whitespace. For a complete
list of <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s built-in expressions, refer to the table in section
<a class="reference internal" href="#built-in-expressions"><span class="std std-ref">Built-in expressions</span></a>. Users can also use the <strong>Insert Function…</strong>
menu, shown in <a class="reference internal" href="#expressionwindow-functionmenu"><span class="std std-numref">Figure 8.2</span></a>, to
insert any of <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s built-in expressions directly into the expression
definition. The list of built-in expressions is divided into certain
categories as shown by the structure of the <strong>Insert Function…</strong>
menu.</p>
<div class="figure" id="id5">
<span id="expressionwindow-functionmenu"></span><img alt="../../_images/expressionwindow-functionmenu.png" src="../../_images/expressionwindow-functionmenu.png" />
<p class="caption"><span class="caption-number">Fig. 8.2 </span><span class="caption-text">Expression Window’s Insert Function… menu</span></p>
</div>
<p>In the example shown in <a class="reference internal" href="#expressionwindow-functionmenu"><span class="std std-numref">Figure 8.2</span></a>,
the <strong>Insert Function…</strong> operation inserted a sort of <em>template</em> for the
function giving some indication of the argument(s) to the function and their
meanings. Users can then simply edit those parts of the function template that
need to be specified.</p>
<p>In addition to the <strong>Insert Function…</strong> menu, which lets users insert built-in
functions into the expression definition, <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s <strong>Expression Window</strong>
provides an <strong>Insert Variable…</strong> menu that allows users to insert variables
from the active database into the expression definition. The
<strong>Insert Variable…</strong> menu, shown in
<a class="reference internal" href="#expressionwindow-varmenu"><span class="std std-numref">Figure 8.3</span></a>, is broken up into Scalars,
Vectors, Meshes, etc. and has the available variables under the appropriate
heading so they are easy to find.</p>
<div class="figure" id="id6">
<span id="expressionwindow-varmenu"></span><img alt="../../_images/expressionwindow-varmenu.png" src="../../_images/expressionwindow-varmenu.png" />
<p class="caption"><span class="caption-number">Fig. 8.3 </span><span class="caption-text">Expression Window’s Insert Variable… menu</span></p>
</div>
<p>Some variables can only be expressed as very complex expressions containing
several intermediate subexpressions that are only used to simplify the
overall expression definition. These types of subexpressions are seldom
visualized on their own. If users want to prevent them from being added to
the <strong>Plot</strong> menu, turn off the <strong>Show variable in plot menus</strong> check box.</p>
</div>
<div class="section" id="deleting-an-expression">
<h3>8.1.1.2. Deleting an expression<a class="headerlink" href="#deleting-an-expression" title="Permalink to this headline">¶</a></h3>
<p>Users can delete an expression by clicking on it in the <strong>Expression list</strong>
and then clicking on the <strong>Delete</strong> button. Deleting an expression removes
it from the list of defined expressions and will cause unresolved references
for any other expressions that use the deleted expression. If a plot uses
an expression with unresolved references, <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will not be able to generate
it until the user resolves the reference.</p>
</div>
</div>
<div class="section" id="expression-grammar">
<h2>8.1.2. Expression grammar<a class="headerlink" href="#expression-grammar" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://visit.llnl.gov">VisIt</a> allows expressions to be written using a host of unary and binary
math operators as well as built-in and user-defined functions. <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s
expressions follow C-language syntax, although there are a few differences.
The following paragraphs detail the syntax of <a class="reference external" href="https://visit.llnl.gov">VisIt</a> expressions.</p>
<div class="section" id="math-operators">
<h3>8.1.2.1. Math operators<a class="headerlink" href="#math-operators" title="Permalink to this headline">¶</a></h3>
<p>These include use of +, -, *, /, ^ as addition, subtraction, multiplication,
division, and exponentiation as infix operators, as well as the unary minus,
in their normal precedence and associativity. Parentheses may be used as
well to force a desired associativity.</p>
<p><em>Examples: a+b^-c (a+b)*c</em></p>
</div>
<div class="section" id="constants">
<h3>8.1.2.2. Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h3>
<p>Scalar constants include floating point numbers and integers, as well as
booleans (true, false, on, off) and strings.</p>
<p><em>Examples: 3e4 10 “mauve” true false</em></p>
</div>
<div class="section" id="vectors">
<h3>8.1.2.3. Vectors<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h3>
<p>Expressions can be grouped into two or three dimensional vector variables
using curly braces.</p>
<p><em>Examples: {xc, yc} {0,0,1}</em></p>
</div>
<div class="section" id="lists">
<h3>8.1.2.4. Lists<a class="headerlink" href="#lists" title="Permalink to this headline">¶</a></h3>
<p>Lists are used to specify multiple items or ranges, using colons to create
ranges of integers, possibly with strides, or using comma-separated lists
of integers, integer ranges, floating points numbers, or strings.</p>
<p><em>Examples: [1,3,2] [1:2, 10:20:5, 22] [silver, gold] [1.1, 2.5, 3.9] [level1, level2]</em></p>
</div>
<div class="section" id="identifiers">
<h3>8.1.2.5. Identifiers<a class="headerlink" href="#identifiers" title="Permalink to this headline">¶</a></h3>
<p>Identifiers include function names, defined variable and function names,
and file variable names. They may include alphabetic characters, numeric
characters, and underscores in any order. Identifiers should have at least
one non-numeric character so that they are not confused with integers, and
they should not look identical to floating point numbers such as 1e6.</p>
<p><em>Examples: density x y z 3d_mesh</em></p>
</div>
<div class="section" id="functions">
<h3>8.1.2.6. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>These are used for built in functions, but they may also be used for
functions/macros defined by the user. They take specific types and numbers
of arguments within the parentheses, separated by commas. Some functions
may accept named arguments in the form identifier=value.</p>
<p><em>Examples: sin(pi / 2) cross(vec1, {0,0,1}) my_xform(mesh1) subselect(materials=[a,b])</em></p>
</div>
<div class="section" id="database-variables">
<h3>8.1.2.7. Database variables<a class="headerlink" href="#database-variables" title="Permalink to this headline">¶</a></h3>
<p>These are like identifiers, but may also include periods, plus, and minus
characters. A normal identifier will map to a file variable when it is not
defined as another expression. To force variables that look like integers
or floating point numbers to be interpreted as variable names, or to force
variable names which are defined by another expression to map to a variable
in a file, they should be enclosed with &lt; and &gt;, the left and right
carats/angle brackets. Note that quotation marks will cause them to be
interpreted as string constants, not variable names. In addition, variables
in files may be in directories within a file, so they may include slashes
in a path when in angle brackets.</p>
<p><em>Examples: density &lt;pressure&gt; &lt;a.001&gt; &lt;a.002&gt; &lt;domain1/density&gt;</em></p>
</div>
<div class="section" id="databases">
<h3>8.1.2.8. Databases<a class="headerlink" href="#databases" title="Permalink to this headline">¶</a></h3>
<p>A database specification looks similar to a database variable contained
in angle brackets, but it is followed by a colon before the closing angle
bracket, and it may also contain extra information. A database specification
includes a file specification possibly followed a machine name, a time
specification by itself, or a file/machine specification followed by a
time specification. A file specification is just a file name with a path
if needed. A machine specification is an at-sign &#64; followed by a host name.
A time specification looks much like a list in that it contains integer
numbers or ranges, or floating point numbers, separated by commas and
enclosed in square brackets. However, it may also be followed by a letter
c, t, or i to specify if the time specification refers to cycles, times,
or indices, respectively. If no letter is specified, then the parser
guesses that integers refer to cycles, floating point numbers refer to
times. There is also an alternative to force indices which is the pound
sign # after the opening square bracket.</p>
<p><em>Examples: &lt;/dir/file:&gt; &lt;file&#64;host.gov:&gt; &lt;[# 0:10]:&gt; &lt;file[1.234]:&gt; &lt;file[000, 023, 047]:&gt; &lt;file[10]c:&gt;</em></p>
</div>
<div class="section" id="qualified-file-variables">
<h3>8.1.2.9. Qualified file variables<a class="headerlink" href="#qualified-file-variables" title="Permalink to this headline">¶</a></h3>
<p>Just like variables may be in directories within a file, they may also be
in other timesteps within the same database, within other databases, and
even within databases on other machines. To specify where a variable is
located, use the angle brackets again, and prefix the variable name with
a database specification, using the colon after the database specification
as a delimiter.</p>
<p><em>Examples: &lt;file:var&gt; &lt;/dir/file:/domain/var&gt; &lt;file&#64;192.168.1.1:/var&gt; &lt;[#0]:zerocyclevar&gt;</em></p>
</div>
</div>
<div class="section" id="built-in-expressions">
<span id="id2"></span><h2>8.1.3. Built-in expressions<a class="headerlink" href="#built-in-expressions" title="Permalink to this headline">¶</a></h2>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last">Add examples for some of the more complicated cases.</p>
</div>
<p>The following table lists built-in expressions that can be used to create
more advanced expressions. Unless otherwise noted in the description, each
expression takes scalar variables as its arguments.</p>
<div class="section" id="arithmetic-operator-expressions-math-expressions">
<span id="arithmetic-operator-expressions"></span><h3>8.1.3.1. Arithmetic Operator Expressions (Math Expressions)<a class="headerlink" href="#arithmetic-operator-expressions-math-expressions" title="Permalink to this headline">¶</a></h3>
<p>In binary arithmetic operator expressions, each operand must evaluate to
the same type field. For example, both must evaluate to a
<em>scalar</em> field or both must evaluate to a <em>vector</em> field.</p>
<p>In addition, if the two expressions differ in centering (e.g. one is <em>zone</em>
or <em>cell</em> centered or <em>piecewise-constant</em> over mesh cells while the other is
<em>node</em> or <em>point</em> centered or <em>pieceiwse-linear</em> over mesh cells), <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will
<em>recenter</em> any <a class="reference internal" href="../glossary.html#term-node-centered"><span class="xref std std-term">node-centered</span></a> fields to <em>zone</em> centering to compute the
expression. This may not always be desirable. When it is not, the
<a class="reference internal" href="#recenter-expression-function"><span class="std std-ref">recenter()</span></a> may be used to explicitly
control the centering of specific operands in an expression.</p>
<dl class="docutils" id="sum-expression-operator">
<dt>Sum Operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">+</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the sum of the <code class="docutils literal notranslate"><span class="pre">exprL</span></code> and <code class="docutils literal notranslate"><span class="pre">exprR</span></code>
expressions.</dd>
</dl>
<dl class="docutils" id="difference-expression-operator">
<dt>Difference Operator (<code class="docutils literal notranslate"><span class="pre">-</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">-</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the difference of the <code class="docutils literal notranslate"><span class="pre">exprL</span></code> and
<code class="docutils literal notranslate"><span class="pre">exprR</span></code> expressions.</dd>
</dl>
<dl class="docutils" id="product-expression-operator">
<dt>Product Operator (<code class="docutils literal notranslate"><span class="pre">*</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">*</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the product of the <code class="docutils literal notranslate"><span class="pre">exprL</span></code> and
<code class="docutils literal notranslate"><span class="pre">exprR</span></code> expressions.</dd>
</dl>
<dl class="docutils" id="division-expression-operator">
<dt>Division Operator (<code class="docutils literal notranslate"><span class="pre">/</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">/</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the quotient after dividing the <code class="docutils literal notranslate"><span class="pre">exprL</span></code>
expression by the <code class="docutils literal notranslate"><span class="pre">exprR</span></code> expression.</dd>
<dt>Division Operator <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">divide(val_numerator,</span> <span class="pre">val_denominator,</span> <span class="pre">[div_by_zero_value,</span> <span class="pre">tolerance])</span></code></span></dt>
<dd>Creates a new expression which is the quotient after dividing the
<code class="docutils literal notranslate"><span class="pre">val_numerator</span></code> expression by the <code class="docutils literal notranslate"><span class="pre">val_denominator</span></code> expression. The
<code class="docutils literal notranslate"><span class="pre">div_by_zero_value</span></code> is used wherever the <code class="docutils literal notranslate"><span class="pre">val_denominator</span></code> is within
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code> of zero.</dd>
</dl>
<dl class="docutils" id="exponent-expression-operator">
<dt>Exponent Operator (<code class="docutils literal notranslate"><span class="pre">^</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">^</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the product after multiplying the
<code class="docutils literal notranslate"><span class="pre">exprL</span></code> expression by itself <code class="docutils literal notranslate"><span class="pre">exprR</span></code> times.</dd>
</dl>
<dl class="docutils" id="logical-and-expression-operator">
<dt>Logical AND Operator (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exprL</span> <span class="pre">&amp;</span> <span class="pre">exprR</span></code></span></dt>
<dd>Creates a new expression which is the logical <em>AND</em> of the <code class="docutils literal notranslate"><span class="pre">exprL</span></code> and
<code class="docutils literal notranslate"><span class="pre">exprR</span></code> expressions treating each value as a binary bit field. It is
probably most useful for expressions involving integer data but can be
applied to expressions involving any type.</dd>
</dl>
<dl class="docutils" id="associative-expression-operator">
<dt>Associative Operator (<code class="docutils literal notranslate"><span class="pre">()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">expr0</span> <span class="pre">OP</span> <span class="pre">expr1</span> <span class="pre">)</span></code></span></dt>
<dd><p class="first">Parenthesis, <em>()</em> are used to explicitly group partial results of sub
expressions and control evaluation order.</p>
<p class="last">For example, the expression <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">/</span> <span class="pre">c</span></code> first computes the sum, <code class="docutils literal notranslate"><span class="pre">a+b</span></code>
and then divides by <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd>
</dl>
<dl class="docutils" id="absolute-value-expression-function">
<dt>Absolute Value Function (<code class="docutils literal notranslate"><span class="pre">abs()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">abs(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the absolute value if its
argument.</dd>
</dl>
<dl class="docutils" id="ceiling-expression-function">
<dt>Ceiling Function (<code class="docutils literal notranslate"><span class="pre">ceil()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ceil(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the <em>ceiling</em> (smallest integer
greater than or equal to) of its argument.</dd>
</dl>
<dl class="docutils" id="exponent-expression-function">
<dt>Exponent Function (<code class="docutils literal notranslate"><span class="pre">exp()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">exp(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere <em>e</em> (base of the natural
logarithm) raised to the power of its argument.</dd>
</dl>
<dl class="docutils" id="floor-expression-function">
<dt>Floor Function (<code class="docutils literal notranslate"><span class="pre">floor()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">floor(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the <em>floor</em> (greatest integer
less than or equal to) of its argument.</dd>
</dl>
<dl class="docutils" id="natural-logarithm-expression-function">
<dt>Natural Logarithm Function (<code class="docutils literal notranslate"><span class="pre">ln()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ln(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the natural logarithm of its
argument.</dd>
</dl>
<dl class="docutils" id="base10-logarithm-expression-function">
<dt>Base 10 Logarithm Function (<code class="docutils literal notranslate"><span class="pre">log10()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">log10(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the base 10 logarithm of its
argument.</dd>
</dl>
<dl class="docutils" id="max-expression-function">
<dt>Max Function (<code class="docutils literal notranslate"><span class="pre">max()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max(expr0,</span> <span class="pre">exrp1</span> <span class="pre">[,</span> <span class="pre">...])</span></code></span></dt>
<dd>Creates a new expression which is everywhere the maximum among all input
variables.</dd>
</dl>
<dl class="docutils" id="min-expression-function">
<dt>Min Function (<code class="docutils literal notranslate"><span class="pre">min()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min(expr0,</span> <span class="pre">exrp1</span> <span class="pre">[,</span> <span class="pre">...])</span></code></span></dt>
<dd>Creates a new expression which is everywhere the minimum among all input
variables.</dd>
</dl>
<dl class="docutils" id="modulo-expression-function">
<dt>Modulo Function (<code class="docutils literal notranslate"><span class="pre">mod()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">mod(expr0,exrp1)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the first argument, <code class="docutils literal notranslate"><span class="pre">expr0</span></code>,
modulo the second argument, <code class="docutils literal notranslate"><span class="pre">expr1</span></code>.</dd>
</dl>
<dl class="docutils" id="random-expression-function">
<dt>Random Function (<code class="docutils literal notranslate"><span class="pre">random()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">random(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a random floating point number
between 0 and 1, as computed by <span class="math notranslate nohighlight">\((\text{rand()} \% 1024) \div 1024\)</span>
where <code class="docutils literal notranslate"><span class="pre">rand()</span></code> is the standard C library
<a class="reference external" href="http://www.cplusplus.com/reference/cstdlib/rand/">rand()</a> random
number generator. The argument, <code class="docutils literal notranslate"><span class="pre">expr0</span></code>, must be a mesh variable. The seed
used on each block of the mesh is the absolute domain number.</dd>
</dl>
<dl class="docutils" id="round-expression-function">
<dt>Round Function (<code class="docutils literal notranslate"><span class="pre">round()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">round(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the result of rounding
its argument.</dd>
</dl>
<dl class="docutils" id="square-expression-function">
<dt>Square Function (<code class="docutils literal notranslate"><span class="pre">sqr()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">sqr(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the result of squaring
its argument.</dd>
</dl>
<dl class="docutils" id="square-root-expression-function">
<dt>Square Root Function (<code class="docutils literal notranslate"><span class="pre">sqrt()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">sqrt(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the square root of
its argument.</dd>
</dl>
</div>
<div class="section" id="relational-conditional-and-logical-expressions">
<h3>8.1.3.2. Relational, Conditional and Logical Expressions<a class="headerlink" href="#relational-conditional-and-logical-expressions" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">if()</span></code> conditional expression is designed to be used in concert with
relation and logical expressions. Together, these expressions can be used to
build up more complex expressions in which very different evaluations are
performed depending on the outcome of other evaluations. For example, the
<code class="docutils literal notranslate"><span class="pre">if()</span></code> conditional expression can be used together with one or more
relational expressions to create a new expression which evaluates to a
dot-product on part of a mesh and to the magnitude of a divergence operator
on another part of a mesh.</p>
<dl class="docutils" id="if-expression-function">
<dt>If Function (<code class="docutils literal notranslate"><span class="pre">if()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">if(exprCondition,</span> <span class="pre">exprTrue,</span> <span class="pre">exprFalse)</span></code></span></dt>
<dd><p class="first">Creates a new expression which is equal to <code class="docutils literal notranslate"><span class="pre">exprTrue</span></code> wherever
the condition, <code class="docutils literal notranslate"><span class="pre">exprCondition</span></code> is non-zero and which is equal to
<code class="docutils literal notranslate"><span class="pre">exprFalse</span></code> wherever <code class="docutils literal notranslate"><span class="pre">exprCondition</span></code> is zero.</p>
<p class="last">For example, the expression
<code class="docutils literal notranslate"><span class="pre">if(and(gt(pressure,</span> <span class="pre">2.0),</span> <span class="pre">lt(pressure,</span> <span class="pre">4.0)),</span> <span class="pre">pressure,</span> <span class="pre">0.0)</span></code>
combines the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression with the <code class="docutils literal notranslate"><span class="pre">gt</span></code> and <code class="docutils literal notranslate"><span class="pre">lt</span></code> expressions
to create a new expression that is equal to <code class="docutils literal notranslate"><span class="pre">pressure</span></code> wherever it is
between 2.0 and 4.0 and 0 otherwise.</p>
</dd>
</dl>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last">Confirm relational and logical expressions produce new, boolean valued
expression variables which are themselves plottable in <a class="reference external" href="https://visit.llnl.gov">VisIt</a>. Their
original intent may have been only to be used as args in the IF expression
and not so much be plottable outputs in their own right.</p>
</div>
<dl class="docutils" id="equal-expression-function">
<dt>Equal Function (<code class="docutils literal notranslate"><span class="pre">eq()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eq(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether its two arguments are equal. A value of 1 is produced
everywhere the arguments <em>are</em> equal and 0 otherwise.</dd>
</dl>
<dl class="docutils" id="greater-than-expression-function">
<dt>Greater Than Function (<code class="docutils literal notranslate"><span class="pre">gt()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">gt(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">exprR</span></code>. A value of 1
is produced everywhere <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">exprR</span></code> and 0
otherwise.</dd>
</dl>
<dl class="docutils" id="greater-than-or-equal-expression-function">
<dt>Greater Than or Equal Function (<code class="docutils literal notranslate"><span class="pre">ge()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ge(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is greater than or equal to <code class="docutils literal notranslate"><span class="pre">exprR</span></code>.
A value of 1 is produced everywhere <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is greater than or equal to
<code class="docutils literal notranslate"><span class="pre">exprR</span></code> and 0 otherwise.</dd>
</dl>
<dl class="docutils" id="less-than-expression-function">
<dt>Less Than Function (<code class="docutils literal notranslate"><span class="pre">lt()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">lt(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is less than <code class="docutils literal notranslate"><span class="pre">exprR</span></code>. A value of 1
is produced everywhere <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is less than <code class="docutils literal notranslate"><span class="pre">exprR</span></code> and 0 otherwise.</dd>
</dl>
<dl class="docutils" id="less-than-or-equal-expression-function">
<dt>Less Than or Equal Function (<code class="docutils literal notranslate"><span class="pre">le()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">le(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is less than or equal to <code class="docutils literal notranslate"><span class="pre">exprR</span></code>. A value
of 1 is produced everywhere <code class="docutils literal notranslate"><span class="pre">exprL</span></code> is less than or equal to <code class="docutils literal notranslate"><span class="pre">exprR</span></code>
and 0 otherwise.</dd>
</dl>
<dl class="docutils" id="not-equal-expression-function">
<dt>Equal Function (<code class="docutils literal notranslate"><span class="pre">ne()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ne(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a boolean value (1 or 0)
indicating whether its two arguments are <em>not</em> equal. A value of 1
is produced everywhere the arguments are <em>not</em> equal and 0 otherwise.</dd>
</dl>
<dl class="docutils" id="logical-and-expression-function">
<dt>Logical And Function (<code class="docutils literal notranslate"><span class="pre">and()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">and(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the logical <em>and</em> of its two
arguments. Non-zero values are treated as true whereas zero values are
treated as false.</dd>
</dl>
<dl class="docutils" id="logical-or-expression-function">
<dt>Logical Or Function (<code class="docutils literal notranslate"><span class="pre">or()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">or(exprL,exprR)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the logical <em>or</em> of its two
arguments. Non-zero values are treated as true whereas zero values are
treated as false.</dd>
</dl>
<dl class="docutils" id="logical-not-expression-function">
<dt>Logical Not Function (<code class="docutils literal notranslate"><span class="pre">not()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">not(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the logical <em>not</em> of its
argument. Non-zero values are treated as true whereas zero values are
treated as false.</dd>
</dl>
</div>
<div class="section" id="trigonometric-expressions">
<h3>8.1.3.3. Trigonometric Expressions<a class="headerlink" href="#trigonometric-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="arc-cosine-expression-function">
<dt>Arc Cosine Function (<code class="docutils literal notranslate"><span class="pre">acos()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">acos(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the arc cosine of its
argument. The returned value is in <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="arc-sine-expression-function">
<dt>Arc Sine Function (<code class="docutils literal notranslate"><span class="pre">asin()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">asin(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the arc sine of its
argument. The returned value is in <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="arc-tangent-expression-function">
<dt>Arc Tangent Function (<code class="docutils literal notranslate"><span class="pre">atan()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">atan(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the arc tangent of its
argument. The returned value is in <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="cosine-expression-function">
<dt>Cosine Function (<code class="docutils literal notranslate"><span class="pre">cos()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cos(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the cosine of its
argument. The argument is treated as in units of <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="hyperbolic-cosine-expression-function">
<dt>Hyperbolic Cosine Function (<code class="docutils literal notranslate"><span class="pre">cosh()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cosh(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the hyperbolic cosine of its
argument. The argument is the <em>hyperbolic angle</em>.</dd>
</dl>
<dl class="docutils" id="sine-expression-function">
<dt>Sine Function (<code class="docutils literal notranslate"><span class="pre">sin()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">sin(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the sine of its
argument. The argument is treated as in units of <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="hyperbolic-sine-expression-function">
<dt>Hyperbolic Sine Function (<code class="docutils literal notranslate"><span class="pre">sinh()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">sinh(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the hyperbolic sine of its
argument. The argument is the <em>hyperbolic angle</em>.</dd>
</dl>
<dl class="docutils" id="tangent-expression-function">
<dt>Tangent Function (<code class="docutils literal notranslate"><span class="pre">tan()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">tan(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the tangent of its
argument. The argument is treated as in units of <em>radians</em>.</dd>
</dl>
<dl class="docutils" id="hyperbolic-tangent-expression-function">
<dt>Hyperbolic Tangent Function (<code class="docutils literal notranslate"><span class="pre">tanh()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">tanh(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the hyperbolic tangent of its
argument. The argument is the <em>hyperbolic angle</em>.</dd>
</dl>
<dl class="docutils" id="degree-to-radians-expression-function">
<dt>Degrees To Radians Conversion Function (<code class="docutils literal notranslate"><span class="pre">deg2rad()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">deg2rad(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the conversion from degrees
to radians of its argument. The argument should be a variable defined
in units of degrees.</dd>
</dl>
<dl class="docutils" id="radians-to-degrees-expression-function">
<dt>Radians To Degrees Conversion Function (<code class="docutils literal notranslate"><span class="pre">rad2deg()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">rad2deg(expr0)</span></code></span></dt>
<dd>Creates a new expression which is everywhere the conversion from radians
to degrees of its argument. The argument should be a variable defined
in units of radians.</dd>
</dl>
</div>
<div class="section" id="vector-and-color-expressions">
<h3>8.1.3.4. Vector and Color Expressions<a class="headerlink" href="#vector-and-color-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="vector-compose-expression-operator">
<dt>Vector Compose Operator (<code class="docutils literal notranslate"><span class="pre">{}</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">{expr0,</span> <span class="pre">expr1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">exprN-1}</span></code></span></dt>
<dd><p class="first">Curly braces, <em>{}</em> are used to create a new expression of higher tensor rank
from 2 or more expression of lower tensor rank.  A common use is to compose
several tensor rank 0 expressions (e.g. scalar expressions) into a tensor
rank 1 expression (e.g. a vector expression). The component expressions,
<code class="docutils literal notranslate"><span class="pre">expr0</span></code>, <code class="docutils literal notranslate"><span class="pre">expr1</span></code>, etc.  must all be the same tensor rank and expression
type. For example, they must all be rank 0 (e.g. <em>scalar</em> expressions) or
they must all be rank 1 (e.g. <em>vector</em>) expressions of the same number of
components. If they are all scalars, the result is a tensor of rank 1 (e.g.
a vector). If they are all vectors, the result is a tensor of rank 2 (e.g.
a tensor). The vector compose operator is also used to compose array
expressions.</p>
<p class="last">For example, the expression <code class="docutils literal notranslate"><span class="pre">{u,</span> <span class="pre">v,</span> <span class="pre">w}</span></code> takes three scalar mesh variables
named <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">w</span></code> and creates a vector mesh variable.</p>
</dd>
</dl>
<dl class="docutils" id="vector-component-expression-operator">
<dt>Vector Component Operator (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">expr[I]</span></code></span></dt>
<dd>Square brackets, <em>[]</em>, are used to create a new expression of lower tensor
rank by extracting a component from an expression of higher tensor rank.
Components are indexed starting from 0. If <code class="docutils literal notranslate"><span class="pre">expr</span></code>
is a tensor of rank 2, the result will be a tensor of rank 1 (e.g. a
vector). If <code class="docutils literal notranslate"><span class="pre">expr</span></code> is a tensor of rank 1, the result will be a tensor
of rank 0 (e.g. a scalar). To obtain the <code class="docutils literal notranslate"><span class="pre">J</span></code>-th component of the <code class="docutils literal notranslate"><span class="pre">I</span></code>-th
row of a tensor of rank 2, the expression would be <code class="docutils literal notranslate"><span class="pre">expr[I][J]</span></code></dd>
</dl>
<dl class="docutils" id="color-expression-function">
<dt>Color Function (<code class="docutils literal notranslate"><span class="pre">color()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">color(exprR,exprG,exprB)</span></code></span></dt>
<dd>Creates a new, RGB <em>vector</em>, expression which defines a <em>color</em> vector where
<code class="docutils literal notranslate"><span class="pre">exprR</span></code> defines the <em>red</em> component, <code class="docutils literal notranslate"><span class="pre">exprG</span></code> defines the <em>green</em>
component and <code class="docutils literal notranslate"><span class="pre">exprB</span></code> defines the <em>blue</em> component of the color vector.
The resulting expression is suitable for plotting with the
<a class="reference internal" href="../Plots/PlotTypes/TruecolorPlot.html#id1"><span class="std std-ref">Truecolor Plot</span></a>. The arguments are used to define color values in
the range 0…255. Values outside that range are clamped. No normalization
is performed. If the arguments have much smaller or larger range than
[0…255], it may be appropriate to select a suitable multiplicative scale
factor.</dd>
</dl>
<dl class="docutils" id="color4-expression-function">
<dt>Color4 Function (<code class="docutils literal notranslate"><span class="pre">color4()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">color4(exprR,exprG,exprB,exprA)</span></code></span></dt>
<dd>See <a class="reference internal" href="#color-expression-function"><span class="std std-ref">color()</span></a>. This function is similar to the
<code class="docutils literal notranslate"><span class="pre">color()</span></code> function but also supports <em>alpha-transparency</em> as the
fourth argument, again in the range 0…255.</dd>
</dl>
<dl class="docutils" id="colorlookup-expression-function">
<dt>Color lookup Function (<code class="docutils literal notranslate"><span class="pre">colorlookup()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">colorlookup(expr0,tabname,scalmode,skewfac)</span></code></span></dt>
<dd>Creates a new <em>vector</em> expression that is the color that each value in
<code class="docutils literal notranslate"><span class="pre">expr0</span></code> maps to. The <code class="docutils literal notranslate"><span class="pre">tabname</span></code> argument is the name of the color table.
The <code class="docutils literal notranslate"><span class="pre">expr0</span></code> and <code class="docutils literal notranslate"><span class="pre">tabname</span></code> arguments are <em>required</em>. The <code class="docutils literal notranslate"><span class="pre">scalmode</span></code>
and <code class="docutils literal notranslate"><span class="pre">skewfac</span></code> arguments are optional. Possible values for <code class="docutils literal notranslate"><span class="pre">scalmode</span></code> are
<code class="docutils literal notranslate"><span class="pre">0</span></code> (for <em>linear</em> scaling mode), <code class="docutils literal notranslate"><span class="pre">1</span></code> (for <em>log</em> scaling mode) and <code class="docutils literal notranslate"><span class="pre">2</span></code>
(for <em>skew</em> scaling mode). The <code class="docutils literal notranslate"><span class="pre">skewfac</span></code> argument is <em>required</em> only for
a <code class="docutils literal notranslate"><span class="pre">scalmode</span></code> of <code class="docutils literal notranslate"><span class="pre">2</span></code>.</dd>
</dl>
<dl class="docutils" id="cross-product-expression-function">
<dt>Cross Product Function (<code class="docutils literal notranslate"><span class="pre">cross()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cross(exprV0,exprV1)</span></code></span></dt>
<dd>Creates a new <em>vector</em> expression which is the vector cross product created
by crossing <code class="docutils literal notranslate"><span class="pre">exprV0</span></code> <em>into</em> <code class="docutils literal notranslate"><span class="pre">exprv1</span></code>. Both arguments must be <em>vector</em>
expression.</dd>
</dl>
<dl class="docutils" id="dot-proeduct-expression-function">
<dt>Dot Product Function (<code class="docutils literal notranslate"><span class="pre">dot()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">dot(exprV0,exprV1)</span></code></span></dt>
<dd>Creates a new <em>scalar</em> expression which is the vector dot product
of <code class="docutils literal notranslate"><span class="pre">exprV0</span></code> with <code class="docutils literal notranslate"><span class="pre">exprV1</span></code>.</dd>
</dl>
<dl class="docutils" id="hsvcolor-expression-function">
<dt>HSV Color Function (<code class="docutils literal notranslate"><span class="pre">hsvcolor()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">hsvcolor(exprH,exprS,exprV)</span></code></span></dt>
<dd>See <a class="reference internal" href="#color-expression-function"><span class="std std-ref">color()</span></a>. This function is similar to the
<code class="docutils literal notranslate"><span class="pre">color()</span></code> function but takes <em>Hue</em>, <em>Saturation</em> and <em>Value</em> (Lightness)
arguments as inputs and produces an RGB <em>vector</em> expression.</dd>
</dl>
<dl class="docutils" id="magnitude-expression-function">
<dt>Magnitude Function (<code class="docutils literal notranslate"><span class="pre">magnitude()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">magnitude(exprV0)</span></code></span></dt>
<dd>Creates a new <em>scalar</em> expression which is everywhere the magnitude of the
<code class="docutils literal notranslate"><span class="pre">exprV0</span></code>.</dd>
</dl>
<dl class="docutils" id="normalize-expression-function">
<dt>Normalize Function (<code class="docutils literal notranslate"><span class="pre">normalize()</span></code>) <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">normalize(exprV0)</span></code></span></dt>
<dd>Creates a new <em>vector</em> expression which is everywhere a normalized vector
(e.g. same direction but unit magnitude) of <code class="docutils literal notranslate"><span class="pre">exprV0</span></code>.</dd>
</dl>
<dl class="docutils" id="curl-expression-function">
<dt>Curl Function: <code class="docutils literal notranslate"><span class="pre">curl()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curl(expr0)</span></code></span></dt>
<dd>Creates a new <em>vector</em> expression which is everywhere the curl of
its input argument, which must be vector valued. In a 3D context, the
result is also a vector. However, in a 2D context the result <em>vector</em>
would always be <code class="docutils literal notranslate"><span class="pre">[0,0,V]</span></code> so expression instead returns only the
<em>scalar</em> V.</dd>
</dl>
<dl class="docutils" id="divergence-expression-function">
<dt>Divergence Function: <code class="docutils literal notranslate"><span class="pre">divergence()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">divergence(expr0)</span></code></span></dt>
<dd>Creates a new <em>scalar</em> expression which is everywhere the divergence of
its input argument, which must be vector valued.</dd>
</dl>
<dl class="docutils" id="gradient-expression-function">
<dt>Gradient Function: <code class="docutils literal notranslate"><span class="pre">gradient()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">gradient(expr0)</span></code></span></dt>
<dd>Creates a new <em>vector</em> expression which is everywhere the gradient of its
input argument, which must be <em>scalar</em>. The method of calculation varies
depending on the type of mesh upon which the input is defined. See also
<a class="reference internal" href="#ij-gradient-expression-function"><span class="std std-ref">ij_gradient()</span></a> and
<a class="reference internal" href="#ijk-gradient-expression-function"><span class="std std-ref">ijk_gradient()</span></a>.</dd>
</dl>
<dl class="docutils" id="ij-gradient-expression-function">
<dt>IJ_Gradient Function: <code class="docutils literal notranslate"><span class="pre">ij_gradient()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ij_gradient(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="ijk-gradient-expression-function">
<dt>IJK_Gradient Function: <code class="docutils literal notranslate"><span class="pre">ijk_gradient()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">ijk_gradient(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="surface-normal-expression-function">
<dt>Surface Normal Function: <code class="docutils literal notranslate"><span class="pre">surface_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">surface_normal(expr0)</span></code></span></dt>
<dd>This function is an <em>alias</em> for
<a class="reference internal" href="#cell-surface-normal-expression-function"><span class="std std-ref">cell_surface_normal()</span></a></dd>
</dl>
<dl class="docutils" id="point-surface-normal-expression-function">
<dt>Point Surface Normal Function: <code class="docutils literal notranslate"><span class="pre">point_surface_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">point_surface_normal(expr0)</span></code></span></dt>
<dd>Like <a class="reference internal" href="#cell-surface-normal-expression-function"><span class="std std-ref">cell_surface_normal()</span></a>
except that after computing face normals, they are averaged to the nodes.</dd>
</dl>
<dl class="docutils" id="cell-surface-normal-expression-function">
<dt>Cell Surface Normal Function: <code class="docutils literal notranslate"><span class="pre">cell_surface_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cell_surface_normal(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Computes a <em>vector</em> variable which is the normal to a <em>surface</em>. The input
argument is a <em>Mesh</em> variable. In addition, this function cannot be used
in isolation. It must be used in combination the
<a class="reference internal" href="../Operators/OperatorTypes/ExternalSurface_operator.html#externalsurface-operator"><span class="std std-ref">external surface</span></a>, <em>first</em>, and the
<a class="reference internal" href="../Operators/OperatorTypes/DeferExpression_operator.html#deferexpression-operator"><span class="std std-ref">defer expression</span></a>, <em>second</em>, operators.</dd>
</dl>
<dl class="docutils" id="edge-normal-expression-function">
<dt>Edge Normal Function: <code class="docutils literal notranslate"><span class="pre">edge_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">edge_normal(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="point-edge-normal-expression-function">
<dt>Point Edge Normal Function: <code class="docutils literal notranslate"><span class="pre">point_edge_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">point_edge_normal(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="cell-edge-normal-expression-function">
<dt>Cell Edge Normal Function: <code class="docutils literal notranslate"><span class="pre">cell_edge_normal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cell_edge_normal(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
</div>
<div class="section" id="tensor-expressions">
<h3>8.1.3.5. Tensor Expressions<a class="headerlink" href="#tensor-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="contraction-expression-function">
<dt>Contraction Function: <code class="docutils literal notranslate"><span class="pre">contraction()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">contraction(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="determinant-expression-function">
<dt>Determinant Function: <code class="docutils literal notranslate"><span class="pre">determinant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">determinant(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="effective-tensor-expression-function">
<dt>Effective Tensor Function: <code class="docutils literal notranslate"><span class="pre">effective_tensor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">effective_tensor(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="eigenvalue-expression-function">
<dt>Eigenvalue Function: <code class="docutils literal notranslate"><span class="pre">eigenvalue()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eigenvalue(expr0)</span></code></span></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">expr0</span></code> argument must evaluate to a 3x3 <em>symmetric</em> tensor. The
eigenvalue
expression returns the eigenvalues of the 3x3 <em>symmetric</em> matrix argument
as a vector valued expression where each eigenvalue is a component of
the vector. Use the vector component operator,
<a class="reference internal" href="#vector-component-expression-operator"><span class="std std-ref">[]</span></a>, to access individual
eigenvalues.</dd>
</dl>
<dl class="docutils" id="eigenvector-expression-function">
<dt>Eigenvector Function: <code class="docutils literal notranslate"><span class="pre">eigenvector()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eigenvector(expr0)</span></code></span></dt>
<dd><p class="first">The <code class="docutils literal notranslate"><span class="pre">expr0</span></code> argument must evaluate to a 3x3 <em>symmetric</em> tensor. The
eigenvector
expression returns the eigenvectors of the 3x3 matrix argument as a tensor
(3x3 matrix) valued expression where each column in the tensor is one of
the eigenvectors.</p>
<p>In order to use the vector component operator
<a class="reference internal" href="#vector-component-expression-operator"><span class="std std-ref">[]</span></a>, to access individual
eigenvectors, the result must be <em>transposed</em> with the
<a class="reference internal" href="#transpose-expression-function"><span class="std std-ref">transpose()</span></a>, expression function.</p>
<p class="last">For example, if
<code class="docutils literal notranslate"><span class="pre">evecs</span> <span class="pre">=</span> <span class="pre">transpose(eigenvector(tensor))</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">evecs[1]</span></code>
will return the second eigenvector.</p>
</dd>
</dl>
<dl class="docutils" id="inverse-expression-function">
<dt>Inverse Function: <code class="docutils literal notranslate"><span class="pre">inverse()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">inverse(expr0)</span></code></span></dt>
<dd>Creates a new tensor expression which is everywhere the inverse of its
input argument, which must also be a tensor.</dd>
</dl>
<dl class="docutils" id="principal-deviatoric-tensor-expression-function">
<dt>Principal Deviatoric Tensor Function: <code class="docutils literal notranslate"><span class="pre">principal_deviatoric_tensor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">principal_deviatoric_tensor(expr0)</span></code></span></dt>
<dd>Creates a new vector expression which is everywhere the
principal deviatoric stress components of the input argument, which must
be a tensor.</dd>
</dl>
<dl class="docutils" id="principal-tensor-expression-function">
<dt>Principal Tensor Function: <code class="docutils literal notranslate"><span class="pre">principal_tensor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">principal_tensor(expr0)</span></code></span></dt>
<dd>Creates a new vector expression which is everywhere the
principal stress components of the input argument, which must
be a tensor.</dd>
</dl>
<dl class="docutils" id="transpose-expression-function">
<dt>Transpose Function: <code class="docutils literal notranslate"><span class="pre">transpose()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">transpose(expr0)</span></code></span></dt>
<dd>Creates a new tensor expression which is everywhere the transpose of
its input argument which must also be a tensor.</dd>
</dl>
<dl class="docutils" id="tensor-maximum-shear-expression-function">
<dt>Tensor Maximum Shear Function: <code class="docutils literal notranslate"><span class="pre">tensor_maximum_shear()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">tensor_maximum_shear(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="trace-expression-function">
<dt>Trace Function: <code class="docutils literal notranslate"><span class="pre">trace()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">trace(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="viscous-stress-expression-function">
<dt>Viscous Stress Function: <code class="docutils literal notranslate"><span class="pre">viscous_stress()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">viscous_stress(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
</div>
<div class="section" id="array-expressions">
<h3>8.1.3.6. Array Expressions<a class="headerlink" href="#array-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="array-compose-expression-function">
<dt>Array Compose Function: <code class="docutils literal notranslate"><span class="pre">array_compose()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_compose(expr0,</span> <span class="pre">expr1,</span> <span class="pre">...,</span> <span class="pre">exprN-1)</span></code></span></dt>
<dd>Create a new <em>array</em> expression variable which is everywhere the array
composition of its arguments, which all must be <em>scalar</em> type.
An array mesh variable is useful when using the label plot or when
doing picks and wanting pick values to always return a certain selected
set of mesh variables. But, all an array mesh variable really is is a
convenient container to hold a group of individual scalar mesh variables.
Each argument to the array_compose expression must evaluate to a scalar
expression and all of the input expressions must have the same centering.
Array variables are collections of scalar variables that are commonly used
with certain plots to display the contents of multiple variables
simultaneously. For example, the Label plot can display the values in an
array variable.</dd>
</dl>
<dl class="docutils" id="array-compose-with-bins-expression-function">
<dt>Array Compose With Bins Function: <code class="docutils literal notranslate"><span class="pre">array_compose_with_bins()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_compose_with_bins(expr0,...,exprN-1,b0,...bn-1</span> <span class="pre">)</span></code></span></dt>
<dd><p class="first">This expression combines two related concepts. One is the array concept
where a group of individual scalar mesh variables are grouped into an array
variable. The other is a set of coordinate values (you can kinda think of
as bin boundaries), that should be used by <a class="reference external" href="https://visit.llnl.gov">VisIt</a> for certain kinds of
operations involving the array variable. If there are N variables in the
array, <code class="docutils literal notranslate"><span class="pre">expr0</span></code>, <code class="docutils literal notranslate"><span class="pre">expr1</span></code>, and so on, there are N+1 coordinate values
(or bin boundaries), <code class="docutils literal notranslate"><span class="pre">b0</span></code>, <code class="docutils literal notranslate"><span class="pre">b1</span></code>. When such a variable is picked using
one of <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s pick operations, <a class="reference external" href="https://visit.llnl.gov">VisIt</a> can display a bar-graph. Each bar in
the bar-graph has a height determined by the associated scalar mesh variable
(at the picked point) and a width determined by the associated
bin-boundaries.</p>
<p>For example, suppose a user had an array variable, foo, composed of 5 scalar
mesh variables, <code class="docutils literal notranslate"><span class="pre">a1</span></code>, <code class="docutils literal notranslate"><span class="pre">a2</span></code>, <code class="docutils literal notranslate"><span class="pre">a3</span></code>, <code class="docutils literal notranslate"><span class="pre">a4</span></code>, and <code class="docutils literal notranslate"><span class="pre">a5</span></code> like so…</p>
<p><code class="docutils literal notranslate"><span class="pre">array_compose_with_bins(a1,a2,a3,a4,a5,0,3.5,10.1,10.7,12,22)</span></code></p>
<p class="last">For any given point on a plot, when the user picked foo, there are 5 values
returned, the value of each of the 5 scalar variable members of foo. If the
user arranged for a pick to return a bar-graph of the variable using the
bin-boundaries, the result might look like…</p>
</dd>
</dl>
<div class="figure" id="id7">
<span id="array-compose-with-bins"></span><a class="reference internal image-reference" href="../../_images/new_array_compose_with_bins.png"><img alt="../../_images/new_array_compose_with_bins.png" src="../../_images/new_array_compose_with_bins.png" style="width: 396.0px; height: 297.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 8.4 </span><span class="caption-text">Bar graph created from picking an array variable created with array_compose_with_bins()</span></p>
</div>
<dl class="docutils" id="array-decompose-expression-function">
<dt>Array Decompose Function: <code class="docutils literal notranslate"><span class="pre">array_decompose()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_decompose(Arr,Idx)</span></code></span></dt>
<dd>Creates a new <em>scalar</em> expression which is everywhere the scalar member of
the <em>array</em> input argument at index <code class="docutils literal notranslate"><span class="pre">Idx</span></code> (numbered starting from zero).</dd>
</dl>
<dl class="docutils" id="array-decompose2d-expression-function">
<dt>Array Decompose 2D Function: <code class="docutils literal notranslate"><span class="pre">array_decompose2d()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_decompose2d(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="array-componentwise-division-expression-function">
<dt>Array Component-wise Division Function: <code class="docutils literal notranslate"><span class="pre">array_componentwise_division()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_componentwise_division(&lt;Array&gt;,&lt;Divisor&gt;)</span></code></span></dt>
<dd>Return a new <em>array</em> variable which is the old input <code class="docutils literal notranslate"><span class="pre">&lt;Array&gt;</span></code> variable
with each of its components divided by the <code class="docutils literal notranslate"><span class="pre">&lt;Divisor&gt;</span></code>.</dd>
</dl>
<dl class="docutils" id="array-componentwise-product-expression-function">
<dt>Array Component-wise Product Function: <code class="docutils literal notranslate"><span class="pre">array_componentwise_product()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_componentwise_product(&lt;Array&gt;,&lt;Multiplier&gt;)</span></code></span></dt>
<dd>Return a new <em>array</em> variable which is the old input <code class="docutils literal notranslate"><span class="pre">&lt;Array&gt;</span></code> variable
with each of its components multiplied by the <code class="docutils literal notranslate"><span class="pre">&lt;Multiplier&gt;</span></code>.</dd>
</dl>
<dl class="docutils" id="array-sum-expression-function">
<dt>Array Sum Function: <code class="docutils literal notranslate"><span class="pre">array_sum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">array_sum(&lt;Array&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable which is the sum of the <code class="docutils literal notranslate"><span class="pre">&lt;Array&gt;</span></code> components.</dd>
</dl>
</div>
<div class="section" id="material-expressions">
<h3>8.1.3.7. Material Expressions<a class="headerlink" href="#material-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="dominant-mat-expression-function">
<dt>Dominant Material Function: <code class="docutils literal notranslate"><span class="pre">dominant_mat()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">domimant_mat(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new scalar expression which is for every mesh cell/zone the
material having the largest volume fraction.</dd>
</dl>
<dl class="docutils" id="materror-expression-function">
<dt>Material Error Function: <code class="docutils literal notranslate"><span class="pre">materror()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">materror(&lt;Mat&gt;,[Const,Const...])</span></code></span></dt>
<dd><p class="first">Creates a new scalar expression which is everywhere the difference in
volume fractions as stored in the database and as computed by <a class="reference external" href="https://visit.llnl.gov">VisIt</a>’s
material interface reconstruction (MIR) algorithm. The <code class="docutils literal notranslate"><span class="pre">&lt;Mat&gt;</span></code> argument
is a <em>material variable</em> from a database and the <code class="docutils literal notranslate"><span class="pre">Const</span></code> argument is
one of the material names as an quoted string or a material number
as an integer. If multiple materials are to be selected from the
<em>material variable</em>, enclose them in square brackets as a list.</p>
<p class="last">Examples…</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">materror</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">materror</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">materror</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="s2">&quot;copper&quot;</span><span class="p">)</span>
<span class="n">materror</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;copper&quot;</span><span class="p">,</span> <span class="s2">&quot;steel&quot;</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils" id="matvf-expression-function">
<dt>Material Volume Fractions Function: <code class="docutils literal notranslate"><span class="pre">matvf()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">matvf(&lt;Mat&gt;,[Const,Const,...])</span></code></span></dt>
<dd><p class="first">Creates a new scalar expression which is everywhere the sum of the volume
fraction of the specified materials within the specified material variable.
The <code class="docutils literal notranslate"><span class="pre">&lt;Mat&gt;</span></code> argument is a <em>material variable</em> from a database and
the <code class="docutils literal notranslate"><span class="pre">Const</span></code> argument(s) identify one or more materials within the
<em>material variable</em>.</p>
<p class="last">Examples…</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matvf</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">matvf</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">matvf</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="s2">&quot;copper&quot;</span><span class="p">)</span>
<span class="n">matvf</span><span class="p">(</span><span class="n">materials</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;copper&quot;</span><span class="p">,</span> <span class="s2">&quot;steel&quot;</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils" id="nmats-expression-function">
<dt>NMats Function: <code class="docutils literal notranslate"><span class="pre">nmats()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">nmats(&lt;Mat&gt;)</span></code></span></dt>
<dd>Creates a new scalar expression which for each mesh cell/zone is the number
of materials in the cell/zone. The <code class="docutils literal notranslate"><span class="pre">&lt;Mat&gt;</span></code> argument is a
<em>material variable</em> from a database.</dd>
</dl>
<dl class="docutils" id="specmf-expression-function">
<dt>Specmf Function: <code class="docutils literal notranslate"><span class="pre">specmf()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">specmf(&lt;Spec&gt;,&lt;MConst&gt;,[Const,Const,...])</span></code></span></dt>
<dd><p class="first">Performs the analogous operation to <code class="docutils literal notranslate"><span class="pre">matvf</span></code> for species mass fractions.
The <code class="docutils literal notranslate"><span class="pre">&lt;Spec&gt;</span></code> argument is a <em>species variable</em> from a database. The
<code class="docutils literal notranslate"><span class="pre">&lt;MConst&gt;</span></code> argument is a specific material within the <em>species variable</em>.
The <code class="docutils literal notranslate"><span class="pre">&lt;Const&gt;</span></code> argument(s) identify which species within the
<em>species variable</em> to select.</p>
<p class="last">Examples:</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">specmf</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">specmf</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="s2">&quot;copper&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">specmf</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="s2">&quot;copper&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils" id="value-for-material-expression-function">
<dt>Value For Material Function: <code class="docutils literal notranslate"><span class="pre">value_for_material()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">value_for_material(&lt;Var&gt;,&lt;Const&gt;)</span></code></span></dt>
<dd>Creates a new scalar expression which is everywhere the material-specific
value of the variable specified by <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> for the material specified by
<code class="docutils literal notranslate"><span class="pre">&lt;Const&gt;</span></code>. If variable specified by <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> has no material specific
values, the values returned from this function will be just the variable’s
values.</dd>
</dl>
</div>
<div class="section" id="mesh-expressions">
<h3>8.1.3.8. Mesh Expressions<a class="headerlink" href="#mesh-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="area-function">
<dt>Area Function: <code class="docutils literal notranslate"><span class="pre">area()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">area(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="cylindrical-expression-function">
<dt>cylindrical Function: <code class="docutils literal notranslate"><span class="pre">cylindrical()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cylindrical(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new vector variable on the mesh which is the cylindrical coordinate
tuple (R,theta,Z) of each mesh node.</dd>
</dl>
<dl class="docutils" id="cylindrical-radius-expression-function">
<dt>Cylindrical Radius <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cylindrical_radius(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a scalar new variable on the mesh which is the radius component of the
cylindrical coordinate (from the Z axis) of each mesh node.</dd>
</dl>
<dl class="docutils" id="cylindrical-theta-expression-function">
<dt>cylindrical theta Function: <code class="docutils literal notranslate"><span class="pre">cylindrical_theta()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cylindrical_theta(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new scalar variable on the mesh which is the angle component of the
cylindrical coordinate (around the Z axis from the +X axis) of each mesh node.</dd>
</dl>
<dl class="docutils" id="polar-radius-expression-function">
<dt>polar radius Function: <code class="docutils literal notranslate"><span class="pre">polar_radius()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">polar_radius(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new scalar variable on the mesh which is the radius component of
the polar coordinate of each mesh node.</dd>
</dl>
<dl class="docutils" id="polar-theta-expression-function">
<dt>polar theta Function: <code class="docutils literal notranslate"><span class="pre">polar_theta()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">polar_theta(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new scalar variable on the mesh which is the theta component of
the polar coordinate of each mesh node.</dd>
</dl>
<dl class="docutils" id="polar-phi-expression-function">
<dt>polar phi Function: <code class="docutils literal notranslate"><span class="pre">polar_phi()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">polar_phi(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new scalar variable on the mesh which is the phi component of
the polar coordinate of each mesh node.</dd>
</dl>
<dl class="docutils" id="min-coord-expression-function">
<dt>min coord Function: <code class="docutils literal notranslate"><span class="pre">min_coord()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_coord(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="max-coord-expression-function">
<dt>max coord Function: <code class="docutils literal notranslate"><span class="pre">max_coord()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_coord(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="external-node-expression-function">
<dt>external node Function: <code class="docutils literal notranslate"><span class="pre">external_node()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">external_node(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="external-cell-expression-function">
<dt>external cell Function: <code class="docutils literal notranslate"><span class="pre">external_cell()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">external_cell(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="zoneid-expression-function">
<dt>Zoneid Function: <code class="docutils literal notranslate"><span class="pre">zoneid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">zoneid(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Return a <a class="reference internal" href="../glossary.html#term-zone-centered"><span class="xref std std-term">zone-centered</span></a> <em>scalar</em> variable where the value for each
zone/cell is local index of a zone, staring from zero, within its domain.</dd>
</dl>
<dl class="docutils" id="global-zoneid-expression-function">
<dt>Global Zoneid Function: <code class="docutils literal notranslate"><span class="pre">global_zoneid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">global_zoneid(&lt;Mesh&gt;)</span></code></span></dt>
<dd>If global zone ids are specified by the input database, return a
<a class="reference internal" href="../glossary.html#term-zone-centered"><span class="xref std std-term">zone-centered</span></a> <em>scalar</em> variable where the value for each zone/cell
is the <em>global</em> index of a zone, as specified by the data producer.</dd>
</dl>
<dl class="docutils" id="nodeid-expression-function">
<dt>Nodeid Function: <code class="docutils literal notranslate"><span class="pre">nodeid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">nodeid(expr0)</span></code></span></dt>
<dd>Return a <a class="reference internal" href="../glossary.html#term-node-centered"><span class="xref std std-term">node-centered</span></a> <em>scalar</em> variable where the value for each
node/vertex/point is local index of a node, staring from zero, within
its domain.</dd>
</dl>
<dl class="docutils" id="global-nodeid-expression-function">
<dt>Global Nodeid Function: <code class="docutils literal notranslate"><span class="pre">global_nodeid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">global_nodeid(expr0)</span></code></span></dt>
<dd>If global node ids are specified by the input database, return a
<a class="reference internal" href="../glossary.html#term-node-centered"><span class="xref std std-term">node-centered</span></a> <em>scalar</em> variable where the value for each
node/vertex/point is the <em>global</em> index of a node, as specified by
the data producer.</dd>
</dl>
<dl class="docutils" id="volume-function">
<dt>Volume Function: <code class="docutils literal notranslate"><span class="pre">volume()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">volume(&lt;Mesh&gt;)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="volume2-function">
<dt>Volume2 Function: <code class="docutils literal notranslate"><span class="pre">volume2()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">volume2(&lt;Mesh&gt;)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="revolved-volume-function">
<dt>Revolved Volume Function: <code class="docutils literal notranslate"><span class="pre">revolved_volume()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">revolved_volume(&lt;Mesh&gt;)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="revolved-surface-area-function">
<dt>Revolved Surface Area Function: <code class="docutils literal notranslate"><span class="pre">revolved_surface_area()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">revolved_surface_area(&lt;Mesh&gt;)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="zonetype-expression-function">
<dt>Zone Type Function: <code class="docutils literal notranslate"><span class="pre">zonetype()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">zonetype(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Return a <em>zone</em> centered, character valued variable which indicates
the <em>shape type</em> of each zone suitable for being used within the
<em>label</em> plot. Upper case characters generally denote 3D shapes
(e.g. <code class="docutils literal notranslate"><span class="pre">T</span></code> for <code class="docutils literal notranslate"><span class="pre">tet</span></code>) while lower case characters denote 2D shapes
(e.g. <code class="docutils literal notranslate"><span class="pre">t</span></code> for <code class="docutils literal notranslate"><span class="pre">triangle</span></code>).</dd>
</dl>
<dl class="docutils" id="zonetype-rank-expression-function">
<dt>Zone Type Rank Function: <code class="docutils literal notranslate"><span class="pre">zonetype_rank()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">zonetype_rank(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Return a <em>zone</em> centered, integer valued variable which indicates
the <em>VTK shape type</em> of each zone. This expression is often useful
with the threshold operator to select only certain shapes within
the mesh to be displayed.</dd>
</dl>
</div>
<div class="section" id="mesh-quality-expressions">
<h3>8.1.3.9. Mesh Quality Expressions<a class="headerlink" href="#mesh-quality-expressions" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://visit.llnl.gov">VisIt</a> employs the <em>Verdict Mesh Quality Library</em> to support a number of
expressions related to computing cell-by-cell mesh quality metrics. The
specific definitions of the various mesh quality metrics defined by the
<em>Verdict Mesh Quality Library</em> are amply explained in the
<a class="reference download internal" download="" href="../../_downloads/6247ea152ab46d9d07001f397265a618/VerdictManual-revA.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Verdict</span> <span class="pre">Manual</span></code></a>. Below, we
simply list all the mesh quality metrics and describe in detail only
those that are not part of the <em>Verdict Mesh Quality Library</em></p>
<p>In all cases in the <strong>Mesh Quality Expressions</strong>, the input argument is
a <em>mesh variable</em> from a database and the output is a <em>scalar</em> expression.</p>
<dl class="docutils" id="neighbor-function">
<dt>Neighbor Function: <code class="docutils literal notranslate"><span class="pre">neighbor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">neighbor(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="node-degree-function">
<dt>Node Degree Function: <code class="docutils literal notranslate"><span class="pre">node_degree()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">node_degree(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="degree-expression-function">
<dt>degree Function: <code class="docutils literal notranslate"><span class="pre">degree()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">degree(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="aspect-function">
<dt>Aspect Function: <code class="docutils literal notranslate"><span class="pre">aspect()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">aspect(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="skew-function">
<dt>Skew Function: <code class="docutils literal notranslate"><span class="pre">skew()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">skew(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="taper-function">
<dt>Taper Function: <code class="docutils literal notranslate"><span class="pre">taper()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">taper(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-corner-angle-function">
<dt>Minimum Corner Angle Function: <code class="docutils literal notranslate"><span class="pre">min_corner_angle()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_corner_angle(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="max-corner-angle-function">
<dt>Maximum Corner Angle Function: <code class="docutils literal notranslate"><span class="pre">max_corner_angle()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_corner_angle(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-edge-length-function">
<dt>Minimum Edge Length Function: <code class="docutils literal notranslate"><span class="pre">min_edge_length()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_edge_length(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="max-edge-length-function">
<dt>Maximum Edge Length Function: <code class="docutils literal notranslate"><span class="pre">max_edge_length()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_edge_length(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-side-volume-function">
<dt>Minimum Side Volume Function: <code class="docutils literal notranslate"><span class="pre">min_side_volume()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_side_volume(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="max-side-volume-function">
<dt>Maximum Side Volume Function: <code class="docutils literal notranslate"><span class="pre">max_side_volume()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_side_volume(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="stretch-function">
<dt>Stretch Function: <code class="docutils literal notranslate"><span class="pre">stretch()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">stretch(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="diagonal-ratio-function">
<dt>Diagonal Ratio Function: <code class="docutils literal notranslate"><span class="pre">diagonal_ratio()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">diagonal_ratio(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="max-diagonal-function">
<dt>Maximum Diagonal Function: <code class="docutils literal notranslate"><span class="pre">max_diagonal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_diagonal(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-diagonal-function">
<dt>Minimum Diagonal Function: <code class="docutils literal notranslate"><span class="pre">min_diagonal()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_diagonal(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="dimension-function">
<dt>Dimension Function: <code class="docutils literal notranslate"><span class="pre">dimension()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">dimension(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="oddy-function">
<dt>Oddy Function: <code class="docutils literal notranslate"><span class="pre">oddy()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">oddy(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="condition-function">
<dt>Condition Function: <code class="docutils literal notranslate"><span class="pre">condition()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">condition(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="jacobian-function">
<dt>Jacobian Function: <code class="docutils literal notranslate"><span class="pre">jacobian()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">jacobian(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="scaled-jacobian-function">
<dt>Scaled Jacobian Function: <code class="docutils literal notranslate"><span class="pre">scaled_jacobian()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">scaled_jacobian(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="shear-function">
<dt>Shear Function: <code class="docutils literal notranslate"><span class="pre">shear()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">shear(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="shape-function">
<dt>Shape Function: <code class="docutils literal notranslate"><span class="pre">shape()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">shape(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="relative-size-function">
<dt>Relative Size Function: <code class="docutils literal notranslate"><span class="pre">relative_size()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">relative_size(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="shape-and-size-function">
<dt>Shape and Size Function: <code class="docutils literal notranslate"><span class="pre">shape_and_size()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">shape_and_size(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="aspect-gamma-function">
<dt>Aspect Gamma Function: <code class="docutils literal notranslate"><span class="pre">aspect_gamma()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">aspect_gamma(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="warpage-function">
<dt>Warpage Function: <code class="docutils literal notranslate"><span class="pre">warpage()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">warpage(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="maximum-angle-function">
<dt>Maximum Angle Function: <code class="docutils literal notranslate"><span class="pre">maximum_angle()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">maximum_angle(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="minimum-angle-function">
<dt>Minimum Angle Function: <code class="docutils literal notranslate"><span class="pre">minimum_angle()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">minimum_angle(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-corner-area-function">
<dt>Minimum Corner Area Function: <code class="docutils literal notranslate"><span class="pre">min_corner_area()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_corner_area(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-sin-corner-function">
<dt>Minimum Sin Corner Function: <code class="docutils literal notranslate"><span class="pre">min_sin_corner()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_sin_corner(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="min-sin-corner-cw-function">
<dt>Minimum Sin Corner CW Function: <code class="docutils literal notranslate"><span class="pre">min_sin_corner_cw()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_sin_corner_cw(&lt;Mesh&gt;)</span></code></span></dt>
<dd>See the Verdict Manual</dd>
</dl>
<dl class="docutils" id="face-planarity-function">
<dt>Face Planarity Function: <code class="docutils literal notranslate"><span class="pre">face_planarity()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">face_planarity(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Creates a new expression which is everywhere a measure of how close to
<em>planar</em> all the points comprising a face are. This is computed for
each face of a cell and the maximum over all faces is selected for each
cell. Planarity is measured as the maximum distance from an arbitrary plane
defined by the first 3 points of a face of the remaining points of the face.
Values closer to zero are <em>better</em>. A triangle face will always have a
planarity measure of zero. This mesh quality expression is not part of
the Verdict library.</dd>
</dl>
<dl class="docutils" id="relative-face-planarity-function">
<dt>Relative Face Planarity Function: <code class="docutils literal notranslate"><span class="pre">relative_face_planarity()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">relative_face_planarity(&lt;Mesh&gt;)</span></code></span></dt>
<dd>Performs the same computation as the
<a class="reference internal" href="#face-planarity-function"><span class="std std-ref">face_planarity()</span></a>, except where each
face’s value is normalized by the average edge length of the face.</dd>
</dl>
</div>
<div class="section" id="comparison-expressions">
<span id="id3"></span><h3>8.1.3.10. Comparison Expressions<a class="headerlink" href="#comparison-expressions" title="Permalink to this headline">¶</a></h3>
<p>Comparing variables defined on the <em>same</em> mesh is often as simple as taking
their difference. What about comparing variables when they are defined on
different meshes? A common example is taking the difference between results
from two runs of the same simulation application. Even if the two runs operate
on computationally <em>identical</em> meshes, the fact that each run involves its own
<em>instance</em> of that mesh means that as far as <a class="reference external" href="https://visit.llnl.gov">VisIt</a> is concerned, they are
different meshes.</p>
<p>In order to compose an expression involving variables on different meshes, the
<em>first</em> step is to <em>map</em> the variables onto a <em>common</em> mesh. The position-based
CMFE function and its friend, the connectivity-based CMFE function,
<a class="reference internal" href="#conn-cmfe-expression-function"><span class="std std-ref">conn_cmfe()</span></a> are the work-horse methods
needed when working with variables from <em>different</em> meshes in the <em>same</em>
expression. <em>CMFE</em> is an abbreviation for <em>cross-mesh field evaluation</em>.</p>
<p>The syntax for specifying CMFE expressions can be complicated. Therefore, the
GUI supports a <em>wizard</em> to help create them. See the
<a class="reference internal" href="DataLevelComparisonsWizard.html#datalevelcomparisonswizard"><span class="std std-ref">Data-Level Comparisons Wizard</span></a> for more
information. Here, we describe the details of creating CMFE expressions
manually.</p>
<p>All of the comparison expressions involve the concepts of a <em>donor variable</em>
and a <em>target mesh</em>. The donor variable (e.g. <em>pressure</em>) is the variable to
be mapped. The target mesh is the mesh onto which the donor variable is to be
mapped. In addition, the term <em>donor mesh</em> refers to the mesh upon which the
donor variable is defined.</p>
<dl class="docutils" id="pos-cmfe-expression-function">
<dt>Position-Based CMFE Function: <code class="docutils literal notranslate"><span class="pre">pos_cmfe()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">pos_cmfe(&lt;Donor</span> <span class="pre">Variable&gt;,&lt;Target</span> <span class="pre">Mesh&gt;,&lt;Fill&gt;)</span></code></span></dt>
<dd><p class="first">The <code class="docutils literal notranslate"><span class="pre">pos_cmfe()</span></code> function performs the mapping assuming the two meshes,
that is the <code class="docutils literal notranslate"><span class="pre">&lt;Target</span> <span class="pre">Mesh&gt;</span></code> and the mesh upon which the
<code class="docutils literal notranslate"><span class="pre">&lt;Donor</span> <span class="pre">Variable&gt;</span></code> (e.g. the <em>donor mesh</em>) is defined, share <em>only</em> a
common spatial (positional) extent. Its friend, the
<a class="reference internal" href="#conn-cmfe-expression-function"><span class="std std-ref">conn_cmfe()</span></a>
function is <em>optimized</em> to perform the mapping when the two meshes are also
<em>topologically identical</em>. In other words, their <em>coordinate</em> <strong>and</strong>
<em>connectivity</em> arrays are 1:1. In this case, the mapping can be performed
with more efficiency and numerical accuracy. Therefore, when it is possible
and makes sense to do so, it is always best to use <code class="docutils literal notranslate"><span class="pre">conn_cmfe()</span></code>.</p>
<p>We’ll describe the arguments to <code class="docutils literal notranslate"><span class="pre">pos_cmfe()</span></code> working backwards from the
last.</p>
<p>The last, <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> argument is a numerical constant that <a class="reference external" href="https://visit.llnl.gov">VisIt</a>
will use to determine the value of the result in places on the target
mesh that do not spatially overlap with the mesh of the donor variable. Note
that if a value is chosen within the range of the donor variable, it may
by difficult to distinguish regions <a class="reference external" href="https://visit.llnl.gov">VisIt</a> deemed were non-overlapping.
On the other hand, if a value outside the range is chosen, it will effect
the range of the mapped variable. A common practice is to choose a value that
is an extremum of the donor variable’s range. Another practice is to
choose a value that is easily distinguishable and then apply a threshold
operator to remove those portions of the result. If the <code class="docutils literal notranslate"><span class="pre">Fill</span></code> argument
is not specified, zero is assumed.</p>
<p class="last">Working backwards, the next argument, is the <code class="docutils literal notranslate"><span class="pre">&lt;Target</span> <span class="pre">Mesh&gt;</span></code>.
The <code class="docutils literal notranslate"><span class="pre">&lt;Target</span> <span class="pre">Mesh&gt;</span></code> argument in <code class="docutils literal notranslate"><span class="pre">pos_cmfe()</span></code> is always
interpreted as a mesh <em>within</em> the currently <em>active</em> database. The CMFE
expressions are always mapping data from <em>other</em> meshes, possibly in <em>other</em>
databases onto the <code class="docutils literal notranslate"><span class="pre">&lt;Target</span> <span class="pre">Mesh&gt;</span></code> which is understood to be in the
currently <em>active</em> database. When mapping data between meshes
<em>in different databases</em>, the additional information necessary to specify
the other database is encoded with a special syntax prepending the
<code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Variable</span></code> argument.</p>
</dd>
</dl>
<blockquote id="pos-cmfe-donor-variable-synax">
<div><p>The <code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Variable</span></code> argument is a string argument of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PATH</span><span class="o">-</span><span class="n">TO</span><span class="o">-</span><span class="n">DATABASE</span><span class="o">-</span><span class="n">FROM</span><span class="o">-</span><span class="n">CWD</span><span class="p">[</span><span class="n">SSS</span><span class="p">]</span><span class="n">MM</span><span class="p">:</span><span class="n">VARNAME</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>consisting of the donor variable’s name and up to three pre-pending
sub-strings which may be optionally needed to specify…</p>
<blockquote>
<div><ol class="arabic simple">
<li>…the <em>Database</em> (<code class="docutils literal notranslate"><span class="pre">PATH-TO-DATABASE-FROM-CWD</span></code>) in which the donor variable resides,</li>
<li>…the <em>State Id</em> (<code class="docutils literal notranslate"><span class="pre">[SSS]</span></code>) from which to take the donor variable,</li>
<li>…the <em>Modality</em> (<code class="docutils literal notranslate"><span class="pre">MM</span></code>) by which states are identified in the <em>State Id</em>
sub-string.</li>
</ol>
</div></blockquote>
<p>Depending on circumstances, specifying the <code class="docutils literal notranslate"><span class="pre">Donor-Variable</span></code> argument to
the CMFE functions can get cumbersome. For this reason, CMFE expressions
are typically created using the
<a class="reference internal" href="DataLevelComparisonsWizard.html#datalevelcomparisonswizard"><span class="std std-ref">Data-Level Comparisons Wizard</span></a>
under the <em>Controls</em> menu. Nonetheless, here we describe the syntax and
provide examples for a number of cases of increasing complexity in specifying
where the <code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Variable</span></code> resides.</p>
<p>When the donor variable is in the same database and state as the target mesh,
then only the variable’s name is needed. The optional substrings are not.
See case A in the examples below.</p>
<p>When the donor variable is in a different database <strong>and</strong> the databases
do not have multiple time states, then only sub-string 1, above, is
needed to specify the path to the database in the file system. The path
to the database can be specified using either <em>absolute</em> or <em>relative</em>
paths. <em>Relative</em> paths are interpreted relative to the current working
directory in which the <a class="reference external" href="https://visit.llnl.gov">VisIt</a> session was started. See cases B and C
in the examples below.</p>
<p>When the donor variable is in a different database <strong>and</strong> the databases
have multiple states, then all 3 sub-strings, above, are required. The
<code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Id</span></code> substring is a square-bracket enclosed number used to identify
<em>which state</em> from which to take the donor variable. The <code class="docutils literal notranslate"><span class="pre">Modality</span></code>
substring is a one- or two-character moniker. The first character indicates
whether the number in the the <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Id</span></code> substring is a cycle (<code class="docutils literal notranslate"><span class="pre">c</span></code>),
a time (<code class="docutils literal notranslate"><span class="pre">t</span></code>), or an index (<code class="docutils literal notranslate"><span class="pre">i</span></code>). The second character, if present, is a
<code class="docutils literal notranslate"><span class="pre">d</span></code> character to indicate the cycle, time or index is <em>relative</em> (e.g. a
<em>delta</em>) to the current state. For example, the substring <code class="docutils literal notranslate"><span class="pre">[200]c</span></code> means to
treat the <code class="docutils literal notranslate"><span class="pre">200</span></code> as a <em>cycle</em> number in the donor database whereas the
the substring <code class="docutils literal notranslate"><span class="pre">[-10]id</span></code> means to treat the <code class="docutils literal notranslate"><span class="pre">-10</span></code> as an (<code class="docutils literal notranslate"><span class="pre">i</span></code>) index
(<code class="docutils literal notranslate"><span class="pre">d</span></code>) delta. So, <code class="docutils literal notranslate"><span class="pre">[200]c</span></code> would map the <em>donor</em> at cycle 200
to the <em>current</em> cycle of the <em>target</em> and <code class="docutils literal notranslate"><span class="pre">[-10]id</span></code> would map the
<em>donor</em> at the current <em>index minus 10</em> to the <em>current</em> index of the <em>target</em>.
In particular, the string <code class="docutils literal notranslate"><span class="pre">[0]id</span></code> is needed to create a CMFE that keeps
<em>donor</em> and <em>target</em> in lock step. Note that in cases where the donor database
does not have an exact match for the specified cycle or time, <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will chose
the state with the cycle or time which is closest in absolute distance. For the
<em>index</em> modality, if there is no exact match for the specified index, an error
results. See cases D-I in the examples below.</p>
<p>Note that the <em>relative</em> form of specifying the <em>State Id</em> is needed even
when working with different states <em>within the same database</em>. In particular,
to create an expression representing a <em>time derivative</em> of a variable in
a database, the key insight is to realize it involves mapping a donor
variable from one state in the database onto a mesh at another state. In
addition, the value in using the <em>relative</em> form of specifying the
<code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">Id</span></code> of the donor variable is that as the current time is changed,
the expression properly identifies the different states of the donor
variable instead of always mapping a fixed state.</p>
<p>Examples…</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Case A: Donor variable, &quot;pressure&quot; in same database as mesh, &quot;ucdmesh&quot;</span>
<span class="c1"># Note that due to a limitation in Expression parsing, the &#39;[0]id:&#39; is</span>
<span class="c1"># currently required in the donor variable name as a substitute for</span>
<span class="c1"># specifying a file system path to a database file. The syntax &#39;[0]id:&#39;</span>
<span class="c1"># means a state index delta of zero within the active database.</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nb">id</span><span class="p">:</span><span class="n">pressure</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">ucdmesh</span><span class="o">&gt;</span><span class="p">,</span><span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case B: Donor variable in a different database using absolute path</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;/</span><span class="n">var</span><span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">foo</span><span class="o">.</span><span class="n">silo</span><span class="p">:</span><span class="n">pressure</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">ucdmesh</span><span class="o">&gt;</span><span class="p">,</span><span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case C: Donor variable in a different database using relative path</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">/</span><span class="n">bar</span><span class="o">.</span><span class="n">silo</span><span class="p">:</span><span class="n">pressure</span><span class="o">&gt;</span><span class="p">,</span><span class="o">&lt;</span><span class="n">ucdmesh</span><span class="o">&gt;</span><span class="p">,</span><span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case D: Map &quot;p&quot; from wave.visit at state index=7 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="n">i</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case E: Map &quot;p&quot; from wave.visit at state index current-1 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="nb">id</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case F: Map &quot;p&quot; from wave.visit at state with cycle~200 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="mi">200</span><span class="p">]</span><span class="n">c</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case G: Map &quot;p&quot; from wave.visit at state with cycle~cycle(current)-200 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="o">-</span><span class="mi">200</span><span class="p">]</span><span class="nb">id</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case H: Map &quot;p&quot; from wave.visit at state with time~1.4 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="mf">1.4</span><span class="p">]</span><span class="n">t</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>

<span class="c1"># Case I: Map &quot;p&quot; from wave.visit at state with time~time(current)-0.8 onto &quot;mesh&quot;</span>
<span class="n">pos_cmfe</span><span class="p">(</span><span class="o">&lt;./</span><span class="n">wave</span><span class="o">.</span><span class="n">visit</span><span class="p">[</span><span class="o">-</span><span class="mf">0.8</span><span class="p">]</span><span class="n">td</span><span class="p">:</span><span class="n">p</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="mf">1e+15</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils" id="conn-cmfe-expression-function">
<dt>Connectivity-Based CMFE Function: <code class="docutils literal notranslate"><span class="pre">conn_cmfe()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">conn_cmfe(&lt;Donor</span> <span class="pre">Variable&gt;,&lt;Target</span> <span class="pre">Mesh&gt;)</span></code></span></dt>
<dd>The connectivity-based CMFE is an <em>optimized</em> version of
<a class="reference internal" href="#pos-cmfe-expression-function"><span class="std std-ref">pos_cmfe()</span></a> for cases where the
<code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">Mesh</span></code> and the mesh of the <code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Variable</span></code> are
<em>topologically and geometrically identical</em>. In such cases, there is no
opportunity for the two meshes to fail to overlap perfectly. Thus, there
is no need for the third, <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> argument. In all other respects,
<code class="docutils literal notranslate"><span class="pre">conn_cmfe()</span></code> performs the same function as
<a class="reference internal" href="#pos-cmfe-expression-function"><span class="std std-ref">pos_cmfe()</span></a> except that
<code class="docutils literal notranslate"><span class="pre">conn_cmfe()</span></code> <em>assumes</em> that any differences in the coordinates of the
two meshes are numerically insignificant to the resulting mapped variable.
In other words, differences in the coordinate fields, if they exist, are
not incorporated into the resulting mapping.</dd>
</dl>
<dl class="docutils" id="curve-cmfe-expression-function">
<dt>Curve CMFE Function: <code class="docutils literal notranslate"><span class="pre">curve_cmfe()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curve_cmfe(&lt;Donor</span> <span class="pre">Curve&gt;,&lt;Target</span> <span class="pre">Curve&gt;)</span></code></span></dt>
<dd>The curve-based CMFE performs the same function as
<a class="reference internal" href="#pos-cmfe-expression-function"><span class="std std-ref">pos_cmfe()</span></a> except for curves. The
arguments specify the <code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">Curve</span></code> and <code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Curve</span></code> and the same
syntax rules apply for specifying the <code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Curve</span></code> as for the
<code class="docutils literal notranslate"><span class="pre">Donor</span> <span class="pre">Variable</span></code> in <a class="reference internal" href="#pos-cmfe-expression-function"><span class="std std-ref">pos_cmfe()</span></a>.
However, if curves represent different spatial extents or different
numbers of samples or sample spacing, no attempt is made to unify them.</dd>
</dl>
<dl class="docutils" id="symm-point-expression-function">
<dt>Symmetric Difference By Point Function: <code class="docutils literal notranslate"><span class="pre">symm_point()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">symm_point(&lt;Scalar&gt;,&lt;Fill&gt;,[Px,Py,Pz])</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable which is the symmetric difference of
<code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> reflected about the point <code class="docutils literal notranslate"><span class="pre">[Px,</span> <span class="pre">Py,</span> <span class="pre">Pz]</span></code>. In 2D, <code class="docutils literal notranslate"><span class="pre">Pz</span></code>
is still required but ignored. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> argument is a numerical
constant that <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will use to determine the value of the result in
places symmetry about the point doesn’t overlap with the donor mesh.
This operation involves <strong>both</strong> the reflection about the point <strong>and</strong>
taking the difference. If the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> is indeed symmetric
about the point, the result will be a constant valued variable of zero.</dd>
</dl>
<dl class="docutils" id="symm-plane-expression-function">
<dt>Symmetric Difference By Plane Function: <code class="docutils literal notranslate"><span class="pre">symm_plane()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">symm_plane(&lt;Scalar&gt;,&lt;Fill&gt;,[Nx,Ny,Nz,Px,Py,Pz])</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable which is the symmetric difference of
<code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> reflected about the plane defined by the point <code class="docutils literal notranslate"><span class="pre">[Px,</span> <span class="pre">Py,</span> <span class="pre">Pz]</span></code>
and normal <code class="docutils literal notranslate"><span class="pre">[Nx,</span> <span class="pre">Ny,</span> <span class="pre">Nz]</span></code>. In 2D, the <code class="docutils literal notranslate"><span class="pre">Nz</span></code> and <code class="docutils literal notranslate"><span class="pre">Pz</span></code> arguments are
still required but ignored. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> argument is a numerical
constant that <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will use to determine the value of the result in
places symmetry about the plane doesn’t overlap with the donor mesh.
This operation involves <strong>both</strong> the reflection about the plane <strong>and</strong>
taking the difference. If the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> is indeed symmetric about
the plane, the result will be a constant valued variable of zero.</dd>
</dl>
<dl class="docutils" id="symm-transform-expression-function">
<dt>Symmetric Difference By Transform Function: <code class="docutils literal notranslate"><span class="pre">symm_transform()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">symm_transform(&lt;Scalar&gt;,&lt;Fill&gt;,[T00,T01,T02,...,T22])</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable which is the symmetric difference of
<code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> reflected through the 3x3 transformation where each point,
<code class="docutils literal notranslate"><span class="pre">[Px,Py,Pz]</span></code>, in the mesh supporting <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> is transformed by the
transform coefficients, <code class="docutils literal notranslate"><span class="pre">[T00,</span> <span class="pre">T01,...,T22]</span></code> as shown below. In 2D, all
9 transform coefficients are still required but the last row and column are
ignored. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> argument is a numerical constant that <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will
use to determine the value of the result in places symmetry through the
transform doesn’t overlap with the donor mesh. This operation involves
<strong>both</strong> the transform <strong>and</strong> taking the difference. If the input
<code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> is indeed symmetric through the transform, the result will
be a constant valued variable of zero.</dd>
</dl>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
    T_{00} &amp; T_{01} &amp; T_{02} \\
    T_{10} &amp; T_{11} &amp; T_{12} \\
    T_{20} &amp; T_{21} &amp; T_{22}
\end{bmatrix}
*
\begin{bmatrix}
    P_{x} \\
    P_{y} \\
    P_{z}
\end{bmatrix}
=
\begin{bmatrix}
    T_{00}*P_{x}+T_{01}*P_{y}+T_{02}*P_{z} \\
    T_{10}*P_{x}+T_{11}*P_{y}+T_{12}*P_{z} \\
    T_{20}*P_{x}+T_{21}*P_{y}+T_{22}*P_{z}
\end{bmatrix}\end{split}\]</div>
<dl class="docutils" id="eval-point-expression-function">
<dt>Evaluate Point Function: <code class="docutils literal notranslate"><span class="pre">eval_point()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eval_point(&lt;Scalar&gt;,&lt;Fill&gt;,[Px,Py,Pz])</span></code></span></dt>
<dd>Performs only the reflection half of the
<a class="reference internal" href="#symm-point-expression-function"><span class="std std-ref">symm_point()</span></a> operation. That is, it
computes a new <em>scalar</em> variable which is the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> reflected
through the symmetric point. It does not then take the <em>difference</em> between
with the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> as
<a class="reference internal" href="#symm-point-expression-function"><span class="std std-ref">symm_point()</span></a> does.</dd>
</dl>
<dl class="docutils" id="eval-plane-expression-function">
<dt>Evaluate Plane Function: <code class="docutils literal notranslate"><span class="pre">eval_plane()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eval_plane(&lt;Scalar&gt;,&lt;Fill&gt;,[Nx,Ny,Nz,Px,Py,Pz])</span></code></span></dt>
<dd>Performs only the reflection half of the
<a class="reference internal" href="#symm-plane-expression-function"><span class="std std-ref">symm_plane()</span></a> operation. That is, it
computes a new <em>scalar</em> variable which is the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> reflected
through the symmetric plane. It does not then take the <em>difference</em> between
with the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> as
<a class="reference internal" href="#symm-plane-expression-function"><span class="std std-ref">symm_plane()</span></a> does.</dd>
</dl>
<dl class="docutils" id="eval-transform-expression-function">
<dt>Evaluate Transform Function: <code class="docutils literal notranslate"><span class="pre">eval_transform()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">eval_transform(expr0,&lt;Fill&gt;,[T00,T01,T02...T22])</span></code></span></dt>
<dd>Performs only the transform half of the
<a class="reference internal" href="#symm-transform-expression-function"><span class="std std-ref">symm_transform()</span></a> operation.
That is, it computes a new <em>scalar</em> variable which is the input
<code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> mapped through the transform. It does not then take the
<em>difference</em> between with the input <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> as
<a class="reference internal" href="#symm-transform-expression-function"><span class="std std-ref">symm_transform()</span></a> does.</dd>
</dl>
</div>
<div class="section" id="image-processing-expressions">
<h3>8.1.3.11. Image Processing Expressions<a class="headerlink" href="#image-processing-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="conservative-smoothing-expression-function">
<dt>conservative smoothing Function: <code class="docutils literal notranslate"><span class="pre">conservative_smoothing()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">conservative_smoothing(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="mean-filter-expression-function">
<dt>Mean Filter Function: <code class="docutils literal notranslate"><span class="pre">mean_filter()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">mean_filter(&lt;Scalar&gt;,&lt;Int&gt;)</span></code></span></dt>
<dd>Return a filtered version of the input <em>scalar</em> variable using the
mean filter of width specified by <code class="docutils literal notranslate"><span class="pre">&lt;Int&gt;</span></code> argument. By default, the
filter width is 3 (3x3). The input scalar must be defined on a structured
mesh.</dd>
</dl>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last">It is not clear how filtering is handled across different domain
boundaries.</p>
</div>
<dl class="docutils" id="median-filter-expression-function">
<dt>Median Filter Function: <code class="docutils literal notranslate"><span class="pre">median_filter()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">median_filter(expr0)</span></code></span></dt>
<dd>Return a filtered version of the input <em>scalar</em> variable using a
3x3 median filter. The input scalar must be defined on a structured
mesh.</dd>
</dl>
<dl class="docutils" id="abel-inversion-expression-function">
<dt>Abel Inversion Function: <code class="docutils literal notranslate"><span class="pre">abel_inversion()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">abel_inversion(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
</div>
<div class="section" id="miscellaneous-expressions">
<h3>8.1.3.12. Miscellaneous Expressions<a class="headerlink" href="#miscellaneous-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="zonal-constant-expression-function">
<dt>Zonal Constant Function: <code class="docutils literal notranslate"><span class="pre">zonal_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">zonal_constant(expr0)</span></code></span></dt>
<dd>Return a <em>scalar</em>, <a class="reference internal" href="../glossary.html#term-zone-centered"><span class="xref std std-term">zone-centered</span></a> field that is everywhere on
<code class="docutils literal notranslate"><span class="pre">&lt;Mesh&gt;</span></code> the constant value <code class="docutils literal notranslate"><span class="pre">&lt;Const&gt;</span></code>.</dd>
</dl>
<dl class="docutils" id="zone-constant-expression-function">
<dt>Zone Constant Function: <code class="docutils literal notranslate"><span class="pre">zone_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">zone_constant(&lt;Mesh&gt;,&lt;Const&gt;)</span></code></span></dt>
<dd>An alias for <a class="reference internal" href="#zonal-constant-expression-function"><span class="std std-ref">zonal_constant()</span></a></dd>
</dl>
<dl class="docutils" id="cell-constant-expression-function">
<dt>Cell Constant Function: <code class="docutils literal notranslate"><span class="pre">cell_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cell_constant(expr0)</span></code></span></dt>
<dd>An alias for <a class="reference internal" href="#zonal-constant-expression-function"><span class="std std-ref">zonal_constant()</span></a></dd>
</dl>
<dl class="docutils" id="nodal-constant-expression-function">
<dt>Nodal Constant Function: <code class="docutils literal notranslate"><span class="pre">nodal_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">nodal_constant(&lt;Mesh&gt;,&lt;Const&gt;)</span></code></span></dt>
<dd>Return a <em>scalar</em>, <a class="reference internal" href="../glossary.html#term-node-centered"><span class="xref std std-term">node-centered</span></a> field that is everywhere on
<code class="docutils literal notranslate"><span class="pre">&lt;Mesh&gt;</span></code> the constant value <code class="docutils literal notranslate"><span class="pre">&lt;Const&gt;</span></code>.</dd>
</dl>
<dl class="docutils" id="node-constant-expression-function">
<dt>Node Constant Function: <code class="docutils literal notranslate"><span class="pre">node_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">node_constant(expr0)</span></code></span></dt>
<dd>An alias for <a class="reference internal" href="#nodal-constant-expression-function"><span class="std std-ref">nodal_constant()</span></a></dd>
</dl>
<dl class="docutils" id="point-constant-expression-function">
<dt>Point Constant Function: <code class="docutils literal notranslate"><span class="pre">point_constant()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">point_constant(expr0)</span></code></span></dt>
<dd>An alias for <a class="reference internal" href="#nodal-constant-expression-function"><span class="std std-ref">nodal_constant()</span></a></dd>
</dl>
<dl class="docutils" id="time-expression-function">
<dt>Time Function: <code class="docutils literal notranslate"><span class="pre">time()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">time(expr0)</span></code></span></dt>
<dd>Return a <em>constant scalar</em> variable which is everywhere the time
of the associated input argument within its time-series.</dd>
</dl>
<dl class="docutils" id="cycle-expression-function">
<dt>Cycle Function: <code class="docutils literal notranslate"><span class="pre">cycle()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cycle(expr0)</span></code></span></dt>
<dd>Return an integer <em>constant scalar</em> variable which is everywhere the cycle
of the associated input argument within its time-series.</dd>
</dl>
<dl class="docutils" id="timestep-expression-function">
<dt>Timestep Function: <code class="docutils literal notranslate"><span class="pre">timestep()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">timestep(expr0)</span></code></span></dt>
<dd>Return an integer <em>constant scalar</em> variable which is everywhere the index
of the associated input argument within its time-series.</dd>
</dl>
<dl class="docutils" id="curve-domain-expression-function">
<dt>curve domain Function: <code class="docutils literal notranslate"><span class="pre">curve_domain()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curve_domain(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="curve-integrate-expression-function">
<dt>curve integrate Function: <code class="docutils literal notranslate"><span class="pre">curve_integrate()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curve_integrate(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="curve-swapxy-expression-function">
<dt>curve swapxy Function: <code class="docutils literal notranslate"><span class="pre">curve_swapxy()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curve_swapxy(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="curve-expression-function">
<dt>curve Function: <code class="docutils literal notranslate"><span class="pre">curve()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">curve(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="enumerate-expression-function">
<dt>Enumerate Function: <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">enumerate(&lt;Int-Scalar&gt;,&lt;[Int-List]&gt;)</span></code></span></dt>
<dd>Map an integer valued <em>scalar</em> variable to a new set of integer values.
If <em>K</em> is the maximum value in the <code class="docutils literal notranslate"><span class="pre">Int-Scalar</span></code> input argument,
the <code class="docutils literal notranslate"><span class="pre">[Int-List]</span></code> argument must be a square bracketed list of <em>K+1</em>
integer values. Value <em>i</em> in the <code class="docutils literal notranslate"><span class="pre">Int-Scalar</span></code> input argument is used to
index the <em>ith</em> entry in the <code class="docutils literal notranslate"><span class="pre">[Int-List]</span></code> to produce mapped value.</dd>
</dl>
<dl class="docutils" id="map-expression-function">
<dt>Map Function: <code class="docutils literal notranslate"><span class="pre">map()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">map(&lt;Scalar&gt;,&lt;[Input-Value-List]&gt;,&lt;[Output-Value-List]&gt;)</span></code></span></dt>
<dd>A more general form of <a class="reference internal" href="#enumerate-expression-function"><span class="std std-ref">enumerate()</span></a>
which supports non-integer input <em>scalar</em> variables and input and output
maps which are not required to include all values in the input <em>scalar</em>
variable. The <code class="docutils literal notranslate"><span class="pre">[Input-Value-List]</span></code> and <code class="docutils literal notranslate"><span class="pre">[Output-Value-List]</span></code> must have
the same number of entries. A value in the input <em>scalar</em> variable that
matches the <em>ith</em> entry in the <code class="docutils literal notranslate"><span class="pre">[Input-Value-List]</span></code> is mapped to the new
value at the <em>ith</em> entry in the <code class="docutils literal notranslate"><span class="pre">[Output-Value-List]</span></code>. Values that do not
match any entry in the <code class="docutils literal notranslate"><span class="pre">[Input-Value-List]</span></code> are mapped to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</dd>
</dl>
<dl class="docutils" id="resample-expression-function">
<dt>Resample Function: <code class="docutils literal notranslate"><span class="pre">resample()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">resample(&lt;Var&gt;,Nx,Ny,Nz)</span></code></span></dt>
<dd>Resample <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> onto a regular grid defined by taking the
X, Y and for 3D, Z spatial extents of the mesh <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> is defined on and
taking <code class="docutils literal notranslate"><span class="pre">Nx</span></code> samples over the spatial extents in X,
<code class="docutils literal notranslate"><span class="pre">Ny</span></code> samples over the spatial extents in Y, and, for 3D,
<code class="docutils literal notranslate"><span class="pre">Nz</span></code> samples over the spatial extents in Z.
Any samples that <em>miss</em> the mesh <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> is defined on are assigned
the value <code class="docutils literal notranslate"><span class="pre">-FLT_MAX</span></code>. For 2D, the <code class="docutils literal notranslate"><span class="pre">Nz</span></code> argument is still required but
ignored.</dd>
</dl>
<dl class="docutils" id="recenter-expression-function">
<dt>Recenter Expression Function <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">recenter(expr,</span> <span class="pre">[&quot;nodal&quot;,</span> <span class="pre">&quot;zonal&quot;,</span> <span class="pre">&quot;toggle&quot;])</span></code></span></dt>
<dd>This function can be used to recenter <code class="docutils literal notranslate"><span class="pre">expr</span></code>. The second argument is
optional and defaults to <em>“toggle”</em> if it is not specified. A value of
<em>“toggle”</em> for the second argument means that if <code class="docutils literal notranslate"><span class="pre">expr</span></code> is <em>node</em>
centered, it is recentered to <em>zone</em> centering and if <code class="docutils literal notranslate"><span class="pre">expr</span></code> is
<em>zone</em> centered, it is recentered to <em>node</em> centering. Note that the
quotes are required for the second argument. This function is typically
used to force a specific centering among the operands of some other
expression.</dd>
</dl>
<dl class="docutils" id="procid-expression-function">
<dt>Process Id Function: <code class="docutils literal notranslate"><span class="pre">procid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">procid(&lt;Var&gt;)</span></code></span></dt>
<dd>Return an integer <em>scalar</em> variable which is everywhere the MPI rank
associated with each of the blocks of the possibly parallel decomposed mesh
upon which <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> is defined. For serial execution or for parallel
execution of a single-block mesh, this will produce a constant zero
variable. Otherwise, the values will vary block by block.</dd>
</dl>
<dl class="docutils" id="threadid-expression-function">
<dt>Thread Id Function: <code class="docutils literal notranslate"><span class="pre">threadid()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">threadid(expr0)</span></code></span></dt>
<dd>Return an integer <em>scalar</em> variable which is everywhere the local thread id
associated with each of the blocks of the possibly parallel decomposed mesh
upon which <code class="docutils literal notranslate"><span class="pre">&lt;Var&gt;</span></code> is defined. For non-threaded execution, this will
produce a constant zero variable. Otherwise, the values will vary block
by block.</dd>
</dl>
<dl class="docutils" id="isnan-expression-function">
<dt>isnan Function: <code class="docutils literal notranslate"><span class="pre">isnan()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">isnan(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="q-criterion-expression-function">
<dt>q criterion Function: <code class="docutils literal notranslate"><span class="pre">q_criterion()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">q_criterion(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="lambda2-expression-function">
<dt>lambda2 Function: <code class="docutils literal notranslate"><span class="pre">lambda2()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">lambda2(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="mean-curvature-expression-function">
<dt>mean curvature Function: <code class="docutils literal notranslate"><span class="pre">mean_curvature()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">mean_curvature(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="gauss-curvature-expression-function">
<dt>Gauss Curvature Function: <code class="docutils literal notranslate"><span class="pre">gauss_curvature()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">gauss_curvature(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="agrad-expression-function">
<dt>agrad Function: <code class="docutils literal notranslate"><span class="pre">agrad()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">agrad(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="key-aggregate-expression-function">
<dt>key aggregate Function: <code class="docutils literal notranslate"><span class="pre">key_aggregate()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">key_aggregate(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="laplacian-expression-function">
<dt>Laplacian Function: <code class="docutils literal notranslate"><span class="pre">laplacian()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">laplacian(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="rectilinear-laplacian-expression-function">
<dt>rectilinear Laplacian Function: <code class="docutils literal notranslate"><span class="pre">rectilinear_laplacian()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">rectilinear_laplacian(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="conn-components-expression-function">
<dt>conn components Function: <code class="docutils literal notranslate"><span class="pre">conn_components()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">conn_components(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="resrad-expression-function">
<dt>resrad Function: <code class="docutils literal notranslate"><span class="pre">resrad()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">resrad(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
</div>
<div class="section" id="time-iteration-expressions">
<h3>8.1.3.13. Time Iteration Expressions<a class="headerlink" href="#time-iteration-expressions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils" id="average-over-time-expression-function">
<dt>Average Over Time Function: <code class="docutils literal notranslate"><span class="pre">average_over_time()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">average_over_time(&lt;Scalar&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
average over the times indicated by <code class="docutils literal notranslate"><span class="pre">Start</span></code>, <code class="docutils literal notranslate"><span class="pre">Stop</span></code> and <code class="docutils literal notranslate"><span class="pre">Stride</span></code>.</dd>
</dl>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last">How does this work with changing topology?
Also, what is the actual math of the average? Is it an update algorithm or a sum and then
division by number of iterations?</p>
</div>
<dl class="docutils" id="min-over-time-expression-function">
<dt>Min Over Time Function: <code class="docutils literal notranslate"><span class="pre">min_over_time()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">min_over_time(&lt;Scalar&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
minimum value the variable, <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code>, attained over the times indicated
by <code class="docutils literal notranslate"><span class="pre">Start</span></code>, <code class="docutils literal notranslate"><span class="pre">Stop</span></code> and <code class="docutils literal notranslate"><span class="pre">Stride</span></code>.</dd>
</dl>
<dl class="docutils" id="max-over-time-expression-function">
<dt>Max Over Time Function: <code class="docutils literal notranslate"><span class="pre">max_over_time()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">max_over_time(&lt;Scalar&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
maximum value the variable, <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code>, attains over the times indicated
by <code class="docutils literal notranslate"><span class="pre">Start</span></code>, <code class="docutils literal notranslate"><span class="pre">Stop</span></code> and <code class="docutils literal notranslate"><span class="pre">Stride</span></code>.</dd>
</dl>
<dl class="docutils" id="sum-over-time-expression-function">
<dt>Sum Over Time Function: <code class="docutils literal notranslate"><span class="pre">sum_over_time()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">sum_over_time(&lt;Scalar&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
sum of the values the variable, <code class="docutils literal notranslate"><span class="pre">&lt;Scalar&gt;</span></code> attains over the times
indicated by <code class="docutils literal notranslate"><span class="pre">Start</span></code>, <code class="docutils literal notranslate"><span class="pre">Stop</span></code> and <code class="docutils literal notranslate"><span class="pre">Stride</span></code>.</dd>
</dl>
<dl class="docutils" id="first-time-when-condition-is-true-expression-function">
<dt>First Time When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">first_time_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">first_time_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
<em>first</em> time (not cycle and not time-index, but floating point time) at which
the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value is used
if there is no <em>first</em> time the condition is true.</dd>
</dl>
<dl class="docutils" id="last-time-when-condition-is-true-expression-function">
<dt>Last Time When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">last_time_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">last_time_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new <em>scalar</em> variable in which each zonal or nodal value is the
<em>last</em> time (not cycle and not time-index, but floating point time) at which
the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value is used
if there is no <em>last</em> time the condition is true.</dd>
</dl>
<dl class="docutils" id="first-cycle-when-condition-is-true-expression-function">
<dt>First Cycle When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">first_cycle_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">first_cycle_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new integer valued <em>scalar</em> variable in which each zonal or nodal
value is the <em>first</em> cycle (not time and not time-index, but integer cycle)
at which the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value
is used if there is no <em>first</em> cycle the condition is true.</dd>
</dl>
<dl class="docutils" id="last-cycle-when-condition-is-true-expression-function">
<dt>Last Cycle When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">last_cycle_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">last_cycle_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new integer valued <em>scalar</em> variable in which each zonal or nodal
value is the <em>last</em> cycle (not time and not time-index, but integer cycle)
at which the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true. The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value
is used if there is no <em>last</em> cycle the condition is true.</dd>
</dl>
<dl class="docutils" id="first-time-index-when-condition-is-true-expression-function">
<dt>First Time Index When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">first_time_index_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">first_time_index_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new integer valued <em>scalar</em> variable in which each zonal or nodal
value is the <em>first</em> time index (not cycle and not time, but integer
time-index) at which the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true.
The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value is used if there is no <em>first</em> time-index the
condition is true.</dd>
</dl>
<dl class="docutils" id="last-time-index-when-condition-is-true-expression-function">
<dt>Last Time Index When Condition Is True Function: <code class="docutils literal notranslate"><span class="pre">last_time_index_when_condition_is_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">last_time_index_when_condition_is_true(&lt;Cond&gt;,&lt;Fill&gt;,&lt;Start&gt;,&lt;Stop&gt;,&lt;Stride&gt;)</span></code></span></dt>
<dd>Return a new integer valued <em>scalar</em> variable in which each zonal or nodal
value is the <em>last</em> time index (not cycle and not time, but integer
time-index) at which the true/false condition, <code class="docutils literal notranslate"><span class="pre">&lt;Cond&gt;</span></code> is true.
The <code class="docutils literal notranslate"><span class="pre">&lt;Fill&gt;</span></code> value is used if there is no <em>last</em> time-index the
condition is true.</dd>
</dl>
<dl class="docutils" id="var-when-condition-is-first-true-expression-function">
<dt>var when condition is first true Function: <code class="docutils literal notranslate"><span class="pre">var_when_condition_is_first_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">var_when_condition_is_first_true(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="var-when-condition-is-last-true-expression-function">
<dt>var when condition is last true Function: <code class="docutils literal notranslate"><span class="pre">var_when_condition_is_last_true()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">var_when_condition_is_last_true(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="time-at-minimum-expression-function">
<dt>time at minimum Function: <code class="docutils literal notranslate"><span class="pre">time_at_minimum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">time_at_minimum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="cycle-at-minimum-expression-function">
<dt>cycle at minimum Function: <code class="docutils literal notranslate"><span class="pre">cycle_at_minimum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cycle_at_minimum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="time-index-at-minimum-expression-function">
<dt>time index at minimum Function: <code class="docutils literal notranslate"><span class="pre">time_index_at_minimum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">time_index_at_minimum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="value-at-minimum-expression-function">
<dt>value at minimum Function: <code class="docutils literal notranslate"><span class="pre">value_at_minimum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">value_at_minimum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="time-at-maximum-expression-function">
<dt>time at maximum Function: <code class="docutils literal notranslate"><span class="pre">time_at_maximum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">time_at_maximum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="cycle-at-maximum-expression-function">
<dt>cycle at maximum Function: <code class="docutils literal notranslate"><span class="pre">cycle_at_maximum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">cycle_at_maximum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="time-index-at-maximum-expression-function">
<dt>time index at maximum Function: <code class="docutils literal notranslate"><span class="pre">time_index_at_maximum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">time_index_at_maximum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="value-at-maximum-expression-function">
<dt>value at maximum Function: <code class="docutils literal notranslate"><span class="pre">value_at_maximum()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">value_at_maximum(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="localized-compactness-expression-function">
<dt>localized compactness Function: <code class="docutils literal notranslate"><span class="pre">localized_compactness()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">localized_compactness(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="merge-tree-expression-function">
<dt>merge tree Function: <code class="docutils literal notranslate"><span class="pre">merge_tree()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">merge_tree(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="split-tree-expression-function">
<dt>split tree Function: <code class="docutils literal notranslate"><span class="pre">split_tree()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">split_tree(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="local-threshold-expression-function">
<dt>local threshold Function: <code class="docutils literal notranslate"><span class="pre">local_threshold()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">local_threshold(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="python-expression-function">
<dt>python Function: <code class="docutils literal notranslate"><span class="pre">python()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">python(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="relative-difference-expression-function">
<dt>relative difference Function: <code class="docutils literal notranslate"><span class="pre">relative_difference()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">relative_difference(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="var-skew-expression-function">
<dt>var skew Function: <code class="docutils literal notranslate"><span class="pre">var_skew()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">var_skew(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="apply-data-binning-expression-function">
<dt>apply data binning Function: <code class="docutils literal notranslate"><span class="pre">apply_data_binning()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">apply_data_binning(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="distance-to-best-fit-line-expression-function">
<dt>distance to best fit line Function: <code class="docutils literal notranslate"><span class="pre">distance_to_best_fit_line()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">distance_to_best_fit_line(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="distance-to-best-fit-line2-expression-function">
<dt>distance to best fit line2 Function: <code class="docutils literal notranslate"><span class="pre">distance_to_best_fit_line2()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">distance_to_best_fit_line2(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="geodesic-vector-quantize-expression-function">
<dt>geodesic vector quantize Function: <code class="docutils literal notranslate"><span class="pre">geodesic_vector_quantize()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">geodesic_vector_quantize(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="bin-expression-function">
<dt>bin Function: <code class="docutils literal notranslate"><span class="pre">bin()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">bin(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="biggest-neighbor-expression-function">
<dt>biggest neighbor Function: <code class="docutils literal notranslate"><span class="pre">biggest_neighbor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">biggest_neighbor(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="smallest-neighbor-expression-function">
<dt>smallest neighbor Function: <code class="docutils literal notranslate"><span class="pre">smallest_neighbor()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">smallest_neighbor(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="neighbor-average-expression-function">
<dt>neighbor average Function: <code class="docutils literal notranslate"><span class="pre">neighbor_average()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">neighbor_average(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
<dl class="docutils" id="displacement-expression-function">
<dt>Displacement Function: <code class="docutils literal notranslate"><span class="pre">displacement()</span></code> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">displacement(expr0)</span></code></span></dt>
<dd>No description available.</dd>
</dl>
</div>
</div>
<div class="section" id="expression-compatibility-gotchas">
<h2>8.1.4. Expression Compatibility Gotchas<a class="headerlink" href="#expression-compatibility-gotchas" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://visit.llnl.gov">VisIt</a> will allow you to define expressions that it winds up determining to be
invalid later when it attempts to execute those expressions. Some common
issues are the mixing of incompatible mesh variables in the same expression
<em>without</em> the necessary additional functions to make them compatible.</p>
<div class="section" id="tensor-rank-compatibility">
<h3>8.1.4.1. Tensor Rank Compatibility<a class="headerlink" href="#tensor-rank-compatibility" title="Permalink to this headline">¶</a></h3>
<p>For example, what happens if you mix scalar and vector mesh variables in the
same expression? <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will allow users to define such an expression. But, when
it is plotted, the plot will fail.</p>
<p>As an aside, as the user goes back and forth between the Expressions window
creating and/or adjusting expression definitions, <a class="reference external" href="https://visit.llnl.gov">VisIt</a> makes no attempt to
keep track of all the changes made in expressions and automatically update
plots as expressions change. Users have to manually clear or delete plots to
force <a class="reference external" href="https://visit.llnl.gov">VisIt</a> to re-draw plots in which the expressions changed.</p>
<p>If what is really intended was a scalar mesh variable, then users must use
one of the expression functions that converts a vector to a scalar such as
the magnitude() built-in expression or the array de-reference operator.</p>
</div>
<div class="section" id="centering-compatibility">
<h3>8.1.4.2. Centering Compatibility<a class="headerlink" href="#centering-compatibility" title="Permalink to this headline">¶</a></h3>
<p>Some variables are zone centered and some are node centered. What happens if
a user combines these in an expression? <a class="reference external" href="https://visit.llnl.gov">VisIt</a> will default to zone centering
for the result. If this is not the desired result, the
<a class="reference internal" href="#recenter-expression-function"><span class="std std-ref">recenter()</span></a> expression function should be
used, where appropriate, to adjust centering of some of the
terms in the expression.  Note that ordering of operations will probably be
important. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">node_var</span> <span class="o">+</span> <span class="n">recenter</span><span class="p">(</span><span class="n">zone_var</span><span class="p">)</span>
<span class="n">recenter</span><span class="p">(</span><span class="n">zone_var</span> <span class="o">+</span> <span class="n">node_var</span><span class="p">)</span>
</pre></div>
</div>
<p>both achieve a <a class="reference internal" href="../glossary.html#term-node-centered"><span class="xref std std-term">node-centered</span></a> result. But, each expression is subtly
(and numerically) different. The first recenter’s <cite>zone_var</cite> to the
nodes and then performs the summation operator at each node. In the
second, there is an implied recentering of <cite>node_var</cite> to the zones first. Then,
the summation operator is applied at each zone center and finally the results
are recentered back to the nodes. In all likelihood this creates in a
numerically lower quality result. The moral is that in a complex series of
expressions be sure to take care where you want recentering to occur.</p>
</div>
<div class="section" id="mesh-compatibility">
<h3>8.1.4.3. Mesh Compatibility<a class="headerlink" href="#mesh-compatibility" title="Permalink to this headline">¶</a></h3>
<p>In many cases, especially in Silo databases, all the available variables in a
database are not always defined on the same mesh. This can complicate matters
involving expressions in variables from different meshes.</p>
<p>Just as in the previous two examples of incompatible variables where the
solution was to apply some function to make the variables compatible, we have
to do the same thing when variables from different meshes are combined in an
expression. The key expression functions which enable this are called
<strong>Cross Mesh Field Evaluation</strong> or <strong>CMFE</strong> expression functions. We will only
briefly touch on these here. <strong>CMFEs</strong> will be discussed in much greater detail
elsewhere.</p>
<p>Just as for centering, we have two options when dealing with variables from
two different meshes. Each of which involves <em>mapping</em> one of the variables
onto the other variable’s mesh using one of the CMFE expression functions.</p>
</div>
</div>
<div class="section" id="automatic-expressions">
<h2>8.1.5. Automatic expressions<a class="headerlink" href="#automatic-expressions" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Query.html" class="btn btn-neutral float-right" title="8.2. Query" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="8. Quantitative Analysis" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2008-2019, LLNL, UCRL-SM-220449.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'2.11',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>