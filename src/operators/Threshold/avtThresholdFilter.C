// ************************************************************************* //
//  File: avtThresholdFilter.C
// ************************************************************************* //

#include <avtThresholdFilter.h>

#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkThreshold.h>
#include <vtkUnstructuredGrid.h>

#include <avtIntervalTree.h>
#include <avtMetaData.h>
#include <avtStructuredMeshChunker.h>

#include <DebugStream.h>
#include <ImproperUseException.h>
#include <NoDefaultVariableException.h>


// ****************************************************************************
//  Method: avtThreshold constructor
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//     
//  Modifications:
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Don't initialize data members that have now been pushed into the base
//    class.
//
// ****************************************************************************

avtThresholdFilter::avtThresholdFilter()
{
    ;
}


// ****************************************************************************
//  Method:  avtThresholdFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

avtFilter *
avtThresholdFilter::Create()
{
    return new avtThresholdFilter();
}


// ****************************************************************************
//  Method:      avtThresholdFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Register the active variable.
//
// ****************************************************************************

void
avtThresholdFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ThresholdAttributes*)a;

    // We need to specify that we want a secondary variable as soon as 
    // possible.
    if (strcmp(atts.GetVariable().c_str(), "default") != 0)
    {
        SetActiveVariable(atts.GetVariable().c_str());
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtThresholdFilter with the given
//      parameters would result in an equivalent avtThresholdFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

bool
avtThresholdFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ThresholdAttributes*)a);
}


// ****************************************************************************
//  Function: UpdateNeighborCells
//
//  Purpose:
//      Updates cells that are neighbors to a point with a value.
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//
// ****************************************************************************

static void UpdateNeighborCells(int pt, const int *pt_dims,
           avtStructuredMeshChunker::ZoneDesignation d,
           std::vector<avtStructuredMeshChunker::ZoneDesignation> &designation)
{
    int I = pt % pt_dims[0];
    int J = (pt / pt_dims[0]) % pt_dims[1];
    int K = pt / (pt_dims[0]*pt_dims[1]);

    for (int i = 0 ; i < 8 ; i++)
    {
        int sI = I - (i & 1 ? 1 : 0);
        int sJ = J - (i & 2 ? 1 : 0);
        int sK = K - (i & 4 ? 1 : 0);
        if (sI < 0)
            continue;
        if (sI >= (pt_dims[0]-1))
            continue;
        if (sJ < 0)
            continue;
        if (sJ >= (pt_dims[1]-1))
            continue;
        if (sK < 0)
            continue;
        if (sK >= (pt_dims[2]-1))
            continue;

        int cell = sK*(pt_dims[0]-1)*(pt_dims[1]-1) + sJ*(pt_dims[0]-1) + sI;
        designation[cell] = d;
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ProcessOneChunk
//
//  Purpose:
//      Sends the specified input and output through the Threshold filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Removed references to active variables.
//
//    Hank Childs, Tue Oct 30 09:29:13 PST 2001
//    Account for cases when we are not switching active variables.
//
//    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray instead.
//
//    Hank Childs, Tue Sep 10 18:29:14 PDT 2002
//    Make memory management be self-contained in this routine.
//
//    Hank Childs, Sat Jun 21 09:25:34 PDT 2003
//    If we have poly data input, then we should have poly data output.
//
//    Hank Childs, Fri May  7 08:33:17 PDT 2004
//    If the variable is not a scalar, then issue a warning.
//
//    Hank Childs, Thu Jul 29 09:43:58 PDT 2004
//    Do not convert output to poly-data, since the base class will now
//    take care of this (when appropriate).
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Use a structured mesh chunker if appropriate.
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Renamed to ProcessOneChunk.  Modified to assume structured chunking.
//
//    Hank Childs, Sun Apr  3 13:06:01 PDT 2005
//    Fix bug with structured chunking.
//
//    Hank Childs, Tue Sep 13 09:03:12 PDT 2005
//    Add support for "PointsOnly".
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ProcessOneChunk(vtkDataSet *in_ds, int domain,
                                    std::string label, bool fromChunker)
{
    if (atts.GetAmount() == ThresholdAttributes::PointsOnly)
    {
        return ThresholdToPointMesh(in_ds);
    }

    if (fromChunker)
    {
        //
        // If in_ds is from the chunker, then the zones in in_ds are all
        // ones we identified that we wanted.  So just return them.
        //
        in_ds->Register(NULL);
        return in_ds;
    }

    vtkThreshold *threshold = vtkThreshold::New();

    //
    // Set up the threshold filter from the attributes.
    //
    threshold->SetInput(in_ds);
    threshold->SetAttributeModeToDefault();
    if (atts.GetAmount() == ThresholdAttributes::Some)
    {
        threshold->AllScalarsOff();
    }
    else if (atts.GetAmount() == ThresholdAttributes::All)
    {
        threshold->AllScalarsOn();
    }
    else
    {
        debug1 << "No good option for threshold attributes for what amount"
               << " to restrict by." << endl;
        threshold->AllScalarsOff();
    }
    threshold->ThresholdBetween(atts.GetLbound(), atts.GetUbound());

    bool usePointData = false;
    if (switchVariables)
    {
        usePointData = activeVariableIsPointData;
    }
    else
    {
        vtkDataArray *s = in_ds->GetPointData()->GetScalars();
        usePointData = (s != NULL ? true : false);
    }
    if (usePointData)
    {
        threshold->SetAttributeModeToUsePointData();
    }
    else
    {
        threshold->SetAttributeModeToUseCellData();
    }
    
    vtkDataSet *out_ds = threshold->GetOutput();
    out_ds->Update();

    if (out_ds->GetNumberOfCells() <= 0)
    {
        out_ds = NULL;
    }
    else
    {
        out_ds->Register(NULL);  // Caller will free.
    }

    threshold->Delete();

    return out_ds;
}


// ****************************************************************************
//  Method: avtThresholdFilter::GetAssignments
//
//  Purpose:
//      Gets the assignments for each zone.
//
//  Programmer: Hank Childs
//  Creation:   March 27, 2005
//
// ****************************************************************************

void
avtThresholdFilter::GetAssignments(vtkDataSet *in_ds, const int *dims,
                     std::vector<avtStructuredMeshChunker::ZoneDesignation> &d)
{
    bool isPoint = false;
    vtkDataArray *arr = GetThresholdVariable(in_ds, isPoint);

    //
    // Determine which zones we want to retain and which we want to
    // discard.
    //
    int ncells = in_ds->GetNumberOfCells();
    int npts = in_ds->GetNumberOfPoints();
    float *p = (float *) arr->GetVoidPointer(0);
    if (isPoint)
    {
        int  i;
        float lbound = atts.GetLbound();
        float ubound = atts.GetUbound();

        if (atts.GetAmount() == ThresholdAttributes::Some)
        {
            for (i = 0 ; i < ncells ; i++)
                d[i] = avtStructuredMeshChunker::DISCARD;
            for (i = 0 ; i < npts ; i++)
            {
                bool pointInThreshold = (p[i] >= lbound && p[i] <= ubound);
                if (pointInThreshold)
                    UpdateNeighborCells(i, dims, 
                                        avtStructuredMeshChunker::RETAIN, d);
            }
        }
        else
        {
            for (i = 0 ; i < ncells ; i++)
                d[i] = avtStructuredMeshChunker::RETAIN;
            for (i = 0 ; i < npts ; i++)
            {
                bool pointOutsideThreshold = (p[i]<lbound || p[i]>ubound);
                if (pointOutsideThreshold)
                    UpdateNeighborCells(i, dims, 
                                        avtStructuredMeshChunker::DISCARD, d);
            }
        }
    }
    else
    {
        float lbound = atts.GetLbound();
        float ubound = atts.GetUbound();
        for (int i = 0 ; i < ncells ; i++)
        {
            d[i] = (p[i] >= lbound && p[i] <= ubound 
                    ? avtStructuredMeshChunker::RETAIN 
                    : avtStructuredMeshChunker::DISCARD);
        }
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ThresholdToPointMesh
//
//  Purpose:
//      Does a threshold on a nodal quantity and then creates a point mesh.
//
//  Programmer: Hank Childs
//  Creation:   September 13, 2005
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ThresholdToPointMesh(vtkDataSet *in_ds)
{
    bool isNodal;
    vtkDataArray *var = GetThresholdVariable(in_ds, isNodal);
    if (!isNodal)
    {
        EXCEPTION1(VisItException, "You can only threshold with this method "
                   "with nodal quantities");
    }

    int numMatching = 0;
    int numPts = in_ds->GetNumberOfPoints();
    float lbound = atts.GetLbound();
    float ubound = atts.GetUbound();
    int i;
    for (i = 0 ; i < numPts ; i++)
    {
        float val = var->GetTuple1(i);
        if (val >= lbound && val <= ubound)
            numMatching++;
    }

    if (numMatching == 0)
        return NULL;

    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
    vtkPoints *pts = vtkPoints::New();
    pts->SetNumberOfPoints(numMatching);
    ugrid->SetPoints(pts);
    ugrid->Allocate(2*numMatching);
    vtkPointData *inPD = in_ds->GetPointData();
    vtkPointData *outPD = ugrid->GetPointData();
    outPD->CopyAllocate(inPD, numMatching);
    pts->Delete();

    int newId = 0;
    vtkIdType onevertex[1];
    for (i = 0 ; i < numPts ; i++)
    {
        float val = var->GetTuple1(i);
        if (val >= lbound && val <= ubound)
        {
            outPD->CopyData(inPD, i, newId);
            double pt[3];
            in_ds->GetPoint(i, pt);
            pts->SetPoint(newId, pt);
            onevertex[0] = newId;
            ugrid->InsertNextCell(VTK_VERTEX, 1, onevertex);
            newId++;
        }
    }

    // Caller will free.
    return ugrid;
}


// ****************************************************************************
//  Method: avtThresholdFilter::GetThresholdVariable
//
//  Purpose:
//      Gets the variable that we should threshold by and performs some sanity
//      checks.
//
//  Programmer: Hank Childs
//  Creation:   March 27, 2005
//
// ****************************************************************************

vtkDataArray *
avtThresholdFilter::GetThresholdVariable(vtkDataSet *in_ds, bool &isPoint)
{
    //
    // Confirm that we got a variable that we can threshold by.
    //
    string v1 = atts.GetVariable();
    string thres_var;
    if (v1 == "default")
        thres_var = pipelineVariable;
    else
        thres_var = v1;
    isPoint = true;
    vtkDataArray *arr = in_ds->GetPointData()->GetArray(thres_var.c_str());
    if (arr == NULL)
    {
        arr = in_ds->GetCellData()->GetArray(thres_var.c_str());
        isPoint = false;
    }
    if (arr == NULL)
    {
        char str[1024];
        sprintf(str, "The threshold operator was not applied because the "
                "variable \"%s\" could not be located.", thres_var.c_str());
        EXCEPTION1(VisItException, str);
    }
    if (arr->GetNumberOfComponents() != 1)
    {
        char str[1024];
        sprintf(str, "The threshold operator was not applied because the "
                "variable \"%s\" is not a scalar.", thres_var.c_str());
        EXCEPTION1(VisItException, str);
    }

    return arr;
}


// ****************************************************************************
//  Method: avtThresholdFilter::RefashionDataObjectInfo
//
//  Purpose:
//      Indicates the zones no longer correspond to the original problem.
//
//  Programmer: Hank Childs
//  Creation:   October 23, 2001
//
//  Modifications:
//
//    Hank Childs, Tue Sep 13 09:07:05 PDT 2005
//    Add support for "PointsOnly".
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Set OrigElementsRequiredForPick. 
//
// ****************************************************************************

void
avtThresholdFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().InvalidateZones();
    if (atts.GetAmount() == ThresholdAttributes::PointsOnly)
    {
        GetOutput()->GetInfo().GetAttributes().SetTopologicalDimension(0);
    }
    GetOutput()->GetInfo().GetAttributes().SetOrigElementsRequiredForPick(true);
}


// ****************************************************************************
//  Method: avtThresholdFilter::PreExecute
//
//  Purpose:
//      Determine if there is a "default" variable to work with.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Aug 29 08:12:22 PDT 2002
//    If the variable was not the 'default' variable, the test was sometimes
//    wrong.
//
//    Hank Childs, Sat Mar 19 10:29:37 PST 2005
//    Initialize chunkedStructuredMesh.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved chunkedStructuredMesh to base class.
//
// ****************************************************************************

void
avtThresholdFilter::PreExecute(void)
{
    avtPluginStructuredChunkStreamer::PreExecute();

    if (atts.GetVariable() == "default" &&
        GetInput()->GetInfo().GetAttributes().GetVariableName() == "<unknown>")
    {
        //
        // Somehow the variable we asked for didn't make it down far enough.
        // This often happens when we are doing a plot that doesn't have a
        // variable (say a material plot) and then we apply the threshold
        // operator.
        //
        EXCEPTION1(NoDefaultVariableException, "Threshold");
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::PerformRestriction
//
//  Purpose:
//      Restrict the data processed by looking at the data extents.
//
//  Programmer: Hank Childs
//  Creation:   May 14, 2003
//
//  Modifications:
//
//    Mark C. Miller, Mon Oct 18 13:02:37 PDT 2004
//    Added code to pass variable name in call to GetDataExtents
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Initialize data members for structured mesh chunking.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved data members for structured mesh chunking to base class.
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Turn on Node & Zone numbers when appropriate. 
//
// ****************************************************************************

avtPipelineSpecification_p
avtThresholdFilter::PerformRestriction(avtPipelineSpecification_p in_spec)
{
    string thres_var = atts.GetVariable();
    if (thres_var == "default")
        thres_var = in_spec->GetDataSpecification()->GetVariable();

    avtIntervalTree *it = GetMetaData()->GetDataExtents(thres_var.c_str());
    if (it == NULL)
    {
        if (in_spec->GetDataSpecification()->MayRequireZones() ||
            in_spec->GetDataSpecification()->MayRequireNodes())
        {
            // Turn on both Nodes and Zones, to prevent another re-execution if
            // user switches between zone and node pick.
            in_spec->GetDataSpecification()->TurnZoneNumbersOn();
            in_spec->GetDataSpecification()->TurnNodeNumbersOn();
        }
        return in_spec;
    }

    avtPipelineSpecification_p spec = new avtPipelineSpecification(in_spec);
    double min = atts.GetLbound();
    double max = atts.GetUbound();
    vector<int> dl;
    it->GetDomainsListFromRange(&min, &max, dl);
    spec->GetDataSpecification()->GetRestriction()->RestrictDomains(dl);

    if (spec->GetDataSpecification()->MayRequireZones() ||
        spec->GetDataSpecification()->MayRequireNodes())
    {
        // Turn on both Nodes and Zones, to prevent another re-execution if
        // user switches between zone and node pick.
        spec->GetDataSpecification()->TurnZoneNumbersOn();
        spec->GetDataSpecification()->TurnNodeNumbersOn();
    }

    return spec;
}


