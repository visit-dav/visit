/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtThresholdFilter.C
// ************************************************************************* //

#include <avtThresholdFilter.h>

#include <vtkDataSet.h>
#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkDataArray.h>
#include <vtkDataObject.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkThreshold.h>
#include <vtkUnstructuredGrid.h>

#include <avtIntervalTree.h>
#include <avtMetaData.h>
#include <avtStructuredMeshChunker.h>

#include <DebugStream.h>
#include <ImproperUseException.h>
#include <NoDefaultVariableException.h>


// ****************************************************************************
//  Method: avtThreshold constructor
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//     
//  Modifications:
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Don't initialize data members that have now been pushed into the base
//    class.
//
// ****************************************************************************

avtThresholdFilter::avtThresholdFilter()
{
    ;
}


// ****************************************************************************
//  Method:  avtThresholdFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

avtFilter *
avtThresholdFilter::Create()
{
    return new avtThresholdFilter();
}


// ****************************************************************************
//  Method:      avtThresholdFilter::SetAtts
//
//  Purpose: Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Register the active variable.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    No longer recognizes the "default" variable.
//
// ****************************************************************************

void
avtThresholdFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ThresholdAttributes*)a;
    
    if (atts.GetShownVariable() != std::string("default"))
        SetActiveVariable(atts.GetShownVariable().c_str());
}


// ****************************************************************************
//  Method: avtThresholdFilter::Equivalent
//
//  Purpose: Returns true if creating a new avtThresholdFilter with the given
//           parameters would result in an equivalent avtThresholdFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

bool
avtThresholdFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ThresholdAttributes*)a);
}


// ****************************************************************************
//  Function: UpdateNeighborCells
//
//  Purpose: Updates cells that are neighbors to a point with a value.
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//
// ****************************************************************************

static void UpdateNeighborCells(int pt, const int *pt_dims,
           avtStructuredMeshChunker::ZoneDesignation d,
           std::vector<avtStructuredMeshChunker::ZoneDesignation> &designation)
{
    int I = pt % pt_dims[0];
    int J = (pt / pt_dims[0]) % pt_dims[1];
    int K = pt / (pt_dims[0]*pt_dims[1]);

    for (int i = 0 ; i < 8 ; i++)
    {
        int sI = I - (i & 1 ? 1 : 0);
        int sJ = J - (i & 2 ? 1 : 0);
        int sK = K - (i & 4 ? 1 : 0);
        if (sI < 0)
            continue;
        if (sI >= (pt_dims[0]-1))
            continue;
        if (sJ < 0)
            continue;
        if (sJ >= (pt_dims[1]-1))
            continue;
        if (sK < 0)
            continue;
        if (sK >= (pt_dims[2]-1))
            continue;

        int cell = sK*(pt_dims[0]-1)*(pt_dims[1]-1) + sJ*(pt_dims[0]-1) + sI;
        designation[cell] = d;
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ProcessOneChunk
//
//  Purpose: Sends the specified input and output through the Threshold filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Removed references to active variables.
//
//    Hank Childs, Tue Oct 30 09:29:13 PST 2001
//    Account for cases when we are not switching active variables.
//
//    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray instead.
//
//    Hank Childs, Tue Sep 10 18:29:14 PDT 2002
//    Make memory management be self-contained in this routine.
//
//    Hank Childs, Sat Jun 21 09:25:34 PDT 2003
//    If we have poly data input, then we should have poly data output.
//
//    Hank Childs, Fri May  7 08:33:17 PDT 2004
//    If the variable is not a scalar, then issue a warning.
//
//    Hank Childs, Thu Jul 29 09:43:58 PDT 2004
//    Do not convert output to poly-data, since the base class will now
//    take care of this (when appropriate).
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Use a structured mesh chunker if appropriate.
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Renamed to ProcessOneChunk.  Modified to assume structured chunking.
//
//    Hank Childs, Sun Apr  3 13:06:01 PDT 2005
//    Fix bug with structured chunking.
//
//    Hank Childs, Tue Sep 13 09:03:12 PDT 2005
//    Add support for "PointsOnly".
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Tue May 16 15:49:24 PDT 2006
//    SetAttributeModeTo* deprecated, now use SetInputArrayToProcess.
//    Pass FieldData, as it is no longer done internally by vtkThreshold.
//
//    Mark Blair, Wed May 31 18:17:00 PDT 2006
//    SetInputScalars deprecated, now use SetInputArrayToProcess.
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ProcessOneChunk(
    vtkDataSet *in_ds, int domain, std::string label, bool fromChunker)
{
    if (atts.GetOutputMeshType() == ThresholdAttributes::PointMesh)
    {
        return ThresholdToPointMesh(in_ds);
    }

    if (fromChunker) {
        //
        // If in_ds is from the chunker, then the zones in in_ds are all
        // ones we identified that we wanted.  So just return them.
        //
        in_ds->Register(NULL);
        return in_ds;
    }

    vtkThreshold *threshold;

    vtkDataSet *curOutDataSet = in_ds;

    const stringVector curVariables    = atts.GetListedVariables();
    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();

    const char *curVarName;
    char errMsg[1024];
    
    for (int curVarNum = 0; curVarNum < curVariables.size(); curVarNum++)
    {
        threshold = vtkThreshold::New();
        
        curVarName = curVariables[curVarNum].c_str();

        threshold->SetInput(curOutDataSet);
        threshold->ThresholdBetween(
            curLowerBounds[curVarNum], curUpperBounds[curVarNum]);
    
        if (curOutDataSet->GetPointData()->GetArray(curVarName) != NULL)
        {
            threshold->SetInputArrayToProcess (
                0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, curVarName);

            if (curZonePortions[curVarNum] == (int)ThresholdAttributes::PartOfZone)
            {
                threshold->AllScalarsOff();
            }
            else if (curZonePortions[curVarNum] == (int)ThresholdAttributes::EntireZone)
            {
                threshold->AllScalarsOn();
            }
        }
        else if (curOutDataSet->GetCellData()->GetArray(curVarName) != NULL)
        {
            threshold->SetInputArrayToProcess (
                0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_CELLS, curVarName);
        }
        else
        {
            curOutDataSet->Register(NULL);
            threshold->Delete();
    
            sprintf (errMsg,
                "Data for variable \"%s\" is not currently available.",
                curVarName);
            EXCEPTION1(VisItException, errMsg);
        }

        curOutDataSet = threshold->GetOutput();
        curOutDataSet->Update();

        if (curOutDataSet->GetNumberOfCells() <= 0)
        {
            curOutDataSet = NULL;
            threshold->Delete();

            break;
        }

        curOutDataSet->Register(NULL);

        threshold->Delete();
    }
    
    if (curOutDataSet != NULL)
    {
        curOutDataSet->GetFieldData()->PassData(in_ds->GetFieldData());
    }

    return curOutDataSet;
}


// ****************************************************************************
//  Method: avtThresholdFilter::GetAssignments
//
//  Purpose: Gets the assignments for each zone.
//
//  Programmer: Hank Childs
//  Creation:   March 27, 2005
//
//  Modifications:
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Reworked to support multi-variable thresholding.
//
// ****************************************************************************

void
avtThresholdFilter::GetAssignments(vtkDataSet *in_ds, const int *dims,
    std::vector<avtStructuredMeshChunker::ZoneDesignation> &d)
{
    const stringVector curVariables    = atts.GetListedVariables();
    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();

    int zoneCount = in_ds->GetNumberOfCells();
    int pointCount = in_ds->GetNumberOfPoints();
    int curVarNum, zoneNum, pointNum;

    bool varIsPointData;
    const char *curVarName;
    vtkDataArray *dataArray;
    float *varValues;
    double lowerBound, upperBound, varValue;
    char errMsg[1024];

    std::vector<avtStructuredMeshChunker::ZoneDesignation> curVarZDs(zoneCount);

    for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
        d[zoneNum] = avtStructuredMeshChunker::RETAIN;

    for (curVarNum = 0; curVarNum < curVariables.size(); curVarNum++)
    {
        curVarName = curVariables[curVarNum].c_str();

        if ((dataArray = in_ds->GetPointData()->GetArray(curVarName)) != NULL)
        {
            varIsPointData = true;
        }
        else if ((dataArray = in_ds->GetCellData()->GetArray(curVarName)) != NULL)
        {
            varIsPointData = false;
        }
        else
        {
            sprintf (errMsg,
                "Data for variable \"%s\" is not currently available.",
                curVarName);
            EXCEPTION1(VisItException, errMsg);
        }

        varValues = (float *)dataArray->GetVoidPointer(0);

        lowerBound = curLowerBounds[curVarNum];
        upperBound = curUpperBounds[curVarNum];

        if (varIsPointData)
        {
            if (curZonePortions[curVarNum] == ThresholdAttributes::PartOfZone)
            {
                for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::DISCARD;

                for (pointNum = 0; pointNum < pointCount; pointNum++)
                {
                    varValue = (double)varValues[pointNum];

                    if ((varValue >= lowerBound) && (varValue <= upperBound))
                    {
                        UpdateNeighborCells(pointNum, dims,
                        avtStructuredMeshChunker::RETAIN, curVarZDs);
                    }
                }
            }
            else
            {
                for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::RETAIN;

                for (pointNum = 0; pointNum < pointCount; pointNum++)
                {
                    varValue = (double)varValues[pointNum];

                    if ((varValue < lowerBound) || (varValue > upperBound))
                    {
                        UpdateNeighborCells(pointNum, dims,
                        avtStructuredMeshChunker::DISCARD, curVarZDs);
                    }
                }
            }
        }
        else
        {
            for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
            {
                varValue = (double)varValues[zoneNum];

                if ((varValue >= lowerBound) && (varValue <= upperBound))
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::RETAIN;
                else
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::DISCARD;
            }
        }

        for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
        {
            if (curVarZDs[zoneNum] == avtStructuredMeshChunker::DISCARD)
                d[zoneNum] = avtStructuredMeshChunker::DISCARD;
        }
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ThresholdToPointMesh
//
//  Purpose:
//      Does a threshold on a nodal quantity and then creates a point mesh.
//
//  Programmer: Hank Childs
//  Creation:   September 13, 2005
//
//  Modifications:
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ThresholdToPointMesh(vtkDataSet *in_ds)
{
    const stringVector curVariables = atts.GetListedVariables();
    int curVarCount = curVariables.size();
    int curVarNum;
    vtkDataArray *dataArray;
    float *valueArray;

    std::vector<float *> valueArrays;

    for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
    {
        dataArray =
            in_ds->GetPointData()->GetArray(curVariables[curVarNum].c_str());

        if (dataArray == NULL)
        {
            EXCEPTION1(VisItException,
                "All threshold variables must be nodal quantities "
                "when point mesh output is requested.");
        }

        valueArray = (float *)dataArray->GetVoidPointer(0);
        valueArrays.push_back(valueArray);
    }

    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();
    int inPointCount = in_ds->GetNumberOfPoints();
    int plotPointCount = 0;
    int inPointID;
    double doubleValue;

    for (inPointID = 0; inPointID < inPointCount; inPointID++)
    {
        for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
        {
            doubleValue = (double)valueArrays[curVarNum][inPointID];

            if (doubleValue < curLowerBounds[curVarNum]) break;
            if (doubleValue > curUpperBounds[curVarNum]) break;
        }

        if (curVarNum >= curVarCount) plotPointCount++;
    }

    if (plotPointCount == 0) return NULL;

    vtkUnstructuredGrid *outputMesh = vtkUnstructuredGrid::New();
    vtkPoints *outMeshPoints = vtkPoints::New();
    vtkPointData *inPointData = in_ds->GetPointData();
    vtkPointData *outPointData = outputMesh->GetPointData();
    int outPointID = 0;
    vtkIdType vertexIDs[1];
    double pointXYZ[3];

    outMeshPoints->SetNumberOfPoints(plotPointCount);
    outputMesh->SetPoints(outMeshPoints);
    outputMesh->Allocate(plotPointCount*(curVarCount+1));
    outPointData->CopyAllocate(inPointData, plotPointCount*curVarCount);
    outMeshPoints->Delete();

    for (inPointID = 0; inPointID < inPointCount; inPointID++)
    {
        for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
        {
            doubleValue = (double)valueArrays[curVarNum][inPointID];

            if (doubleValue < curLowerBounds[curVarNum]) break;
            if (doubleValue > curUpperBounds[curVarNum]) break;
        }

        if (curVarNum >= curVarCount)
        {
            outPointData->CopyData(inPointData, inPointID, outPointID);
            in_ds->GetPoint(inPointID, pointXYZ);
            outMeshPoints->SetPoint(outPointID, pointXYZ);
            vertexIDs[0] = outPointID++;
            outputMesh->InsertNextCell(VTK_VERTEX, 1, vertexIDs);
        }
    }

    return outputMesh;
}


// ****************************************************************************
//  Method: avtThresholdFilter::RefashionDataObjectInfo
//
//  Purpose: Indicates the zones no longer correspond to the original problem.
//
//  Programmer: Hank Childs
//  Creation:   October 23, 2001
//
//  Modifications:
//
//    Hank Childs, Tue Sep 13 09:07:05 PDT 2005
//    Add support for "PointsOnly".
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Set OrigElementsRequiredForPick. 
//
// ****************************************************************************

void
avtThresholdFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().InvalidateZones();

    if (atts.GetOutputMeshType() == ThresholdAttributes::PointMesh)
    {
        GetOutput()->GetInfo().GetAttributes().SetTopologicalDimension(0);
    }

    GetOutput()->GetInfo().GetAttributes().SetOrigElementsRequiredForPick(true);
}


// ****************************************************************************
//  Method: avtThresholdFilter::PreExecute
//
//  Purpose: Determine if there is a "default" variable to work with.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Aug 29 08:12:22 PDT 2002
//    If the variable was not the 'default' variable, the test was sometimes
//    wrong.
//
//    Hank Childs, Sat Mar 19 10:29:37 PST 2005
//    Initialize chunkedStructuredMesh.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved chunkedStructuredMesh to base class.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    No longer recognizes the "default" variable.
//
// ****************************************************************************

void
avtThresholdFilter::PreExecute(void)
{
    avtPluginStructuredChunkStreamer::PreExecute();

    if (GetInput()->GetInfo().GetAttributes().GetVariableName() == "<unknown>")
    {
        //
        // Somehow the variable we asked for didn't make it down far enough.
        // This often happens when we are doing a plot that doesn't have a
        // variable (say a material plot) and then we apply the threshold
        // operator.
        //
        EXCEPTION1(NoDefaultVariableException, "Threshold");
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::PerformRestriction
//
//  Purpose: Restrict the data processed by looking at the data extents.
//
//  Programmer: Hank Childs
//  Creation:   May 14, 2003
//
//  Modifications:
//
//    Mark C. Miller, Mon Oct 18 13:02:37 PDT 2004
//    Added code to pass variable name in call to GetDataExtents
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Initialize data members for structured mesh chunking.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved data members for structured mesh chunking to base class.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Turn on Node & Zone numbers when appropriate. 
//
// ****************************************************************************

avtPipelineSpecification_p
avtThresholdFilter::PerformRestriction(avtPipelineSpecification_p in_spec)
{
    const char *pipelineVar = in_spec->GetDataSpecification()->GetVariable();
    
    atts.SwitchToPipelineVariable(std::string(pipelineVar));
    
    avtPipelineSpecification_p outSpec = new avtPipelineSpecification(in_spec);

    const std::vector<CharStrRef> curSecondaryVars =
        outSpec->GetDataSpecification()->GetSecondaryVariables();
    const stringVector curListedVars = atts.GetListedVariables();
    const char *curListedVar;
    const char *curSecondaryVar;
    int listedVarNum, secVarNum;

    for (listedVarNum = 0; listedVarNum < curListedVars.size(); listedVarNum++)
    {
        curListedVar = curListedVars[listedVarNum].c_str();
        
        if (strcmp(curListedVar, pipelineVar) != 0)
        {
            for (secVarNum = 0; secVarNum < curSecondaryVars.size(); secVarNum++)
            {
                if (strcmp(*curSecondaryVars[secVarNum],curListedVar) == 0)
                {
                    break;
                }
            }

            if (secVarNum >= curSecondaryVars.size())
            {
                outSpec->GetDataSpecification()->AddSecondaryVariable(curListedVar);
            }
        }
    }

    for (secVarNum = 0; secVarNum < curSecondaryVars.size(); secVarNum++)
    {
        curSecondaryVar = *curSecondaryVars[secVarNum];

        for (listedVarNum = 0; listedVarNum < curListedVars.size(); listedVarNum++)
        {
            if (strcmp(curListedVars[listedVarNum].c_str(), curSecondaryVar) == 0)
            {
                break;
            }
        }

        if (listedVarNum >= curListedVars.size())
        {
            outSpec->GetDataSpecification()->
            RemoveSecondaryVariable(curSecondaryVar);
        }
    }

    bool atLeastOneTree = false;
    avtIntervalTree *it;
    int varDomNum, curDomNum, curDomain;
    intVector varDomains;
    intVector curDomains;
    intVector outDomains;

    doubleVector curLowerBounds = atts.GetLowerBounds();
    doubleVector curUpperBounds = atts.GetUpperBounds();
    double lowerBound, upperBound;

    for (listedVarNum = 0; listedVarNum < curListedVars.size(); listedVarNum++)
    {
        curListedVar = curListedVars[listedVarNum].c_str();

        if ((it = GetMetaData()->GetDataExtents(curListedVar)) != NULL)
        {
            lowerBound = curLowerBounds[listedVarNum];
            upperBound = curUpperBounds[listedVarNum];

            if (atLeastOneTree)
            {
                it->GetDomainsListFromRange(&lowerBound, &upperBound, varDomains);

                for (curDomNum = 0; curDomNum < curDomains.size(); curDomNum++)
                {
                    if ((curDomain = curDomains[curDomNum]) != -1)
                    {
                        for (varDomNum=0; varDomNum<varDomains.size(); varDomNum++)
                        {
                            if (varDomains[varDomNum] == curDomain) break;
                        }

                        if (varDomNum >= varDomains.size())
                        {
                            curDomains[curDomNum] = -1;
                        }
                    }
                }
            }
            else
            {
                it->GetDomainsListFromRange(&lowerBound, &upperBound, curDomains);
                atLeastOneTree = true;
            }
        }
    }

    if (atLeastOneTree)
    {
        for (curDomNum = 0; curDomNum < curDomains.size(); curDomNum++)
        {
            if (curDomains[curDomNum] != -1)
            {
                outDomains.push_back(curDomains[curDomNum]);
            }
        }

        outSpec->GetDataSpecification()->GetRestriction()->RestrictDomains(outDomains);
    }

    if (outSpec->GetDataSpecification()->MayRequireZones() ||
        outSpec->GetDataSpecification()->MayRequireNodes())
    {
        // Turn on both Nodes and Zones, to prevent another re-execution if
        // user switches between zone and node pick.
        outSpec->GetDataSpecification()->TurnZoneNumbersOn();
        outSpec->GetDataSpecification()->TurnNodeNumbersOn();
    }

    return outSpec;
}
