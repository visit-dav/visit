/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtExtractPointFunction2DFilter.C
// ************************************************************************* //

#include <avtExtractPointFunction2DFilter.h>

#include <float.h>

#include <vtkCellData.h>
#include <vtkDataArray.h>
#include <vtkDoubleArray.h>
#include <vtkFieldData.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>

// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter constructor
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

avtExtractPointFunction2DFilter::avtExtractPointFunction2DFilter()
{
    range[0] = 0;
    range[1] = 0;
    spatialExtents[0] = 0;
    spatialExtents[1] = 0;
    spatialExtents[2] = 0;
    spatialExtents[3] = 0;
    spatialExtents[4] = 0;
    spatialExtents[5] = 0;
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter destructor
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
//  Modifications:
//
// ****************************************************************************

avtExtractPointFunction2DFilter::~avtExtractPointFunction2DFilter()
{
}


// ****************************************************************************
//  Method:  avtExtractPointFunction2DFilter::Create
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

avtFilter *
avtExtractPointFunction2DFilter::Create()
{
    return new avtExtractPointFunction2DFilter();
}


// ****************************************************************************
//  Method:      avtExtractPointFunction2DFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

void
avtExtractPointFunction2DFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ExtractPointFunction2DAttributes*)a;
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtExtractPointFunction2DFilter with the given
//      parameters would result in an equivalent avtExtractPointFunction2DFilter.
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

bool
avtExtractPointFunction2DFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ExtractPointFunction2DAttributes*)a);
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::PreExecute
//
//  Purpose:
//      Called before "Execute". Initialize variable we use to keep track of
//      value range.
//
//  Programmer: Gunther H. Weber 
//  Creation:   June 6, 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtExtractPointFunction2DFilter::PreExecute(void)
{
    avtPluginDataTreeIterator::PreExecute();
    range[0] =  FLT_MAX;
    range[1] = -FLT_MAX;
    spatialExtents[0] = 0;
    spatialExtents[1] = 0;
    spatialExtents[2] = 0;
    spatialExtents[3] = 0;
    spatialExtents[4] = 0;
    spatialExtents[5] = 0;
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the ExtractPointFunction2D filter.
//
//  Arguments:
//      in_dr      The input data representation.
//
//  Returns:       The output data representation.
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
//  Modifications:
//    Kathleen Biagas, Tue Jul  8 14:52:03 PDT 2014
//    Moved avtRealDims code into FIXME comment, to suppress warnings until
//    such a time as they are used.
//
//    Eric Brugger, Thu Jul 24 13:27:16 PDT 2014
//    Modified the class to work with avtDataRepresentation.
//
// ****************************************************************************

avtDataRepresentation *
avtExtractPointFunction2DFilter::ExecuteData(avtDataRepresentation *in_dr)
{
    //
    // Get the VTK data set.
    //
    vtkDataSet *in_ds = in_dr->GetDataVTK();

    // Ensure that we are working on rectilinear grid
    vtkRectilinearGrid *rgrid = dynamic_cast<vtkRectilinearGrid*>(in_ds);
    if (!rgrid)
        EXCEPTION1(ImproperUseException,
                "Can only extract point function for a rectilinear grid.");

    // Dimensions of data set
    int dims[3];
    rgrid->GetDimensions(dims);
    // We want number of cells as grid dimension, not number of samples
    for (int d=0; d<3; ++d)
        dims[d]--;


    vtkIntArray *arr = dynamic_cast<vtkIntArray*>(in_ds->GetFieldData()->GetArray("base_index"));
    int base_index[3] = { 0, 0, 0 };
    if (arr)
        for (int d = 0; d < 3; ++d)
            base_index[d] = arr->GetValue(d);


    int iMin = base_index[0];
    int iMax = base_index[0] + dims[0] - 1;
    int jMin = base_index[1];
    int jMax = base_index[1] + dims[1] - 1;

    // FIXME: Take avtRealDims into account
    // arr = dynamic_cast<vtkIntArray*>(in_ds->GetFieldData()->GetArray("avtRealDims"));
    // int avtRealDims[6] = { 0, 0, 0, 0, 0, 0 };
    // if (arr)
    //     for (int d = 0; d < 6; ++d)
    //         avtRealDims[d] = arr->GetValue(d);

    if (iMin <= atts.GetI() && atts.GetI() <= iMax && jMin <= atts.GetJ() && atts.GetJ() <= jMax)
    {
        double dvpar = 1.0;
        double dmu = 1.0;
        vtkDoubleArray *dx_arr = dynamic_cast<vtkDoubleArray*>(in_ds->GetFieldData()->GetArray("dx_array"));
        vtkIntArray *v_base_index_arr = dynamic_cast<vtkIntArray*>(in_ds->GetFieldData()->GetArray("v_base_index"));
        vtkIntArray *v_dims_arr = dynamic_cast<vtkIntArray*>(in_ds->GetFieldData()->GetArray("v_dims"));
        if (dx_arr)
        {
            dvpar = dx_arr->GetValue(0);
            dmu = dx_arr->GetValue(1);
        }

        int v_base_index[2] = { 0, 0 };
        int v_dims[2] = { 0, 0 };
        if (v_base_index_arr && v_dims_arr)
        {
            for (int i = 0; i < 2; ++i)
            {
                v_base_index[i] = v_base_index_arr->GetValue(i);
                v_dims[i] = v_dims_arr->GetValue(i);
            }
        }
        else
        {
            EXCEPTION1(ImproperUseException,
                    "Internal error: Velocity base index and dimensions not set by database plugin.");
        }

        const char *justTheVar = pipelineVariable + strlen("operators/ExtractPointFunction2D/");
        vtkDataArray *data = in_ds->GetCellData()->GetArray(justTheVar);

        vtkRectilinearGrid *ogrid = vtkRectilinearGrid::New();
        ogrid->SetDimensions(v_dims[0]+1, v_dims[1]+1, 1);
        vtkDataArray *xCoords = rgrid->GetZCoordinates()->NewInstance();
        xCoords->SetNumberOfTuples(v_dims[0]+1);
        for (int k = 0; k < v_dims[0]+1; ++k)
            xCoords->SetTuple1(k, (v_base_index[0]+k)*dvpar);
        ogrid->SetXCoordinates(xCoords);
        xCoords->Delete();
        vtkDataArray *yCoords = rgrid->GetZCoordinates()->NewInstance();
        yCoords->SetNumberOfTuples(v_dims[1]+1);
        for (int l = 0; l < v_dims[1]+1; ++l)
            yCoords->SetTuple1(l, (v_base_index[1]+l)*dmu);
        ogrid->SetYCoordinates(yCoords);
        yCoords->Delete();

        spatialExtents[0] = v_base_index[0] * dvpar;
        spatialExtents[1] = (v_base_index[0] + v_dims[0]) * dvpar;
        spatialExtents[2] = v_base_index[1] * dmu;
        spatialExtents[3] = (v_base_index[1] + v_dims[1]) * dmu;
        spatialExtents[4] = 0;
        spatialExtents[5] = 0;

        vtkDataArray *zCoords = rgrid->GetZCoordinates()->NewInstance();
        zCoords->SetNumberOfTuples(1);
        zCoords->SetTuple1(0,0.0);
        ogrid->SetZCoordinates(zCoords);
        zCoords->Delete();

        vtkDataArray *odata = data->NewInstance();
        odata->SetNumberOfComponents(1);
        odata->SetNumberOfTuples(v_dims[0]*v_dims[1]);
        int ijk_f[3] = { atts.GetI() - base_index[0], atts.GetJ() - base_index[1], 0 };
        vtkIdType id_f = rgrid->ComputeCellId(ijk_f);
        for (int k = 0; k < v_dims[0]; ++k)
            for (int l = 0; l < v_dims[1]; ++l)
            {
                int ijk_t[3] = { k, l, 0 };
                vtkIdType id_t = ogrid->ComputeCellId(ijk_t);
                double val = data->GetComponent(id_f, k*v_dims[1]+l);
                odata->SetTuple1(id_t, val);
                if (val < range[0]) range[0] = val;
                if (val > range[1]) range[1] = val;
            }
        ogrid->GetCellData()->SetScalars(odata);
        odata->Delete();

        avtDataRepresentation *out_dr = new avtDataRepresentation(ogrid,
            in_dr->GetDomain(), in_dr->GetLabel());

        ogrid->Delete();

        return out_dr;
    }
    else
        return 0;
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::PostExecute
//
//  Purpose:
//      Called after "Execute". Update value range.
//
//  Programmer: Gunther H. Weber 
//  Creation:   June 6, 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtExtractPointFunction2DFilter::PostExecute(void)
{
    avtPluginDataTreeIterator::PostExecute();
    if (outVarName != "")
    {
        avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
        atts.GetThisProcsOriginalDataExtents(outVarName.c_str())->Set(range);
        atts.GetThisProcsActualDataExtents(outVarName.c_str())->Set(range);
        atts.GetOriginalSpatialExtents()->Clear();
        atts.GetThisProcsOriginalSpatialExtents()->Set(spatialExtents);
    }
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

avtContract_p
avtExtractPointFunction2DFilter::ModifyContract(avtContract_p in_contract)
{
    avtContract_p rv;
    if (strncmp(pipelineVariable, "operators/ExtractPointFunction2D/", strlen("operators/ExtractPointFunction2D/")) == 0)
    {
        outVarName = pipelineVariable;
        const char *justTheVar = pipelineVariable + strlen("operators/ExtractPointFunction2D/");
        avtDataRequest_p dr = new avtDataRequest(in_contract->GetDataRequest(), justTheVar);
        rv = new avtContract(in_contract, dr);
    }
    else
    {
        rv = new avtContract(in_contract);
    }
    return rv;
}


// ****************************************************************************
//  Method: avtExtractPointFunction2DFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: ghweber -- generated by xml2avt
//  Creation:   Tue Jun 4 10:46:56 PDT 2013
//
// ****************************************************************************

void
avtExtractPointFunction2DFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    atts.SetSpatialDimension(2);
    atts.SetTopologicalDimension(2);
    atts.AddFilterMetaData("ExtractPointFunction2D");

    GetOutput()->GetInfo().GetValidity().SetPointsWereTransformed(true);
    GetOutput()->GetInfo().GetAttributes().SetCanUseTransform(false);
    GetOutput()->GetInfo().GetAttributes().SetCanUseInvTransform(false);
    GetOutput()->GetInfo().GetValidity().InvalidateSpatialMetaData();
    GetOutput()->GetInfo().GetValidity().InvalidateDataMetaData();

   if (outVarName != "")
   {
       if (! atts.ValidVariable(outVarName))
       {
           atts.AddVariable(outVarName.c_str());
           atts.SetActiveVariable(outVarName.c_str());
           atts.SetVariableDimension(1);
           atts.SetVariableType(AVT_SCALAR_VAR);
           atts.SetCentering(AVT_ZONECENT);
       }
   }
}
