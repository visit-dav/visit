/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtDataBinningFilter.C
// ************************************************************************* //

#include <avtDataBinningFilter.h>

#include <vtkCellData.h>
#include <vtkDataSet.h>
#include <vtkPointData.h>

#include <avtDataBinning.h>
#include <avtDataBinningConstructor.h>
#include <avtExtents.h>
#include <avtParallel.h>

#include <float.h>

#include <string>
#include <vector>

// ****************************************************************************
//  Method: avtDataBinningFilter constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
// ****************************************************************************

avtDataBinningFilter::avtDataBinningFilter()
{
    varname = "operators/DataBinning";
}


// ****************************************************************************
//  Method: avtDataBinningFilter destructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtDataBinningFilter::~avtDataBinningFilter()
{
}


// ****************************************************************************
//  Method:  avtDataBinningFilter::Create
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
// ****************************************************************************

avtFilter *
avtDataBinningFilter::Create()
{
    return new avtDataBinningFilter();
}


// ****************************************************************************
//  Method:      avtDataBinningFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
// ****************************************************************************

void
avtDataBinningFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const DataBinningAttributes*)a;
}


// ****************************************************************************
//  Method: avtDataBinningFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtDataBinningFilter with the given
//      parameters would result in an equivalent avtDataBinningFilter.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
// ****************************************************************************

bool
avtDataBinningFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(DataBinningAttributes*)a);
}


// ****************************************************************************
//  Method: avtDataBinningFilter::Execute
//
//  Purpose:
//      Calculates the data binning.
//
//  Returns:       The output dataset.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Thu Aug 19 20:24:23 PST 2010
//
//  Modifications:
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
//    Hank Childs, Sun Oct 17 09:45:44 PDT 2010
//    Change the name of the variable we create.
//
//    Hank Childs, Tue Nov 30 20:13:43 PST 2010
//    Set the spatial extents of the output.  Otherwise downstream filters might
//    get confused.
//
//    Hank Childs, Mon Aug  1 07:13:23 PDT 2011
//    Add support for spatial dimensions.
//
// ****************************************************************************

void
avtDataBinningFilter::Execute(void)
{
    ConstructDataBinningAttributes dba = atts.CreateConstructionAtts();
    std::vector<double> bb = dba.GetBinBoundaries();
    if (! atts.GetDim1SpecifyRange())
    {
        if (atts.GetDim1BinBasedOn() == DataBinningAttributes::Variable)
        {
            std::string v1name = atts.GetDim1Var();
            if (v1name == "default")
                v1name = pipelineVariable;
            double range[2];
            GetDataExtents(range, v1name.c_str());
            bb[0] = range[0];
            bb[1] = range[1];
        }
        else
        {
            int dim = (atts.GetDim1BinBasedOn()-DataBinningAttributes::X);
            double range[6];
            GetSpatialExtents(range);
            bb[0] = range[2*dim];
            bb[1] = range[2*dim+1];
        }
    }
    if ((! atts.GetDim2SpecifyRange()) && (atts.GetNumDimensions() == DataBinningAttributes::Two ||
                                         atts.GetNumDimensions() == DataBinningAttributes::Three))
    {
        if (atts.GetDim2BinBasedOn() == DataBinningAttributes::Variable)
        {
            std::string v2name = atts.GetDim2Var();
            if (v2name == "default")
                v2name = pipelineVariable;
            double range[2];
            GetDataExtents(range, v2name.c_str());
            bb[2] = range[0];
            bb[3] = range[1];
        }
        else
        {
            int dim = (atts.GetDim2BinBasedOn()-DataBinningAttributes::X);
            double range[6];
            GetSpatialExtents(range);
            bb[2] = range[2*dim];
            bb[3] = range[2*dim+1];
        }
    }
    if ((! atts.GetDim3SpecifyRange()) && atts.GetNumDimensions() == DataBinningAttributes::Three)
    {
        if (atts.GetDim3BinBasedOn() == DataBinningAttributes::Variable)
        {
            std::string v3name = atts.GetDim3Var();
            if (v3name == "default")
                v3name = pipelineVariable;
            double range[2];
            GetDataExtents(range, v3name.c_str());
            bb[4] = range[0];
            bb[5] = range[1];
        }
        else
        {
            int dim = (atts.GetDim3BinBasedOn()-DataBinningAttributes::X);
            double range[6];
            GetSpatialExtents(range);
            bb[4] = range[2*dim];
            bb[5] = range[2*dim+1];
        }
    }
    dba.SetBinBoundaries(bb);

    avtDataBinningConstructor dbc;
    dbc.SetInput(GetInput());
    avtDataBinning *d = dbc.ConstructDataBinning(&dba, lastContract, false);
    if (PAR_Rank() == 0)
    {
        vtkDataSet *ds = d->CreateGrid();
        if (atts.GetNumDimensions() == DataBinningAttributes::One)
            ds->GetPointData()->GetScalars()->SetName(varname.c_str());
        else
            ds->GetCellData()->GetScalars()->SetName(varname.c_str());
        ds->GetCellData()->SetActiveScalars(varname.c_str());
        SetOutputDataTree(new avtDataTree(ds, -1));
        double range[2] = { FLT_MAX, -FLT_MAX };
        GetDataRange(ds, range, varname.c_str(), false);
        avtDataAttributes &dataAtts = GetOutput()->GetInfo().GetAttributes();
        dataAtts.GetThisProcsOriginalDataExtents(varname.c_str())->Set(range);
        dataAtts.GetThisProcsActualDataExtents(varname.c_str())->Set(range);

        ds->Delete();
    }
    else
        SetOutputDataTree(new avtDataTree());
 
    avtDataAttributes &dataAtts = GetOutput()->GetInfo().GetAttributes();
    int dim = ( (atts.GetNumDimensions() == DataBinningAttributes::One) ? 1
              : ((atts.GetNumDimensions() == DataBinningAttributes::Two) ? 2 : 3));
    dataAtts.GetThisProcsOriginalSpatialExtents()->Set(&bb[0]);
    dataAtts.GetOriginalSpatialExtents()->Set(&bb[0]);

    delete d;
}


// ****************************************************************************
//  Method: avtDataBinningFilter::ModifyContract
//
//  Purpose:
//      Sets up the contract to have the requisite variables.
//
//  Programmer: Hank Childs
//  Creation:   August 19, 2010
//
//  Modifications:
//
//    Hank Childs, Tue Aug 31 10:20:08 PDT 2010
//    Change names of added variable.
//
//    Hank Childs, Tue Aug 31 13:28:48 PDT 2010
//    Beef up error messages.
//
// ****************************************************************************

avtContract_p
avtDataBinningFilter::ModifyContract(avtContract_p inContract)
{
    bool defaultVarOK = true;
    if (strncmp(pipelineVariable, "operators/DataBinning", strlen("operators/DataBinning")) == 0)
    {
        defaultVarOK = false;
        varname = pipelineVariable;
    }

    const char *dim1Var = atts.GetDim1Var().c_str();
    if (atts.GetDim1BinBasedOn() == DataBinningAttributes::Variable)
    {
        if (strcmp(dim1Var, "default") == 0)
        {    
            if (defaultVarOK)
                dim1Var = pipelineVariable;
            else
            {
                EXCEPTION1(VisItException, "You specified the first dimension of the "
                                   "data binning as \"default\", but your plotting variable "
                                   "(which \"default\" resolves to) is of the output of the "
                                   "data binning.  This is a recursion definition.  Please "
                                   "change the first dimension of the data binning to be "
                                   "something besides \"default\".");
            }
        }
    }

    const char *dim2Var = atts.GetDim2Var().c_str();
    if (atts.GetDim2BinBasedOn() == DataBinningAttributes::Variable)
    {
        if (strcmp(dim2Var, "default") == 0 && 
            (atts.GetNumDimensions() == DataBinningAttributes::Two || 
             atts.GetNumDimensions() == DataBinningAttributes::Three))
        {    
            if (defaultVarOK)
                dim2Var = pipelineVariable;
            else
            {
                EXCEPTION1(VisItException, "You specified the second dimension of the "
                                   "data binning as \"default\", but your plotting variable "
                                   "(which \"default\" resolves to) is of the output of the "
                                   "data binning.  This is a recursion definition.  Please "
                                   "change the first dimension of the data binning to be "
                                   "something besides \"default\".");
            }
        }
    }

    const char *dim3Var = atts.GetDim3Var().c_str();
    if (atts.GetDim3BinBasedOn() == DataBinningAttributes::Variable)
    {
        if (strcmp(dim3Var, "default") == 0 && 
            atts.GetNumDimensions() == DataBinningAttributes::Three)
        {    
            if (defaultVarOK)
                dim3Var = pipelineVariable;
            else
            {
                EXCEPTION1(VisItException, "You specified the third dimension of the "
                                   "data binning as \"default\", but your plotting variable "
                                   "(which \"default\" resolves to) is of the output of the "
                                   "data binning.  This is a recursion definition.  Please "
                                   "change the first dimension of the data binning to be "
                                   "something besides \"default\".");
            }
        }
    }

    avtDataRequest_p in_dr  = inContract->GetDataRequest();
    avtDataRequest_p out_dr;
    avtDataAttributes &inAtts   = GetInput()->GetInfo().GetAttributes();
    if (strncmp(in_dr->GetVariable(), "operators/DataBinning", strlen("operators/DataBinning")) == 0)
        out_dr = new avtDataRequest(in_dr, inAtts.GetMeshname().c_str());
    else
        out_dr = new avtDataRequest(in_dr);
    std::vector<CharStrRef>   vars2nd = in_dr->GetSecondaryVariablesWithoutDuplicates();
    std::vector<std::string>  removeMe;
    int  i;
    for (i = 0 ; i < vars2nd.size() ; i++)
        if (strncmp(*(vars2nd[i]), "operators/DataBinning", strlen("operators/DataBinning")) == 0)
        {
            varname = *(vars2nd[i]);
            removeMe.push_back(*(vars2nd[i]));
        }
    for (i = 0 ; i < removeMe.size() ; i++)
        out_dr->RemoveSecondaryVariable(removeMe[i].c_str());

    if (atts.GetDim1BinBasedOn() == DataBinningAttributes::Variable)
        out_dr->AddSecondaryVariable(dim1Var);
    if ((atts.GetNumDimensions() == DataBinningAttributes::Two || 
        atts.GetNumDimensions() == DataBinningAttributes::Three)
        && (atts.GetDim2BinBasedOn() == DataBinningAttributes::Variable))
        out_dr->AddSecondaryVariable(dim2Var);
    if ((atts.GetNumDimensions() == DataBinningAttributes::Three)
        && (atts.GetDim3BinBasedOn() == DataBinningAttributes::Variable))
        out_dr->AddSecondaryVariable(dim3Var);
    if (atts.GetReductionOperator() != DataBinningAttributes::PDF && 
        atts.GetReductionOperator() != DataBinningAttributes::Count)
    {
        if (atts.GetVarForReduction() == "default")
        {
            if (defaultVarOK)
                out_dr->AddSecondaryVariable(pipelineVariable);
            else
            {
                EXCEPTION1(VisItException, "You specified the variable for the reduction operator of your "
                               "data binning as \"default\", but your plotting variable "
                               "(which \"default\" resolves to) is of the output of the "
                               "data binning.  This is a recursion definition.  Please "
                               "change the first dimension of the data binning to be "
                               "something besides \"default\".");
            }
        }
        else
            out_dr->AddSecondaryVariable(atts.GetVarForReduction().c_str());
    }

    //
    // Calculate the "original" extents.  If we clip away part of the volume, we don't
    // want the extents bouncing all around because certain regions aren't contributing.
    //
    avtContract_p rv = new avtContract(inContract, out_dr);
    if (! atts.GetDim1SpecifyRange() && dim1Var != pipelineVariable
        && atts.GetDim1BinBasedOn() == DataBinningAttributes::Variable)
        rv->SetCalculateVariableExtents(dim1Var, true);
    if ((! atts.GetDim2SpecifyRange()) && (atts.GetNumDimensions() == DataBinningAttributes::Two ||
                                         atts.GetNumDimensions() == DataBinningAttributes::Three)
         && (dim2Var != pipelineVariable)
         && (atts.GetDim2BinBasedOn() == DataBinningAttributes::Variable))
        rv->SetCalculateVariableExtents(dim2Var, true);
    if ((! atts.GetDim3SpecifyRange()) && atts.GetNumDimensions() == DataBinningAttributes::Three
         && (dim2Var != pipelineVariable)
         && (atts.GetDim3BinBasedOn() == DataBinningAttributes::Variable))
        rv->SetCalculateVariableExtents(dim3Var, true);

    int numSpatialDimensions = 0;
    if ((atts.GetDim1BinBasedOn() != DataBinningAttributes::Variable) &&
        (! atts.GetDim1SpecifyRange()))
        numSpatialDimensions++;
    if ((atts.GetDim2BinBasedOn() != DataBinningAttributes::Variable) 
        && (! atts.GetDim2SpecifyRange()) 
        && (atts.GetNumDimensions() == DataBinningAttributes::Two ||
            atts.GetNumDimensions() == DataBinningAttributes::Three))
        numSpatialDimensions++;
    if ((atts.GetDim3BinBasedOn() != DataBinningAttributes::Variable) 
        && (! atts.GetDim3SpecifyRange()) 
        && (atts.GetNumDimensions() == DataBinningAttributes::Three))
        numSpatialDimensions++;

    if (numSpatialDimensions > 0)
        rv->SetCalculateMeshExtents(true);
    
    lastContract = rv;

    return rv;
}


// ****************************************************************************
//  Method: avtDataBinningFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Changes the info to reflect the new dimensions.
//
//  Programmer: Hank Childs
//  Creation:   August 19, 2010
//
//  Modifications:
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
//    Hank Childs, Tue Aug 31 10:20:08 PDT 2010
//    Set up output labels.
//
//    Hank Childs, Sun Oct 17 09:45:44 PDT 2010
//    Change the name of the variable we create.
//
//    Cyrus Harrison, Tue Feb 15 13:44:45 PST 2011
//    Preserve units if possible & better y-axis label for 1D case.
//
// ****************************************************************************

void
avtDataBinningFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &inAtts   = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &dataAtts = GetOutput()->GetInfo().GetAttributes();
    int dim = ( (atts.GetNumDimensions() == DataBinningAttributes::One) ? 1
              : ((atts.GetNumDimensions() == DataBinningAttributes::Two) ? 2 : 3));
    dataAtts.SetTopologicalDimension(dim);
    dataAtts.SetSpatialDimension(dim);
    dataAtts.GetThisProcsOriginalSpatialExtents()->Clear();
    dataAtts.GetOriginalSpatialExtents()->Clear();
    dataAtts.GetDesiredSpatialExtents()->Clear();
    dataAtts.AddVariable(varname);
    dataAtts.SetActiveVariable(varname.c_str());
    dataAtts.SetVariableDimension(1);
    dataAtts.SetVariableType(AVT_SCALAR_VAR);
    if (atts.GetNumDimensions() == DataBinningAttributes::One)
        dataAtts.SetCentering(AVT_NODECENT);
    else
        dataAtts.SetCentering(AVT_ZONECENT);

    std::string var1 = "";
    if (atts.GetDim1Var() == "default")
    {
        if (pipelineVariable != NULL)
            var1 = pipelineVariable;
    }
    else
        var1 = atts.GetDim1Var();
    dataAtts.SetXLabel(var1);
    if(inAtts.ValidVariable(var1.c_str()))
        dataAtts.SetXUnits(inAtts.GetVariableUnits(var1.c_str()));
    else
        dataAtts.SetXUnits("");

    if (atts.GetNumDimensions() == DataBinningAttributes::One)
    {
        // In this case we generate a curve, so create a sensible
        // axis name for the output var.
        DataBinningAttributes::ReductionOperator rop_id = atts.GetReductionOperator();
        std::string rop_str = DataBinningAttributes::ReductionOperator_ToString(rop_id);
        if( ! (rop_id == DataBinningAttributes::Count ||
               rop_id == DataBinningAttributes::RMS ||
               rop_id == DataBinningAttributes::PDF) )
        {
            rop_str = rop_str + "(" + atts.GetVarForReduction() + ")";
        }
        dataAtts.SetYLabel(rop_str);
        dataAtts.SetYUnits("");
    }

    if ((atts.GetNumDimensions() == DataBinningAttributes::Two ||
         atts.GetNumDimensions() == DataBinningAttributes::Three))
    {
        std::string var2 = "";
        if (atts.GetDim2Var() == "default")
        {
            if (pipelineVariable != NULL)
                var2 = pipelineVariable;
        }
        else
            var2 = atts.GetDim2Var();
        dataAtts.SetYLabel(var2);
        dataAtts.SetYUnits("");
        if(inAtts.ValidVariable(var2.c_str()))
            dataAtts.SetYUnits(inAtts.GetVariableUnits(var2.c_str()));
        else
            dataAtts.SetYUnits("");
    }

    if (atts.GetNumDimensions() == DataBinningAttributes::Three)
    {
        std::string var3 = "";
        if (atts.GetDim3Var() == "default")
        {
            if (pipelineVariable != NULL)
                var3 = pipelineVariable;
        }
        else
            var3 = atts.GetDim3Var();
        dataAtts.SetZLabel(var3);
        if(inAtts.ValidVariable(var3.c_str()))
            dataAtts.SetZUnits(inAtts.GetVariableUnits(var3.c_str()));
        else
            dataAtts.SetZUnits("");
    }
}


