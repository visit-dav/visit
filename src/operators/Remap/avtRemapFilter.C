
/*****************************************************************************
*
* Copyright (c) 2000 - 2019, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtRemapFilter.C
// ************************************************************************* //

#include <avtRemapFilter.h>

#include <vector>

#include <vtkDataArray.h>
#include <vtkInformationVector.h>
#include <vtkInformation.h>
//#include <vtkUnstructuredGridAlgorithm.h>
#include <vtkUnstructuredGrid.h>
#include <vtkImplicitBoolean.h>
#include <vtkPlane.h>
#include <vtkCell.h>
#include <vtkAppendFilter.h>
#include <vtkCellData.h>

#include <verdict.h>

#include <avtExtents.h>
#include <avtDataAttributes.h>
#include <avtDataTree.h>
#include <avtSourceFromAVTDataset.h>
// #include <avtSamplePoints.h>
#include <avtSamplePointExtractor.h>
#include <vtkVisItClipper.h>


// ****************************************************************************
//  Method: avtRemapFilter constructor
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
// ****************************************************************************

avtRemapFilter::avtRemapFilter()
: rGridBounds{0., 0., 0., 0., 0., 0.},
  rCellVolume(0.),
  is3D(false)
{
    rg = vtkRectilinearGrid::New();
    vars = vtkDoubleArray::New();
}


// ****************************************************************************
//  Method: avtRemapFilter destructor
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
//  Modifications:
//
// ****************************************************************************

avtRemapFilter::~avtRemapFilter()
{
    rg->Delete();
    vars->Delete();
}


// ****************************************************************************
//  Method:  avtRemapFilter::Create
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
// ****************************************************************************

avtFilter *
avtRemapFilter::Create()
{
    return new avtRemapFilter();
}


// ****************************************************************************
//  Method:      avtRemapFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
// ****************************************************************************

void
avtRemapFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const RemapAttributes*)a;
}


// ****************************************************************************
//  Method: avtRemapFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtRemapFilter with the given
//      parameters would result in an equivalent avtRemapFilter.
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
// ****************************************************************************

bool
avtRemapFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(RemapAttributes*)a);
}


// ****************************************************************************
//  Method: avtRemapFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Remap filter.
//
//  Arguments:
//      in_dr      The input data representation.
//
//  Returns:       The output data representation.
//
//  TODO:          (-) Refactor the clipping so that the planes of the
//                     rectilinear grid are only generated once.
//                 (-) How to handle avtOriginalCellNumbers?
//                         Resample might already have this.
//                 (-) How to handle ghost zones?
//                 (-) Make it work for multiple domains.
//                 (-) Make it work in parallel.
//
//  Programmer: rusu1 -- generated by xml2avt
//  Creation:   Tue Oct 23 14:58:25 PST 2018
//
// ****************************************************************************

void
avtRemapFilter::Execute(void)
{

// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_TRIANGLE",   0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_QUAD",       0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_PIXEL",      0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_VOXEL",      0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_HEXAHEDRON", 0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_TETRA",      0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_WEDGE",      0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("VTK_PYRAMID",    0));
DEBUG_CellTypeList.insert(std::pair<std::string, int>("unknown",        0));
// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //
    

    // --------------------------------- //
    // --- Generate Rectilinear Grid --- //
    // --------------------------------- //
    GetBounds();
    int width = atts.GetCellsX();
    int height = atts.GetCellsY();
    
    // Setup whatever variables I can assuming the grid is 2D. Then, check if it
    // is actually 3D. If so, modify parameters and build rg. Otherwise, build
    // rg with 2D variable values.
    int nCellsOut = width*height;
    rCellVolume = (rGridBounds[1] - rGridBounds[0]) *
                  (rGridBounds[3] - rGridBounds[2]) /
                  (nCellsOut);    
    if (is3D) 
    {
        int depth = atts.GetCellsZ();
        nCellsOut *= depth;
        rCellVolume *= (rGridBounds[5] - rGridBounds[4]) / depth;
        CreateGrid(width, height, depth, 0, width, 0, height, 0, depth);
    }
    else
    {
        CreateGrid(width, height, 0, width, 0, height);
    }
    
    // If there are no variables, then just create the mesh and exit
    int nVariables = GetInput()->GetInfo().GetAttributes().GetNumberOfVariables();
    if (nVariables <= 0)
    {
        std::cout << "There are no variables" << std::endl;
        Output();
        return;
    }
    
    // Add variables to the rectilinear grid
    // TODO: What about the case with more than 1 variable?
    std::cout << "Number of variables: " << nVariables << std::endl;    
    vars->SetNumberOfComponents(1);
    vars->SetNumberOfTuples(nCellsOut);
    for (vtkIdType i = 0; i < vars->GetNumberOfTuples(); ++i) {
        vars->SetComponent(i, 0, 0); // Initialize vars to 0
    }
    vars->SetName(GetInput()->GetInfo().GetAttributes().GetVariableName().c_str());
    rg->GetCellData()->AddArray(vars);
    rg->GetCellData()->SetScalars(vars);
    
    // ----------------------------------------------------- //
    // --- Clip the domains against the rectilinear grid --- //
    // ----------------------------------------------------- //
    avtDataTree_p inTree = GetInputDataTree();
    std::vector<int> domainIds;
    inTree->GetAllDomainIds(domainIds); // Populate domainIds
    
    // TODO: The input data tree needs to be unravelled recursively
    // NOTE: Looks like when a domain is turned off, then it is not a part of
    // the inTree anymore, so it does not get processed.
    //for (int i = 0; i < inTree->GetNChildren(); ++i)
    //{
    //    std::cout << "Child number: " << domainIds[i] << std::endl;
    //    ClipDomain(inTree->GetChild(i));
    //}
    TraverseDomainTree(inTree);
    
// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //
std::cout << "Types and numbers of cells in sub meshes" << std::endl;
for (std::map<std::string,int>::const_iterator iter = DEBUG_CellTypeList.begin();
        iter != DEBUG_CellTypeList.end(); ++iter)
{
    if (iter->second > 0)
    {
        std::cout << iter->first << ": " << iter->second << std::endl;
    }
}
// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //

    
    Output();
    std::cout << "DONE" << std::endl;
    return;
}


void
avtRemapFilter::TraverseDomainTree(avtDataTree_p inTree)
{
    if (*inTree == NULL)
    {
        std::cout << "inTree is null" << std::endl;
        return;
    }
    
    std::vector<int> domainIds;
    inTree->GetAllDomainIds(domainIds);
    
    int numChildren = inTree->GetNChildren();
    
    if (numChildren <= 0 && !inTree->HasData())
    {
        std::cout << "No children and no data" << std::endl;
    }
    
    if (numChildren == 0)
    {
        std::cout << "Number of children is 0. Clipping this domain." << std::endl;
        std::cout << "Domain Id: " << domainIds[0] << std::endl;
        ClipDomain(inTree);
        return;
    }
    else
    {
        std::cout << "Number of children is " << numChildren
                  << ". Looping over children." << std::endl;
        for (int i = 0; i < numChildren; ++i)
        {
            if (inTree->ChildIsPresent(i))
            {
                std::cout << "Domain Id: " << domainIds[i] << std::endl;
                TraverseDomainTree(inTree->GetChild(i));
            }
        }
    }
}







void
avtRemapFilter::ClipDomain(avtDataTree_p inLeaf) {

    // --------------------------------------------------- //
    // --- Convert the avtDataTree_p into a vtkDataSet --- //
    // --------------------------------------------------- //
    avtDataRepresentation in_dr = inLeaf->GetDataRepresentation();
    int domainId = in_dr.GetDomain();
    vtkDataSet* in_ds = in_dr.GetDataVTK();
    
    // If there are no cells, then return null.
    // NOTE: When a domain is turned off, it is not a part of the input tree anymore,
    // so it is unlikely that we will hit this code.
    double nCellsIn = in_ds->GetNumberOfCells();
    if (in_ds == NULL || in_ds->GetNumberOfPoints() == 0 || nCellsIn == 0)
    {
        std::cout << "Domain " << domainId << " is invalid." << std::endl;
        in_ds->Delete();
        return;
    }
    
    // OLD CODE: might be useful for when I switch to a map
    // --------------------------- //
    // --- Setup the variables --- //
    // --------------------------- //
    // 
    // THIS HAS BEEN MOVED UP TO EXECUTE //
    // Because the rgrid is now global, we need some way to enforce the tracking
    // of each variable across the entire mesh in a consistent way. If all domains
    // have the same variables and if they are all ordered the same way,
    // then we get this automatically. However, that may not be the case. So I
    // have to use a Map to track the variables instead of an array.
    // For now, just assume that there is one variable. Add multivariables later.
    // TODO: use a Map to track multliple variables across the domains.
    // 
    // int nVariables = in_ds->GetCellData()->GetNumberOfArrays();    
    // vtkDataArray** vars;
    // vars = new vtkDataArray*[nVariables];
    // for (int vdx = 0, vdy = 0; vdx < nVariables; vdx++)
    // {
    //     vars[vdx] = vtkDoubleArray::New();
    //     vars[vdx]->SetNumberOfComponents(1); // Can only handle scalar values now
    //     vars[vdx]->SetNumberOfTuples(nCellsOut);
    //     vars[vdx]->SetName(in_ds->GetCellData()->GetArray(vdx)->GetName());
    //     
    //     rg->GetCellData()->AddArray(vars[vdx]);
    //     rg->GetCellData()->SetScalars(vars[vdx]);
    // }
    // OLD CODE END
    
    
    // ------------------------------------------------------- //
    // --- Calculate volumes of each cell in Original Grid --- //
    // ------------------------------------------------------- //
    
    // Add the original volume to the in_ds AFTER the variables have already
    // been added to rg so that we don't add an artificial variable.
    vtkDoubleArray* avtRemapOriginalVolume = CalculateCellVolumes(in_ds,
            "avtRemapOriginalVolume");
    in_ds->GetCellData()->AddArray(avtRemapOriginalVolume);
    
    
    // -------------------------------------------------------- //
    // --- Clip the input grid against the rectilinear grid --- //
    // -------------------------------------------------------- //
    
    // CURRENT CODE NEEDS REFACTOR.
    // We calculate all 6 planes each time, which costs xDim*yDim*zDim*6, but we can
    // precompute and setup a mapping between cells and planes to cost xDim+yDim+zDim

// --- DEBUG --- DEBUG -------- //
#include <float.h>
#include <cstdlib>
double DEBUG_maxDiff = DBL_MIN;
// --- DEBUG --- DEBUG -------- //
    
    // + ----- +
    // |   3   |
    // |0     1|
    // |   2   |
    // + ----- +
    
    for (vtkIdType rCell = 0; rCell < rg->GetNumberOfCells(); rCell++)
    {
        // Get the bounds from the cell.
        double cellBounds[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
        rg->GetCell(rCell)->GetBounds(cellBounds);
        
        // Loop over each plane and clip the cells
        vtkVisItClipper* last = NULL;
        // These are stored in vectors so that I can delete the pointers
        // after the clipping occurs
        std::vector<vtkVisItClipper*> clipperArray;      
        std::vector<vtkImplicitBoolean*> funcsArray;
        std::vector<vtkPlane*> planeArray;
        for (int cdx = 0; cdx < 6; cdx++) {

            if (cdx == 4 && !is3D) // Stop if only 2D
            {
                break;
            }
        
            double origin[3] = {0., 0., 0.};
            double normal[3] = {0., 0., 0.};
            if (cdx == 0) {
                origin[0] = cellBounds[cdx];
                normal[0] = -1.0;
            } else if (cdx == 1) {
                origin[0] = cellBounds[cdx];
                normal[0] = 1.0;
            } else if (cdx == 2) {
                origin[1] = cellBounds[cdx];
                normal[1] = -1.0;
            } else if (cdx == 3) {
                origin[1] = cellBounds[cdx];
                normal[1] = 1.0;
            } else if (cdx == 4) {
                origin[2] = cellBounds[cdx];
                normal[2] = -1.0;
            } else if (cdx == 5) {
                origin[2] = cellBounds[cdx];
                normal[2] = 1.0;
            }
            vtkPlane* plane = vtkPlane::New();
            plane->SetOrigin(origin);
            plane->SetNormal(normal);
            planeArray.push_back(plane);
        
            vtkImplicitBoolean* funcs = vtkImplicitBoolean::New();
            funcs->AddFunction(plane);
            funcsArray.push_back(funcs);
            
            vtkVisItClipper* clipper = vtkVisItClipper::New();
            clipper->SetInputData(in_ds);
            clipper->SetClipFunction(funcs);
            clipper->SetInsideOut(true);
            clipper->SetRemoveWholeCells(false);
            
            if (last != NULL) {
                clipper->SetInputConnection(last->GetOutputPort());
            }
            last = clipper;
            clipperArray.push_back(clipper);
        } // end clipping loop
        
        // Collection of clipped cells from the original grid that now take the shape
        // of the rgrid cell, could be something like this:
        // + -------------- +
        // |   |      /     |
        // |   |     /      |
        // |   ^    /------ |
        // |  / \  /    |   |
        // | /   \/     |   |
        // |/     \     |   |
        // + -------------- +
        last->Update();
        vtkUnstructuredGrid* ug = vtkUnstructuredGrid::New();
        ug->DeepCopy(last->GetOutput());
    
        // --- Calculate volume of subcells --- //
        // Now that we have the unstrucutred grid from the clipping, we can loop
        // over the subcells in that grid, calculate the volumes, and generate
        // a new volume for the rectilinear grid. We also need the ratio
        // between old and new volumes to weigh the variables (like mass, density,
        // pressure, etc.).
        
        vtkDoubleArray* subCellVolumes = CalculateCellVolumes(ug, "subCellVolume");
        
// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //
double DEBUG_rCellVolumeTEST = 0.0;
for (vtkIdType j = 0; j < subCellVolumes->GetNumberOfTuples(); j++) {
    DEBUG_rCellVolumeTEST += subCellVolumes->GetComponent(j,0);
}
if (DEBUG_rCellVolumeTEST != rCellVolume)
{
    double diff = std::abs(DEBUG_rCellVolumeTEST - rCellVolume);
    DEBUG_maxDiff = diff > DEBUG_maxDiff ? diff : DEBUG_maxDiff;
    // std::cout << "Volume from subcells: " << DEBUG_rCellVolumeTEST << std::endl;
}
// --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG --- DEBUG ---- //
        
        // Get the volume of the original cells for this ugrid
        vtkDoubleArray* originalCellVolumes = vtkDoubleArray::SafeDownCast(
            ug->GetCellData()->GetArray("avtRemapOriginalVolume"));
        
        
        // --- Calculate variable updates --- //
        // Two types of variables: intrinsic (like density) and extrinsic (like
        // mass). To update the variables:
        //        (1) Intrinsic values must be made extrinsic within the volume of
        //            the sub cell, then totaled among the set of sub cells, then
        //            made intrinsic again within the volume of the new cell.
        //        (2) Extrinsic values must be made intrisic within the volume of
        //            original cell, then made extrinsic within the volume of the
        //            sub cell, then totaled among the set of sub cells.
        
        double value = 0.0;
        vtkDataArray* myVariable = ug->GetCellData()->GetArray(0);
        if (atts.GetVariableType() == RemapAttributes::intrinsic) // like density
        {
            for (vtkIdType tuple = 0;
                 tuple < myVariable->GetNumberOfTuples(); tuple++)
            {
                value += myVariable->GetComponent(tuple, 0) *
                    subCellVolumes->GetComponent(tuple, 0);
            }
            value /= rCellVolume;
            vars->SetComponent(rCell, 0, value + vars->GetComponent(rCell, 0));
        }
        else if (atts.GetVariableType() == RemapAttributes::extrinsic) // like mass
        {
            for (vtkIdType tuple = 0;
                 tuple < myVariable->GetNumberOfTuples(); tuple++)
            {
                value += myVariable->GetComponent(tuple, 0) / 
                    originalCellVolumes->GetComponent(tuple, 0) *
                    subCellVolumes->GetComponent(tuple, 0);
            }
            vars->SetComponent(rCell, 0, value + vars->GetComponent(rCell, 0));
        }
        else
        {
            std::cout << "Should not be possible to get here... " << std::endl;
        }
        
        // --- Clean up --- //
        //std::cout << "Deleting myVariable" << std::endl;
        //myVariable->Delete();
        //std::cout << "Deleting originalCellVolumes" << std::endl;
        //originalCellVolumes->Delete();
        //std::cout << "Deleting subCellVolumes" << std::endl;
        //subCellVolumes->Delete();
        //std::cout << "Deleting ug" << std::endl;
        // ug->Delete();
        //std::cout << "Does not like trying to delete ug" << std::endl;
        //std::cout << "Deleting vectors" << std::endl;
        //std::cout << "Does not like trying to delete vectors" << std::endl;
        //int stop = is3D ? 6 : 4;
        //for (int i = 0; i < stop; ++i)
        //{
            //clipperArray[i]->Delete();
            //funcsArray[i]->Delete();
            //planeArray[i]->Delete();
        //}
        //std::cout << "Deleting last" << std::endl;
        //last->Delete();
    } // End loop over rCells
    
    // --- More Clean up --- //
    //std::cout << "Deleting avtRemapOriginVolume" << std::endl;
    //avtRemapOriginalVolume->Delete();
    //std::cout << "Deleting in_ds" << std::endl;
    //in_ds->Delete();
    
    return;
} // End ClipDomain





void
avtRemapFilter::Output() {
    avtDataTree_p outTree = new avtDataTree(rg, 0);
    SetOutputDataTree(outTree);
}

// ****************************************************************************
//  Method: avtResampleFilter::CalculateCellVolumes
//
//  Purpose:
//      Calculates the volumes of the cells in a vtkDataSet. Stores the volumes
//        in a vtkDoubleArray.
//
//  Arguments:
//      in_ds       Input vtkDataSet* that represents the input mesh.
//        name        The desired name for the array. If empty then vtk default.
//
//  Returns: av vtkDoubleArray* that stores the volumes of each cell.
//
//  Programmer: Edward Rusu
//  Creation:   Nov 9, 2018
//
// ****************************************************************************


inline void
Swap1(double &a, double &b)
{
    double tmp = a;
    a = b;
    b = tmp;
}

inline void
Swap3(double c[][3], int a, int b)
{
    Swap1(c[a][0], c[b][0]);
    Swap1(c[a][1], c[b][1]);
    Swap1(c[a][2], c[b][2]);
}

inline
void Copy3(double coords[][3], double a[], int i)
{
    a[0] = coords[i][0];
    a[1] = coords[i][1];
    a[2] = coords[i][2];
}

vtkDoubleArray*
avtRemapFilter::CalculateCellVolumes(vtkDataSet* in_ds, const char* name)
{
    vtkDoubleArray* volumeArray = vtkDoubleArray::New(); // return element
    
    // Set up necessary variables
    const int MAXPOINTS = 100; // Set maximum number of points per cell to 100
    double coordinates[MAXPOINTS][3]; // array of points for each cell in 3D
    
    // Get information from the mesh
    int nCells = in_ds->GetNumberOfCells();
    
    // Setup the volumeArray
    if (name != "")
    {
        volumeArray->SetName(name);
    }
    volumeArray->SetNumberOfComponents(1);
    volumeArray->SetNumberOfTuples(nCells);
    
    for (vtkIdType i = 0; i < nCells; i++)
    {
        double volume = 0.0;
        vtkCell* cell = in_ds->GetCell(i); // Get the cell
        vtkDataArray* pointData = cell->GetPoints()->GetData(); // Get the points
        for (vtkIdType j = 0; j < cell->GetNumberOfPoints(); j++)
        {
            coordinates[j][2] = 0; // Set to 0 in case 2D
            pointData->GetTuple(j, coordinates[j]); // Set the j-th entry in coordiantes to the tuple from pointData at j
        }
        
        int subdiv[3][4] = { {0,5,4,3}, {0,2,1,4}, {0,4,5,2} };
        // ^ Need this to be before switch otherwise ill-formed program.
        switch(cell->GetCellType()) // right now only support Triangle and Quad
        {
            case VTK_TRIANGLE:
DEBUG_CellTypeList["VTK_TRIANGLE"]++;
                volume = v_tri_area(3, coordinates);
                break;
            case VTK_QUAD:
DEBUG_CellTypeList["VTK_QUAD"]++;
                //volume = v_quad_area(3, coordinates);
                volume = v_quad_area(4, coordinates);
                // Based on V_QuadMetric, I believe this should be 4.
                // TODO: run tests and see if there is a change in the output
                break;
            case VTK_PIXEL:
DEBUG_CellTypeList["VTK_PIXEL"]++;
                Swap3(coordinates, 2, 3);
                volume = v_quad_area(4, coordinates);
                break;
            case VTK_VOXEL:
DEBUG_CellTypeList["VTK_VOXEL"]++;
                Swap3(coordinates, 2, 3);
                Swap3(coordinates, 6, 7);
                volume = v_hex_volume(8, coordinates);
                break;
            case VTK_HEXAHEDRON:
DEBUG_CellTypeList["VTK_HEXAHEDRON"]++;
                volume = v_hex_volume(8, coordinates);
                break;
            case VTK_TETRA:
DEBUG_CellTypeList["VTK_TETRA"]++;
                volume = v_tet_volume(4, coordinates);
                break;
            case VTK_WEDGE:
DEBUG_CellTypeList["VTK_WEDGE"]++;
                double tet_coordinates[4][3];
                volume = 0;
                for (int i = 0 ; i < 3 ; i++)
                {
                    for (int j = 0 ; j < 4 ; j++)
                        for (int k = 0 ; k < 3 ; k++)
                            tet_coordinates[j][k] = coordinates[subdiv[i][j]][k];
                    volume += v_tet_volume(4, tet_coordinates);
                }
                break;
            case VTK_PYRAMID:
DEBUG_CellTypeList["VTK_PYRAMID"]++;
                double one[4][3];
                double two[4][3];
                Copy3(coordinates,one[0], 0);
                Copy3(coordinates,one[1], 1);
                Copy3(coordinates,one[2], 2);
                Copy3(coordinates,one[3], 4);
                Copy3(coordinates,two[0], 0);
                Copy3(coordinates,two[1], 2);
                Copy3(coordinates,two[2], 3);
                Copy3(coordinates,two[3], 4);
                volume = v_tet_volume(4,one) + v_tet_volume(4, two);
                break;
            default:
DEBUG_CellTypeList["unknown"]++;
                std::cout << "Cannot calculate volume for cell of type: "
                          << cell->GetCellType() << std::endl
                          << "Scalars won't be remapped." << std::endl;
                break;
        } // End switch
        
        volumeArray->SetComponent(i, 0, volume); // store the volume in our array
        
        // --- Clean up --- //
        // pointData->Delete();
        // cell->Delete();
    }
    
    
    return volumeArray;
}

// ****************************************************************************
//  Method: avtResampleFilter::GetBounds
//
//  Purpose:
//      Obtains the bounds of the resampled volume.  This could come from
//      attributes, or the existing spatial extents of the input.
//
//  Arguments:
//      bounds       Output array.  Format is min/max X, then m/m Y, m/m Z.
//
//  Returns: whether or not these specify 3-dimensional bounds.
//
//  Programmer: Tom Fogal
//  Creation:   June 23, 2009
//
//  Modifications:
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
//    Hank Childs, Tue Nov 30 21:54:43 PST 2010
//    Remove const qualification.
//
// ****************************************************************************
void
avtRemapFilter::GetBounds()
{
    // TODO: fix errors that arise from the bounds
    if (!atts.GetUseExtents())
    {
        rGridBounds[0] = atts.GetStartX();
        rGridBounds[1] = atts.GetEndX();
        rGridBounds[2] = atts.GetStartY();
        rGridBounds[3] = atts.GetEndY();
        rGridBounds[4] = atts.GetStartZ();
        rGridBounds[5] = atts.GetEndZ();
    }
    else
    {
        const avtDataAttributes &datts = GetInput()->GetInfo().GetAttributes();
        avtExtents *exts = datts.GetDesiredSpatialExtents();
        if (exts->HasExtents())
        {
            exts->CopyTo(rGridBounds);
        }
        else
        {
            GetSpatialExtents(rGridBounds);
        }
        // exts->Delete();
    }
    if (fabs(rGridBounds[4]) < 1e-100 && fabs(rGridBounds[5]) < 1e-100)
    {
        is3D = false;
    }
    else {
        is3D = atts.GetIs3D();
    }
}

// ****************************************************************************
//  Method: CreateGrid
//
//  Purpose:
//      Creates a rectilinear grid that makes sense for the bounds of the
//      original dataset.
//
//  Arguments:
//      bounds    The bounds of the original dataset.
//      numX      The number of samples in X.
//      numY      The number of samples in Y.
//      minX      The minimum X index for this processor.
//      maxX      The maximum Y index for this processor.
//      minY      The minimum X index for this processor.
//      maxY      The maximum Y index for this processor.
//
//  Programmer:   Hank Childs
//  Creation:     March 26, 2001
//
//  Modifications:
//
//    Kathleen Bonnell, Mon Nov 19 15:31:36 PST 2001
//    Use vtkDataArray instead of vtkScalars to match VTK 4.0 API.
//
//    Hank Childs, Tue Feb  5 09:49:34 PST 2002
//    Use double for bounds.
//
//    Hank Childs, Fri Sep 30 10:50:24 PDT 2005
//    Add support for distributed resampling.
//
//    Hank Childs, Fri Jun  1 16:17:51 PDT 2007
//    Add support for cell-centered data.
//
//    Gunther H. Weber, Wed Aug  3 11:55:02 PDT 2011
//    Ensure that 2D data sets are 2D even for cell centered case
//
// ****************************************************************************

void
avtRemapFilter::CreateGrid(int numX, int numY, int numZ,
        int minX, int maxX, int minY, int maxY, int minZ, int maxZ)
{
    vtkDataArray *xc = NULL;
    vtkDataArray *yc = NULL;
    vtkDataArray *zc = NULL;

    double width  = rGridBounds[1] - rGridBounds[0];
    double height = rGridBounds[3] - rGridBounds[2];
    double depth  = rGridBounds[5] - rGridBounds[4];

    xc = GetCoordinates(rGridBounds[0], width, numX+1, minX, maxX+1);
    yc = GetCoordinates(rGridBounds[2], height, numY+1, minY, maxY+1);
    zc = GetCoordinates(rGridBounds[4], depth, numZ+1, minZ, maxZ+1);

    rg->SetDimensions(maxX-minX+1, maxY-minY+1, maxZ-minZ+1);
    rg->SetXCoordinates(xc);
    xc->Delete();
    rg->SetYCoordinates(yc);
    yc->Delete();
    rg->SetZCoordinates(zc);
    zc->Delete();
}

void
avtRemapFilter::CreateGrid(
        int numX, int numY, int minX, int maxX, int minY, int maxY)
{
    vtkDataArray *xc = NULL;
    vtkDataArray *yc = NULL;
    vtkDataArray *zc = NULL;

    double width  = rGridBounds[1] - rGridBounds[0];
    double height = rGridBounds[3] - rGridBounds[2];

    xc = GetCoordinates(rGridBounds[0], width, numX+1, minX, maxX+1);
    yc = GetCoordinates(rGridBounds[2], height, numY+1, minY, maxY+1);
    zc = GetCoordinates(rGridBounds[4], 0, 1, 0, 1);

    rg->SetDimensions(maxX-minX+1, maxY-minY+1, 1);
    rg->SetXCoordinates(xc);
    xc->Delete();
    rg->SetYCoordinates(yc);
    yc->Delete();
    rg->SetZCoordinates(zc);
    zc->Delete();
}


// ****************************************************************************
//  Function: GetCoordinates
//
//  Purpose:
//      Creates a coordinates array based on specifications.
//
//  Arguments:
//      start    The start of the coordinates array.
//      length   The length of the coordinates array.
//      numEls   The number of elements in the coordinates array.
//
//  Returns:     A vtkDataArray element for the coordinate.
//
//  Programmer:  Hank Childs
//  Creation:    March 26, 2001
//
//  Modifications:
//    Kathleen Bonnell, Mon Nov 19 15:31:36 PST 2001
//    Changes in VTK 4.0 API require use of vtkDataArray /vtkFloatArray
//    in place of vtkScalars. 
//
//    Hank Childs, Fri Sep 30 10:50:24 PDT 2005
//    Add support for distributed resampling.
//
// ****************************************************************************

vtkDataArray *
avtRemapFilter::GetCoordinates(double start, double length, int numEls, int myStart, int myStop)
{
    vtkDoubleArray *rv = vtkDoubleArray::New();

    //
    // Make sure we don't have any degenerate cases here.
    //
    if (length <= 0. || numEls <= 1 || myStart >= myStop)
    {
        rv->SetNumberOfValues(1);
        rv->SetValue(0, start);
        return rv;
    }

    int realNumEls = myStop - myStart;
    rv->SetNumberOfValues(realNumEls);
    double offset = length / (numEls-1);
    for (int i = myStart ; i < myStop ; i++)
    {
        rv->SetValue(i-myStart, start + i*offset);
    }

    return rv;
}











// **
// This function isn't real. Just using it to debug.
// **

void avtRemapFilter::PrintData(avtDataRepresentation* in_dr)
{
    PrintData(in_dr->GetDataVTK());
}

void avtRemapFilter::PrintData(vtkDataSet* in_ds)
{
    for (int i = 0; i < in_ds->GetCellData()->GetNumberOfArrays(); i++)
    {
        PrintData(in_ds->GetCellData()->GetArray(i));
        /*
        vtkDataArray* myArray = in_ds->GetCellData()->GetArray(i);
        std::cout << "Array name: " << myArray->GetName()
                  << std::endl;
        std::cout << "Values: ";
        for (int j = 0; j < myArray->GetNumberOfTuples(); j++)
        {
            std::cout << "{";
            for (int k = 0; k < myArray->GetNumberOfComponents(); k++)
            {
                std::cout << myArray->GetComponent(j,k);
                if (k != myArray->GetNumberOfComponents() - 1)
                {
                    std::cout << ", ";
                }
            }
            std::cout << "}";
            if (j != myArray->GetNumberOfTuples() - 1)
            {
                std::cout << "; ";
            }
        }
        std::cout << std::endl ;
        */
    }
    std::cout << std::endl;
}

void avtRemapFilter::PrintData(vtkDataArray* myArray)
{
    if (myArray->GetName()) {
        std::cout << "Array name: " << myArray->GetName()
                  << std::endl;
    }
    std::cout << "Values: ";
    for (int j = 0; j < myArray->GetNumberOfTuples(); j++)
    {
        std::cout << "{";
        for (int k = 0; k < myArray->GetNumberOfComponents(); k++)
        {
            std::cout << myArray->GetComponent(j,k);
            if (k != myArray->GetNumberOfComponents() - 1)
            {
                std::cout << ", ";
            }
        }
        std::cout << "}";
        if (j != myArray->GetNumberOfTuples() - 1)
        {
            std::cout << "; ";
        }
    }
    std::cout << std::endl ;
}






