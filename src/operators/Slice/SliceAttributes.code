Code: SetAxisType
Prefix:
Postfix:
    UpdateOrthogonalAxes();

Code: SetFlip
Prefix:
Postfix:
    UpdateOrthogonalAxes();

Function: CopyAttributes
Declaration: virtual bool CopyAttributes(const AttributeGroup *);
Definition:
// ****************************************************************************
// Method: SliceAttributes::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the SliceAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 15 15:24:44 PST 2002
//
// Modifications:
//    Jeremy Meredith, Fri Mar 15 15:47:24 PST 2002
//    Made origin be a Point.
//
//    Jeremy Meredith, Sun Nov 17 17:38:10 PST 2002
//    Updated for some orthogonal additions.
//
//    Jeremy Meredith, Mon May  5 15:01:30 PDT 2003
//    Changed the way origin works.
//
// ****************************************************************************

bool
SliceAttributes::CopyAttributes(const AttributeGroup *atts)
{
    bool retval = false;

    if(TypeName() == atts->TypeName())
    {
        // Call assignment operator.
        const SliceAttributes *tmp = (const SliceAttributes *)atts;
        *this = *tmp;
        retval = true;
    }
    else if(atts->TypeName() == "PlaneAttributes")
    {
        if(interactive)
        {
            const PlaneAttributes *tmp = (const PlaneAttributes *)atts;
            SetOriginPoint(tmp->GetOrigin());
            SetOriginType(Point);
            SetNormal(tmp->GetNormal());
            SetUpAxis(tmp->GetUpAxis());
            SetAxisType(Arbitrary);
            retval = true;
        }
    }

    return retval;
}

Function: CreateCompatible
Declaration: virtual AttributeSubject *CreateCompatible(const std::string &) const;
Definition:
// ****************************************************************************
// Method: SliceAttributes::CreateCompatible
//
// Purpose: 
//   Creates an object of the specified type initialized with the attributes
//   from this object.
//
// Arguments:
//   tname : The typename of the object that we want to create.
//
// Returns:    A new object of the type specified by tname or 0.
//
// Note:       
//
// Programmer: Brad Whitlock
// Creation:   Mon Feb 11 15:36:32 PST 2002
//
// Modifications:
//    Jeremy Meredith, Fri Mar 15 15:42:27 PST 2002
//    Made origin be a Point.
//   
//    Jeremy Meredith, Mon May  5 15:01:30 PDT 2003
//    Changed the way origin works.
//
//    Kathleen Bonnell, Thu Jul  3 11:18:43 PDT 2003 
//    Set 'threeSpace' variable in PlaneAtts from 'project2d'. 
//
//    Gunther H. Weber, Wed Aug 15 16:30:08 PDT 2007
//    Update plane tool correctly if in fixed axis and/or intercept
//    mode. Percentage, node and zone still won't work since
//    viewer does not have access to information necessary for that.
//
// ****************************************************************************

AttributeSubject *
SliceAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;

    if(TypeName() == tname)
    {
        retval = new SliceAttributes(*this);
    }
    else if(tname == "PlaneAttributes")
    {
        PlaneAttributes *p = new PlaneAttributes;

        double nx = 0.;
        double ny = 0.;
        double nz = 0.;

        switch (GetAxisType())
        {
            case XAxis:
                nx = 1.;
                break;
            case YAxis:
                ny = 1.;
                break;
            case ZAxis:
                nz = 1.;
                break;
            case Arbitrary:
                nx = GetNormal()[0];
                ny = GetNormal()[1];
                nz = GetNormal()[2];
                break;
        }
        double normal[3] = { nx, ny, nz };
        p->SetNormal(normal);

        if (GetOriginType() == Intercept)
        {
            double nl = std::sqrt(nx*nx + ny*ny + nz*nz);

            // We want to make sure for orthogonal slices that "intercept" is still
            // meaningful even when the normal is pointing in the negative direction
            if (nx+ny+nz < 0 && GetAxisType() != Arbitrary)
            {
                nl *= -1;
            }

            double d = GetOriginIntercept();

            double o[3];
            o[0] = nx * d / nl;
            o[1] = ny * d / nl;
            o[2] = nz * d / nl;

            p->SetOrigin(o);
        }
        else
        {
            p->SetOrigin(GetOriginPoint());
        }

        p->SetUpAxis(GetUpAxis());
        p->SetThreeSpace(!GetProject2d());
        retval = p;
    }

    return retval;
}

Function: UpdateOrthogonalAxes
Declaration: void UpdateOrthogonalAxes();
Definition:
// ****************************************************************************
//  Method:  SliceAttributes::UpdateOrthogonalAxes
//
//  Purpose:
//    Updates upaxis and normal for an orthogonal axis.
//
//  Programmer:  Jeremy Meredith
//  Creation:    November 17, 2002
//
//  Modifications:
//    Jeremy Meredith, Mon May  5 15:01:59 PDT 2003
//    Re-ordered some fields, so the select calls needed to be changed here.
//
//    Kathleen Bonnell, Tue Jul  8 20:21:23 PDT 2003 
//    Slice now uses right-hand system when creating projection matrix.
//    Updated normals and upAxis to conform (with help from Jeremy). 
//
// ****************************************************************************
void
SliceAttributes::UpdateOrthogonalAxes()
{
    if (axisType == Arbitrary)
        return;

    switch(axisType)
    {
      case XAxis:
        if (!flip)
        {
            // X: Y vs Z
            normal[0] = -1.; normal[1] =  0.; normal[2] =  0.;
            upAxis[0] =  0.; upAxis[1] =  1.; upAxis[2] =  0.;
        }
        else
        {
            // X: Z vs Y
            normal[0] =  1.; normal[1] =  0.; normal[2] =  0.;
            upAxis[0] =  0.; upAxis[1] =  0.; upAxis[2] =  1.;
        }
        break;
      case YAxis:
        if (!flip)
        {
            // Y: Z vs X
            normal[0] =  0.; normal[1] = -1.; normal[2] =  0.;
            upAxis[0] =  0.; upAxis[1] =  0.; upAxis[2] =  1.;
        }
        else
        {
            // Y: X vs Z
            normal[0] =  0.; normal[1] =  1.; normal[2] =  0.;
            upAxis[0] =  1.; upAxis[1] =  0.; upAxis[2] =  0.;
        }
        break;
      case ZAxis:
        if (!flip)
        {
            // Z: Y vs X
            normal[0] =  0.; normal[1] =  0.; normal[2] =  1.;
            upAxis[0] =  0.; upAxis[1] =  1.; upAxis[2] =  0.;
        }
        else
        {
            // Z: X vs Y
            normal[0] =  0.; normal[1] =  0.; normal[2] = -1.;
            upAxis[0] =  1.; upAxis[1] =  0.; upAxis[2] =  0.;
        }
        break;
      default:
        break;
    }

    Select(6, (void *)normal, 3);
    Select(8, (void *)upAxis, 3);
}

