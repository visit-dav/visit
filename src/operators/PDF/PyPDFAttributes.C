// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

#include <PyPDFAttributes.h>
#include <ObserverToCallback.h>
#include <stdio.h>
#include <Py2and3Support.h>

// ****************************************************************************
// Module: PyPDFAttributes
//
// Purpose:
//   Attributes for the PDF operator
//
// Note:       Autogenerated by xml2python. Do not modify by hand!
//
// Programmer: xml2python
// Creation:   omitted
//
// ****************************************************************************

//
// This struct contains the Python type information and a PDFAttributes.
//
struct PDFAttributesObject
{
    PyObject_HEAD
    PDFAttributes *data;
    bool        owns;
    PyObject   *parent;
};

//
// Internal prototypes
//
static PyObject *NewPDFAttributes(int);
std::string
PyPDFAttributes_ToString(const PDFAttributes *atts, const char *prefix, const bool forLogging)
{
    std::string str;
    char tmpStr[1000];

    snprintf(tmpStr, 1000, "%svar1 = \"%s\"\n", prefix, atts->GetVar1().c_str());
    str += tmpStr;
    if(atts->GetVar1MinFlag())
        snprintf(tmpStr, 1000, "%svar1MinFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar1MinFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetVar1MaxFlag())
        snprintf(tmpStr, 1000, "%svar1MaxFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar1MaxFlag = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar1Min = %g\n", prefix, atts->GetVar1Min());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar1Max = %g\n", prefix, atts->GetVar1Max());
    str += tmpStr;
    const char *var1Scaling_names = "Linear, Log, Skew";
    switch (atts->GetVar1Scaling())
    {
      case PDFAttributes::Linear:
          snprintf(tmpStr, 1000, "%svar1Scaling = %sLinear  # %s\n", prefix, prefix, var1Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Log:
          snprintf(tmpStr, 1000, "%svar1Scaling = %sLog  # %s\n", prefix, prefix, var1Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Skew:
          snprintf(tmpStr, 1000, "%svar1Scaling = %sSkew  # %s\n", prefix, prefix, var1Scaling_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    snprintf(tmpStr, 1000, "%svar1SkewFactor = %g\n", prefix, atts->GetVar1SkewFactor());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar1NumSamples = %d\n", prefix, atts->GetVar1NumSamples());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar2 = \"%s\"\n", prefix, atts->GetVar2().c_str());
    str += tmpStr;
    if(atts->GetVar2MinFlag())
        snprintf(tmpStr, 1000, "%svar2MinFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar2MinFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetVar2MaxFlag())
        snprintf(tmpStr, 1000, "%svar2MaxFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar2MaxFlag = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar2Min = %g\n", prefix, atts->GetVar2Min());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar2Max = %g\n", prefix, atts->GetVar2Max());
    str += tmpStr;
    const char *var2Scaling_names = "Linear, Log, Skew";
    switch (atts->GetVar2Scaling())
    {
      case PDFAttributes::Linear:
          snprintf(tmpStr, 1000, "%svar2Scaling = %sLinear  # %s\n", prefix, prefix, var2Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Log:
          snprintf(tmpStr, 1000, "%svar2Scaling = %sLog  # %s\n", prefix, prefix, var2Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Skew:
          snprintf(tmpStr, 1000, "%svar2Scaling = %sSkew  # %s\n", prefix, prefix, var2Scaling_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    snprintf(tmpStr, 1000, "%svar2SkewFactor = %g\n", prefix, atts->GetVar2SkewFactor());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar2NumSamples = %d\n", prefix, atts->GetVar2NumSamples());
    str += tmpStr;
    const char *numAxes_names = "Two, Three";
    switch (atts->GetNumAxes())
    {
      case PDFAttributes::Two:
          snprintf(tmpStr, 1000, "%snumAxes = %sTwo  # %s\n", prefix, prefix, numAxes_names);
          str += tmpStr;
          break;
      case PDFAttributes::Three:
          snprintf(tmpStr, 1000, "%snumAxes = %sThree  # %s\n", prefix, prefix, numAxes_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    snprintf(tmpStr, 1000, "%svar3 = \"%s\"\n", prefix, atts->GetVar3().c_str());
    str += tmpStr;
    if(atts->GetVar3MinFlag())
        snprintf(tmpStr, 1000, "%svar3MinFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar3MinFlag = 0\n", prefix);
    str += tmpStr;
    if(atts->GetVar3MaxFlag())
        snprintf(tmpStr, 1000, "%svar3MaxFlag = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%svar3MaxFlag = 0\n", prefix);
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar3Min = %g\n", prefix, atts->GetVar3Min());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar3Max = %g\n", prefix, atts->GetVar3Max());
    str += tmpStr;
    const char *var3Scaling_names = "Linear, Log, Skew";
    switch (atts->GetVar3Scaling())
    {
      case PDFAttributes::Linear:
          snprintf(tmpStr, 1000, "%svar3Scaling = %sLinear  # %s\n", prefix, prefix, var3Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Log:
          snprintf(tmpStr, 1000, "%svar3Scaling = %sLog  # %s\n", prefix, prefix, var3Scaling_names);
          str += tmpStr;
          break;
      case PDFAttributes::Skew:
          snprintf(tmpStr, 1000, "%svar3Scaling = %sSkew  # %s\n", prefix, prefix, var3Scaling_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    snprintf(tmpStr, 1000, "%svar3SkewFactor = %g\n", prefix, atts->GetVar3SkewFactor());
    str += tmpStr;
    snprintf(tmpStr, 1000, "%svar3NumSamples = %d\n", prefix, atts->GetVar3NumSamples());
    str += tmpStr;
    if(atts->GetScaleCube())
        snprintf(tmpStr, 1000, "%sscaleCube = 1\n", prefix);
    else
        snprintf(tmpStr, 1000, "%sscaleCube = 0\n", prefix);
    str += tmpStr;
    const char *densityType_names = "Probability, ZoneCount";
    switch (atts->GetDensityType())
    {
      case PDFAttributes::Probability:
          snprintf(tmpStr, 1000, "%sdensityType = %sProbability  # %s\n", prefix, prefix, densityType_names);
          str += tmpStr;
          break;
      case PDFAttributes::ZoneCount:
          snprintf(tmpStr, 1000, "%sdensityType = %sZoneCount  # %s\n", prefix, prefix, densityType_names);
          str += tmpStr;
          break;
      default:
          break;
    }

    return str;
}

static PyObject *
PDFAttributes_Notify(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    obj->data->Notify();
    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_SetVar1(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the var1 in the object.
    obj->data->SetVar1(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetVar1().c_str());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var1MinFlag in the object.
    obj->data->SetVar1MinFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar1MinFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var1MaxFlag in the object.
    obj->data->SetVar1MaxFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar1MaxFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var1Min in the object.
    obj->data->SetVar1Min(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar1Min());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var1Max in the object.
    obj->data->SetVar1Max(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar1Max());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid var1Scaling value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Linear";
        ss << ", Log";
        ss << ", Skew";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the var1Scaling in the object.
    obj->data->SetVar1Scaling(PDFAttributes::Scaling(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar1Scaling()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var1SkewFactor in the object.
    obj->data->SetVar1SkewFactor(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar1SkewFactor());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar1NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the var1NumSamples in the object.
    obj->data->SetVar1NumSamples(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar1NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar1NumSamples()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the var2 in the object.
    obj->data->SetVar2(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetVar2().c_str());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var2MinFlag in the object.
    obj->data->SetVar2MinFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar2MinFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var2MaxFlag in the object.
    obj->data->SetVar2MaxFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar2MaxFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var2Min in the object.
    obj->data->SetVar2Min(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar2Min());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var2Max in the object.
    obj->data->SetVar2Max(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar2Max());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid var2Scaling value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Linear";
        ss << ", Log";
        ss << ", Skew";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the var2Scaling in the object.
    obj->data->SetVar2Scaling(PDFAttributes::Scaling(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar2Scaling()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var2SkewFactor in the object.
    obj->data->SetVar2SkewFactor(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar2SkewFactor());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar2NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the var2NumSamples in the object.
    obj->data->SetVar2NumSamples(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar2NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar2NumSamples()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetNumAxes(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 2)
    {
        std::stringstream ss;
        ss << "An invalid numAxes value was given." << std::endl;
        ss << "Valid values are in the range [0,1]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Two";
        ss << ", Three";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the numAxes in the object.
    obj->data->SetNumAxes(PDFAttributes::NumAxes(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetNumAxes(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetNumAxes()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged as first member of a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyUnicode_Check(packaged_args))
            args = packaged_args;
    }

    if (!PyUnicode_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a unicode string");
    }

    char const *val = PyUnicode_AsUTF8(args);
    std::string cval = std::string(val);

    if (val == 0 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as utf8 string");
    }

    Py_XDECREF(packaged_args);

    // Set the var3 in the object.
    obj->data->SetVar3(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetVar3().c_str());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var3MinFlag in the object.
    obj->data->SetVar3MinFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3MinFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar3MinFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the var3MaxFlag in the object.
    obj->data->SetVar3MaxFlag(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3MaxFlag(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetVar3MaxFlag()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var3Min in the object.
    obj->data->SetVar3Min(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3Min(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar3Min());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var3Max in the object.
    obj->data->SetVar3Max(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3Max(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar3Max());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 3)
    {
        std::stringstream ss;
        ss << "An invalid var3Scaling value was given." << std::endl;
        ss << "Valid values are in the range [0,2]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Linear";
        ss << ", Log";
        ss << ", Skew";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the var3Scaling in the object.
    obj->data->SetVar3Scaling(PDFAttributes::Scaling(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3Scaling(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar3Scaling()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    double val = PyFloat_AsDouble(args);
    double cval = double(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ double");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(double(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ double");
    }

    Py_XDECREF(packaged_args);

    // Set the var3SkewFactor in the object.
    obj->data->SetVar3SkewFactor(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3SkewFactor(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyFloat_FromDouble(obj->data->GetVar3SkewFactor());
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetVar3NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ int");
    }

    Py_XDECREF(packaged_args);

    // Set the var3NumSamples in the object.
    obj->data->SetVar3NumSamples(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetVar3NumSamples(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetVar3NumSamples()));
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetScaleCube(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    bool cval = bool(val);

    if (val == -1 && PyErr_Occurred())
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ bool");
    }
    if (fabs(double(val))>1.5E-7 && fabs((double(long(cval))-double(val))/double(val))>1.5E-7)
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_ValueError, "arg not interpretable as C++ bool");
    }

    Py_XDECREF(packaged_args);

    // Set the scaleCube in the object.
    obj->data->SetScaleCube(cval);

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetScaleCube(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetScaleCube()?1L:0L);
    return retval;
}

/*static*/ PyObject *
PDFAttributes_SetDensityType(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;

    PyObject *packaged_args = 0;

    // Handle args packaged into a tuple of size one
    // if we think the unpackaged args matches our needs
    if (PySequence_Check(args) && PySequence_Size(args) == 1)
    {
        packaged_args = PySequence_GetItem(args, 0);
        if (PyNumber_Check(packaged_args))
            args = packaged_args;
    }

    if (PySequence_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "expecting a single number arg");
    }

    if (!PyNumber_Check(args))
    {
        Py_XDECREF(packaged_args);
        return PyErr_Format(PyExc_TypeError, "arg is not a number type");
    }

    long val = PyLong_AsLong(args);
    int cval = int(val);

    if ((val == -1 && PyErr_Occurred()) || long(cval) != val)
    {
        Py_XDECREF(packaged_args);
        PyErr_Clear();
        return PyErr_Format(PyExc_TypeError, "arg not interpretable as C++ int");
    }

    if (cval < 0 || cval >= 2)
    {
        std::stringstream ss;
        ss << "An invalid densityType value was given." << std::endl;
        ss << "Valid values are in the range [0,1]." << std::endl;
        ss << "You can also use the following symbolic names:";
        ss << " Probability";
        ss << ", ZoneCount";
        return PyErr_Format(PyExc_ValueError, ss.str().c_str());
    }

    Py_XDECREF(packaged_args);

    // Set the densityType in the object.
    obj->data->SetDensityType(PDFAttributes::DensityType(cval));

    Py_INCREF(Py_None);
    return Py_None;
}

/*static*/ PyObject *
PDFAttributes_GetDensityType(PyObject *self, PyObject *args)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetDensityType()));
    return retval;
}



PyMethodDef PyPDFAttributes_methods[PDFATTRIBUTES_NMETH] = {
    {"Notify", PDFAttributes_Notify, METH_VARARGS},
    {"SetVar1", PDFAttributes_SetVar1, METH_VARARGS},
    {"GetVar1", PDFAttributes_GetVar1, METH_VARARGS},
    {"SetVar1MinFlag", PDFAttributes_SetVar1MinFlag, METH_VARARGS},
    {"GetVar1MinFlag", PDFAttributes_GetVar1MinFlag, METH_VARARGS},
    {"SetVar1MaxFlag", PDFAttributes_SetVar1MaxFlag, METH_VARARGS},
    {"GetVar1MaxFlag", PDFAttributes_GetVar1MaxFlag, METH_VARARGS},
    {"SetVar1Min", PDFAttributes_SetVar1Min, METH_VARARGS},
    {"GetVar1Min", PDFAttributes_GetVar1Min, METH_VARARGS},
    {"SetVar1Max", PDFAttributes_SetVar1Max, METH_VARARGS},
    {"GetVar1Max", PDFAttributes_GetVar1Max, METH_VARARGS},
    {"SetVar1Scaling", PDFAttributes_SetVar1Scaling, METH_VARARGS},
    {"GetVar1Scaling", PDFAttributes_GetVar1Scaling, METH_VARARGS},
    {"SetVar1SkewFactor", PDFAttributes_SetVar1SkewFactor, METH_VARARGS},
    {"GetVar1SkewFactor", PDFAttributes_GetVar1SkewFactor, METH_VARARGS},
    {"SetVar1NumSamples", PDFAttributes_SetVar1NumSamples, METH_VARARGS},
    {"GetVar1NumSamples", PDFAttributes_GetVar1NumSamples, METH_VARARGS},
    {"SetVar2", PDFAttributes_SetVar2, METH_VARARGS},
    {"GetVar2", PDFAttributes_GetVar2, METH_VARARGS},
    {"SetVar2MinFlag", PDFAttributes_SetVar2MinFlag, METH_VARARGS},
    {"GetVar2MinFlag", PDFAttributes_GetVar2MinFlag, METH_VARARGS},
    {"SetVar2MaxFlag", PDFAttributes_SetVar2MaxFlag, METH_VARARGS},
    {"GetVar2MaxFlag", PDFAttributes_GetVar2MaxFlag, METH_VARARGS},
    {"SetVar2Min", PDFAttributes_SetVar2Min, METH_VARARGS},
    {"GetVar2Min", PDFAttributes_GetVar2Min, METH_VARARGS},
    {"SetVar2Max", PDFAttributes_SetVar2Max, METH_VARARGS},
    {"GetVar2Max", PDFAttributes_GetVar2Max, METH_VARARGS},
    {"SetVar2Scaling", PDFAttributes_SetVar2Scaling, METH_VARARGS},
    {"GetVar2Scaling", PDFAttributes_GetVar2Scaling, METH_VARARGS},
    {"SetVar2SkewFactor", PDFAttributes_SetVar2SkewFactor, METH_VARARGS},
    {"GetVar2SkewFactor", PDFAttributes_GetVar2SkewFactor, METH_VARARGS},
    {"SetVar2NumSamples", PDFAttributes_SetVar2NumSamples, METH_VARARGS},
    {"GetVar2NumSamples", PDFAttributes_GetVar2NumSamples, METH_VARARGS},
    {"SetNumAxes", PDFAttributes_SetNumAxes, METH_VARARGS},
    {"GetNumAxes", PDFAttributes_GetNumAxes, METH_VARARGS},
    {"SetVar3", PDFAttributes_SetVar3, METH_VARARGS},
    {"GetVar3", PDFAttributes_GetVar3, METH_VARARGS},
    {"SetVar3MinFlag", PDFAttributes_SetVar3MinFlag, METH_VARARGS},
    {"GetVar3MinFlag", PDFAttributes_GetVar3MinFlag, METH_VARARGS},
    {"SetVar3MaxFlag", PDFAttributes_SetVar3MaxFlag, METH_VARARGS},
    {"GetVar3MaxFlag", PDFAttributes_GetVar3MaxFlag, METH_VARARGS},
    {"SetVar3Min", PDFAttributes_SetVar3Min, METH_VARARGS},
    {"GetVar3Min", PDFAttributes_GetVar3Min, METH_VARARGS},
    {"SetVar3Max", PDFAttributes_SetVar3Max, METH_VARARGS},
    {"GetVar3Max", PDFAttributes_GetVar3Max, METH_VARARGS},
    {"SetVar3Scaling", PDFAttributes_SetVar3Scaling, METH_VARARGS},
    {"GetVar3Scaling", PDFAttributes_GetVar3Scaling, METH_VARARGS},
    {"SetVar3SkewFactor", PDFAttributes_SetVar3SkewFactor, METH_VARARGS},
    {"GetVar3SkewFactor", PDFAttributes_GetVar3SkewFactor, METH_VARARGS},
    {"SetVar3NumSamples", PDFAttributes_SetVar3NumSamples, METH_VARARGS},
    {"GetVar3NumSamples", PDFAttributes_GetVar3NumSamples, METH_VARARGS},
    {"SetScaleCube", PDFAttributes_SetScaleCube, METH_VARARGS},
    {"GetScaleCube", PDFAttributes_GetScaleCube, METH_VARARGS},
    {"SetDensityType", PDFAttributes_SetDensityType, METH_VARARGS},
    {"GetDensityType", PDFAttributes_GetDensityType, METH_VARARGS},
    {NULL, NULL}
};

//
// Type functions
//

static void
PDFAttributes_dealloc(PyObject *v)
{
   PDFAttributesObject *obj = (PDFAttributesObject *)v;
   if(obj->parent != 0)
       Py_DECREF(obj->parent);
   if(obj->owns)
       delete obj->data;
}

static PyObject *PDFAttributes_richcompare(PyObject *self, PyObject *other, int op);
PyObject *
PyPDFAttributes_getattr(PyObject *self, char *name)
{
    if(strcmp(name, "var1") == 0)
        return PDFAttributes_GetVar1(self, NULL);
    if(strcmp(name, "var1MinFlag") == 0)
        return PDFAttributes_GetVar1MinFlag(self, NULL);
    if(strcmp(name, "var1MaxFlag") == 0)
        return PDFAttributes_GetVar1MaxFlag(self, NULL);
    if(strcmp(name, "var1Min") == 0)
        return PDFAttributes_GetVar1Min(self, NULL);
    if(strcmp(name, "var1Max") == 0)
        return PDFAttributes_GetVar1Max(self, NULL);
    if(strcmp(name, "var1Scaling") == 0)
        return PDFAttributes_GetVar1Scaling(self, NULL);
    if(strcmp(name, "Linear") == 0)
        return PyInt_FromLong(long(PDFAttributes::Linear));
    if(strcmp(name, "Log") == 0)
        return PyInt_FromLong(long(PDFAttributes::Log));
    if(strcmp(name, "Skew") == 0)
        return PyInt_FromLong(long(PDFAttributes::Skew));

    if(strcmp(name, "var1SkewFactor") == 0)
        return PDFAttributes_GetVar1SkewFactor(self, NULL);
    if(strcmp(name, "var1NumSamples") == 0)
        return PDFAttributes_GetVar1NumSamples(self, NULL);
    if(strcmp(name, "var2") == 0)
        return PDFAttributes_GetVar2(self, NULL);
    if(strcmp(name, "var2MinFlag") == 0)
        return PDFAttributes_GetVar2MinFlag(self, NULL);
    if(strcmp(name, "var2MaxFlag") == 0)
        return PDFAttributes_GetVar2MaxFlag(self, NULL);
    if(strcmp(name, "var2Min") == 0)
        return PDFAttributes_GetVar2Min(self, NULL);
    if(strcmp(name, "var2Max") == 0)
        return PDFAttributes_GetVar2Max(self, NULL);
    if(strcmp(name, "var2Scaling") == 0)
        return PDFAttributes_GetVar2Scaling(self, NULL);
    if(strcmp(name, "Linear") == 0)
        return PyInt_FromLong(long(PDFAttributes::Linear));
    if(strcmp(name, "Log") == 0)
        return PyInt_FromLong(long(PDFAttributes::Log));
    if(strcmp(name, "Skew") == 0)
        return PyInt_FromLong(long(PDFAttributes::Skew));

    if(strcmp(name, "var2SkewFactor") == 0)
        return PDFAttributes_GetVar2SkewFactor(self, NULL);
    if(strcmp(name, "var2NumSamples") == 0)
        return PDFAttributes_GetVar2NumSamples(self, NULL);
    if(strcmp(name, "numAxes") == 0)
        return PDFAttributes_GetNumAxes(self, NULL);
    if(strcmp(name, "Two") == 0)
        return PyInt_FromLong(long(PDFAttributes::Two));
    if(strcmp(name, "Three") == 0)
        return PyInt_FromLong(long(PDFAttributes::Three));

    if(strcmp(name, "var3") == 0)
        return PDFAttributes_GetVar3(self, NULL);
    if(strcmp(name, "var3MinFlag") == 0)
        return PDFAttributes_GetVar3MinFlag(self, NULL);
    if(strcmp(name, "var3MaxFlag") == 0)
        return PDFAttributes_GetVar3MaxFlag(self, NULL);
    if(strcmp(name, "var3Min") == 0)
        return PDFAttributes_GetVar3Min(self, NULL);
    if(strcmp(name, "var3Max") == 0)
        return PDFAttributes_GetVar3Max(self, NULL);
    if(strcmp(name, "var3Scaling") == 0)
        return PDFAttributes_GetVar3Scaling(self, NULL);
    if(strcmp(name, "Linear") == 0)
        return PyInt_FromLong(long(PDFAttributes::Linear));
    if(strcmp(name, "Log") == 0)
        return PyInt_FromLong(long(PDFAttributes::Log));
    if(strcmp(name, "Skew") == 0)
        return PyInt_FromLong(long(PDFAttributes::Skew));

    if(strcmp(name, "var3SkewFactor") == 0)
        return PDFAttributes_GetVar3SkewFactor(self, NULL);
    if(strcmp(name, "var3NumSamples") == 0)
        return PDFAttributes_GetVar3NumSamples(self, NULL);
    if(strcmp(name, "scaleCube") == 0)
        return PDFAttributes_GetScaleCube(self, NULL);
    if(strcmp(name, "densityType") == 0)
        return PDFAttributes_GetDensityType(self, NULL);
    if(strcmp(name, "Probability") == 0)
        return PyInt_FromLong(long(PDFAttributes::Probability));
    if(strcmp(name, "ZoneCount") == 0)
        return PyInt_FromLong(long(PDFAttributes::ZoneCount));



    // Add a __dict__ answer so that dir() works
    if (!strcmp(name, "__dict__"))
    {
        PyObject *result = PyDict_New();
        for (int i = 0; PyPDFAttributes_methods[i].ml_meth; i++)
            PyDict_SetItem(result,
                PyString_FromString(PyPDFAttributes_methods[i].ml_name),
                PyString_FromString(PyPDFAttributes_methods[i].ml_name));
        return result;
    }

    return Py_FindMethod(PyPDFAttributes_methods, self, name);
}

int
PyPDFAttributes_setattr(PyObject *self, char *name, PyObject *args)
{
    PyObject NULL_PY_OBJ;
    PyObject *obj = &NULL_PY_OBJ;

    if(strcmp(name, "var1") == 0)
        obj = PDFAttributes_SetVar1(self, args);
    else if(strcmp(name, "var1MinFlag") == 0)
        obj = PDFAttributes_SetVar1MinFlag(self, args);
    else if(strcmp(name, "var1MaxFlag") == 0)
        obj = PDFAttributes_SetVar1MaxFlag(self, args);
    else if(strcmp(name, "var1Min") == 0)
        obj = PDFAttributes_SetVar1Min(self, args);
    else if(strcmp(name, "var1Max") == 0)
        obj = PDFAttributes_SetVar1Max(self, args);
    else if(strcmp(name, "var1Scaling") == 0)
        obj = PDFAttributes_SetVar1Scaling(self, args);
    else if(strcmp(name, "var1SkewFactor") == 0)
        obj = PDFAttributes_SetVar1SkewFactor(self, args);
    else if(strcmp(name, "var1NumSamples") == 0)
        obj = PDFAttributes_SetVar1NumSamples(self, args);
    else if(strcmp(name, "var2") == 0)
        obj = PDFAttributes_SetVar2(self, args);
    else if(strcmp(name, "var2MinFlag") == 0)
        obj = PDFAttributes_SetVar2MinFlag(self, args);
    else if(strcmp(name, "var2MaxFlag") == 0)
        obj = PDFAttributes_SetVar2MaxFlag(self, args);
    else if(strcmp(name, "var2Min") == 0)
        obj = PDFAttributes_SetVar2Min(self, args);
    else if(strcmp(name, "var2Max") == 0)
        obj = PDFAttributes_SetVar2Max(self, args);
    else if(strcmp(name, "var2Scaling") == 0)
        obj = PDFAttributes_SetVar2Scaling(self, args);
    else if(strcmp(name, "var2SkewFactor") == 0)
        obj = PDFAttributes_SetVar2SkewFactor(self, args);
    else if(strcmp(name, "var2NumSamples") == 0)
        obj = PDFAttributes_SetVar2NumSamples(self, args);
    else if(strcmp(name, "numAxes") == 0)
        obj = PDFAttributes_SetNumAxes(self, args);
    else if(strcmp(name, "var3") == 0)
        obj = PDFAttributes_SetVar3(self, args);
    else if(strcmp(name, "var3MinFlag") == 0)
        obj = PDFAttributes_SetVar3MinFlag(self, args);
    else if(strcmp(name, "var3MaxFlag") == 0)
        obj = PDFAttributes_SetVar3MaxFlag(self, args);
    else if(strcmp(name, "var3Min") == 0)
        obj = PDFAttributes_SetVar3Min(self, args);
    else if(strcmp(name, "var3Max") == 0)
        obj = PDFAttributes_SetVar3Max(self, args);
    else if(strcmp(name, "var3Scaling") == 0)
        obj = PDFAttributes_SetVar3Scaling(self, args);
    else if(strcmp(name, "var3SkewFactor") == 0)
        obj = PDFAttributes_SetVar3SkewFactor(self, args);
    else if(strcmp(name, "var3NumSamples") == 0)
        obj = PDFAttributes_SetVar3NumSamples(self, args);
    else if(strcmp(name, "scaleCube") == 0)
        obj = PDFAttributes_SetScaleCube(self, args);
    else if(strcmp(name, "densityType") == 0)
        obj = PDFAttributes_SetDensityType(self, args);

    if (obj != NULL && obj != &NULL_PY_OBJ)
        Py_DECREF(obj);

    if (obj == &NULL_PY_OBJ)
    {
        obj = NULL;
        PyErr_Format(PyExc_NameError, "name '%s' is not defined", name);
    }
    else if (obj == NULL && !PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "unknown problem with '%s'", name);

    return (obj != NULL) ? 0 : -1;
}

static int
PDFAttributes_print(PyObject *v, FILE *fp, int flags)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)v;
    fprintf(fp, "%s", PyPDFAttributes_ToString(obj->data, "",false).c_str());
    return 0;
}

PyObject *
PDFAttributes_str(PyObject *v)
{
    PDFAttributesObject *obj = (PDFAttributesObject *)v;
    return PyString_FromString(PyPDFAttributes_ToString(obj->data,"", false).c_str());
}

//
// The doc string for the class.
//
#if PY_MAJOR_VERSION > 2 || (PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION >= 5)
static const char *PDFAttributes_Purpose = "Attributes for the PDF operator";
#else
static char *PDFAttributes_Purpose = "Attributes for the PDF operator";
#endif

//
// Python Type Struct Def Macro from Py2and3Support.h
//
//         VISIT_PY_TYPE_OBJ( VPY_TYPE,
//                            VPY_NAME,
//                            VPY_OBJECT,
//                            VPY_DEALLOC,
//                            VPY_PRINT,
//                            VPY_GETATTR,
//                            VPY_SETATTR,
//                            VPY_STR,
//                            VPY_PURPOSE,
//                            VPY_RICHCOMP,
//                            VPY_AS_NUMBER)

//
// The type description structure
//

VISIT_PY_TYPE_OBJ(PDFAttributesType,         \
                  "PDFAttributes",           \
                  PDFAttributesObject,       \
                  PDFAttributes_dealloc,     \
                  PDFAttributes_print,       \
                  PyPDFAttributes_getattr,   \
                  PyPDFAttributes_setattr,   \
                  PDFAttributes_str,         \
                  PDFAttributes_Purpose,     \
                  PDFAttributes_richcompare, \
                  0); /* as_number*/

//
// Helper function for comparing.
//
static PyObject *
PDFAttributes_richcompare(PyObject *self, PyObject *other, int op)
{
    // only compare against the same type 
    if ( Py_TYPE(self) != &PDFAttributesType
         || Py_TYPE(other) != &PDFAttributesType)
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    PyObject *res = NULL;
    PDFAttributes *a = ((PDFAttributesObject *)self)->data;
    PDFAttributes *b = ((PDFAttributesObject *)other)->data;

    switch (op)
    {
       case Py_EQ:
           res = (*a == *b) ? Py_True : Py_False;
           break;
       case Py_NE:
           res = (*a != *b) ? Py_True : Py_False;
           break;
       default:
           res = Py_NotImplemented;
           break;
    }

    Py_INCREF(res);
    return res;
}

//
// Helper functions for object allocation.
//

static PDFAttributes *defaultAtts = 0;
static PDFAttributes *currentAtts = 0;

static PyObject *
NewPDFAttributes(int useCurrent)
{
    PDFAttributesObject *newObject;
    newObject = PyObject_NEW(PDFAttributesObject, &PDFAttributesType);
    if(newObject == NULL)
        return NULL;
    if(useCurrent && currentAtts != 0)
        newObject->data = new PDFAttributes(*currentAtts);
    else if(defaultAtts != 0)
        newObject->data = new PDFAttributes(*defaultAtts);
    else
        newObject->data = new PDFAttributes;
    newObject->owns = true;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

static PyObject *
WrapPDFAttributes(const PDFAttributes *attr)
{
    PDFAttributesObject *newObject;
    newObject = PyObject_NEW(PDFAttributesObject, &PDFAttributesType);
    if(newObject == NULL)
        return NULL;
    newObject->data = (PDFAttributes *)attr;
    newObject->owns = false;
    newObject->parent = 0;
    return (PyObject *)newObject;
}

///////////////////////////////////////////////////////////////////////////////
//
// Interface that is exposed to the VisIt module.
//
///////////////////////////////////////////////////////////////////////////////

PyObject *
PDFAttributes_new(PyObject *self, PyObject *args)
{
    int useCurrent = 0;
    if (!PyArg_ParseTuple(args, "i", &useCurrent))
    {
        if (!PyArg_ParseTuple(args, ""))
            return NULL;
        else
            PyErr_Clear();
    }

    return (PyObject *)NewPDFAttributes(useCurrent);
}

//
// Plugin method table. These methods are added to the visitmodule's methods.
//
static PyMethodDef PDFAttributesMethods[] = {
    {"PDFAttributes", PDFAttributes_new, METH_VARARGS},
    {NULL,      NULL}        /* Sentinel */
};

static Observer *PDFAttributesObserver = 0;

std::string
PyPDFAttributes_GetLogString()
{
    std::string s("PDFAtts = PDFAttributes()\n");
    if(currentAtts != 0)
        s += PyPDFAttributes_ToString(currentAtts, "PDFAtts.", true);
    return s;
}

static void
PyPDFAttributes_CallLogRoutine(Subject *subj, void *data)
{
    typedef void (*logCallback)(const std::string &);
    logCallback cb = (logCallback)data;

    if(cb != 0)
    {
        std::string s("PDFAtts = PDFAttributes()\n");
        s += PyPDFAttributes_ToString(currentAtts, "PDFAtts.", true);
        cb(s);
    }
}

void
PyPDFAttributes_StartUp(PDFAttributes *subj, void *data)
{
    if(subj == 0)
        return;

    currentAtts = subj;
    PyPDFAttributes_SetDefaults(subj);

    //
    // Create the observer that will be notified when the attributes change.
    //
    if(PDFAttributesObserver == 0)
    {
        PDFAttributesObserver = new ObserverToCallback(subj,
            PyPDFAttributes_CallLogRoutine, (void *)data);
    }

}

void
PyPDFAttributes_CloseDown()
{
    delete defaultAtts;
    defaultAtts = 0;
    delete PDFAttributesObserver;
    PDFAttributesObserver = 0;
}

PyMethodDef *
PyPDFAttributes_GetMethodTable(int *nMethods)
{
    *nMethods = 1;
    return PDFAttributesMethods;
}

bool
PyPDFAttributes_Check(PyObject *obj)
{
    return (obj->ob_type == &PDFAttributesType);
}

PDFAttributes *
PyPDFAttributes_FromPyObject(PyObject *obj)
{
    PDFAttributesObject *obj2 = (PDFAttributesObject *)obj;
    return obj2->data;
}

PyObject *
PyPDFAttributes_New()
{
    return NewPDFAttributes(0);
}

PyObject *
PyPDFAttributes_Wrap(const PDFAttributes *attr)
{
    return WrapPDFAttributes(attr);
}

void
PyPDFAttributes_SetParent(PyObject *obj, PyObject *parent)
{
    PDFAttributesObject *obj2 = (PDFAttributesObject *)obj;
    obj2->parent = parent;
}

void
PyPDFAttributes_SetDefaults(const PDFAttributes *atts)
{
    if(defaultAtts)
        delete defaultAtts;

    defaultAtts = new PDFAttributes(*atts);
}

