Target: xml2atts
Function: CopyAttributes
Declaration: bool CopyAttributes(const AttributeGroup *atts);
Definition:
// ****************************************************************************
// Method: PoincareAttributes::CopyAttributes
//
// Purpose:
//   CopyAttributes method for the PoincareAttributes class.
//
// Programmer: Dave Pugmire
// Creation:   Tues Oct 21 14:22:17 EDT 2008
//
// Modifications:
//    Jeremy Meredith, Wed Apr  8 16:48:05 EDT 2009
//    Initial steps to unification with integral curve attributes.
// ****************************************************************************

bool
PoincareAttributes::CopyAttributes(const AttributeGroup *atts)
{
    bool retval = false;
    if(TypeName() == atts->TypeName())
    {
        // Call assignment operator.
        const PoincareAttributes *tmp = (const PoincareAttributes *)atts;
        *this = *tmp;
        retval = true;
    }
    else if(atts->TypeName() == "PointAttributes")
    {
        const PointAttributes *p = (PointAttributes *)atts;
        SetPointSource(p->GetPoint());
        retval = true;
    }
    else if(atts->TypeName() == "Line")
    {
        const Line *line = (const Line *)atts;
        SetLineStart(line->GetPoint1());
        SetLineEnd(line->GetPoint2());
        retval = true;
    }
    return retval;
}

Target: xml2atts
Function: CreateCompatible
Declaration: AttributeSubject *CreateCompatible(const std::string &tname) const;
Definition:
// ****************************************************************************
// Method: PoincareAttributes::CreateCompatible
//
// Purpose:
//   Creates a new state object of the desired type.
//
// Programmer: Dave Pugmire
// Creation:   Tues Oct 21 14:22:17 EDT 2008
//
// Modifications:
//    Jeremy Meredith, Wed Apr  8 16:48:05 EDT 2009
//    Initial steps to unification with integral curve attributes.
// ****************************************************************************

AttributeSubject *
PoincareAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if (TypeName() == tname)
    {
        retval = new PoincareAttributes(*this);
    }
    else if (tname == "PointAttributes")
    {
        PointAttributes *p = new PointAttributes;
        p->SetPoint(GetPointSource());
        retval = p;
    }
    else if (tname == "Line")
    {
        Line *l = new Line;
        l->SetPoint1(GetLineStart());
        l->SetPoint2(GetLineEnd());
        retval = l;
    }
    return retval;
}

Target: xml2atts
Function: ChangesRequireRecalculation
Declaration: bool ChangesRequireRecalculation(const PoincareAttributes &obj) const;
Definition:
// ****************************************************************************
// Method: PoincareAttributes::ChangesRequireRecalculation
//
// Purpose:
//   Determine if attribute changes require recalculation.
//
// Programmer: Dave Pugmire
// Creation:   Tues Oct 21 14:22:17 EDT 2008
//
// Modifications:
//
// ****************************************************************************

bool
PoincareAttributes::ChangesRequireRecalculation(const PoincareAttributes &obj) const
{
    std::cerr << IntegralCurveAttsRequireRecalculation(obj) << "  "
              << PoincareAttsRequireRecalculation(obj) << std::endl;

    return IntegralCurveAttsRequireRecalculation(obj) ||
           PoincareAttsRequireRecalculation(obj);
}

Target: xml2atts
Function: IntegralCurveAttsRequireRecalculation
Declaration: bool IntegralCurveAttsRequireRecalculation(const PoincareAttributes &obj) const;
Definition:
// ****************************************************************************
// Method: PoincareAttributes::IntegralCurveAttsRequireRecalculation
//
// Purpose:
//   Determine if integral curve attribute changes require recalculation.
//
// Programmer: Dave Pugmire
// Creation:   Tues Oct 21 14:22:17 EDT 2008
//
// Modifications:
//
// ****************************************************************************

#define PDIF(p1,p2,i) ((p1)[i] != (p2)[i])
#define POINT_DIFFERS(p1,p2) (PDIF(p1,p2,0) || PDIF(p1,p2,1) || PDIF(p1,p2,2))

bool
PoincareAttributes::IntegralCurveAttsRequireRecalculation(const PoincareAttributes &obj) const
{
    // If we're in point source mode and the points differ, sourcePointsDiffer
    // evaluates to true.
    bool sourcePointsDiffer = ((sourceType == SpecifiedPoint) &&
                               POINT_DIFFERS(pointSource, obj.pointSource));

    bool sourcePointListDiffer = false;

    if (sourceType == PointList)
    {
        if (pointList.size() != obj.pointList.size())
            sourcePointListDiffer = true;
        else
            for (size_t i = 0 ; i < pointList.size() ; i++)
                if (pointList[i] != obj.pointList[i])
                    sourcePointListDiffer = true;
    }

    // If we're in line source mode and the line differs, sourceLineDiffers
    // evaluates to true.
    bool sourceLineDiffers = ((sourceType == SpecifiedLine) &&
                              (POINT_DIFFERS(lineStart, obj.lineStart) ||
                               POINT_DIFFERS(lineEnd, obj.lineEnd) ||
                               pointDensity != obj.pointDensity));

    return (sourceType != obj.sourceType ||
            sourcePointsDiffer ||
            sourcePointListDiffer ||
            sourceLineDiffers ||

            (fieldType == FlashField &&
             POINT_DIFFERS(velocitySource, obj.velocitySource)) ||

            minPunctures != obj.minPunctures ||
            maxPunctures != obj.maxPunctures ||

            puncturePlane != obj.puncturePlane ||

            fieldType != obj.fieldType ||
            fieldConstant != obj.fieldConstant ||
            integrationType != obj.integrationType ||
            maxStepLength != obj.maxStepLength ||
            limitMaximumTimestep != obj.limitMaximumTimestep ||
            maxTimeStep != obj.maxTimeStep ||
            relTol != obj.relTol ||
            absTolSizeType != obj.absTolSizeType ||
            absTolAbsolute != obj.absTolAbsolute ||
            absTolBBox != obj.absTolBBox);
}

Target: xml2atts
Function: PoincareAttsRequireRecalculation
Declaration: bool PoincareAttsRequireRecalculation(const PoincareAttributes &obj) const;
Definition:
// ****************************************************************************
// Method: PoincareAttributes::PoincareAttsRequireRecalculation
//
// Purpose:
//   Determine if poincare attribute changes require recalculation.
//
// Programmer: Dave Pugmire
// Creation:   Tues Oct 21 14:22:17 EDT 2008
//
// Modifications:
//
// ****************************************************************************

bool
PoincareAttributes::PoincareAttsRequireRecalculation(const PoincareAttributes &obj) const
{
    return coordinateSystem != obj.coordinateSystem ||

           analysis != obj.analysis ||

           maximumToroidalWinding != obj.maximumToroidalWinding ||
           overrideToroidalWinding != obj.overrideToroidalWinding ||
           overridePoloidalWinding != obj.overridePoloidalWinding ||
           windingPairConfidence != obj.windingPairConfidence ||
           rationalSurfaceFactor != obj.rationalSurfaceFactor ||

           showOPoints != obj.showOPoints ||
           OPointMaxIterations != obj.OPointMaxIterations ||

           performOLineAnalysis != obj.performOLineAnalysis ||
           OLineToroidalWinding != obj.OLineToroidalWinding ||
           OLineAxisFileName != obj.OLineAxisFileName ||

           showXPoints != obj.showXPoints ||
           XPointMaxIterations != obj.XPointMaxIterations ||

           overlaps != obj.overlaps ||

           showIslands != obj.showIslands ||
           show1DPlots != obj.show1DPlots ||
           showChaotic != obj.showChaotic ||
           verboseFlag != obj.verboseFlag ||

           dataValue != obj.dataValue ||

           meshType != obj.meshType ||
           numberPlanes != obj.numberPlanes ||
           singlePlane != obj.singlePlane ||

           showLines != obj.showLines ||
           showPoints != obj.showPoints;
}

Target: xml2info
Function: PoincareViewerEnginePluginInfo::GetOperatorVarDescription
Declaration: virtual std::string GetOperatorVarDescription(AttributeSubject *atts, const avtPlotMetaData &plot);
Definition:
// ****************************************************************************
//  Method: PoincareViewerEnginePluginInfo::GetOperatorVarDescription
//
//  Purpose:
//    Return the operator variable description.
//
//  Arguments:
//    atts        The attribute subject to initialize.
//    plot        The viewer plot that owns the operator.
//
//  Programmer: Allen Sanderson
//  Creation:   19 August 2013
//
// ****************************************************************************

#include <avtPlotMetaData.h>
#include <cstring>

std::string
PoincareViewerEnginePluginInfo::GetOperatorVarDescription(AttributeSubject *atts,
                                                    const avtPlotMetaData &plot)
{
    PoincareAttributes *atts_in = (PoincareAttributes *)atts;

    const char *typeString[14] =
      { "None", "Safety Factor Q", "Safety Factor P",
        "Safety Factor Q != P", "Safety Factor P != Q",
        "Toroidal Windings", "Poloidal Windings Q", "Poloidal Windings P",
        "Fieldline Order", "Point Order","Plane Order",
        "Winding Group Order", "Winding Point Order",
        "Winding Point Order Modulo" };

    std::string var = plot.GetVariableName();

    if( strncmp(var.c_str(), "operators/Poincare/",
                strlen("operators/Poincare/")) == 0)
    {
      std::string justTheVar = var.substr(strlen("operators/Poincare/"));

      var = justTheVar;
    }

    var += std::string(" - ") +
        std::string(typeString[atts_in->GetDataValue()]);

    return var;
}

Target: xml2atts
Function: ProcessOldVersions
Declaration: virtual void ProcessOldVersions(DataNode *parentNode, const char *configVersion);
Definition:
// ****************************************************************************
// Method: PoincareAttributes::ProcessOldVersions
//
// Purpose:
//   This method allows handling of older config/session files that may
//   contain fields that are no longer present or have been modified/renamed.
//
// Programmer: Mark C. Miller
// Creation:   October 27, 2023
//
// ****************************************************************************
#include <visit-config.h>
#ifdef VIEWER
#include <avtCallback.h>
#endif

void
PoincareAttributes::ProcessOldVersions(DataNode *parentNode,
                                     const char *configVersion)
{
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("PoincareAttributes");
    if(searchNode == 0)
        return;

#if VISIT_OBSOLETE_AT_VERSION(3,5,0)
#error This code is obsolete in this version of VisIt and should be removed.
#else
    if (VersionLessThan(configVersion, "3.4.0"))
    {
        DataNode *dn = nullptr;

        // We need deal with only ManagerWorker case here because it replaces
        // the old entry of MasterSlave
        if ((dn = searchNode->GetNode("parallelizationAlgorithmType")) != nullptr)
        {
            std::string type = dn->AsString();
            if (type == "MasterSlave")
            {
#ifdef VIEWER
                avtCallback::IssueWarning(DeprecationMessage("MasterSlave",
                    "ManagerWorker", "3.5.0"));
#endif
                dn->SetString(ParallelizationAlgorithmType_ToString(PoincareAttributes::ManagerWorker));
            }
        }
    }
#endif
}

Target: xml2python
Code: PyPoincareAttributes_getattr
Prefix:
Postfix:
#include <visit-config.h>

#if VISIT_OBSOLETE_AT_VERSION(3,5,0) 
#error This code is obsolete in this version of VisIt and should be removed.
#else
    // Try and handle legacy fields
#define NAME_CHANGE_MESSAGE2(oldname, newname) \
    PyErr_WarnFormat(NULL, 1, "'%s' is no longer a valid Poincare attribute.\n" \
                    "It's name has been changed to '%s', " \
                    "please update your script.\n", oldname, newname);
        
    // parallelizationAlgorithmType
    if(strcmp(name, "MasterSlave") == 0)
    {       
        NAME_CHANGE_MESSAGE2(name, "ManagerWorker");
        return PyInt_FromLong(long(PoincareAttributes::ManagerWorker));
    }           
    // end parallelizationAlgorithmType 
    // NOTE: no cooresponding _setattr method is needed for this case because this
    // is handling only a change in enum symbol name. Those are constants in the
    // python object and never set
#endif  

