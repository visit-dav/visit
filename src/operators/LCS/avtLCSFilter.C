/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLCSFilter.C
// ************************************************************************* //

#include <avtLCSFilter.h>
#include <avtLCSIC.h>

// For now use the avtLCSIC as the state does not need to be recorded
// for the FSLE. That is because currently the integration is being
// done step by step rather than in chunks. However, the code is set up
// to use avtStreamlineIC. Which if the integration is done in chucks
// will probably be more efficient.

//#include <avtStreamlineIC.h>
#define avtStreamlineIC avtLCSIC

#include <avtExtents.h>
#include <avtMatrix.h>
#include <avtParallel.h>
#include <avtCallback.h>

#include <avtOriginatingSource.h>
#include <avtGradientExpression.h>
#include <vtkVisItScalarTree.h>

#include <VisItException.h>
#include <ImproperUseException.h>

#include <vtkMath.h>
#include <vtkUniformGrid.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkDoubleArray.h>
#include <vtkPointData.h>
#include <vtkStreamer.h>

#include <iostream>
#include <limits>
#include <cmath>

// ****************************************************************************
//  Method: avtLCSFilter constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Wed Mar 28 08:36:34 PDT 2012
//    Initialize pathlines later.  Also set tolerances.
//
// ****************************************************************************

avtLCSFilter::avtLCSFilter() : seedVelocity(0,0,0)
{
    outVarRoot = std::string("operators/LCS/");

    //outVarName ="operators/LCS/mesh";
    //doPathlines();
    //SetPathlines(atts.GetPathlines(),
    //              atts.GetPathlinesOverrideStartingTimeFlag(),
    //              atts.GetPathlinesOverrideStartingTime(),
    //              atts.GetPathlinesCMFE());
    //SetPathlines(true,false,0,PICS_CONN_CMFE);
    //SetPathlines(false,false,0,PICS_CONN_CMFE);

    // These initializations prevent harmless UMRs when we do our first
    // cache lookups.
    global_bounds[0] = global_bounds[2] = global_bounds[4] = 0;
    global_bounds[1] = global_bounds[3] = global_bounds[5] = 1;
    global_resolution[0] = global_resolution[1] = global_resolution[2] = 10;
    absTol = 1e-6;
    relTol = 1e-7;

    numSteps = 0;
    fsle_dt = 0;
    fsle_ds = 0;

    minSizeValue = std::numeric_limits<double>::max();
    maxSizeValue = std::numeric_limits<double>::min();
}


// ****************************************************************************
//  Method: avtLCSFilter destructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
// ****************************************************************************

avtLCSFilter::~avtLCSFilter()
{
}


// ****************************************************************************
//  Method: avtLCSFilter::Create
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtFilter *avtLCSFilter::Create()
{
    return new avtLCSFilter();
}


// ****************************************************************************
//  Method: avtLCSFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Tue Mar 27 16:24:13 PDT 2012
//    Don't do pathlines if steady state is indicated.
//
//    Hank Childs, Wed Apr 11 11:35:16 PDT 2012
//    Add reverse flow.
//
// ****************************************************************************

void
avtLCSFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LCSAttributes*)a;

    needsRecalculation =
      atts.ChangesRequireRecalculation(*(const LCSAttributes*)a);

    int CMFEType = (atts.GetPathlinesCMFE() == LCSAttributes::CONN_CMFE
                    ? PICS_CONN_CMFE : PICS_POS_CMFE);

    SetPathlines(atts.GetPathlines(),
                 atts.GetPathlinesOverrideStartingTimeFlag(),
                 atts.GetPathlinesOverrideStartingTime(),
                 atts.GetPathlinesPeriod(),
                 CMFEType);

    SetIntegrationDirection(atts.GetIntegrationDirection());

    SetFieldType(atts.GetFieldType());
    SetFieldConstant(atts.GetFieldConstant());
    SetVelocitySource(atts.GetVelocitySource());

    SetIntegrationType(atts.GetIntegrationType());
    SetParallelizationAlgorithm(atts.GetParallelizationAlgorithmType(), 
                                atts.GetMaxProcessCount(),
                                atts.GetMaxDomainCacheSize(),
                                atts.GetWorkGroupSize());

    if (atts.GetIntegrationType() == LCSAttributes::DormandPrince)
    {
      if( atts.GetOperationType() ==  LCSAttributes::Lyapunov &&
            atts.GetTerminateBySize() )
        {
          EXCEPTION1(ImproperUseException,
                     "When performing FSLE the step size must be fixed. "
                     "Please select a different solver and "
                     "set the maximum time step.");
        }

        // For DoPri, the max time step is sent in to the PICS filter
        // as the max step length.
        double step;
        if (atts.GetLimitMaximumTimestep())
          step = atts.GetMaxTimeStep();
        else
          step = 0;

        SetMaxStepLength(step);
    }
    else
        SetMaxStepLength(atts.GetMaxStepLength());

    double absTol = 0.;
    bool doBBox = (atts.GetAbsTolSizeType() == LCSAttributes::FractionOfBBox);
    if (doBBox)
        absTol = atts.GetAbsTolBBox();
    else
        absTol = atts.GetAbsTolAbsolute();
    SetTolerances(atts.GetRelTol(), absTol, doBBox);

    SetTermination(atts.GetMaxSteps(),
                   atts.GetTerminateByDistance(),
                   atts.GetTermDistance(),
                   atts.GetTerminateByTime(),
                   atts.GetTermTime(),
                   atts.GetTerminateBySize(),
                   atts.GetTermSize());

    IssueWarningForMaxStepsTermination(atts.GetIssueTerminationWarnings());
    IssueWarningForStiffness(atts.GetIssueStiffnessWarnings());
    IssueWarningForCriticalPoints(atts.GetIssueCriticalPointsWarnings(),
                                  atts.GetCriticalPointThreshold());
}


// ****************************************************************************
//  Method: avtLCSFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLCSFilter with the given
//      parameters would result in an equivalent avtLCSFilter.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

bool
avtLCSFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LCSAttributes*)a);
}


// ****************************************************************************
// Method: avtLCSFilter::SetVelocitySource
//
// Purpose: 
//   Sets the integral curve velocity source.
//
// Arguments:
//   vel : The velocity of the point.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetVelocitySource(const double *p)
{
  seedVelocity.set(p);
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialVelocities
//
//  Purpose:
//      Get the seed velocities out of the attributes.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialVelocities(void)
{
    std::vector<avtVector> seedVels;

    seedVels.push_back( seedVelocity );

    return seedVels;
}


// ****************************************************************************
//  Method: avtLCSFilter::SetTermination
//
//  Purpose:
//      Sets the termination criteria for an integral curve.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetTermination(int maxSteps_,
                              bool doDistance_, double maxDistance_,
                              bool doTime_,     double maxTime_,
                              bool doSize_,     double maxSize_)
{
    maxSteps = maxSteps_;
    doDistance = doDistance_;
    maxDistance = maxDistance_;
    doTime = doTime_;
    maxTime = maxTime_;
    doSize = doSize_;
    maxSize = maxSize_;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an uninitialized integral curve.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(void)
{
  if( doSize ) 
    return (new avtStreamlineIC());
  else
    return (new avtLCSIC());
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve with specific IDs and parameters.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(const avtIVPSolver* model,
                                   avtIntegralCurve::Direction dir,
                                   const double& t_start,
                                   const avtVector &p_start,
                                   const avtVector& v_start, long ID)
{
    double t;

    if (doPathlines)
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = seedTime0 - maxTime;
        else
            t = seedTime0 + maxTime;
    }
    else
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = -maxTime;
        else
            t = maxTime;
    }

    if( doSize )
    {
      // For now use the avtLCSIC as the state does not need to be
      // recorded for the FSLE. That is because currently the
      // integration is being done step by step rather than in
      // chunks. However, the code is set up to use
      // avtStreamlineIC. Which if the integration is done in chucks
      // will probably be more efficient.

      // unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_TIME;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_ARCLENGTH;
      
      // return
      //   (new avtStreamlineIC(numSteps, doDistance, maxDistance, doTime, t,
      //                        attr, model, dir, t_start, p_start, v_start, ID));
      return
        (new avtLCSIC(numSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
    else
    {
      return
        (new avtLCSIC(maxSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtContract_p
avtLCSFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    std::string var =  in_dr->GetOriginalVariable();
//    in_contract->SetReplicateSingleDomainOnAllProcessors(true);
//    in_contract->SetOnDemandStreaming(false);
//    in_contract->GetDataRequest();
    in_dr->SetUsesAllDomains(true);
    if( strncmp(var.c_str(), "operators/LCS/", strlen("operators/LCS/")) == 0)
    {
        std::string justTheVar = var.substr(strlen("operators/LCS/"));

        outVarName = justTheVar;
        avtDataRequest_p out_dr = new avtDataRequest(in_dr,justTheVar.c_str());
        //out_dr->SetDesiredGhostDataType(GHOST_NODE_DATA);
        //out_dr->SetDesiredGhostDataType(GHOST_ZONE_DATA);

        return avtPICSFilter::ModifyContract( new avtContract(in_contract,out_dr) );
    }
    else
    {
      outVarName = var;
      outVarRoot = "";
    }

    return avtPICSFilter::ModifyContract(in_contract);
}


// ****************************************************************************
//  Method: avtLCSFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//    Brad Whitlock, Mon Apr  7 15:55:02 PDT 2014
//    Add filter metadata used in export.
//    Work partially supported by DOE Grant SC0007548.
//
// ****************************************************************************

void
avtLCSFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes  &in_dataatts =  GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &out_dataatts = GetOutput()->GetInfo().GetAttributes();

    timeState = in_dataatts.GetTimeIndex();

    //the outvarname has been assigned and will be added.
    //outVarName = "velocity";

    if (outVarRoot != "" && outVarName != "")
    {
        std::string fullVarName = outVarRoot + outVarName;

        out_dataatts.RemoveVariable(in_dataatts.GetVariableName());

        if (! out_dataatts.ValidVariable(fullVarName) )
        {
            //atts.AddVariable(outVarName.c_str());
            out_dataatts.AddVariable((fullVarName).c_str());
            out_dataatts.SetActiveVariable(fullVarName.c_str());
            //atts.SetTopologicalDimension(3);
            out_dataatts.SetVariableDimension(1);
            out_dataatts.SetVariableType(AVT_SCALAR_VAR);
            out_dataatts.SetCentering(AVT_NODECENT);
        }
    }
    else if (outVarName != "")
    {
      if( atts.GetOperationType() == LCSAttributes::EigenVector )
      {
        out_dataatts.SetVariableDimension(3);
        out_dataatts.SetVariableType(AVT_VECTOR_VAR);
      }
    }

    avtPICSFilter::UpdateDataObjectInfo();

    out_dataatts.AddFilterMetaData("LCS");
}


// ****************************************************************************
//  Method: avtLCSFilter::PostExecute
//
//  Purpose:
//      
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
// ****************************************************************************

// void 
// avtLCSFilter::PostExecute(void)
// {
// }

// ****************************************************************************
//  Method: avtLCSFilter::PreExecute
//
//  Purpose:
//      Initialize data attributes for this filter and its base type (PICS).
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Jul  6 14:17:47 PDT 2012
//    Set resolution for Z to be 1 for 2D meshes.
//
// ****************************************************************************

void 
avtLCSFilter::PreExecute(void)
{
    SetActiveVariable(outVarName.c_str());
    GetSpatialExtents(global_bounds);

    // Cache the time and cycle at the start because for pathlines
    // they will change to the end.
    cycleCached = (int)   GetInput()->GetInfo().GetAttributes().GetCycle();
    timeCached  = (float) GetInput()->GetInfo().GetAttributes().GetTime();

    if (GetInput()->GetInfo().GetAttributes().GetSpatialDimension() == 2)
    {
        // we set them to 0->1 earlier and GetSpatialExtents only sets the
        // X and Y parts of the extents for 2D.
        global_bounds[4] = 0;
        global_bounds[5] = 0;
    }

    if(atts.GetUseDataSetStart() == LCSAttributes::Subset)
    {
        double* a = atts.GetStartPosition();
        global_bounds[0] = a[0];
        global_bounds[2] = a[1];
        global_bounds[4] = a[2];
    }

    if(atts.GetUseDataSetEnd() == LCSAttributes::Subset)
    {
        double* a = atts.GetEndPosition();
        global_bounds[1] = a[0];
        global_bounds[3] = a[1];
        global_bounds[5] = a[2];
    }

    const int* res = atts.GetResolution();
    global_resolution[0] = res[0];
    global_resolution[1] = res[1];
    global_resolution[2] = res[2];
    if (global_bounds[4] == global_bounds[5])
        global_resolution[2] = 1;

    double minResolution = std::numeric_limits<double>::max();

    double resX = 0., resY = 0., resZ = 0.;

    if (global_resolution[0] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[0]-1);

      resX = (global_bounds[1] - global_bounds[0]) * pcnt; 

      minResolution = std::min( resX, minResolution );
    }
      
    if (global_resolution[1] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[1]-1);

      resY = (global_bounds[3] - global_bounds[2]) * pcnt; 
 
      minResolution = std::min( resY, minResolution );
    }
      
    if (global_resolution[2] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[2]-1);

      resZ = (global_bounds[5] - global_bounds[4]) * pcnt; 

      minResolution = std::min( resZ, minResolution );
    }

    if( atts.GetOperationType() == LCSAttributes::Lyapunov &&
        doSize && maxSize <= minResolution )
    {
        char str[1028];

        SNPRINTF(str, 1028, "\nThe size limit for the FSLE is %f. "
                 "and is equal to or smaller than the resolution of the grid "
                 "(%f, %f, %f). ",
                 atts.GetTermSize(), resX, resY, resZ );

        avtCallback::IssueWarning(str);
        
//      EXCEPTION1(ImproperUseException, str );
    }

    avtPICSFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtLCSFilter::Execute
//
//  Purpose:
//      Executes the LCS.  If we already have a cached version, then it
//      just returns that version.  If not, it calls PICS execute, which will
//      call our LCS set up routines via CreateIntegralCurveOutput.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::Execute(void)
{
    avtDataTree_p dt = GetCachedDataSet();

    if (!needsRecalculation && *dt != NULL)
    {
        debug1 << "LCS: using cached version" << std::endl;
        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
            if (PAR_Rank() != 0)
                dt = new avtDataTree();
        SetOutputDataTree(dt);
        return;
    }
    else
    {
      debug1 << "LCS: no cached version, must re-execute" << std::endl;

      avtPICSFilter::Execute();

      std::vector<avtIntegralCurve *> ics;
      GetTerminatedIntegralCurves(ics);
      
      ReportWarnings( ics );
    }
}

// ****************************************************************************
//  Method: avtLCSFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

bool
avtLCSFilter::ContinueExecute()
{
    ++numSteps;

    if( atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      if( doSize )
      {
//      std::cerr << "Continue execute " << numSteps << std::endl;
        
        std::vector<avtIntegralCurve *> ics;
        
        GetTerminatedIntegralCurves(ics);
        
        if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        {
          if (NativeMeshIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
        else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        {
          if (RectilinearGridIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
      }
    }

    return false;
}

// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurveOutput
//
//  Purpose:
//      Computes the LCS output (via sub-routines) after the PICS filter has
//      calculated the final particle positions.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void 
avtLCSFilter::CreateIntegralCurveOutput(std::vector<avtIntegralCurve*> &ics)
{
  if( atts.GetOperationType() == LCSAttributes::Lyapunov && doSize )
  {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        CreateNativeMeshIterativeCalcOutput(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        CreateRectilinearGridIterativeCalcOutput(ics);
  }
  else
  {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
          NativeMeshSingleCalc(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
          RectilinearGridSingleCalc(ics);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocations
//
//  Purpose:
//      Tells the PICS filter where to place the initial seed locations.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialLocations()
{
    seedPoints.clear();

    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        GetInitialLocationsFromNativeMesh(GetInputDataTree());
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        GetInitialLocationsFromRectilinearGrid();
    }

    return seedPoints;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromMesh
//
//  Purpose:
//      Walks through an AVT data tree and sets up the initial locations from
//      each point in the mesh.
//
//  Arguments:
//      inDT          A pointer to a data tree.  
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromNativeMesh(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        size_t pts = in_ds->GetNumberOfPoints();

        size_t numberOfSeeds = seedPoints.size();
        size_t totalNumberOfSeeds = numberOfSeeds + pts;

        seedPoints.resize( totalNumberOfSeeds );

        double points[3];
        for(size_t i = 0; i < pts; ++i)
        {
          in_ds->GetPoint(i, points);
          seedPoints[numberOfSeeds+i].set(points);
        }
    }
    else
    {
        //
        // there is more than one input dataset to process
        // and we need an output datatree for each
        //
        for (int j = 0; j < nc; j++)
        {
            if (inDT->ChildIsPresent(j))
            {
                GetInitialLocationsFromNativeMesh(inDT->GetChild(j));
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromRectilinearGrid
//
//  Purpose:
//      Created a series of seeds points based on the user specified mesh
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromRectilinearGrid()
{
    //compute total number of seeds that will be generated.
    size_t totalNumberOfSeeds =
      global_resolution[0] * global_resolution[1] * global_resolution[2];
    
    seedPoints.resize(totalNumberOfSeeds);

    size_t l = 0; //current line of the seed.
  
    //add sample points by looping over in x,y,z
    for(int k = 0; k < global_resolution[2]; ++k)
    {
        double zpcnt = 0;

        if (global_resolution[2] > 1)
          zpcnt = ((double)k)/((double)global_resolution[2]-1);

        double z = global_bounds[4]*(1.0-zpcnt) + global_bounds[5]*zpcnt;
        
        for(int j = 0; j < global_resolution[1]; ++j)
        {
            double ypcnt = 0;

            if (global_resolution[1] > 1)
              ypcnt = ((double)j)/((double)global_resolution[1]-1);

            double y = global_bounds[2]*(1.0-ypcnt) + global_bounds[3]*ypcnt;
            
            for(int i = 0; i < global_resolution[0]; ++i)
            {
                double xpcnt = 0;

                if (global_resolution[0] > 1)
                  xpcnt = ((double)i)/((double)global_resolution[0]-1);

                double x =
                  global_bounds[0]*(1.0-xpcnt) +
                  global_bounds[1]*xpcnt;
                
                seedPoints[l++].set(x,y,z);
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent after the particles have been advected.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void avtLCSFilter::NativeMeshSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    offset = 0;

    avtDataTree_p outTree =
      MultiBlockSingleCalc(GetInputDataTree(), ics, offset, minv, maxv);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
            outTree = new avtDataTree();
    SetOutputDataTree(outTree);

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[6];
    range[0] = minv;
    range[1] = maxv;
    range[2] = minv;
    range[3] = maxv;
    range[4] = minv;
    range[5] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for the whole data set, using the final particle
//      locations, at the blocks native mesh resolution.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::MultiBlockSingleCalc( avtDataTree_p inDT,
                                    std::vector<avtIntegralCurve*> &ics,
                                    int &offset, double &minv, double &maxv )
{
    if (*inDT == NULL)
        return 0;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        vtkDataSet *out_ds =
          SingleBlockSingleCalc( in_ds, ics, offset, dom, minv, maxv );
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = MultiBlockSingleCalc( inDT->GetChild(j), ics, 
                                                    offset, minv, maxv );
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for a single block of a data set, using the final
//      particle locations, at the blocks native mesh resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

vtkDataSet *
avtLCSFilter::SingleBlockSingleCalc( vtkDataSet *in_ds,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset, int domain,
                                     double &minv, double &maxv )
{
    //variable name.
    std::string var = outVarRoot + outVarName;

    //create new instance from old.
    vtkDataSet* out_grid = in_ds->NewInstance();
    out_grid->ShallowCopy(in_ds);
    int nTuples = in_ds->GetNumberOfPoints();

    //an array for the initial locations.
    std::vector<avtVector> remapPoints;
    remapPoints.resize(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l < remapPoints.size()) ///TODO: l >=0 is always true
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < (size_t)nTuples; i++)
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
                remapPoints[i] = seedPoints.at(offset + i);
            else
                remapPoints[i] = zero;
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
            remapPoints[i] = seedPoints.at(offset + i);
    }

    for(size_t i = 0; i < ics.size(); ++i)
    {
        size_t index = ics[i]->id;
        int l = (int)(index-offset);
        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(l >= 0 && l < (int)remapPoints.size())
        {

          // remapPoints[l] = ((avtLCSIC*)ics[i])->GetEndPoint() -
          //                ((avtLCSIC*)ics[i])->GetStartPoint();

          if( atts.GetOperationType() == LCSAttributes::EigenValue ||
              atts.GetOperationType() == LCSAttributes::EigenVector ||
              atts.GetOperationType() == LCSAttributes::Lyapunov )
          {
            remapPoints.at(l) = ((avtLCSIC*)ics[i])->GetEndPoint();
          }
          else
          {
            double ave = 0;

            if( ((avtLCSIC*)ics[i])->GetNumSteps() )
              remapPoints.at(l) =
                avtVector( ((avtLCSIC*)ics[i])->GetTime(),
                           ((avtLCSIC*)ics[i])->GetDistance(),
                           (((avtLCSIC*)ics[i])->GetSummation0() /
                            (double) ((avtLCSIC*)ics[i])->GetNumSteps()) );
            else
              remapPoints.at(l) =
                avtVector( ((avtLCSIC*)ics[i])->GetTime(),
                           ((avtLCSIC*)ics[i])->GetDistance(),
                           0 );
          }
        }
    }

    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.
    vtkDoubleArray *outputArray = vtkDoubleArray::New();
    outputArray->SetName(var.c_str());
    if( atts.GetOperationType() == LCSAttributes::EigenVector )
      outputArray->SetNumberOfComponents(3);
    else
      outputArray->SetNumberOfComponents(1);
    outputArray->SetNumberOfTuples(nTuples);
    out_grid->GetPointData()->AddArray(outputArray);

    vtkDoubleArray *workingArray = vtkDoubleArray::New();
    workingArray->SetName("workingArray");
    workingArray->SetNumberOfComponents(1);
    workingArray->SetNumberOfTuples(nTuples);
    out_grid->GetPointData()->AddArray(workingArray);
    out_grid->GetPointData()->SetActiveScalars("workingArray");

    if( atts.GetOperationType() == LCSAttributes::EigenValue ||
        atts.GetOperationType() == LCSAttributes::EigenVector ||
        atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      vtkDataArray* jacobian[3];
    
      for(int i = 0; i < 3; ++i)
      {
        for(size_t j = 0; j < (size_t)nTuples; ++j)
            workingArray->SetTuple1(j, remapPoints[j][i]);

        // ARS FIX ME - what does this do?
        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            double *newvals = new double[nTuples];
            double *origvals = (double *) workingArray->GetVoidPointer(0);
            SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(double));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_grid, var.c_str());
      }

      for (int i = 0; i < nTuples; i++)
        outputArray->SetTuple1(i, std::numeric_limits<double>::epsilon());

      //now have the jacobian - 3 arrays with 3 workingArrays.
      if( atts.GetOperationType() == LCSAttributes::EigenValue )
        ComputeEigenValues(jacobian, outputArray);
      else if( atts.GetOperationType() == LCSAttributes::EigenVector )
        ComputeEigenVectors(jacobian, workingArray, outputArray);
      else //if( atts.GetOperationType() == LCSAttributes::Lyapunov )
        ComputeLyapunovExponent(jacobian, outputArray);

      jacobian[0]->Delete();
      jacobian[1]->Delete();
      jacobian[2]->Delete();
    }

    // The value stored in the points is the arc length, integration
    // time, and average distance form the seed. So just move it into
    // the output array.
    else if( atts.GetOperatorType() == LCSAttributes::BaseValue )
    {
      int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);

      for(size_t j = 0; j < (size_t)nTuples; ++j)
        outputArray->SetTuple1(j, remapPoints[j][index]);

      // ARS FIX ME - what does this do?
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
      {
        double *newvals = new double[nTuples];
        double *origvals = (double *) outputArray->GetVoidPointer(0);
        SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
        // copy newvals back into origvals
        memcpy(origvals, newvals, nTuples*sizeof(double));
        delete [] newvals;
      }
    }
    else if( atts.GetOperatorType() == LCSAttributes::Gradient )
    {
      int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);
      
      // The base value is used to clamp the log values to be only
      // positive or both positive and negative.
      double baseValue;
      
      if (atts.GetClampLogValues() == true )
        baseValue = 1.0;
      else
        baseValue = std::numeric_limits<double>::epsilon();
      
      for (size_t l = 0; l < nTuples; l++)
        workingArray->SetTuple1(l, remapPoints[l][index]);

      // ARS FIX ME - what does this do?
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
      {
        double *newvals = new double[nTuples];
        double *origvals = (double *) workingArray->GetVoidPointer(0);
        SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
        // copy newvals back into origvals
        memcpy(origvals, newvals, nTuples*sizeof(double));
        delete [] newvals;
      }
      
      vtkDataArray* gradient =
        avtGradientExpression::CalculateGradient(out_grid, var.c_str());
      
      for (size_t l = 0; l < nTuples; l++)
      {
        double *grad = gradient->GetTuple3(l);
        
        double lambda = baseValue;
        lambda = std::max( lambda, grad[0]*grad[0] );
        lambda = std::max( lambda, grad[1]*grad[1] );
        lambda = std::max( lambda, grad[2]*grad[2] );
        lambda = log( sqrt( lambda ) );
        
        if( doTime )
          lambda /= maxTime;
        else if( doDistance )
          lambda /= maxDistance;
        
        outputArray->SetTuple1(l, lambda);
      }
      
      gradient->Delete();
    }

    if( atts.GetOperationType() == LCSAttributes::EigenVector )
    {
      minv = 0;
      maxv = 1;

      // for(int i = 0; i < nTuples; ++i)
      // {
      //   double *vals = outputArray->GetTuple3(i);
      //   double mag = sqrt(vals[0]*vals[0]+vals[1]*vals[1]+vals[2]*vals[2]);

      //   minv = std::min(mag, minv);
      //   maxv = std::max(mag, maxv);
      // }
    }
    else
    {
      for(int i = 0; i < nTuples; ++i)
      {
        minv = std::min(outputArray->GetTuple1(i), minv);
        maxv = std::max(outputArray->GetTuple1(i), maxv);
      }
    }

    outputArray->Delete();
    workingArray->Delete();

    // Set the vectors to be the active data
    if( atts.GetOperationType() == LCSAttributes::EigenVector )
      out_grid->GetPointData()->SetActiveVectors(var.c_str());
    else
      out_grid->GetPointData()->SetActiveScalars(var.c_str());

    // Remove the working array.
    out_grid->GetPointData()->RemoveArray("workingArray");

    //Store this dataset in Cache for next time.
    std::string str = CreateCacheString();
    StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                            outVarName.c_str(), domain, -1,
                            str.c_str(), out_grid);

    // Calling function must free this.
    return out_grid;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent on a rectilinear grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_points, result_counts on 
//    rank 0 (root).
// ****************************************************************************

void
avtLCSFilter::RectilinearGridSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    int    maxSteps = std::numeric_limits<int>::min();
    double maxTime = std::numeric_limits<double>::min();
    double maxLength = std::numeric_limits<double>::min();

    //variable name.
    std::string var = outVarRoot + outVarName;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());
    doubleVector lengths(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        indices[i] = ics[i]->id;
        times[i] = ((avtLCSIC*)ics[i])->GetTime();
        lengths[i] = ((avtLCSIC*)ics[i])->GetArcLength();

        maxSteps  = std::max( ((avtLCSIC*)ics[i])->GetNumSteps(), maxSteps);
        maxTime   = std::max( ((avtLCSIC*)ics[i])->GetTime(), maxTime);
        maxLength = std::max( ((avtLCSIC*)ics[i])->GetArcLength(), maxLength);

        if( atts.GetOperationType() == LCSAttributes::EigenValue ||
            atts.GetOperationType() == LCSAttributes::EigenVector ||
            atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          avtVector end_point = ((avtLCSIC*)ics[i])->GetEndPoint();
          
          // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
          //             << end_point << std::endl;

          points[j+0] = end_point[0];
          points[j+1] = end_point[1];
          points[j+2] = end_point[2];
        }
        else
        {
          points[j+0] = ((avtLCSIC*)ics[i])->GetTime();
          points[j+1] = ((avtLCSIC*)ics[i])->GetArcLength();

          if( ((avtLCSIC*)ics[i])->GetNumSteps() )
            points[j+2] = (((avtLCSIC*)ics[i])->GetSummation0() /
                           (double) ((avtLCSIC*)ics[i])->GetNumSteps());
          else
            points[j+2] = 0;
        }
    }

    // std::cerr << "Max steps " << maxSteps
    //           << "  max time " << maxTime
    //           << "  max arc length " << maxLength
    //           << std::endl;

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    double* all_lengths = 0;
    int *length_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), (int)indices.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), (int)times.size());

    CollectDoubleArraysOnRootProc(all_lengths, time_counts,
                                  &lengths.front(), (int)lengths.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), (int)points.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
        //rank 0
        //now create a rectilinear grid.
        vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

        vtkDoubleArray* lxcoord = vtkDoubleArray::New();
        vtkDoubleArray* lycoord = vtkDoubleArray::New();
        vtkDoubleArray* lzcoord = vtkDoubleArray::New();

        rect_grid->SetDimensions(global_resolution);

        lxcoord->SetNumberOfTuples(global_resolution[0]);
        for (int i = 0; i < global_resolution[0]; i++)
        {
            double pcnt = 0;
            if (global_resolution[0] > 1)
                pcnt = ((double)i)/((double)global_resolution[0]-1);
            lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
        }

        lycoord->SetNumberOfTuples(global_resolution[1]);
        for (int i = 0; i < global_resolution[1]; i++)
        {
            double pcnt = 0;
            if (global_resolution[1] > 1)
                pcnt = ((double)i)/((double)global_resolution[1]-1);
            lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
        }

        lzcoord->SetNumberOfTuples(global_resolution[2]);
        for (int i = 0; i < global_resolution[2]; i++)
        {
            double pcnt = 0;
            if (global_resolution[2] > 1)
                pcnt = ((double)i)/((double)global_resolution[2]-1);
            lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
        }

        rect_grid->SetXCoordinates(lxcoord);
        rect_grid->SetYCoordinates(lycoord);
        rect_grid->SetZCoordinates(lzcoord);

        //cleanup
        lxcoord->Delete();
        lycoord->Delete();
        lzcoord->Delete();

        //now global grid has been created.
        size_t nTuples =
          global_resolution[0] * global_resolution[1] * global_resolution[2];

        // std::cout << "final resolution: " << PAR_Rank() << " "
        //         << global_resolution[0] << " "
        //         << global_resolution[1] << " "
        //         << global_resolution[2] << std::endl;

        vtkDoubleArray *outputArray = vtkDoubleArray::New();
        outputArray->SetName(var.c_str());
        if( atts.GetOperationType() == LCSAttributes::EigenVector )
          outputArray->SetNumberOfComponents(3);
        else
          outputArray->SetNumberOfComponents(1);
        outputArray->SetNumberOfTuples(nTuples);
        rect_grid->GetPointData()->AddArray(outputArray);

        vtkDoubleArray *workingArray = vtkDoubleArray::New();
        workingArray->SetName("workingArray");
        workingArray->SetNumberOfComponents(1);
        workingArray->SetNumberOfTuples(nTuples);
        rect_grid->GetPointData()->AddArray(workingArray);
        rect_grid->GetPointData()->SetActiveScalars("workingArray");
    
        //calculate jacobian in parts (x,y,z).
        std::vector<double> remapTimes(nTuples);
        std::vector<double> remapLengths(nTuples);
        std::vector<avtVector> remapPoints(nTuples);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }
            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(size_t j = 0,k = 0; j < total; ++j, k += 3)
        {
            size_t index = all_indices[j];

            if(index >= nTuples)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;

            remapTimes[index] = all_times[j];
            remapLengths[index] = all_lengths[j];
            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);
            
            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        if( atts.GetOperationType() == LCSAttributes::EigenValue ||
            atts.GetOperationType() == LCSAttributes::EigenVector ||
            atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          vtkDataArray* jacobian[3];

          for(int i = 0; i < 3; ++i)
          {
            for (size_t l = 0; l < nTuples; l++)
                workingArray->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(rect_grid, var.c_str());
          }

          for (size_t l = 0; l < nTuples; l++)
            outputArray->SetTuple1(l, std::numeric_limits<double>::epsilon());

          if( atts.GetOperationType() == LCSAttributes::EigenValue )
            ComputeEigenValues(jacobian, outputArray);
          else if( atts.GetOperationType() == LCSAttributes::EigenVector )
            ComputeEigenVectors(jacobian, workingArray, outputArray);
          else if( atts.GetOperationType() == LCSAttributes::Lyapunov )
            ComputeLyapunovExponent(jacobian, outputArray);

          jacobian[0]->Delete();
          jacobian[1]->Delete();
          jacobian[2]->Delete();
        }

        // The value stored in the points is the arc length, integration
        // time, and average distance form the seed. So just move it into
        // the output array.
        else if( atts.GetOperatorType() == LCSAttributes::BaseValue )
        {
          int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);

          for (size_t l = 0; l < nTuples; l++)
            outputArray->SetTuple1(l, remapPoints[l][index]);
        }

        else if( atts.GetOperatorType() == LCSAttributes::Gradient )
        {
          int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);
          
          // The base value is used to clamp the log values to be only
          // positive or both positive and negative.
          double baseValue;

          if (atts.GetClampLogValues() == true )
            baseValue = 1.0;
          else
            baseValue = std::numeric_limits<double>::epsilon();

          for (size_t l = 0; l < nTuples; l++)
            workingArray->SetTuple1(l, remapPoints[l][index]);

          vtkDataArray* gradient =
            avtGradientExpression::CalculateGradient(rect_grid, var.c_str());

          for (size_t l = 0; l < nTuples; l++)
          {
            double *grad = gradient->GetTuple3(l);

            double lambda = baseValue;
            lambda = std::max( lambda, grad[0]*grad[0] );
            lambda = std::max( lambda, grad[1]*grad[1] );
            lambda = std::max( lambda, grad[2]*grad[2] );
            lambda = log( sqrt( lambda ) );

            if( doTime )
              lambda /= maxTime;
            else if( doDistance )
              lambda /= maxDistance;

            outputArray->SetTuple1(l, lambda);
          }

          gradient->Delete();
        }

        //min and max values over all datasets of the tree.
        double minv = std::numeric_limits<double>::max();
        double maxv = std::numeric_limits<double>::min();

        if( atts.GetOperationType() == LCSAttributes::EigenVector )
        {
          minv = 0;
          maxv = 1;

          // for(int i = 0; i < nTuples; ++i)
          // {
          //   double *vals = outputArray->GetTuple3(i);
          //   double mag = sqrt(vals[0]*vals[0]+vals[1]*vals[1]+vals[2]*vals[2]);

          //   minv = std::min(mag, minv);
          //   maxv = std::max(mag, maxv);
          // }
        }
        else
        {
          for(size_t l = 0; l < nTuples; ++l)
          {
            minv = std::min(outputArray->GetTuple1(l), minv);
            maxv = std::max(outputArray->GetTuple1(l), maxv);
          }
        }

        outputArray->Delete();
        workingArray->Delete();

        // Set the vectors to be the active data
        if( atts.GetOperationType() == LCSAttributes::EigenVector )
          rect_grid->GetPointData()->SetActiveVectors(var.c_str());
        else
          rect_grid->GetPointData()->SetActiveScalars(var.c_str());

        // Remove the working array.
        rect_grid->GetPointData()->RemoveArray("workingArray");

        if (all_indices)  delete [] all_indices;
        if (index_counts) delete [] index_counts;

        if (all_times)  delete [] all_times;
        if (time_counts) delete [] time_counts;

        if (all_lengths)  delete [] all_lengths;
        if (length_counts) delete [] length_counts;

        if (all_points)   delete [] all_points;
        if (point_counts) delete [] point_counts;

        //store this dataset in Cache for next time.
        // double bounds[6];
        // rect_grid->GetBounds(bounds);

        // std::cout << "final size and bounds: "
        //        << PAR_Rank() << " " << nTuples << " "
        //        << bounds[0] << " " << bounds[1] << " " << bounds[2]
        //        << " " << bounds[3] << " " << bounds[4] << " "
        //        << bounds[5] << std::endl;

        std::string str = CreateCacheString();
        StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                outVarName.c_str(), -1, -1,
                                str.c_str(), rect_grid);

        int index = 0;//what does index mean in this context?
        avtDataTree* dt = new avtDataTree(rect_grid,index);
        int x = 0;
        dt->GetAllLeaves(x);

        // std::cout << "total leaves:: " << x << std::endl;

        SetOutputDataTree(dt);

        //set atts.
        avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
        avtExtents* e = dataatts.GetThisProcsActualDataExtents();

        double range[6];
        range[0] = minv;
        range[1] = maxv;
        range[2] = minv;
        range[3] = maxv;
        range[4] = minv;
        range[5] = maxv;
        e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeRightCauchyGreenTensor
//
//  Purpose:
//      Given a Gradient in place compute the Right Cauchy Green Tensor.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeRightCauchyGreenTensor(double **j)
{
    double *j0 = j[0];
    double *j1 = j[1];
    double *j2 = j[2];
    
    // From the gradients compute the right Cauchy-Green Tensor J*J^T   
    double a = j0[0]*j0[0] + j0[1]*j0[1] + j0[2]*j0[2];
    double b = j0[0]*j1[0] + j0[1]*j1[1] + j0[2]*j1[2];
    double c = j0[0]*j2[0] + j0[1]*j2[1] + j0[2]*j2[2];
    
    double d = j1[0]*j1[0] + j1[1]*j1[1] + j1[2]*j1[2];
    double e = j1[0]*j2[0] + j1[1]*j2[1] + j1[2]*j2[2];
    double f = j2[0]*j2[0] + j2[1]*j2[1] + j2[2]*j2[2];

    j0[0] = a;       j0[1] = b;       j0[2] = c;
    j1[0] = b;       j1[1] = d;       j1[2] = e;
    j2[0] = c;       j2[1] = e;       j2[2] = f;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeEigenValue
//
//  Purpose:
//      Computes the eigen vectors given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::Jacobi(double **j, double *w)
{
    double *j0 = j[0];
    double *j1 = j[1];
    double *j2 = j[2];

    // a b c
    // b d e
    // c e f

    double a = j0[0];
    double b = j0[1];
    double c = j0[2];
    double d = j1[1];
    double e = j1[2];
    double f = j2[2];

    // Now calculate the eigen values
    double x = ( a + d + f ) / 3.0f;  // trace

    a -= x;
    d -= x;
    f -= x;

    // Det / 2;
    double q = (a*d*f + b*e*c + c*b*e - c*d*c - e*e*a - f*b*b) / 2.0f;
    double r = (a*a + b*b + c*c + b*b + d*d + e*e + c*c + e*e + f*f) / 6.0f;

    double D = (r*r*r - q*q);
    double phi = 0.0f;

    // std::cout << a << " " << b << " " << c << " " << d << " "
    //           << e << " " << f << " " << x << " " << q << " "
    //           << r << std::endl;

    if( D < std::numeric_limits<double>::epsilon())
      phi = 0.0f;
    else
    {
      phi = atanf( sqrt(D)/q ) / 3.0f;
      
      if( phi < 0 )
          phi += M_PI;
    }

    const double sqrt3 = sqrt(3.0f);
    const double sqrtr = sqrt(r);

    double sinphi = 0.0f, cosphi = 0.0f;
    sinphi = sinf(phi);
    cosphi = cosf(phi);

    w[0] = x + 2.0f*sqrtr*cosphi;
    w[1] = x - sqrtr*(cosphi - sqrt3*sinphi);
    w[2] = x - sqrtr*(cosphi + sqrt3*sinphi);

    return 1;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeEigenValues
//
//  Purpose:
//      Computes the eigen vectors given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeEigenValues(vtkDataArray *jacobian[3],
                                      vtkDataArray *result)
{
    size_t nTuples = result->GetNumberOfTuples();

    for(size_t l = 0; l < nTuples; ++l)
    {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        input[0][2] = 0;
        input[1][2] = 0;
        input[2][0] = 0;
        input[2][1] = 0;
        input[2][2] = 0;

        ComputeRightCauchyGreenTensor(input);

        double eigenvals[3];

        Jacobi(input, eigenvals);

        if( atts.GetEigenComponent() == LCSAttributes::First )
          result->SetTuple1(l, eigenvals[0]);
        else if( atts.GetEigenComponent() == LCSAttributes::Second )
          result->SetTuple1(l, eigenvals[1]);
        else // if( atts.GetEigenComponent() == LCSAttributes::Third )
          result->SetTuple1(l, eigenvals[2]);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeEigenVectors
//
//  Purpose:
//      Computes the eigen vectors given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeEigenVectors(vtkDataArray *jacobian[3],
                                       vtkDataArray *result,
                                       vtkDataArray *secondary)
{
    size_t nTuples = result->GetNumberOfTuples();

    int cc = 0;
    double maxDiff = 0;

    for(size_t l = 0; l < nTuples; ++l)
    {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        input[0][2] = 0;
        input[1][2] = 0;
        input[2][0] = 0;
        input[2][1] = 0;
        input[2][2] = 0;

        ComputeRightCauchyGreenTensor(input);
        
        double eigenvals[3];
        double *eigenvecs[3];

        double outrow1[3];
        double outrow2[3];
        double outrow3[3];
        eigenvecs[0] = outrow1;
        eigenvecs[1] = outrow2;
        eigenvecs[2] = outrow3;

        vtkMath::Jacobi(input, eigenvals, eigenvecs);

        double diff = fabs(eigenvecs[0][0] * eigenvecs[0][0] +
                           eigenvecs[0][1] * eigenvecs[0][1] +
                           eigenvecs[0][2] * eigenvecs[0][2] - 1.0);

        if( diff > std::numeric_limits<double>::round_error() )
        {
          ++cc;

          if( maxDiff < diff )
            maxDiff = diff;
        }

        if( atts.GetEigenComponent() == LCSAttributes::First )
        {
          result->SetTuple1(l, eigenvals[0]);
          secondary->SetTuple(l, eigenvecs[0]);
        }
        else if( atts.GetEigenComponent() == LCSAttributes::Second )
        {
          result->SetTuple1(l, eigenvals[1]);
          secondary->SetTuple(l, eigenvecs[1]);
        }
        else // if( atts.GetEigenComponent() == LCSAttributes::Third )
        {
          result->SetTuple1(l, eigenvals[2]);
          secondary->SetTuple(l, eigenvecs[2]);
        }
    }

    if( cc )
      std::cerr << cc << "VTK bad eigen vector(s) " << maxDiff << std::endl;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeLyapunovExponent
//
//  Purpose:
//      Computes the FTLE or FLLE given a Jacobian. Which is the
//      following: log of the square root of the maximum eigen value
//      of the right Caughy-Green Tensor with the result divided by
//      the time or distance.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Fri Sep  7 15:47:12 PDT 2012
//    Convert calculation to double precision, which prevents a "cliff" from
//    too large epsilon associated with float.
//
// ****************************************************************************

void avtLCSFilter::ComputeLyapunovExponent(vtkDataArray *jacobian[3],
                                           vtkDataArray *result)
{
    bool takeLog = doTime || doDistance;

    size_t nTuples = result->GetNumberOfTuples();

    // The base value is used to clamp the log values to be only
    // positive or both positive and negative.
    double baseValue, denominator = 1.0;

    // Clamp only if taking the log.
    if (takeLog && atts.GetClampLogValues() == true )
      baseValue = 1.0;
    else
      baseValue = std::numeric_limits<double>::epsilon();

    if( doTime )
      denominator /= maxTime;
    else if( doDistance )
      denominator /= maxDistance;

    for(size_t l = 0; l < nTuples; ++l)
    {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        ComputeRightCauchyGreenTensor(input);

        double eigenvals[3];

        // Get the eigen values.
        Jacobi( input, eigenvals );

        double lambda = baseValue;

        if( atts.GetEigenComponent() == LCSAttributes::First )
          lambda = sqrt( std::max( lambda, eigenvals[0] ) );
        else if( atts.GetEigenComponent() == LCSAttributes::Second )
          lambda = sqrt( std::max( lambda, eigenvals[1] ) );
        else if( atts.GetEigenComponent() == LCSAttributes::Third )
          lambda = sqrt( std::max( lambda, eigenvals[2] ) );

        if( takeLog )
          lambda = log( lambda );

        lambda *= denominator;

        result->SetTuple1(l, lambda);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataTree
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::CreateIterativeCalcDataTree(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return 0;
    
    int nc = inDT->GetNChildren();
    
    if (nc < 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //variable name.
        std::string var = outVarRoot + outVarName;

        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();

        //create new instance from old.
        vtkDataSet* out_ds = in_ds->NewInstance();
        out_ds->ShallowCopy(in_ds);
        int nTuples = in_ds->GetNumberOfPoints();

        // Create storage for the components that need to be used
        // for calculating the exponent. All arrays but the exponent
        // array will be deleted when done.
        vtkDoubleArray *exponents = vtkDoubleArray::New();
        exponents->SetName(var.c_str());
        exponents->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(exponents);
        // Will set the exponents to be the active scalars when
        // finished. In the mean time the component is the working
        // active scalars.
//      out_ds->GetPointData()->SetActiveScalars(var.c_str());

        for (size_t i = 0; i < (size_t)nTuples; i++)
          exponents->SetTuple1(i, std::numeric_limits<double>::min() );

        vtkDoubleArray *component = vtkDoubleArray::New();
        component->SetName("component");
        component->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(component);
        out_ds->GetPointData()->SetActiveScalars("component");
        
        vtkDoubleArray *times = vtkDoubleArray::New();
        times->SetName("times");
        times->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(times);

        //cleanup
        exponents->Delete();
        component->Delete();
        times->Delete();
        
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = CreateIterativeCalcDataTree(inDT->GetChild(j));
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataSet
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

vtkDataSet*
avtLCSFilter::CreateIterativeCalcDataSet()
{
  //rank 0
  //variable name.
  std::string var = outVarRoot + outVarName;

  //now create a rectilinear grid.
  size_t nTuples =
    global_resolution[0] * global_resolution[1] * global_resolution[2];

          
  // The grid is stored so not to be created as each curve is
  // extended.
  vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

  vtkDoubleArray* lxcoord = vtkDoubleArray::New();
  vtkDoubleArray* lycoord = vtkDoubleArray::New();
  vtkDoubleArray* lzcoord = vtkDoubleArray::New();

  rect_grid->SetDimensions(global_resolution);
      
  lxcoord->SetNumberOfTuples(global_resolution[0]);
  for (int i = 0; i < global_resolution[0]; i++)
  {
      double pcnt = 0;
      if (global_resolution[0] > 1)
        pcnt = ((double)i)/((double)global_resolution[0]-1);
      lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
  }

  lycoord->SetNumberOfTuples(global_resolution[1]);
  for (int i = 0; i < global_resolution[1]; i++)
  {
      double pcnt = 0;
      if (global_resolution[1] > 1)
        pcnt = ((double)i)/((double)global_resolution[1]-1);
      lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
  }

  lzcoord->SetNumberOfTuples(global_resolution[2]);
  for (int i = 0; i < global_resolution[2]; i++)
  {
      double pcnt = 0;
      if (global_resolution[2] > 1)
        pcnt = ((double)i)/((double)global_resolution[2]-1);
      lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
  }
      
  rect_grid->SetXCoordinates(lxcoord);
  rect_grid->SetYCoordinates(lycoord);
  rect_grid->SetZCoordinates(lzcoord);
        
  //cleanup
  lxcoord->Delete();
  lycoord->Delete();
  lzcoord->Delete();

  // std::cout << "final resolution: " << PAR_Rank() << " "
  //         << global_resolution[0] << " "
  //         << global_resolution[1] << " "
  //         << global_resolution[2] << std::endl;

  // Create storage for the components that need to be used
  // for calculating the exponent. All arrays but the exponent
  // array will be deleted when done.
  vtkDoubleArray *exponents = vtkDoubleArray::New();
  exponents->SetName(var.c_str());
  exponents->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(exponents);
  // Will set the exponents to be the active scalars when
  // finished. In the mean time the component is the working
  // active scalars.
  // rect_grid->GetPointData()->SetActiveScalars(var.c_str());

  for (size_t i = 0; i < nTuples; i++)
    exponents->SetTuple1(i, std::numeric_limits<double>::min() );

  vtkDoubleArray *component = vtkDoubleArray::New();
  component->SetName("component");
  component->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(component);
  rect_grid->GetPointData()->SetActiveScalars("component");

  vtkDoubleArray *times = vtkDoubleArray::New();
  times->SetName("times");
  times->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(times);

  //cleanup
  exponents->Delete();
  component->Delete();
  times->Delete();

  return rect_grid;
}
  

// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a native resolution grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::NativeMeshIterativeCalc(std::vector<avtIntegralCurve*> &ics)
{
    int offset = 0;

    if( *fsle_dt == NULL )
    {
      fsle_dt = CreateIterativeCalcDataTree(GetInputDataTree());
      
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
          fsle_dt = new avtDataTree();

      SetOutputDataTree(fsle_dt);
    }

    return MultiBlockIterativeCalc(fsle_dt, ics, offset);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

bool
avtLCSFilter::MultiBlockIterativeCalc(avtDataTree_p inDT,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset)
{
    if (*inDT == NULL)
        return true;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
        return true;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();

        return SingleBlockIterativeCalc( in_ds, ics, offset );
    }
    else
    {
      bool haveAllExponents = true;

      //
      // there is more than one input dataset to process
      // and we need an input datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
        if (inDT->ChildIsPresent(j) )
        {
          if( MultiBlockIterativeCalc( inDT->GetChild(j), ics, offset ) == false )
            haveAllExponents = false;
        }
      }

      return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      out_ds  The block to calculate the FSLE on
//      ics     The list of particles for all blocks on this MPI task.
//
//  Returns:    The new version of in_ds that includes the FSLE scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

bool
avtLCSFilter::SingleBlockIterativeCalc( vtkDataSet *out_ds,
                                        std::vector<avtIntegralCurve*> &ics,
                                        int &offset )
{
    //variable name.
    std::string var = outVarRoot + outVarName;

    int nTuples = out_ds->GetNumberOfPoints();
    
    int dims[3];

    if (out_ds->GetDataObjectType() == VTK_UNIFORM_GRID)
    {
      ((vtkUniformGrid*)out_ds)->GetDimensions(dims);
    }      
    else if (out_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
    {
      ((vtkRectilinearGrid*)out_ds)->GetDimensions(dims);
    }      
    else if (out_ds->GetDataObjectType() == VTK_STRUCTURED_GRID)
    {
      ((vtkStructuredGrid*)out_ds)->GetDimensions(dims);
    }      
    else
    {
      EXCEPTION1(VisItException,
                 "Can only compute SingleBlockIterativeCalc on "
                 "imagedata, rectilinear grids, or structured grids. ");
    }

    // Get the stored data arrays
    vtkDataArray* jacobian[3];
    
    vtkDoubleArray *exponents = (vtkDoubleArray *)
      out_ds->GetPointData()->GetArray(var.c_str());
    vtkDoubleArray *component = (vtkDoubleArray *)
      out_ds->GetPointData()->GetArray("component");
    vtkDoubleArray *times = (vtkDoubleArray *)
      out_ds->GetPointData()->GetArray("times");

    // Storage for the points and times
    std::vector<avtVector> remapPoints(nTuples);
    std::vector<double> remapTimes(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l < remapPoints.size()) ///l >= 0 is always true
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < (size_t)nTuples; i++)
        {
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
            {
                remapPoints[i] = seedPoints.at(offset + i);
                remapTimes[i] = 0;
            }
            else
            {
                remapPoints[i] = zero;
                remapTimes[i] = 0;
            }
        }
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
        {
            remapPoints[i] = seedPoints.at(offset + i);
            remapTimes[i] = 0;
        }
    }

    for(size_t i = 0; i < ics.size(); ++i)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t index = ic->id;
        int l = (int)(index-offset);

        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(l >= 0 && l < (int)remapPoints.size())
        {
          // remapPoints[l] = ((avtLCSIC*)ics[i])->GetEndPoint() -
          //                ((avtLCSIC*)ics[i])->GetStartPoint();

          remapPoints.at(l) = ic->GetEndPoint();

          if( doPathlines )
            remapTimes.at(l) = ic->GetTime() - seedTime0;
          else
            remapTimes.at(l) = ic->GetTime();
        }
    }

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    // Note the mesh is uniform with all distances being one.
    for(int i = 0; i < 3; ++i)
    {
        for(size_t j = 0; j < (size_t)nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_ds, var.c_str());
    }

    // Store the times for the exponent.
    for(size_t l = 0; l < (size_t)nTuples; ++l)
    {
      times->SetTuple1(l, remapTimes[l]);
    }

    for (int i = 0; i < nTuples; i++)
      component->SetTuple1(i, std::numeric_limits<double>::epsilon());

    //now have the jacobian - 3 arrays with 3 components.
    ComputeLyapunovExponent(jacobian, component);
    
    jacobian[0]->Delete();
    jacobian[1]->Delete();
    jacobian[2]->Delete();
    
    // Compute the FSLE
    ComputeFSLE( component, times, exponents );

    bool haveAllExponents = true;

    // For each integral curve check it's mask value to see it
    // additional integration is required.
    for(size_t i=0; i<ics.size(); ++i)
    {
      avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

      size_t index = ic->id;
      size_t l = (index-offset);

      if( ic->maxSteps < (unsigned int)maxSteps )
      {
        ic->maxSteps++;
        ic->status.ClearTerminationMet();
      }

      // Check to see if all exponents have been found.
      if( exponents->GetTuple1(l) == std::numeric_limits<double>::min() &&
          ic->maxSteps < (unsigned int)maxSteps )
        haveAllExponents = false;
    }
    
    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    return haveAllExponents;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a rectilinear grid.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::RectilinearGridIterativeCalc( std::vector<avtIntegralCurve*> &ics )
{
//  std::cerr << "Computing ... " << std::endl;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        indices[i] = ic->id;

//        avtVector spoint = ic->GetStartPoint();

        avtVector point = ic->GetEndPoint();

//      if( spoint[0] == 79 && spoint[1] == 90 && spoint[2] == 10 )
        // if( spoint[0] == 76 && spoint[1] == 88 && spoint[2] == 10 )
        //   std::cerr << i << "   " << ic->id << "   "
        //          << spoint[0] << "  " << spoint[1] << "  " << spoint[2] << "    "

        //          << point[0] << "  " << point[1] << "  " << point[2] << "  "
        //          << std::endl;

        points[j+0] = point[0];
        points[j+1] = point[1];
        points[j+2] = point[2];

        if( doPathlines )
          times[i] = ic->GetTime() - seedTime0;
        else
          times[i] = ic->GetTime();

        // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
        //             << end_point << std::endl;
    }

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), (int)indices.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), (int)points.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), (int)times.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        return true;
    }
    else
    {
        //variable name.
        std::string var = outVarRoot + outVarName;

        //now global grid has been created.
        if( fsle_ds == 0 )
          fsle_ds = CreateIterativeCalcDataSet();

        // Get the stored data arrays
        vtkDoubleArray *exponents = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray(var.c_str());
        vtkDoubleArray *component = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray("component");
        vtkDoubleArray *times = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray("times");

        size_t nTuples = exponents->GetNumberOfTuples();

        // Storage for the points and times
        std::vector<avtVector> remapPoints(nTuples);
        std::vector<double> remapTimes(nTuples);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i] ||
               index_counts[i]   != time_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }

            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(size_t j=0, k=0; j<total; ++j, k+=3)
        {
            size_t index = all_indices[j];

            if(nTuples <= index)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;
            
            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);

            remapTimes[index] = all_times[j];

            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        // Store the times for the exponent.
        for(size_t l=0; l<nTuples; ++l)
          times->SetTuple1(l, remapTimes[l]);

        //use static function in avtGradientExpression to calculate
        //gradients.  since this function only does scalar, break our
        //vectors into scalar components and calculate one at a time.

        vtkDataArray* jacobian[3];

        for(int i = 0; i < 3; ++i)
        {
            // Store the point component by component
            for(size_t l=0; l<nTuples; ++l)
                component->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(fsle_ds, "component");
        }

        for (size_t i = 0; i < nTuples; i++)
          component->SetTuple1(i, std::numeric_limits<double>::epsilon());

        //now have the jacobian - 3 arrays with 3 components.
        ComputeLyapunovExponent(jacobian, component);
        
        jacobian[0]->Delete();
        jacobian[1]->Delete();
        jacobian[2]->Delete();
      
        // Compute the FSLE
        ComputeFSLE( component, times, exponents );

        bool haveAllExponents = true;

        // For each integral curve check it's mask value to see it
        // additional integration is required.

        for(size_t i=0; i<ics.size(); ++i)
        {
          avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

          if( ic->maxSteps < (unsigned int)maxSteps )
          {
            ic->maxSteps++;
            ic->status.ClearTerminationMet();
          }

          size_t l = ic->id; // The curve id is the index into the VTK data.

          // Check to see if all exponents have been found.
          if( exponents->GetTuple1(l) == std::numeric_limits<double>::min() &&
              ic->maxSteps < (unsigned int)maxSteps )
            haveAllExponents = false;
        }

//      std::cerr << haveAllExponents << std::endl;

        //cleanup.
        if (all_indices)   delete [] all_indices;
        if (index_counts)  delete [] index_counts;

        if (all_points)    delete [] all_points;
        if (point_counts)  delete [] point_counts;

        if (all_times)    delete [] all_times;
        if (time_counts)  delete [] time_counts;

        return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeFSLE
//
//  Purpose:
//      Computes the FSLE given the distances.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeFSLE( vtkDataArray *component,
                                vtkDataArray *times,
                                vtkDataArray *exponents )
{
  size_t nTuples = component->GetNumberOfTuples();

  for(size_t l = 0; l < nTuples; ++l)
  {
    double lambda = exponents->GetTuple1(l);

    // if( l == 20200 )
    //   std::cerr << lambda << std::endl;

    // If the exponent was previously set skip checking it.
    if( lambda == std::numeric_limits<double>::min() )
    {
      // if( l == 20200 )
      //        std::cerr
      //          << floor( fabs(times->GetTuple1(l)) / maxStepLength + 0.5) << "  "
      //          << numSteps << std::endl;

      // Check for a curve that has terminated which will not have
      // taken a step forward or backwards.
      if( floor( fabs(times->GetTuple1(l)) / maxStepLength + 0.5) != numSteps )
      {
        // If a curve has terminated set the exponent to zero.
        lambda = 0;
        exponents->SetTuple1(l, lambda);
      }            

      // Check the distances between neighbors.
      else
      {
        double size = component->GetTuple1(l);

        minSizeValue = std::min(size, minSizeValue);
        maxSizeValue = std::max(size, maxSizeValue);

        // Record the Lyapunov exponent if the max
        // size has been reached.
        if( maxSize < size )
        {
          lambda = log( size ) / fabs(times->GetTuple1(l));
              
          exponents->SetTuple1(l, lambda);
        }
      }
    }
  }

  // std::cerr << minSizeValue << "  " << maxSizeValue << std::endl;
}


// ****************************************************************************
//  Method: avtLCSFilter::InBounds
//
//  Purpose:
//      Returns true if indexes are in bounds.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::InBounds( int x, int y, int z,
                            int x_max, int y_max, int z_max )
{
  if( 0 <= x && x < x_max &&
      0 <= y && y < y_max &&
      0 <= z && z < z_max )
    return (z * y_max + y) * x_max + x;
  else
    return -1;
}


// ****************************************************************************
//  Method: avtLCSFilter::Increment
//
//  Purpose:
//      Increments a counter
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::Increment( int x, int y, int z, vtkDataArray *array,
                              int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );
  
  if( 0 <= l && l < array->GetNumberOfTuples() )
  {      
    int cc = array->GetTuple1(l);
    ++cc;
    array->SetTuple1(l, cc);
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::Value
//
//  Purpose:
//      Returns the value for a coordinate
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

double avtLCSFilter::Value( int x, int y, int z, vtkDataArray *array,
                            int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );

  if( 0 <= l && l < array->GetNumberOfTuples() )
    return array->GetTuple1(l);
  else
    return 0;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateNativeMeshIterativeCalcOutput
//
//  Purpose:
//      Computes the IterativeCalc output (via sub-routines) after the PICS filter
//      has calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateNativeMeshIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    int    offset = 0;
    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    count  = 0;

    CreateMultiBlockIterativeCalcOutput(GetInputDataTree(), GetDataTree(),
                                        ics, offset, minv, maxv, count);

    int nTuples = (int)ics.size();

    if( 1 || count <= nTuples/10 )
    {
      if( minSizeValue == std::numeric_limits<double>::max() )
        minSizeValue = 0.0;
      
      if( maxSizeValue == std::numeric_limits<double>::min() )
        maxSizeValue = 0.0;
      
      char str[1028];
      
      SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
               "exaimed produced a valid exponent (%f to %f). "
               "This may be due to too large of a size limit (%f), "
               "too small of an integration step (%f), or "
               "too few integration steps (%d out of %d where taken), or "
               "simply due to the nature of the data. "
               "The size range was from %f to %f. ",
               (int) (100.0 * (double) count / (double) nTuples),
               count, nTuples,
               minv, maxv,
               maxSize, maxStepLength, numSteps, maxSteps,
               minSizeValue, maxSizeValue );
      
      avtCallback::IssueWarning(str);
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateMultiBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::CreateMultiBlockIterativeCalcOutput( avtDataTree_p inDT,
                                                   avtDataTree_p outDT,
                                                   std::vector<avtIntegralCurve*> &ics,
                                                   int &offset,
                                                   double &minv, double &maxv,
                                                   int &count)
{
    if (*inDT == NULL || *outDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
        return;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        CreateSingleBlockIterativeCalcOutput(in_ds, out_ds, ics,
                                             offset, dom, minv, maxv, count);
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            CreateMultiBlockIterativeCalcOutput(inDT->GetChild(j),
                                                outDT->GetChild(j),
                                                ics, offset, minv, maxv, count);
      }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateSingleBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//      count   The number of nodes with a valid exponent
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

void
avtLCSFilter::CreateSingleBlockIterativeCalcOutput( vtkDataSet *in_ds,
                                                    vtkDataSet *out_ds,
                                                    std::vector<avtIntegralCurve*> &ics,
                                                    int &offset, int domain,
                                                    double &minv, double &maxv,
                                                    int &count )
{
  //variable name.
  std::string var = outVarRoot + outVarName;

  vtkDoubleArray *exponents = (vtkDoubleArray *)
    out_ds->GetPointData()->GetArray(var.c_str());

  int nTuples = exponents->GetNumberOfTuples();

  bool clampLogValues = atts.GetClampLogValues();

  for(size_t i=0; i<ics.size(); ++i)
  {
    avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];
    
    size_t index = ic->id;
    size_t l = (index-offset);

    double lambda = exponents->GetTuple1(l);
    
    if( lambda == std::numeric_limits<double>::min() )
    {
      lambda = 0;
      exponents->SetTuple1(l, lambda );
    }
    else
    {
      ++count;
      ic->status.ClearTerminationMet();

      if( clampLogValues && lambda < 0 )
      {
        lambda = 0;
        exponents->SetTuple1(l, lambda );
      }
    }
    
    minv = std::min(lambda, minv);
    maxv = std::max(lambda, maxv);
    
  }

  // Make the exponents the the active scalars.
  out_ds->GetPointData()->SetActiveScalars(var.c_str());

  // Remove the working arrays.
  out_ds->GetPointData()->RemoveArray("component");
  out_ds->GetPointData()->RemoveArray("times");

  //done with offset, increment it for the next call to this
  //function.
  offset += nTuples;

  //store this dataset in Cache for next time.
  // double bounds[6];
  // fsle_ds->GetBounds(bounds);
          
  // std::cout << "final size and bounds: "
  //          << PAR_Rank() << " " << nTuples << " "
  //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
  //          << " " << bounds[3] << " " << bounds[4] << " "
  //          << bounds[5] << std::endl;

  // std::cerr << "Caching fsle_ds" << std::endl;
  
  
  //Store this dataset in Cache for next time.
  std::string str = CreateCacheString();  
  StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                          outVarName.c_str(), domain, -1,
                          str.c_str(), out_ds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateRectilinearGridIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent output (via sub-routines) after the PICS filter has
//      calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateRectilinearGridIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
      if (fsle_ds->GetDataObjectType() != VTK_RECTILINEAR_GRID)
      {
        EXCEPTION1(VisItException,
                   "Can only compute CreateRectilinearGridIterativeCalcOutput on "
                   "rectilinear grids. ");
      }

      //variable name.
      std::string var = outVarRoot + outVarName;

      vtkDoubleArray *exponents = (vtkDoubleArray *)
        fsle_ds->GetPointData()->GetArray(var.c_str());

      int nTuples = exponents->GetNumberOfTuples();

      //min and max values over all datasets of the tree.
      double minv = std::numeric_limits<double>::max();
      double maxv = std::numeric_limits<double>::min();
      
      int count = 0;

      bool clampLogValues = atts.GetClampLogValues();

      for(size_t i=0; i<ics.size(); ++i)
      {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t l = ic->id; // The curve id is the index into the VTK data.

        double lambda = exponents->GetTuple1(l);

        if( lambda == std::numeric_limits<double>::min() )
        {
          lambda = 0;
          exponents->SetTuple1(l, lambda );
        }
        else
        {
          ++count;
          ic->status.ClearTerminationMet();

          if( clampLogValues && lambda < 0 )
          {
            lambda = 0;
            exponents->SetTuple1(l, lambda );
          }
        }

        minv = std::min(lambda, minv);
        maxv = std::max(lambda, maxv);
      }

      if( count <= nTuples/10 )
      {
        if( minSizeValue == std::numeric_limits<double>::max() )
          minSizeValue = 0.0;

        if( maxSizeValue == std::numeric_limits<double>::min() )
          maxSizeValue = 0.0;

        char str[1028];

        SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
                 "exaimed produced a valid exponent (%f to %f). "
                 "This may be due to too large of a size limit (%f), "
                 "too small of an integration step (%f), or "
                 "too few integration steps (%d out of %d where taken), or "
                 "simply due to the nature of the data. "
                 "The size range was from %f to %f. ",
                 (int) (100.0 * (double) count / (double) nTuples),
                 count, nTuples,
                 minv, maxv,
                 maxSize, maxStepLength, numSteps, maxSteps,
                 minSizeValue, maxSizeValue );

        avtCallback::IssueWarning(str);
      }
      
      // Make the exponents the the active scalars.
      fsle_ds->GetPointData()->SetActiveScalars(var.c_str());

      // Remove the working arrays.
      fsle_ds->GetPointData()->RemoveArray("component");
      fsle_ds->GetPointData()->RemoveArray("times");

      //store this dataset in Cache for next time.
      // double bounds[6];
      // fsle_ds->GetBounds(bounds);
          
      // std::cout << "final size and bounds: "
      //          << PAR_Rank() << " " << nTuples << " "
      //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
      //          << " " << bounds[3] << " " << bounds[4] << " "
      //          << bounds[5] << std::endl;

      // std::cerr << "Caching fsle_ds" << std::endl;
      std::string str = CreateCacheString();
      StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1,
                              str.c_str(), fsle_ds);
      
      int index = 0;//what does index mean in this context?
      avtDataTree* dt = new avtDataTree(fsle_ds,index);
      int x = 0;
      dt->GetAllLeaves(x);
      
      // std::cout << "total leaves:: " << x << std::endl;
      
      SetOutputDataTree(dt);
      
      //set atts.
      avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
      avtExtents* e = dataatts.GetThisProcsActualDataExtents();
      
      double range[2];
      range[0] = minv;
      range[1] = maxv;
      e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ReportWarnings() 
//
//  Purpose:
//      Reports any potential integration warnings
//
//  Programmer: Allen Sanderson
//  Creation:   20 August 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtLCSFilter::ReportWarnings(std::vector<avtIntegralCurve *> &ics)
{
    if (ics.size() == 0)
        return;

    int numICs = (int)ics.size();
//    int numPts = 0;
    int numEarlyTerminators = 0;
    int numStiff = 0;
    int numCritPts = 0;

    if (DebugStream::Level5())
    {
        debug5 << "::CreateIntegralCurveOutput " << ics.size() << endl;
    }

    //See how many pts, ics we have so we can preallocate everything.
    for (int i = 0; i < numICs; i++)
    {
        bool terminatedBecauseOfMaxSteps;
        bool encounteredNumericalProblems;

        if( doSize )
        {
            avtStreamlineIC *ic = dynamic_cast<avtStreamlineIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }
        else
        {
            avtLCSIC *ic = dynamic_cast<avtLCSIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }

        // NOT USED ??????????????????????????
        // size_t numSamps = (ic ? ic->GetNumberOfSamples() : 0);
        // if (numSamps > 1)
        //     numPts += numSamps;

        if (terminatedBecauseOfMaxSteps)
        {
            // Calculated only with avtStateRecorderIntegralCurve
            // if (ic->SpeedAtTermination() <= criticalPointThreshold)
            //     numCritPts++;
            // else
            numEarlyTerminators++;
        }

        if (encounteredNumericalProblems)
            numStiff++;
    }

    char str[4096] = "";

    if ((doDistance || doTime || doSize) && issueWarningForMaxStepsTermination)
    {
        SumIntAcrossAllProcessors(numEarlyTerminators);
        if (numEarlyTerminators > 0)
        {
          SNPRINTF(str, 4096,
                   "%s\n%d of your integral curves terminated because they "
                   "reached the maximum number of steps.  This may be indicative of your "
                   "time or distance criteria being too large or of other attributes being "
                   "set incorrectly (example: your step size is too small).  If you are "
                   "confident in your settings and want the particles to advect farther, "
                   "you should increase the maximum number of steps.  If you want to disable "
                   "this message, you can do this under the Advaced tab."
                   "  Note that this message does not mean that an error has occurred; it simply "
                   "means that VisIt stopped advecting particles because it reached the maximum "
                   "number of steps. (That said, this case happens most often when other attributes "
                   "are set incorrectly.)\n", str, numEarlyTerminators);
        }
    }

    if (issueWarningForCriticalPoints)
    {
        SumIntAcrossAllProcessors(numCritPts);
        if (numCritPts > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves circled round and round a critical point (a zero"
                     " velocity location).  Normally, VisIt is able to advect the particle "
                     "to the critical point location and terminate.  However, VisIt was not able "
                     "to do this for these particles due to numerical issues.  In all likelihood, "
                     "additional steps will _not_ help this problem and only cause execution to "
                     "take longer.  If you want to disable this message, you can do this under "
                     "the Advanced tab.\n", str, numCritPts);
        }
    }

    if (issueWarningForStiffness)
    {
        SumIntAcrossAllProcessors(numStiff);
        if (numStiff > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves were unable to advect because of \"stiffness\".  "
                     "When one component of a velocity field varies quickly and another stays "
                     "relatively constant, then it is not possible to choose step sizes that "
                     "remain within tolerances.  This condition is referred to as stiffness and "
                     "VisIt stops advecting in this case.  If you want to disable this message, "
                     "you can do this under the Advanced tab.\n", str,numStiff);
        }
    }

    if( strlen( str ) )
      avtCallback::IssueWarning(str);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateCacheString
//
//  Purpose:
//      A routine that calculates a string for caching that encodes all the
//      parameters of the LCS: bounds, integration time, and variable name.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

std::string
avtLCSFilter::CreateCacheString(void)
{
  const int*    resolution = atts.GetResolution();
  const double* startPosition = atts.GetStartPosition();
  const double* endPosition = atts.GetEndPosition();
  const double* velocitySource = atts.GetVelocitySource();

  std::ostringstream os;

  // Note the string is a brute force string. That is all attributes
  // are munged together regarless of whether they are used. Overly
  // simple but most attributes can not be changed unless an option is
  // selected. As such, for the most part the brute force approach is
  // acceptable.
  os << cycleCached << "  "
     << timeCached << "  "
     << atts.GetSourceType() << " "
     << resolution[0] << " "
     << resolution[1] << " "
     << resolution[2] << " "
     << atts.GetUseDataSetStart() << " "
     << startPosition[0] << " "
     << startPosition[1] << " "
     << startPosition[2] << " "
     << atts.GetUseDataSetEnd() << " "
     << endPosition[0] << " "
     << endPosition[1] << " "
     << endPosition[2] << " "
     << atts.GetIntegrationDirection() << " "
     << atts.GetMaxSteps() << " "
     << atts.GetOperationType() << " "
     << atts.GetEigenComponent() << " "
     << atts.GetOperatorType() << " "
     << atts.GetClampLogValues() << " "
     << atts.GetTerminationType() << " "
     << atts.GetTerminateBySize() << " "
     << atts.GetTermSize() << " "
     << atts.GetTerminateByDistance() << " "
     << atts.GetTermDistance() << " "
     << atts.GetTerminateByTime() << " "
     << atts.GetTermTime() << " "
     << atts.GetMaxStepLength() << " "
     << atts.GetLimitMaximumTimestep() << " "
     << atts.GetMaxTimeStep() << " "
     << atts.GetRelTol() << " "
     << atts.GetAbsTolSizeType() << " "
     << atts.GetAbsTolAbsolute() << " "
     << atts.GetAbsTolBBox() << " "
     << atts.GetFieldType() << " "
     << atts.GetFieldConstant() << " "
     << velocitySource[0] << " "
     << velocitySource[1] << " "
     << velocitySource[2] << " "
     << atts.GetIntegrationType() << " "
     << atts.GetParallelizationAlgorithmType() << " "
     << atts.GetMaxProcessCount() << " "
     << atts.GetMaxDomainCacheSize() << " "
     << atts.GetWorkGroupSize() << " "
     << atts.GetPathlines() << " "
     << atts.GetPathlinesOverrideStartingTimeFlag() << " "
     << atts.GetPathlinesOverrideStartingTime() << " "
     << atts.GetPathlinesCMFE() << " "
     << atts.GetForceNodeCenteredData() << " "
     << atts.GetIssueTerminationWarnings() << " "
     << atts.GetIssueStiffnessWarnings() << " "
     << atts.GetIssueCriticalPointsWarnings() << " "
     << atts.GetCriticalPointThreshold() << " ";

  return os.str();
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedDataSet
//
//  Purpose:
//      Checks to see if we have already calculated the LCS.  Works for
//      both resampling and native options (realized through sub-routine calls).
//      This routine uses collective communication to decided whether
//      it can use a cached data set.
//      - For the native resolution, all domains on all MPI tasks must have
//      the LCS cached.
//      - For the resampled version, one MPI task somewhere must find it.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedDataSet()
{
    avtDataTree_p rv = NULL;
    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        rv = GetCachedNativeDataSet(GetInputDataTree());
        int looksOK = 1;
        if ((*rv == NULL) && (*(GetInputDataTree()) != NULL))
            looksOK = 0;
        looksOK = UnifyMinimumValue(looksOK); // if any fails, we all fail
        if (looksOK == 0)
            rv = NULL;
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        rv = GetCachedResampledDataSet();
        int looksOK = (*rv == NULL ? 0 : 1);
        looksOK = UnifyMaximumValue(looksOK); // if one has it, we're all OK
        if (looksOK == 0)
            rv = NULL;
        else if ((looksOK == 1) && (*rv == NULL))
            rv = new avtDataTree();
    }
    return rv;
}

// ****************************************************************************
//  Method: avtLCSFilter::GetCachedNativeDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS on this
//      domain previously.  Checks to make sure parameters match: integration
//      time, etc.
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedNativeDataSet(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return NULL;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return NULL;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        int domain = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        std::string str = CreateCacheString();
        vtkDataSet *rv = (vtkDataSet *)
          FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                  outVarName.c_str(), domain, -1, str.c_str());
        if (rv == NULL)
            return NULL;
        else
            return new avtDataTree(rv, domain, label);
    }

    //
    // there is more than one input dataset to process
    // and we need an output datatree for each
    //
    avtDataTree_p *outDT = new avtDataTree_p[nc];
    bool badOne = false;
    for (int j = 0; j < nc; j++)
    {
        if (inDT->ChildIsPresent(j))
        {
            outDT[j] = GetCachedNativeDataSet(inDT->GetChild(j));
            if (*(outDT[j]) == NULL)
                badOne = true;
        }
        else
        {
            outDT[j] = NULL;
        }
    }

    avtDataTree_p rv = NULL;

    if (!badOne) // if we don't have LCS for one domain, then just re-calc whole thing
        rv = new avtDataTree(nc, outDT);
    delete [] outDT;
    return rv;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedResampledDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS before.  It
//      also ensures that the parameters of previous calculations are the
//      same: integration time, bounds, variable, etc.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedResampledDataSet()
{
    std::string str = CreateCacheString();
    vtkRectilinearGrid *rv = (vtkRectilinearGrid *)
      FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1, str.c_str());

    if(rv != NULL)
    {
        return new avtDataTree(rv, -1);
    }

    return NULL;
}
