/*****************************************************************************
 *
 * Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
 * Produced at the Lawrence Livermore National Laboratory
 * LLNL-CODE-442911
 * All rights reserved.
 *
 * This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
 * full copyright notice is contained in the file COPYRIGHT located at the root
 * of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
 *
 * Redistribution  and  use  in  source  and  binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of  source code must  retain the above  copyright notice,
 *    this list of conditions and the disclaimer below.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
 *    documentation and/or other materials provided with the distribution.
 *  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
 * ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
 * LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
 * DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
 * CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
 * LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
 * OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 *****************************************************************************/

// ************************************************************************* //
//  File: avtSPHResampleFilter.C
// ************************************************************************* //
#include <algorithm>

#include <vtkDataSet.h>
#include <avtSPHResampleFilter.h>
#include <avtParallel.h>
#include <avtResampleSelection.h>

#include <vtkCellData.h>
#include <vtkCellType.h>
#include <vtkPoints.h>
#include <vtkPointData.h>
#include <vtkDoubleArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkAppendPolyData.h>
#include <vtkCleanPolyData.h>

#include <InvalidVariableException.h>
#include <DebugStream.h>

#ifdef PARALLEL
#include <mpi.h>
#endif

using std::vector;
using std::min;
using std::max;

// ****************************************************************************
//  Method: avtSPHResampleFilter constructor
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

avtSPHResampleFilter::avtSPHResampleFilter() : keepNodeZone(false)
{
    
}


// ****************************************************************************
//  Method: avtSPHResampleFilter destructor
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
//  Modifications:
//
// ****************************************************************************

avtSPHResampleFilter::~avtSPHResampleFilter()
{
}


// ****************************************************************************
//  Method:  avtSPHResampleFilter::Create
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

avtFilter *
avtSPHResampleFilter::Create()
{
    return new avtSPHResampleFilter();
}


// ****************************************************************************
//  Method:      avtSPHResampleFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

void
avtSPHResampleFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const SPHResampleAttributes*)a;
}


// ****************************************************************************
//  Method: avtSPHResampleFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtSPHResampleFilter with the given
//      parameters would result in an equivalent avtSPHResampleFilter.
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

bool
avtSPHResampleFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(SPHResampleAttributes*)a);
}

// ****************************************************************************
// Method:  avtSPHResampleFilter::kernelValue
//
// Purpose:
//   Return the value of the kernel for a given normalized distance.
//
// Arguments:
//   etaMagnitude   The normalized distance (r/h)
//   Hdet           Determinant of the support tensor (if the tensor is symmetric,
//                  this is equivalent to 1/h^3 and can never be zeror under
//                  normal circumstances)
//
// Programmer:  Cody Raskin (raskin1@llnl.gov)
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
double
avtSPHResampleFilter::kernelValue(double etaMagnitude, double Hdet) {
    double result = 0;
    double volumeNormalization = 10.0/(7.0*3.14159);
    if(Dim==3)
        volumeNormalization = 1.0/3.14159;
    
    if (etaMagnitude < 1.0) {
        double eta2 = etaMagnitude*etaMagnitude;
        result = volumeNormalization*Hdet*(1.0 - 1.5*eta2 + 0.75*eta2*etaMagnitude);
    } else if (etaMagnitude < 2.0) {
        result = volumeNormalization*Hdet*0.25*pow(2.0 - etaMagnitude,3.0);
    } else {
        result = 0;
    }
    
    return result;
}

// ****************************************************************************
// Method:  avtSPHResampleFilter::kernelGradValue
//
// Purpose:
//   Return the value of the gradient of the kernel for a given normalized distance
//
// Arguments:
//   etaMagnitude   The normalized distance (r/h)
//   Hdet           Determinant of the support tensor (if the tensor is symmetric,
//                  this is equivalent to 1/h^3 and can never be zero under normal
//                  circumstances)
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
double
avtSPHResampleFilter::kernelGradValue(double etaMagnitude, double Hdet) {
    
    double volumeNormalization = 10.0/(7.0*3.14159);
    if(Dim==3)
        volumeNormalization = 1.0/3.14159;
    
    if (etaMagnitude < 1.0) {
        return -volumeNormalization*Hdet*(3.0 - 2.25*etaMagnitude)*etaMagnitude;
    } else if (etaMagnitude < 2.0) {
        return -volumeNormalization*Hdet*0.75*pow(2.0 - etaMagnitude,2.0);
    } else {
        return 0.0;
    }
}

// ****************************************************************************
// Method:  stepSize
//
// Purpose:
//   Compute the step size of the grid.
//
// Arguments:
//   xmin       Vector for the min grid location in each direction
//   xmax       Vector for the max grid location in each direction
//   nsample    Vector for the number of grid cells in each direction
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
inline
vector<double>
stepSize(vector<double>& xmin, vector<double>& xmax, vector<int>& nsample) {
    vector<double> result(Dim);
    for (int i = 0; i < Dim; ++i) {
        result[i] = (xmax[i]-xmin[i])/nsample[i];
    }
    
    return result;
}

// ****************************************************************************
// Method:  makeIndex
//
// Purpose:
//   Generate the dimension appropriate index vector from integers.
//
// Arguments:
//   ix Dimension 1 index
//   iy Dimension 2 index
//   iz Dimension 3 index
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
inline
vector<int>
makeIndex(const int ix,
          const int iy,
          const int iz) {
    //REQUIRE(false);
}

template<>
inline
vector<int>
makeIndex<1>(const int ix,
             const int iy,
             const int iz) {
    vector<int> result(1);
    result[0] = ix;
    return result;
}

template<>
inline
vector<int>
makeIndex<2>(const int ix,
             const int iy,
             const int iz) {
    vector<int> result(2);
    result[0] = ix;
    result[1] = iy;
    return result;
}

template<>
inline
vector<int>
makeIndex<3>(const int ix,
             const int iy,
             const int iz) {
    vector<int> result(3);
    result[0] = ix;
    result[1] = iy;
    result[2] = iz;
    return result;
}

// ****************************************************************************
// Method:  latticePoints
//
// Purpose:
//   Compute the indicies of the lattice over which a given particle overlaps.
//
// Arguments:
//   ri         Location of the particle
//   extent     Extent of the kernel
//   xmin       Vector for the min grid location in each direction
//   stepSize   Vector describing the distance between grid location in each direction
//   nsample    Vector for the number of grid cells in each direction
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
inline
vector< vector<int> >
latticePoints(const double* ri,
              vector<double>& extent,
              vector<double>& xmin,
              vector<double>& stepSize,
              const vector<int>& nsample) {
    // Find the min & max indicies in each dimension.
    vector<int> imin(Dim);
    vector<int> imax(Dim);
    int ntot = 1;
    
    for (int i = 0; i < Dim; ++i) {
        imin[i] = max(0, min(nsample[i] - 1, int((ri[i] - extent[i] - xmin[i])/stepSize[i])));
        imax[i] = max(0, min(nsample[i] - 1, int((ri[i] + extent[i] - xmin[i])/stepSize[i]) + 1));
        ntot *= imax[i] - imin[i] + 1;
    }
    
    // Now build the result with the full set of indicies.
    vector< vector<int> > result;
    result.reserve(ntot);
    int ix = imin[0];
    int iy = imin[1];
    int iz = Dim == 3 ? imin[2] : 0;
    int i = 0;
    
    while (i < ntot) {
        result.push_back(makeIndex<Dim>(ix, iy, iz));
        ++i;
        ++ix;
        if (ix > imax[0]) {
            ix = imin[0];
            ++iy;
            if (iy > imax[1]) {
                iy = imin[1];
                ++iz;
            }
        }
    }
    
    return result;
}

// ****************************************************************************
// Method:  latticePosition
//
// Purpose:
//   Compute the position for the given lattice index.
//
// Arguments:
//   indicies       Vector of grid indices
//   xmin           Vector for the minimum grid location in each direction
//   xmax           Vector for the maximum grid location in each direction
//   xstep          Vector describing the distance between grid locations in
//                  each direction
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

template<int Dim>
inline
vector<double>
latticePosition(const vector<int>& indicies,
                vector<double>& xmin,
                vector<double>& xmax,
                vector<double>& xstep)
{
    vector<double> result(Dim);
    for(int k=0;k<Dim;++k)
        result[k] = xmin[k]+indicies[k]*xstep[k] + 0.5*xstep[k];
    return result;
}

// ****************************************************************************
// Method:  latticeIndex
//
// Purpose:
//    Convert the tuple of indicies into the flat index for the lattice arrays.
//
// Arguments:
//   indicies       Vector of grid indices
//   nsample        Vector for the number of grid cells in each direction
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************

inline
int
latticeIndex(const vector<int>& indicies,
             const vector<int>& nsample) {
    if (nsample.size() == 1) {
        return indicies[0];
    } else if (nsample.size() == 2) {
        return indicies[1]*nsample[0] + indicies[0];
    } else {
        return (indicies[2]*nsample[1]*nsample[0] +
                indicies[1]*nsample[0] +
                indicies[0]);
    }
}

// ****************************************************************************
// Method:  Helper Functions (mainly linear algebra)
//
// Purpose: Linear algebra
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************
template<int Dim>
inline
double
determinant(tensorStruct& T) {
    double result;
    if(Dim==3)  result = (T.xx*T.yy*T.zz + T.xy*T.yz*T.zx + T.xz*T.yx*T.zy) - (T.xx*T.yz*T.zy + T.xy*T.yx*T.zz + T.xz*T.yy*T.zx);
    else        result = T.xx*T.yy - T.xy*T.yx;
    return result;
}

template<int Dim>
inline
tensorStruct
square(tensorStruct& T) {
    tensorStruct S;
    if(Dim==3)
    {
        S.xx = T.xx*T.xx + T.xy*T.yx + T.xz*T.zx;
        S.xy = T.xx*T.xy + T.xy*T.yy + T.xz*T.zy;
        S.xz = T.xx*T.xz + T.xy*T.yz + T.xz*T.zz;
        S.yx = T.yx*T.xx + T.yy*T.yx + T.yz*T.zx;
        S.yy = T.yx*T.xy + T.yy*T.yy + T.yz*T.zy;
        S.yz = T.yx*T.xz + T.yy*T.yz + T.yz*T.zz;
        S.zx = T.zx*T.xx + T.zy*T.yx + T.zz*T.zx;
        S.zy = T.zx*T.xy + T.zy*T.yy + T.zz*T.zy;
        S.zz = T.zx*T.xz + T.zy*T.yz + T.zz*T.zz;
    }
    else
    {
        S.xx = T.xx*T.xx + T.xy*T.yx;
        S.xy = T.xx*T.xy + T.xy*T.yy;
        S.yx = T.yx*T.xx + T.yy*T.yx;
        S.yy = T.yx*T.xy + T.yy*T.yy;
    }
    return S;
}

template<int Dim>
inline
vector<double>
tensorVectorMult(tensorStruct& T,vector<double>& v) {
    vector<double> result(Dim);
    if(Dim==3)
    {
        result[0] = v[0]*T.xx + v[1]*T.xy + v[2]*T.xz;
        result[1] = v[0]*T.yz + v[1]*T.yy + v[2]*T.yz;
        result[2] = v[0]*T.zx + v[1]*T.zy + v[2]*T.zz;
    }
    else
    {
        result[0] = v[0]*T.xx + v[1]*T.xy;
        result[1] = v[0]*T.yx + v[1]*T.yy;
    }
    return result;
}

template<int Dim>
inline
tensorStruct
tensorScalarMult(tensorStruct& T, double x) {
    tensorStruct M;
    M.xx = T.xx * x;
    M.xy = T.xy * x;
    M.xz = T.xz * x;
    M.yx = T.yx * x;
    M.yy = T.yy * x;
    M.yz = T.yz * x;
    M.zx = T.zx * x;
    M.zy = T.zy * x;
    M.zz = T.zz * x;
    return M;
}

template<int Dim>
inline
tensorStruct
tensorSum(tensorStruct& T1, tensorStruct& T2) {
    tensorStruct M;
    M.xx = T1.xx + T2.xx;
    M.xy = T1.xy + T2.xy;
    M.xz = T1.xz + T2.xz;
    M.yx = T1.yx + T2.yx;
    M.yy = T1.yy + T2.yy;
    M.yz = T1.yz + T2.yz;
    M.zx = T1.zx + T2.zx;
    M.zy = T1.zy + T2.zy;
    M.zz = T1.zz + T2.zz;
    return M;
}

template<int Dim>
inline
tensorStruct
tensorInverse(tensorStruct& T) {
    tensorStruct M;
    double Tdet = determinant<Dim>(T);
    if(Dim==3)
    {
        M.xx = (T.yy*T.zz - T.yz*T.zy)/Tdet;
        M.xy = (T.xz*T.zy - T.xy*T.zz)/Tdet;
        M.xz = (T.xy*T.yz - T.xz*T.yy)/Tdet;
        M.yx = (T.yz*T.zx - T.yx*T.zz)/Tdet;
        M.yy = (T.xx*T.zz - T.xz*T.zx)/Tdet;
        M.yz = (T.xz*T.yx - T.xx*T.yz)/Tdet;
        M.zx = (T.yx*T.zy - T.yy*T.zx)/Tdet;
        M.zy = (T.xy*T.zx - T.xx*T.zy)/Tdet;
        M.zz = (T.xx*T.yy - T.xy*T.yx)/Tdet;
    }
    else
    {
        M.xx = T.yy/Tdet;
        M.xy = -1.0*T.xy/Tdet;
        M.yx = -1.0*T.yx/Tdet;
        M.yy = T.xx/Tdet;
    }
    return M;
}

template<int Dim>
inline
double
dotP(vector<double>& v1, vector<double>& v2) {
    double result;
    for(int k=0;k<Dim;++k)
        result += v1[k]*v2[k];
    return result;
}

template<int Dim>
inline
double
vectorMag(vector<double>& v) {
    double result=0;
    for(int d=0;d<Dim;++d)
        result += v[d]*v[d];
    result = sqrt(result);
    return result;
}

template<int Dim>
inline
vector<double>
vectorScalarMult(vector<double>& v, double s) {
    vector<double> result(Dim);
    for(int i=0;i<Dim;++i)
        result[i] = v[i]*s;
    return result;
}

template<int Dim>
inline
vector<double>
vectorSum(vector<double>& v1, vector<double>& v2) {
    vector<double> result(Dim);
    for(int i=0;i<Dim;++i)
        result[i] = v1[i] + v2[i];
    return result;
}

template<int Dim>
inline
tensorStruct
outerProduct(vector<double>& v1, vector<double>& v2) {
    tensorStruct M;
    M.xx = v1[0]*v2[0];
    M.xy = v1[0]*v2[1];
    M.yx = v1[1]*v2[0];
    M.yy = v1[1]*v2[1];
    if(Dim==3)
    {
        M.xz = v1[0]*v2[2];
        M.yz = v1[1]*v2[2];
        M.zx = v1[2]*v2[0];
        M.zy = v1[2]*v2[1];
        M.zz = v1[2]*v2[2];
    }
    return M;
}

// ****************************************************************************
//  Method:      avtSPHResampleFilter::GetIndexFromLatticeIndex
//
//  Purpose:
//      Return the local index corresponding to the lattice 1D index.
//
//  Arguments:
//      latticeIndex    The lattice index to convert to a local index
//
//  Returns:
//      The local index corresponding to the lattice index or -1 if there is no
//      corresponding local index.
//
//  Programmer: Kevin Griffin
//  Creation:   Tue Aug 25 18:01:32 PDT 2015
//
// ****************************************************************************
int
avtSPHResampleFilter::GetIndexFromLatticeIndex(const int latticeIndex)
{
    std::map<int,int>::iterator itr = latticeIndexMap.find(latticeIndex);
    
    if(itr != latticeIndexMap.end()) {
        return itr->second;
    }
    
    return -1;
}

template<int Dim>
tensorStruct *
avtSPHResampleFilter::CreateTensorStruct(vtkDataArray* const input_support, const int i)
{
    tensorStruct* Hi = new tensorStruct;
    
    if(input_support->GetNumberOfComponents() == 1)
    {
        if (Dim==3)
        {
            Hi->xx = 1.0/(*input_support->GetTuple(i));
            Hi->xy = 0.0;
            Hi->xz = 0.0;
            Hi->yx = 0.0;
            Hi->yy = 1.0/(*input_support->GetTuple(i));
            Hi->yz = 0.0;
            Hi->zx = 0.0;
            Hi->zy = 0.0;
            Hi->zz = 1.0/(*input_support->GetTuple(i));
        }
        else
        {
            Hi->xx = 1.0/(*input_support->GetTuple(i));
            Hi->xy = 0.0;
            Hi->yx = 0.0;
            Hi->yy = 1.0/(*input_support->GetTuple(i));
        }
    }
    else
    {
        if (Dim==3)
        {
            Hi->xx = (*input_support->GetTuple(i));
            Hi->xy = (*(input_support->GetTuple(i)+1));
            Hi->xz = (*(input_support->GetTuple(i)+2));
            Hi->yx = (*(input_support->GetTuple(i)+3));
            Hi->yy = (*(input_support->GetTuple(i)+4));
            Hi->yz = (*(input_support->GetTuple(i)+5));
            Hi->zx = (*(input_support->GetTuple(i)+6));
            Hi->zy = (*(input_support->GetTuple(i)+7));
            Hi->zz = (*(input_support->GetTuple(i)+8));
        }
        else
        {
            Hi->xx = (*input_support->GetTuple(i));
            Hi->xy = (*(input_support->GetTuple(i)+1));
            Hi->yx = (*(input_support->GetTuple(i)+3));
            Hi->yy = (*(input_support->GetTuple(i)+4));
        }
    }
    
    return Hi;
}

// ****************************************************************************
//  Method:      avtSPHResampleFilter::Sample
//
//  Purpose:
//      Sample a given particle dataset to a rectilinear grid.
//
//  Arguments:
//      scalarValues    Vector of doubles holding the sampled data in a flat array
//
//  Programmer: Cody Raskin
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************
template<int Dim>
void
avtSPHResampleFilter::Sample(vector<double>& scalarValues)
{
    std::string varname = resampleVarName;
    int nsets = 0;
    // Size of the kernel.
    const double kernelExtent = 2.0;
    
    avtDataTree_p input_tree = GetInputDataTree();   /* get input data tree to obtain datasets */
    
    //    int num_input_vars = GetInput()->GetInfo().GetAttributes().GetNumberOfVariables();
    //    for most plots -- we expect at least 2 vars, one input var and one support tensor.
    vtkDataSet **data_sets = input_tree->GetAllLeaves(nsets);
    
    /// get the var we want to resample
    // make sure the name passed isn't simply our mesh name
    bool vars_to_resample = (GetInput()->GetInfo().GetAttributes().GetMeshname() != varname);
    
    // creating the lattice
    vector<double> latticeMin(Dim);
    vector<double> latticeMax(Dim);
    vector<int> n(Dim); // X, Y, Z Grid Cells
    
    n[0] = atts.GetXnum();
    n[1] = atts.GetYnum();
    latticeMin[0] = atts.GetMinX();
    latticeMin[1] = atts.GetMinY();
    latticeMax[0] = atts.GetMaxX();
    latticeMax[1] = atts.GetMaxY();
    
    if(Dim==3)
    {
        latticeMin[2] = atts.GetMinZ();
        latticeMax[2] = atts.GetMaxZ();
        n[2] = atts.GetZnum();
    }
    
    if(vars_to_resample && (nsets > 0))
    {
        //        int var_ncomps = GetInput()->GetInfo().GetAttributes().GetVariableDimension(varname.c_str());
        // number of components can be used in the future to deal with resampled scalars, tensors, etc
        
        vtkDataSet *dset = data_sets[0];
        vtkAppendPolyData *appender = NULL;
        
        if(nsets > 1)   // Merge all datasets into one
        {
            appender = vtkAppendPolyData::New();
            
            for(int i=0; i<nsets; i++)
            {
                // Merge data sets
                appender->AddInputData(dynamic_cast<vtkPolyData *>(data_sets[i]));
            }
            
            appender->Update();
            dset = appender->GetOutput();
        }
        
        // Compute the step size.
        vector<double> stepSizeAllDim = stepSize<Dim>(latticeMin, latticeMax, n);
        
        // Prepare the output
        vector<double> m0;  // moments of data points
        vector<vector<double> > m1; // data points?
        vector<tensorStruct> m2;
        vector<double> A;   // correction terms
        vector<vector<double> > B;  // correction terms
        
        vtkDataArray *input_var     = dset->GetPointData()->GetArray(varname.c_str());
        vtkDataArray *input_support = dset->GetPointData()->GetArray(supportVarName.c_str());
        vtkDataArray *input_weight  = dset->GetPointData()->GetArray(weightVarName.c_str());
        
        // assemble your input data arrays ...
        vtkIdType npart = dset->GetNumberOfPoints();
        
        if (Dim==3)
        {
            debug5 << "P" << PAR_Rank() << ": " << npart << " particles to " << n[0] << "x" << n[1] << "x" << n[2] << " cells" << endl;
        }
        else
        {
            debug5 << "P" << PAR_Rank() << ": " << npart << " particles to " << n[0] << "x" << n[1] << " cells" << endl;
        }
        
//        cout << "P" << PAR_Rank() << ": started iterate over particles" << endl;
        for(int i=0; i<npart;++i)   // Loop through all the points in the merged dataset
        {
            tensorStruct* Hi = CreateTensorStruct<Dim>(input_support, i);
            
            double Hdet = determinant<Dim>(*Hi);
            tensorStruct M = square<Dim>(*Hi);
            
            double weighti = *input_weight->GetTuple(i);
            vector<double> extent(Dim);
            
            extent[0] = kernelExtent/Hdet*sqrt(M.yy);
            extent[1] = kernelExtent/Hdet*sqrt(M.xx);
            
            double ri[3] = {0, 0, 0};
            dset->GetPoint(i, &ri[0]);
            
            if(Dim==3)
            {
                extent[0] = kernelExtent/Hdet*sqrt(M.yy*M.zz - M.yz*M.zy);
                extent[1] = kernelExtent/Hdet*sqrt(M.xx*M.zz - M.xz*M.zx);
                extent[2] = kernelExtent/Hdet*sqrt(M.xx*M.yy - M.xy*M.yx);
            }
            
            // Compute the set of lattice positions this node contributes to.
            const vector< vector<int> > ids = latticePoints<Dim>(&ri[0], extent, latticeMin, stepSizeAllDim, n);
            
            // Iterate over the lattice points.
            for (vector< vector<int> >::const_iterator itr = ids.begin(); itr != ids.end(); ++itr)
            {
                // Compute the sample position and index into the lattice sample array.
                vector<double> rj = latticePosition<Dim>(*itr, latticeMin, latticeMax, stepSizeAllDim);
                const int j = latticeIndex(*itr, n);
                
                // Update the latticeIndex List if necessary
                int idx = GetIndexFromLatticeIndex(j);
                
                if(idx == -1) {
                    idx = latticeIndexMap.size();
                    latticeIndexMap[j] = idx;
                    
                    m0.push_back(0.0);
                    m1.push_back(vector<double>(Dim,0.0));
                    tensorStruct ts;
                    m2.push_back(ts);
                    
                    A.push_back(0.0);
                    B.push_back(vector<double>(Dim,0.0));
                    
                    scalarValues.push_back(0.0);
                }
                
                // Contribution of the SPH point to this position.
                vector<double> rij(Dim);
                for(int k=0;k<Dim;++k)
                    rij[k] = ri[k]-rj[k];
                
                vector<double> etaVec(Dim);
                etaVec              = tensorVectorMult<Dim>(*Hi,rij);
                
                const double etai   = vectorMag<Dim>(etaVec);
                
                //= (Hi*rij).magnitude();
                const double Wi     = avtSPHResampleFilter::kernelValue<Dim>(etai, Hdet);
                //                    const double gradWi = avtSPHResampleFilter::kernelGradValue<Dim>(etai, Hdet);
                
                // zeroth moment
                const double wwi    = Wi*weighti;
                //                m0[j]               += wwi;
                m0[idx]               += wwi;
                //gradm0[j]           += gradWi*weighti;
                
                // first moment
                vector<double> m1i(Dim);
                m1i                 = vectorScalarMult<Dim>(rij,wwi);
                m1[idx]               = vectorSum<Dim>(m1[idx],m1i);
                
                //second moment
                tensorStruct thpt;
                thpt                = outerProduct<Dim>(rij,rij);
                tensorStruct m2i;
                m2i                 = tensorScalarMult<Dim>(thpt,wwi);
                m2[idx]               = tensorSum<Dim>(m2[idx],m2i);
            }
            
            delete Hi;
        }
//        cout << "P" << PAR_Rank() << ": ended iterate over particles" << endl;
        
#ifdef PARALLEL
//        Barrier();
        int myRank = PAR_Rank();
        
        vector<int> i_latticeIndexList;
        vector<double> i_m0;
        vector<vector<double> > i_m1;
        vector<tensorStruct> i_m2;
        
        // Keep copy of the current state of the data to send
        vector<double> m_m0(m0.begin(), m0.end());
        vector<vector<double> > m_m1(m1.begin(), m1.end());
        vector<tensorStruct> m_m2(m2.begin(), m2.end());
        
//        cout << "P" << myRank << " Started Parallel Section 1" << endl;
        
        for(int root=0; root<PAR_Size(); root++) {
            if(myRank == root) {
                int ntot = latticeIndexMap.size();
                
                // Send the list of lattice indices this processor has
                vector<int> latticeIndexList(ntot);
                for(std::map<int,int>::iterator itr=latticeIndexMap.begin(); itr!=latticeIndexMap.end(); itr++) {
                    latticeIndexList[itr->second] = itr->first;
                }
                
                BroadcastIntVectorFromAny(latticeIndexList, root, root);
                
                // Send m0
                BroadcastDoubleVectorFromAny(m_m0, root, root);
                
                // Send m1
                double *m1DblArray = new double[Dim*ntot];
                
                for(int i=0; i<ntot; i++) {
                    for(int j=0; j<Dim; j++) {
                        m1DblArray[i*Dim+j] = m_m1[i].at(j);
                    }
                }
                
                BroadcastDoubleArrayFromAny(m1DblArray, ntot*Dim, root);
                
                delete [] m1DblArray;
                
                // Send m2
                BroadcastDoubleArrayFromAny(&m_m2[0].xx, ntot*9, root);
            } else {
                // Receive the list of lattice indices this processor has
                BroadcastIntVectorFromAny(i_latticeIndexList, myRank, root);
                int ntot = i_latticeIndexList.size();
                
                // Receive m0
                BroadcastDoubleVectorFromAny(i_m0, myRank, root);
                
                // Receive m1
                double *temp_m1 = new double[Dim*ntot];
                i_m1.resize(ntot);
                BroadcastDoubleArrayFromAny(temp_m1, ntot*Dim, root);
                
                for(int i=0; i<ntot; i++) {
                    vector<double> m1Val;
                    
                    for(int j=0; j<Dim; j++) {
                        m1Val.push_back(temp_m1[i*Dim+j]);
                    }
                    
                    i_m1[i] = m1Val;
                }
                
                delete [] temp_m1;
                
                // Receive m2
                i_m2.resize(9*ntot);
                BroadcastDoubleArrayFromAny(&i_m2[0].xx, ntot*9, root);
                
                // Update values
                for(int i=0; i<ntot; i++) {
                    int index = GetIndexFromLatticeIndex(i_latticeIndexList[i]);
                    
                    if(index != -1) {
                        m0[index] += i_m0[i];
                        m1[index] = vectorSum<Dim>(m1[index],i_m1[i]);
                        m2[index] = tensorSum<Dim>(m2[index],i_m2[i]);
                    }
                }
            }
        }
        
        i_latticeIndexList.erase(i_latticeIndexList.begin(), i_latticeIndexList.end());
        
        i_m0.erase(i_m0.begin(), i_m0.end());
        i_m2.erase(i_m2.begin(), i_m2.end());
        i_m1.erase(i_m1.begin(), i_m1.end());
        
        m_m0.erase(m_m0.begin(), m_m0.end());
        m_m1.erase(m_m1.begin(), m_m1.end());
        m_m2.erase(m_m2.begin(), m_m2.end());
        
//        cout << "P" << myRank << " Ended Parallel Section 1" << endl;
#endif
        // compute A & B on the lattice points
        for(int i=0; i<latticeIndexMap.size();++i)
        {
            double m2det            = determinant<Dim>(m2[i]);
            //double m2det = 0;
            tensorStruct m2inv;
            if(fabs(m2det) < 1.0e-10) m2det = 0;
            if(fabs(m2det) > 0)
                m2inv               = tensorInverse<Dim>(m2[i]);
            
            //printf("m2inv=[[%3.2f %3.2f][%3.2f %3.2f]]\n",m2inv.xx,m2inv.xy,m2inv.yx,m2inv.yy);
            
            vector<double> m2invm1(Dim);
            m2invm1                 = tensorVectorMult<Dim>(m2inv,m1[i]);
            
            //printf("m2invm1=[%3.3f,%3.3f]\n",m2invm1[0],m2invm1[1]);
            //double Ainv             = m0[i] - dotP<Dim>(m2invm1,m1[i]);
            double Ainv             = m0[i];
            A[i]                    = (fabs(Ainv)>1e-10 ? 1.0/Ainv : 1.0);
            B[i]                    = vectorScalarMult<Dim>(m2invm1,-1.0);
        }
        
        for(int i=0; i<npart; ++i)
        {
            tensorStruct *Hi = CreateTensorStruct<Dim>(input_support, i);
            
            double Hdet = determinant<Dim>(*Hi);
            tensorStruct M = square<Dim>(*Hi);
            
            double weighti = *input_weight->GetTuple(i);
            vector<double> extent(Dim);
            
            extent[0] = kernelExtent/Hdet*sqrt(M.yy);
            extent[1] = kernelExtent/Hdet*sqrt(M.xx);
            
            double ri[3] = {0, 0, 0};
            dset->GetPoint(i, ri);
            
            if(Dim==3)
            {
                extent[0] = kernelExtent/Hdet*sqrt(M.yy*M.zz - M.yz*M.zy);
                extent[1] = kernelExtent/Hdet*sqrt(M.xx*M.zz - M.xz*M.zx);
                extent[2] = kernelExtent/Hdet*sqrt(M.xx*M.yy - M.xy*M.yx);
            }
            
            double field = *input_var->GetTuple(i);
            
            // Compute the set of lattice positions this node contributes to.
            const vector< vector<int> > ids = latticePoints<Dim>(ri, extent,
                                                                 latticeMin, stepSizeAllDim, n);
            
            // Iterate over the lattice points.
            for (vector< vector<int> >::const_iterator itr = ids.begin(); itr != ids.end(); ++itr)
            {
                // Compute the sample position and index into the lattice sample array.
                vector<double> rj = latticePosition<Dim>(*itr, latticeMin, latticeMax, stepSizeAllDim);
                const int j = latticeIndex(*itr, n);
                const int idx = GetIndexFromLatticeIndex(j);
                
                // Contribution of the SPH point to this position.
                vector<double> rij(Dim);
                for(int k=0;k<Dim;++k)
                    rij[k] = ri[k]-rj[k];
                vector<double> etaVec(Dim);
                etaVec            = tensorVectorMult<Dim>(*Hi,rij);
                
                const double etai = vectorMag<Dim>(etaVec);
                
                //= (Hi*rij).magnitude();
                const double Wi = avtSPHResampleFilter::kernelValue<Dim>(etai, Hdet);
                const double thpt = weighti*Wi;
                //scalarValues[j] += thpt * field;
                if(RKcorrections)
                    //scalarValues[j] += thpt * field * A[j] * (1.0+dotP<Dim>(B[j],rij));
                    scalarValues[idx] += thpt * field * A[idx];
                else
                    scalarValues[idx] += thpt * field;
                //printf("SPH=%3.2e RK=%3.2e\n",thpt * field,thpt * field * (1.0 + A[j] * (1.0+dotP<Dim>(B[j],rij))));
            }
            
            delete Hi;
        }
        
        // Cleanup Memory
        if(nsets > 1) {
            appender->Delete();
        }
    }
    else
    {           // For processors without any datasets
#ifdef PARALLEL
        int myRank = PAR_Rank();
        
        vector<int> latticeIndexList(1, 0);
        scalarValues = vector<double>(1, 0.0);
        
        vector<double> m0(1, 0.0);  // moments of data points
        vector<double> m1(Dim, 0.0); // data points?
        vector<double> m2(9, 0.0);
        
        vector<int> i_latticeIndexList;
        vector<double> i_m0;
        
        for(int root=0; root<PAR_Size(); root++) {
            if(myRank == root) {
                // Send lattice indices
                BroadcastIntVectorFromAny(latticeIndexList, root, root);
                // Send m0
                BroadcastDoubleVectorFromAny(m0, root, root);
                // Send m1
                BroadcastDoubleArrayFromAny(&m1[0], Dim, root);
                // Send m2
                BroadcastDoubleArrayFromAny(&m2[0], 9, root);
            } else {
                // Receive lattice indices
                BroadcastIntVectorFromAny(i_latticeIndexList, myRank, root);
                
                int ntot = i_latticeIndexList.size();
                
                // Receive m0
                BroadcastDoubleVectorFromAny(i_m0, myRank, root);
                i_m0.erase(i_m0.begin(), i_m0.end());
                // Receive m1
                double *temp_m1 = new double[Dim*ntot];
                BroadcastDoubleArrayFromAny(temp_m1, Dim*ntot, root);
                delete [] temp_m1;
                // Receive m2
                double *temp_m2 = new double[ntot*9];
                BroadcastDoubleArrayFromAny(temp_m2, ntot*9, root);
                delete [] temp_m2;
            }
        }
        
        i_latticeIndexList.erase(i_latticeIndexList.begin(), i_latticeIndexList.end());
#endif
    }
}

// ****************************************************************************
//  Method: avtSPHResampleFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the SPHResample filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************
void
avtSPHResampleFilter::Execute()
{
    const int myRank = PAR_Rank();
    int parSize = PAR_Size();
    vector<double> vectorofScalars;
    std::string varname = resampleVarName;
    //    int var_ncomps = GetInput()->GetInfo().GetAttributes().GetVariableDimension(varname.c_str());
    
    avtDataAttributes &inAtts = GetInput()->GetInfo().GetAttributes();
    nDim = inAtts.GetSpatialDimension();
    
    if(atts.GetRK())
        RKcorrections=1.0;
    else
        RKcorrections=0.0;
    
    if(nDim==3)
    {
        parSize = parSize <= atts.GetZnum() ? parSize : atts.GetZnum();
        avtSPHResampleFilter::Sample<3>(vectorofScalars);
    }
    else
    {
        parSize = parSize <= atts.GetYnum() ? parSize : atts.GetYnum();
        avtSPHResampleFilter::Sample<2>(vectorofScalars);
    }
    
    double dx = (atts.GetMaxX() - atts.GetMinX()) / atts.GetXnum();
    double dy = (atts.GetMaxY() - atts.GetMinY()) / atts.GetYnum();
    double dz = (nDim == 3) ? (atts.GetMaxZ() - atts.GetMinZ()) / atts.GetZnum() : 0.0;
    
    //    cout << "dy = " << dy << endl;
    
    int l_dims[] = {0, 0, 0};
    l_dims[0] = atts.GetXnum();
    l_dims[1] = (nDim == 2) ? (atts.GetYnum() / parSize) : atts.GetYnum();
    l_dims[2] = (nDim == 3) ? (atts.GetZnum() / parSize) : 1;
    
    if(myRank == (parSize-1)) {
        if(nDim == 2) {
            l_dims[1] += atts.GetYnum() - (l_dims[1]*parSize);
        } else {
            l_dims[2] += atts.GetZnum() - (l_dims[2]*parSize);
        }
    }
    
    double l_xMin = atts.GetMinX();
    double l_yMin = myRank != (parSize - 1) ? atts.GetMinY() + (myRank * l_dims[1] * dy)
                                            : atts.GetMinY() + (myRank * (atts.GetYnum() / parSize) * dy);
    double l_zMin = 0;
    
    if(nDim == 3) {
        l_yMin = atts.GetMinY();
        l_zMin = myRank != (parSize - 1) ? atts.GetMinZ() + (myRank * l_dims[2] * dz)
        : atts.GetMinZ() + (myRank * (atts.GetZnum() / parSize) * dz);
    }
    
    // Allows separate datasets to line-up
    if(nDim == 2) {
        l_dims[1] += 1; // Create overlap so datasets can merge correctly
    } else {
        l_dims[2] += 1;
    }
    
    const int l_ntot = l_dims[0] * l_dims[1] * l_dims[2];
//    cout << "l_ntot = " << l_ntot << endl;
    
#ifdef PARALLEL
//    cout << "P" << myRank << " Started Parallel Section 2" << endl;
    // This processors original scalar values
    vector<double> m_vectorofScalars(vectorofScalars.begin(), vectorofScalars.end());
    
    vectorofScalars.erase(vectorofScalars.begin(), vectorofScalars.end());
    vectorofScalars.resize(l_ntot, 0.0);
    
    // Data Exchanges
    vector<double> i_vectorofScalars;
    vector<int> i_latticeIndexList;
    int minIndex = 0;
    int maxIndex = 0;
    
    for(int root=0; root<PAR_Size(); root++) {
        // Send the list of lattice indices
        if(myRank == root) {
            vector<int> latticeIndexList(latticeIndexMap.size());
            for(std::map<int,int>::iterator itr=latticeIndexMap.begin(); itr!=latticeIndexMap.end(); itr++) {
                latticeIndexList[itr->second] = itr->first;
            }
            BroadcastIntVectorFromAny(latticeIndexList, root, root);
        } else {
            BroadcastIntVectorFromAny(i_latticeIndexList, myRank, root);
        }
        
        // Broadcast Scalar Values
        if(myRank == root) {
            BroadcastDoubleVectorFromAny(m_vectorofScalars, root, root);
            
            if(myRank < parSize) {
                GetLocalMinMaxIndex(l_dims, minIndex, maxIndex, nDim, parSize);
                
                for(std::map<int,int>::iterator itr=latticeIndexMap.begin(); itr!=latticeIndexMap.end(); itr++) {
                    if(itr->first >= minIndex && itr->first < maxIndex) {
                        int localIndex = itr->first - minIndex;
                        vectorofScalars[localIndex] += m_vectorofScalars[itr->second];
                    }
                }
            }
            
            m_vectorofScalars.erase(m_vectorofScalars.begin(), m_vectorofScalars.end());
            
        } else {
            BroadcastDoubleVectorFromAny(i_vectorofScalars, myRank, root);
            
            if(myRank < parSize) {
                GetLocalMinMaxIndex(l_dims, minIndex, maxIndex, nDim, parSize);
                
                for(unsigned int i=0; i<i_latticeIndexList.size(); i++) {
                    if(i_latticeIndexList[i] >= minIndex && i_latticeIndexList[i] < maxIndex) {
                        int localIndex = i_latticeIndexList[i] - minIndex;
                        vectorofScalars[localIndex] += i_vectorofScalars[i];
                    }
                }
            }
        }
    }
    
    i_latticeIndexList.erase(i_latticeIndexList.begin(), i_latticeIndexList.end());
    i_vectorofScalars.erase(i_vectorofScalars.begin(), i_vectorofScalars.end());
//    cout << "P" << myRank << " Ended Parallel Section 2" << endl;
    
#else
    // For a single processor need to put scalars in the correct position
    vector<double> m_vectorofScalars(vectorofScalars.begin(), vectorofScalars.end());
    
    vectorofScalars.erase(vectorofScalars.begin(), vectorofScalars.end());
    vectorofScalars.resize(l_ntot, 0.0);
    
    for(std::map<int,int>::iterator itr=latticeIndexMap.begin(); itr!=latticeIndexMap.end(); itr++) {
        vectorofScalars[itr->first] = m_vectorofScalars[itr->second];
    }
    
#endif
    
    if(myRank < parSize) {
        vtkDoubleArray *out_var = vtkDoubleArray::New();
        out_var->SetName(varname.c_str());
        out_var->SetNumberOfTuples(l_ntot);
        out_var->SetNumberOfComponents(1);
        
        // Initialize Data Array
        for(unsigned int i=0; i<l_ntot; i++)
        {
            out_var->SetTuple1(i, vectorofScalars[i]);
        }
        
        vtkDataSet *out_dset = CreateLocalOutputGrid(l_xMin, l_yMin, l_zMin, dx, dy, dz, l_dims);
        
        out_dset->GetPointData()->AddArray(out_var);
        out_dset->GetPointData()->SetActiveScalars(out_var->GetName());
        
        out_var->Delete();
        
        avtDataTree_p out_tree = new avtDataTree(out_dset, 0);
        SetOutputDataTree(out_tree);
        
        out_dset->Delete();
    } else {
        avtDataTree_p dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
}

// ****************************************************************************
// Method:  avtSPHResampleFilter::GetLocalMinMaxIndex
//
// Purpose: Get the min and max indices covered by this processor's portion
//          of the output grid.
//
// Arguments:
//      dims    The x,y,z dimensions
//      min     An output variable for the minimum index
//      max     An output variable for the maximum index
//      dim     The grid dimensionality
//      size    The number of processors helping to compute the output grid
//
//
// Programmer:  Kevin Griffin
// Creation:    Tue Aug 25 18:01:32 PDT 2015
//
// ****************************************************************************
void
avtSPHResampleFilter::GetLocalMinMaxIndex(const int dims[], int &min, int &max, const int dim, const int size) {
    int myRank = PAR_Rank();
    int parSize = size;
    int dimY = dims[1] - 1; // Remove overlap for min calculation
    int dimZ = dims[2] - 1; // Remove overlap for min calculation
    
    if(dim == 2) {
        if(myRank != (parSize - 1)) {
            min = myRank * dims[0] * dimY;
        } else {
            min = myRank * dims[0] * (atts.GetYnum() / parSize);
        }
        
        max = min + (dims[0] * dims[1]);
    } else if(dim == 3) {
        if(myRank != (parSize - 1)) {
            min = myRank * (dims[0] * dims[1] * dimZ);
        } else {
            min = myRank * (dims[0] * dims[1] * (atts.GetZnum() / parSize));
        }
        
        max = min + (dims[0] * dims[1] * dims[2]);
    }
}

// ****************************************************************************
// Method:  avtSPHResampleFilter::CreateLocalOutputGrid
//
// Purpose: Create this processor's portion of the output grid.
//
// Arguments:
//      l_xmin  Minimum x value for this portion of the output grid
//      l_ymin  Minimum y value for this portion of the output grid
//      l_zmin  Minimum z value for this portion of the output grid
//      dx      The step size along the x-axis
//      dy      The step size along the y-axis
//      dz      The step size along the z-axis
//      dims    The x,y,z dimensions
//
// Returns: Part of the output grid
//
// Programmer:  Kevin Griffin
// Creation:    Tue Aug 25 18:01:32 PDT 2015
//
// ****************************************************************************
vtkDataSet *
avtSPHResampleFilter::CreateLocalOutputGrid(const double l_xmin, const double l_ymin, const double l_zmin,
                                            const double dx, const double dy, const double dz, int dims[])
{
    vtkRectilinearGrid *out_dset = vtkRectilinearGrid::New();
    out_dset->SetDimensions(dims);
    
    // create the xcoords
    vtkDoubleArray *out_xcoords = vtkDoubleArray::New();
    out_xcoords->SetNumberOfTuples(dims[0]);
    out_xcoords->SetNumberOfComponents(1);
    
    for(int i=0; i<dims[0]; i++)
    {
        double val = l_xmin + i * dx + dx/2.0;
        out_xcoords->SetTuple1(i,val);
    }
    
    out_dset->SetXCoordinates(out_xcoords);
    out_xcoords->Delete();
    
    // create the ycoords
    vtkDoubleArray *out_ycoords = vtkDoubleArray::New();
    if(dims[1] > 1)
    {
        out_ycoords->SetNumberOfTuples(dims[1]);
        out_ycoords->SetNumberOfComponents(1);
        
        for(int i=0; i<dims[1]; i++)
        {
            double val = l_ymin + i * dy + dy/2.0;
            out_ycoords->SetTuple1(i,val);
        }
    }
    else
    {
        out_ycoords->SetNumberOfTuples(1);
        out_ycoords->SetNumberOfComponents(1);
        out_ycoords->SetTuple1(0,0.0);
    }
    
    out_dset->SetYCoordinates(out_ycoords);
    out_ycoords->Delete();
    
    // create the zcoords
    if(nDim == 3)
    {
        vtkDoubleArray *out_zcoords = vtkDoubleArray::New();
        out_zcoords->SetNumberOfTuples(dims[2]);
        out_zcoords->SetNumberOfComponents(1);
        
        for(int i=0; i<dims[2]; i++)
        {
            double val = l_zmin + i * dz + dz/2.0;
            out_zcoords->SetTuple1(i,val);
        }
        
        out_dset->SetZCoordinates(out_zcoords);
        out_zcoords->Delete();
    }
    
    return out_dset;
}

// ****************************************************************************
// Method:  avtSPHResampleFilter::CreateOutputGrid
//
// Purpose: Map the sampled grid to the output grid.
//
//
// Programmer:  Cody Raskin
// Creation:    July 1, 2015
//
// ****************************************************************************
vtkDataSet *
avtSPHResampleFilter::CreateOutputGrid()
{
    vtkRectilinearGrid *out_dset = vtkRectilinearGrid::New();
    
    int dims[3]  = {0,0,0};
    // get the dimensions from the input attributes
    dims[0] = atts.GetXnum();
    dims[1] = atts.GetYnum();
    dims[2] = (nDim==3 ? atts.GetZnum() : 1);
    
    //    printf("x: %d y: %d z: %d\n", dims[0], dims[1], dims[2]);
    
    out_dset->SetDimensions(dims);
    
    
    // create the xcoords
    vtkDoubleArray *out_xcoords = vtkDoubleArray::New();
    out_xcoords->SetNumberOfTuples(dims[0]);
    out_xcoords->SetNumberOfComponents(1);
    double xmin = atts.GetMinX();
    double dx = (atts.GetMaxX() - xmin) / atts.GetXnum();
    for(int i=0;i<dims[0];i++)
    {
        double val = xmin + i * dx + dx/2.0;
        out_xcoords->SetTuple1(i,val);
    }
    
    out_dset->SetXCoordinates(out_xcoords);
    out_xcoords->Delete();
    
    // create the ycoords
    vtkDoubleArray *out_ycoords = vtkDoubleArray::New();
    if(dims[1] > 1)
    {
        out_ycoords->SetNumberOfTuples(dims[1]);
        out_ycoords->SetNumberOfComponents(1);
        double ymin = atts.GetMinY();
        double dy = (atts.GetMaxY() - ymin) / atts.GetYnum();
        for(int i=0;i<dims[1];i++)
        {
            double val = ymin + i * dy + dy/2.0;
            out_ycoords->SetTuple1(i,val);
        }
        
    }
    else
    {
        out_ycoords->SetNumberOfTuples(1);
        out_ycoords->SetNumberOfComponents(1);
        out_ycoords->SetTuple1(0,0.0);
    }
    
    out_dset->SetYCoordinates(out_ycoords);
    out_ycoords->Delete();
    
    // create the zcoords
    if(nDim == 3)
    {
        vtkDoubleArray *out_zcoords = vtkDoubleArray::New();
        out_zcoords->SetNumberOfTuples(dims[2]);
        out_zcoords->SetNumberOfComponents(1);
        double zmin = atts.GetMinZ();
        double dz   = (atts.GetMaxZ() - zmin) / atts.GetZnum();
        
        for(int i=0;i<dims[2];i++)
        {
            double val = zmin + i * dz + dz/2.0;
            out_zcoords->SetTuple1(i,val);
        }
        
        out_dset->SetZCoordinates(out_zcoords);
        out_zcoords->Delete();
    }
    
    return out_dset;
}

// ****************************************************************************
//  Method: avtSPHResampleFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

avtContract_p
avtSPHResampleFilter::ModifyContract(avtContract_p in_contract)
{
    avtContract_p rv = new avtContract(in_contract);
    // Turn off ghost data, since ghost data created upstream will not be pertinent
    // after resampling.
    rv->GetDataRequest()->SetDesiredGhostDataType(NO_GHOST_DATA);
    rv->NoStreaming();
    
    avtResampleSelection *sel = new avtResampleSelection;
    int counts[3];
    counts[0] = atts.GetXnum();
    counts[1] = atts.GetYnum();
    counts[2] = atts.GetZnum();
    sel->SetCounts(counts);
    
    double starts[3];
    starts[0] = atts.GetMinX();
    starts[1] = atts.GetMinY();
    starts[2] = atts.GetMinZ();
    sel->SetStarts(starts);
    
    double stops[3];
    stops[0] = atts.GetMaxX();
    stops[1] = atts.GetMaxY();
    stops[2] = atts.GetMaxZ();
    sel->SetStops(stops);
    
    rv->GetDataRequest()->AddDataSelection(sel);
    
    resampleVarName = std::string(rv->GetDataRequest()->GetVariable());
    supportVarName  = atts.GetTensorSupportVariable();
    weightVarName   = atts.GetWeightVariable();
    
    if( supportVarName == "default")
    {
        EXCEPTION1(InvalidVariableException,"default");
    }
    
    if( weightVarName == "default")
    {
        weightVarName = "mass";
    }
    
    debug5 << "Resample Variable Name: " << resampleVarName << endl;
    debug5 << "Tensor Support Variable Name: " << supportVarName << endl;
    debug5 << "Weight Variable Name: " << weightVarName << endl;
    
    // make sure to request the tensor support var
    rv->GetDataRequest()->AddSecondaryVariable(supportVarName.c_str());
    rv->GetDataRequest()->AddSecondaryVariable(weightVarName.c_str());
    
    if (in_contract->GetDataRequest()->MayRequireZones() ||
        in_contract->GetDataRequest()->MayRequireNodes())
    {
        avtDataAttributes &data = GetInput()->GetInfo().GetAttributes();
        
        if (data.ValidActiveVariable())
        {
            if (data.GetCentering() == AVT_NODECENT)
            {
                rv->GetDataRequest()->TurnNodeNumbersOn();
            }
            else if (data.GetCentering() == AVT_ZONECENT)
            {
                rv->GetDataRequest()->TurnZoneNumbersOn();
            }
        }
        else
        {
            // canot determine variable centering, so turn on both
            // node numbers and zone numbers.
            rv->GetDataRequest()->TurnNodeNumbersOn();
            rv->GetDataRequest()->TurnZoneNumbersOn();
        }
    }
    
    return rv;
}

// ****************************************************************************
//  Method: avtSPHResampleFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: harrison37 -- generated by xml2avt
//  Creation:   Fri Dec 5 13:50:31 PST 2014
//
// ****************************************************************************

void
avtSPHResampleFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &inAtts   = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    outAtts.AddFilterMetaData("SPH Resample");
    
    GetOutput()->GetInfo().GetValidity().InvalidateZones();
    GetOutput()->GetInfo().GetValidity().InvalidateNodes();
    outAtts.SetTopologicalDimension(inAtts.GetSpatialDimension());
    
    avtExtents *exts = outAtts.GetDesiredDataExtents();
    double bounds[6];
    bounds[0] = atts.GetMinX();
    bounds[1] = atts.GetMaxX();
    bounds[2] = atts.GetMinY();
    bounds[3] = atts.GetMaxY();
    bounds[4] = atts.GetMinZ();
    bounds[5] = atts.GetMaxZ();
    exts->Set(bounds);
    
    if (!resampleVarName.empty() && outAtts.ValidActiveVariable())
    {
        if (outAtts.GetVariableName() != resampleVarName)
            outAtts.SetActiveVariable(resampleVarName.c_str());
    }
}