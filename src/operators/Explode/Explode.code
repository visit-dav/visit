Function: AttributesMatch
Declaration: bool AttributesMatch (const ExplodeAttributes &obj) const;
Definition:
// ****************************************************************************
// Method: ExplodeAttributes::AttributesMatch
//
// Purpose:
//     Compare two attributes, excluding their explosions list.
//
// Programmer: Alister Maguire
// Creation:   Tue Feb 20 11:06:54 PST 2018
//
// Modifications:
//
// ****************************************************************************

bool
ExplodeAttributes::AttributesMatch (const ExplodeAttributes &obj) const
{
    // Compare the explosionPoint arrays.
    bool explosionPoint_equal = true;
    for(int i = 0; i < 3 && explosionPoint_equal; ++i)
        explosionPoint_equal = (explosionPoint[i] == obj.explosionPoint[i]);

    // Compare the planePoint arrays.
    bool planePoint_equal = true;
    for(int i = 0; i < 3 && planePoint_equal; ++i)
        planePoint_equal = (planePoint[i] == obj.planePoint[i]);

    // Compare the planeNorm arrays.
    bool planeNorm_equal = true;
    for(int i = 0; i < 3 && planeNorm_equal; ++i)
        planeNorm_equal = (planeNorm[i] == obj.planeNorm[i]);

    // Compare the cylinderPoint1 arrays.
    bool cylinderPoint1_equal = true;
    for(int i = 0; i < 3 && cylinderPoint1_equal; ++i)
        cylinderPoint1_equal = (cylinderPoint1[i] == obj.cylinderPoint1[i]);

    // Compare the cylinderPoint2 arrays.
    bool cylinderPoint2_equal = true;
    for(int i = 0; i < 3 && cylinderPoint2_equal; ++i)
        cylinderPoint2_equal = (cylinderPoint2[i] == obj.cylinderPoint2[i]);

    // Create the return value
    return ((explosionType == obj.explosionType) &&
            explosionPoint_equal &&
            planePoint_equal &&
            planeNorm_equal &&
            cylinderPoint1_equal &&
            cylinderPoint2_equal &&
            (materialExplosionFactor == obj.materialExplosionFactor) &&
            (material == obj.material) &&
            (cylinderRadius == obj.cylinderRadius) &&
            (explodeMaterialCells == obj.explodeMaterialCells) &&
            (cellExplosionFactor == obj.cellExplosionFactor) &&
            (explosionPattern == obj.explosionPattern) &&
            (explodeAllCells == obj.explodeAllCells) &&
            (boundaryNames == obj.boundaryNames));
}

Target: xml2python
Function: PyExplodeAttributes_SetDefaults
Declaration: PyExplodeAttributes_SetDefaults
Definition:
//****************************************************************************
//  Modifications:
//    Alister Maguire, Wed Jan 10 11:29:50 PST 2018
//    Make defaultAtts point to the passed atts directly.
//
//****************************************************************************
void
PyExplodeAttributes_SetDefaults(const ExplodeAttributes *atts)
{
    defaultAtts = const_cast<ExplodeAttributes*>(atts);
}

Target: xml2info
Function: ExplodeViewerEnginePluginInfo::InitializeOperatorAtts
Declaration: void InitializeOperatorAtts(AttributeSubject *, const avtPlotMetaData &, const bool);
Definition:
// ****************************************************************************
//  Method: ExplodeViewerEnginePluginInfo::InitializeOperatorAtts
//
//  Purpose:
//    Initialize the operator attributes to the default attributes.
//
//  Arguments:
//    atts        The attribute subject to initialize.
//    plot        The viewer plot that owns the operator.
//    fromDefault True to initialize the attributes from the defaults. False
//                to initialize from the current attributes.
//
//  Programmer: generated by xml2info
//  Creation:   omitted
//
//  Modifications:
//
//      Alister Maguire, Wed Nov  8 10:12:34 PST 2017
//      Added retrieval of boundary names.
//
//      Alister Maguire, Wed Jan 17 15:28:46 PST 2018
//      Moved most of the method to PrivateSetOperatorAtts().
//
// ****************************************************************************
#include <avtPlotMetaData.h>

void
ExplodeViewerEnginePluginInfo::InitializeOperatorAtts(AttributeSubject *atts,
    const avtPlotMetaData &plot, const bool fromDefault)
{
    if (fromDefault)
        *(ExplodeAttributes*)atts = *defaultAtts;
    else
        *(ExplodeAttributes*)atts = *clientAtts;

    PrivateSetOperatorAtts(atts, plot);
}

Function: ExplodeViewerEnginePluginInfo::UpdateOperatorAtts
Declaration: void UpdateOperatorAtts(AttributeSubject *, const avtPlotMetaData &, const bool);
Definition:
// ****************************************************************************
//  Method: ExplodeViewerEnginePluginInfo::UpdateOperatorAtts
//
//  Purpose:
//    Update the operator attributes when using operator expressions.
//
//  Arguments:
//    atts        The attribute subject to update.
//    plot        The viewer plot that owns the operator.
//
//  Programmer: generated by xml2info
//  Creation:   omitted
//
//  Modifications:
//      Alister Maguire, Wed Jan 17 15:28:46 PST 2018
//      Added a call to PrivateSetOperatorAtts().
//
// ****************************************************************************

void
ExplodeViewerEnginePluginInfo::UpdateOperatorAtts(AttributeSubject *atts,
    const avtPlotMetaData &plot)
{
    cerr << "UPDATING OPERATOR ATTS" << endl;
    *(ExplodeAttributes*)atts = *defaultAtts;

    PrivateSetOperatorAtts(atts, plot);
}

Function: ExplodeViewerEnginePluginInfo::PrivateSetOperatorAtts
Declaration: void PrivateSetOperatorAtts(AttributeSubject *, const avtPlotMetaData &);
Definition:
// ****************************************************************************
//  Method: ExplodeViewerEnginePluginInfo::PrivateSetOperatorAtts
//
//  Purpose:
//      Retrieve the boundary (material) names and set them within the i
//      operator attributes.
//
//  Programmer: Alister Maguire
//  Creation:   Wed Jan 17 15:28:46 PST 2018
//
//  Modifications:
//
//      Alister Maguire, Tue Sep 18 14:57:03 PDT 2018
//      Added the ability to handle multiple types of subsets.
//
// ****************************************************************************

#include <set>

#include <DebugStream.h>
#include <InvalidVariableException.h>

void
ExplodeViewerEnginePluginInfo::PrivateSetOperatorAtts(AttributeSubject *atts,
    const avtPlotMetaData &plot)
{
    ExplodeAttributes *explodeAtts = (ExplodeAttributes *)atts;

    const avtMaterialMetaData *mat = NULL;
    const avtDatabaseMetaData *md  = plot.GetMetaData();
    if (md == NULL)
    {
        return;
    }

    std::string  varName(plot.GetVariableName());
    std::string  meshName = md->MeshForVar(varName);
    avtMeshMetaData *mesh =
        const_cast <avtMeshMetaData *> (md->GetMesh(meshName));
    stringVector subsetNames;
    stringVector::const_iterator pos;
    char temp[512];

    //
    // Create subset names, based on Subset Type
    //
    avtSubsetType subT = md->DetermineSubsetType(varName);
    switch (subT)
    {
        case AVT_DOMAIN_SUBSET :
        {
            debug5 << "Exploding a domain mesh subset." << endl;
            explodeAtts->SetSubsetType(ExplodeAttributes::Domain);
            defaultAtts->SetSubsetType(ExplodeAttributes::Domain);
            if (mesh->blockNames.empty())
            {
                for (int i = 0; i < mesh->numBlocks; i++)
                {
                    sprintf(temp, "%d", i+mesh->blockOrigin);
                    subsetNames.push_back(temp);
                }
            }
            else
            {
                for(pos = mesh->blockNames.begin();
                    pos != mesh->blockNames.end(); ++pos)
                {
                    subsetNames.push_back(*pos);
                }
            }
        }
        break;

        case AVT_GROUP_SUBSET :
        {
            debug5 << "Exploding a group mesh subset." << endl;
            explodeAtts->SetSubsetType(ExplodeAttributes::Group);
            defaultAtts->SetSubsetType(ExplodeAttributes::Group);

            std::set<int>    groupSet;
            std::vector<int> gIDS;

            if (!mesh->groupNames.empty())
            {
                for (size_t i = 0; i < mesh->groupNames.size(); ++i)
                {
                    subsetNames.push_back(mesh->groupNames[i]);
                }
            }
            else if (mesh->groupIds.size() > 0)
            {
                for (size_t i = 0; i < mesh->groupIds.size(); i++)
                {
                    if (groupSet.count(mesh->groupIds[i]) == 0)
                    {
                        groupSet.insert(mesh->groupIds[i]);
                        gIDS.push_back(mesh->groupIds[i]);
                    }
                }
                for (size_t i = 0; i < gIDS.size(); i++)
                {
                    sprintf(temp, "%d", gIDS[i]);
                    subsetNames.push_back(temp);
                }
            }
            else
            {
                int origin = mesh->groupOrigin;
                int nGroups = (int)mesh->groupIdsBasedOnRange.size()-1;
                for (int i = 0; i < nGroups; i++)
                {
                    groupSet.insert(origin+i);
                    gIDS.push_back(origin+i);
                    sprintf(temp, "%d", origin+i);
                    subsetNames.push_back(temp);
                }
            }
        }
        break;

        case AVT_ENUMSCALAR_SUBSET :
        {
            debug5 << "Exploding an enumerated scalar subset." << endl;
            explodeAtts->SetSubsetType(ExplodeAttributes::EnumScalar);
            defaultAtts->SetSubsetType(ExplodeAttributes::EnumScalar);
            const avtScalarMetaData *smd = md->GetScalar(varName);
            if (smd != NULL)
            {
                for(pos = smd->enumNames.begin();
                    pos != smd->enumNames.end(); ++pos)
                {
                    subsetNames.push_back(*pos);
                }
            }
        }
        break;

        case AVT_MATERIAL_SUBSET:
        // Fall through to default

        default:
        {
            //
            // By default, we explode materials.
            //
            debug5 << "Exploding a materials." << endl;
            int numMaterials = md->GetNumMaterials();
            explodeAtts->SetSubsetType(ExplodeAttributes::Material);
            defaultAtts->SetSubsetType(ExplodeAttributes::Material);

            for (int i = 0; i < numMaterials; ++i)
            {
                mat = md->GetMaterial(i);
                if (mat != NULL)
                {
                    for (pos = mat->materialNames.begin();
                         pos != mat->materialNames.end(); ++pos)
                    {
                        if ( !(*pos).empty() )
                        {
                            subsetNames.push_back(*pos);
                        }
                    }
                }
                mat = NULL;
            }
        }
        break;
    }

    explodeAtts->SetBoundaryNames(subsetNames);
    defaultAtts->SetBoundaryNames(subsetNames);
}
